!% $MAX_ARRAYS=1500
!% $MAX_CLASSES=200
!% $MAX_VERBS=255
!% $MAX_LABELS=10000
!% $MAX_ZCODE_SIZE=100000
!% $MAX_STATIC_DATA=180000
!% $MAX_PROP_TABLE_SIZE=200000
!% $MAX_INDIV_PROP_TABLE_SIZE=20000
!% $MAX_STACK_SIZE=65536
!% $MAX_SYMBOLS=20000
!% $MAX_EXPRESSION_NODES=256


Constant Grammar__Version 2;

! This file was compiled by Inform 7: the build number and version of the
! I6 template layer used are as follows.
Constant NI_BUILD_COUNT "6G60";

Constant LibSerial = "080126";
Constant LibRelease = "6/12N";
Constant LIBRARY_VERSION = 612;

Constant PLUGIN_FILES;


Array UUID_ARRAY string "UUID://C8A63770-6D0B-11E2-B933-F96839AE4917//";

Constant Story "Harry Potter and the Philosopher's stone";
Constant Headline SC_2;
Constant Story_Author SC_3;
Serial "131119";

Default Story 0;
Default Headline 0;

[ ShowExtensionVersions;
    print "Standard Rules version 2/090402 by Graham Nelson^";
    print "Rideable Vehicles version 3 by Graham Nelson^";
    print "Snippetage version 2 by Dave Robinson^";
    print "Epistemology version 6 by Eric eve^";
    print "Conversation Framework version 10 by Eric Eve^";
    print "Real-Time Delays version 1/100607 by Erik Temple^";
    print "Telephones by George Tryfonas^";
    print "Postures by Emily Short^";
    print "After Not Doing Something by Ron Newcomb^";
];
[ ShowFullExtensionVersions;
    print "Standard Rules version 2/090402 by Graham Nelson^";
    print "Rideable Vehicles version 3 by Graham Nelson^";
    print "Menus version 3 by Emily Short^";
    print "Snippetage version 2 by Dave Robinson^";
    print "Mixed Extensions by Orion Zymaris^";
    print "3 Digit Number Lock version 1 by Orion Zymaris^";
    print "Epistemology version 6 by Eric eve^";
    print "Conversation Framework version 10 by Eric Eve^";
    print "Real-Time Delays version 1/100607 by Erik Temple^";
    print "Telephones by George Tryfonas^";
    print "Postures by Emily Short^";
    print "Basic Screen Effects version 7 by Emily Short^";
    print "After Not Doing Something by Ron Newcomb^";
    print "Hpmenu for chapter 1 by Orion Zymaris^";
    print "Plurality version 9 by Emily Short^";
    print "HPMenu by Orion Zymaris^";
    print "Door Directions by Orion Zymaris^";
    print "Cheats by Orion Zymaris^";
    print "Wizard Money by Orion Zymaris^";
    print "Glulx Entry Points version 9 by Emily Short^";
];


! Use option:
 Constant DynamicMemoryAllocation = 8192; 
! Use option:
 Constant IT_MemoryBufferSize = 1024+3; 
! Use option:
 Constant MATCH_LIST_WORDS = 100; 
! Use option:
 Constant AUTHORIAL_MODESTY; 


#Ifndef WORDSIZE; ! compiling with Z-code only compiler
Constant TARGET_ZCODE;
Constant WORDSIZE 2;
#Endif;

#Iftrue (WORDSIZE == 2);
Constant NULL = $ffff;
Constant WORD_HIGHBIT = $8000;
Constant WORD_NEXTTOHIGHBIT = $4000;
Constant IMPROBABLE_VALUE = $7fe3;
Constant MAX_POSITIVE_NUMBER 32767;
Constant MIN_NEGATIVE_NUMBER -32768;
Constant REPARSE_CODE = 10000;
#Endif;

#Iftrue (WORDSIZE == 4);
Constant NULL = $ffffffff;
Constant WORD_HIGHBIT = $80000000;
Constant WORD_NEXTTOHIGHBIT = $40000000;
Constant IMPROBABLE_VALUE = $deadce11;
Constant MAX_POSITIVE_NUMBER 2147483647;
Constant MIN_NEGATIVE_NUMBER -2147483648;
Constant REPARSE_CODE = $40000000;
#Endif;

#Ifdef TARGET_ZCODE;

Global max_z_object;

Constant INDIV_PROP_START 64;

! Offsets into Z-machine header:

Constant HDR_ZCODEVERSION     = $00;     ! byte
Constant HDR_TERPFLAGS        = $01;     ! byte
Constant HDR_GAMERELEASE      = $02;     ! word
Constant HDR_HIGHMEMORY       = $04;     ! word
Constant HDR_INITIALPC        = $06;     ! word
Constant HDR_DICTIONARY       = $08;     ! word
Constant HDR_OBJECTS          = $0A;     ! word
Constant HDR_GLOBALS          = $0C;     ! word
Constant HDR_STATICMEMORY     = $0E;     ! word
Constant HDR_GAMEFLAGS        = $10;     ! word
Constant HDR_GAMESERIAL       = $12;     ! six ASCII characters
Constant HDR_ABBREVIATIONS    = $18;     ! word
Constant HDR_FILELENGTH       = $1A;     ! word
Constant HDR_CHECKSUM         = $1C;     ! word
Constant HDR_TERPNUMBER       = $1E;     ! byte
Constant HDR_TERPVERSION      = $1F;     ! byte
Constant HDR_SCREENHLINES     = $20;     ! byte
Constant HDR_SCREENWCHARS     = $21;     ! byte
Constant HDR_SCREENWUNITS     = $22;     ! word
Constant HDR_SCREENHUNITS     = $24;     ! word
Constant HDR_FONTWUNITS       = $26;     ! byte
Constant HDR_FONTHUNITS       = $27;     ! byte
Constant HDR_ROUTINEOFFSET    = $28;     ! word
Constant HDR_STRINGOFFSET     = $2A;     ! word
Constant HDR_BGCOLOUR         = $2C;     ! byte
Constant HDR_FGCOLOUR         = $2D;     ! byte
Constant HDR_TERMCHARS        = $2E;     ! word
Constant HDR_PIXELSTO3        = $30;     ! word
Constant HDR_TERPSTANDARD     = $32;     ! two bytes
Constant HDR_ALPHABET         = $34;     ! word
Constant HDR_EXTENSION        = $36;     ! word
Constant HDR_UNUSED           = $38;     ! two words
Constant HDR_INFORMVERSION    = $3C;     ! four ASCII characters

#Endif;

#IFDEF TARGET_GLULX;

Global unicode_gestalt_ok; ! Set if interpreter supports Unicode

! Offsets into Glulx header and start of ROM:

Constant HDR_MAGICNUMBER      = $00;     ! long word
Constant HDR_GLULXVERSION     = $04;     ! long word
Constant HDR_RAMSTART         = $08;     ! long word
Constant HDR_EXTSTART         = $0C;     ! long word
Constant HDR_ENDMEM           = $10;     ! long word
Constant HDR_STACKSIZE        = $14;     ! long word
Constant HDR_STARTFUNC        = $18;     ! long word
Constant HDR_DECODINGTBL      = $1C;     ! long word
Constant HDR_CHECKSUM         = $20;     ! long word
Constant ROM_INFO             = $24;     ! four ASCII characters
Constant ROM_MEMORYLAYOUT     = $28;     ! long word
Constant ROM_INFORMVERSION    = $2C;     ! four ASCII characters
Constant ROM_COMPVERSION      = $30;     ! four ASCII characters
Constant ROM_GAMERELEASE      = $34;     ! short word
Constant ROM_GAMESERIAL       = $36;     ! six ASCII characters

#Endif;

Array PowersOfTwo_TB
  --> $$100000000000
      $$010000000000
      $$001000000000
      $$000100000000
      $$000010000000
      $$000001000000
      $$000000100000
      $$000000010000
      $$000000001000
      $$000000000100
      $$000000000010
      $$000000000001;

Array IncreasingPowersOfTwo_TB
  --> $$0000000000000001
      $$0000000000000010
      $$0000000000000100
      $$0000000000001000
      $$0000000000010000
      $$0000000000100000
      $$0000000001000000
      $$0000000010000000
      $$0000000100000000
      $$0000001000000000
      $$0000010000000000
	  $$0000100000000000
	  $$0001000000000000
	  $$0010000000000000
	  $$0100000000000000
	  $$1000000000000000;

Constant NORMAL_VMSTY     = 0;
Constant HEADER_VMSTY     = 3;
Constant SUBHEADER_VMSTY  = 4;
Constant ALERT_VMSTY      = 5;
Constant NOTE_VMSTY       = 6;
Constant BLOCKQUOTE_VMSTY = 7;
Constant INPUT_VMSTY      = 8;

Constant CLR_DEFAULT = 1;
Constant CLR_BLACK   = 2;
Constant CLR_RED     = 3;
Constant CLR_GREEN   = 4;
Constant CLR_YELLOW  = 5;
Constant CLR_BLUE    = 6;
Constant CLR_MAGENTA = 7; Constant CLR_PURPLE  = 7;
Constant CLR_CYAN    = 8; Constant CLR_AZURE   = 8;
Constant CLR_WHITE   = 9;

Constant WIN_ALL     = 0; ! Both windows at once
Constant WIN_STATUS  = 1;
Constant WIN_MAIN    = 2;

Constant PARA_COMPLETED          = 1;
Constant PARA_PROMPTSKIP         = 2;
Constant PARA_SUPPRESSPROMPTSKIP = 4;
Constant PARA_NORULEBOOKBREAKS   = 8;
Constant PARA_CONTENTEXPECTED    = 16;

Constant POSSESS_PK  = $100;
Constant DEFART_PK   = $101;
Constant INDEFART_PK = $102;

Constant RTP_BACKDROP                = 1;
Constant RTP_EXITDOOR                = 2;
Constant RTP_NOEXIT                  = 3;
Constant RTP_CANTCHANGE              = 4;
Constant RTP_IMPREL                  = 5;
Constant RTP_RULESTACK               = 6;
Constant RTP_TOOMANYRULEBOOKS        = 7;
Constant RTP_TOOMANYEVENTS           = 8;
Constant RTP_BADPROPERTY             = 9;
Constant RTP_UNPROVIDED              = 10;
Constant RTP_UNSET                   = 11;
Constant RTP_TOOMANYACTS             = 12;
Constant RTP_CANTABANDON             = 13;
Constant RTP_CANTEND                 = 14;
Constant RTP_CANTMOVENOTHING         = 15;
Constant RTP_CANTREMOVENOTHING       = 16;
Constant RTP_DIVZERO                 = 17;
Constant RTP_BADVALUEPROPERTY        = 18;
Constant RTP_NOTBACKDROP             = 19;
Constant RTP_TABLE_NOCOL             = 20;
Constant RTP_TABLE_NOCORR            = 21;
Constant RTP_TABLE_NOROW             = 22;
Constant RTP_TABLE_NOENTRY           = 23;
Constant RTP_TABLE_NOTABLE           = 24;
Constant RTP_TABLE_NOMOREBLANKS      = 25;
Constant RTP_TABLE_NOROWS            = 26;
Constant RTP_TABLE_CANTSORT          = 27;
Constant RTP_NOTINAROOM              = 28;
Constant RTP_BADTOPIC                = 29;
Constant RTP_ROUTELESS               = 30;
Constant RTP_PROPOFNOTHING           = 31;
Constant RTP_DECIDEONWRONGKIND       = 32;
Constant RTP_DECIDEONNOTHING         = 33;
Constant RTP_TABLE_CANTSAVE          = 34;
Constant RTP_TABLE_WONTFIT           = 35;
Constant RTP_TABLE_BADFILE           = 36;
Constant RTP_LOWLEVELERROR           = 37;
Constant RTP_DONTIGNORETURNSEQUENCE  = 38;
Constant RTP_SAYINVALIDSNIPPET       = 39;
Constant RTP_SPLICEINVALIDSNIPPET    = 40;
Constant RTP_INCLUDEINVALIDSNIPPET   = 41;
Constant RTP_LISTWRITERMEMORY        = 42;
Constant RTP_CANTREMOVEPLAYER        = 43;
Constant RTP_CANTREMOVEDOORS         = 44;
Constant RTP_CANTCHANGEOFFSTAGE      = 45;
Constant RTP_MSTACKMEMORY            = 46;
Constant RTP_TYPECHECK               = 47;
Constant RTP_FILEIOERROR             = 48;
Constant RTP_HEAPERROR               = 49;
Constant RTP_LISTRANGEERROR          = 50;
Constant RTP_REGEXPSYNTAXERROR       = 51;
Constant RTP_NOGLULXUNICODE          = 52;
Constant RTP_BACKDROPONLY            = 53;
Constant RTP_NOTTHING                = 54;
Constant RTP_SCENEHASNTSTARTED       = 55;
Constant RTP_SCENEHASNTENDED         = 56;
Constant RTP_NEGATIVEROOT            = 57;
Constant RTP_TABLE_CANTRUNTHROUGH    = 58;
Constant RTP_CANTITERATE             = 59;
Constant RTP_WRONGASSIGNEDKIND       = 60;

Constant PRINTING_THE_NAME_ACT           = 0;
Constant PRINTING_THE_PLURAL_NAME_ACT    = 1;
Constant PRINTING_A_NUMBER_OF_ACT        = 2;
Constant PRINTING_ROOM_DESC_DETAILS_ACT  = 3;
Constant LISTING_CONTENTS_ACT            = 4;
Constant GROUPING_TOGETHER_ACT           = 5;
Constant WRITING_A_PARAGRAPH_ABOUT_ACT   = 6;
Constant LISTING_NONDESCRIPT_ITEMS_ACT   = 7;

Constant PRINTING_NAME_OF_DARK_ROOM_ACT  = 8;
Constant PRINTING_DESC_OF_DARK_ROOM_ACT  = 9;
Constant PRINTING_NEWS_OF_DARKNESS_ACT   = 10;
Constant PRINTING_NEWS_OF_LIGHT_ACT      = 11;
Constant REFUSAL_TO_ACT_IN_DARK_ACT      = 12;

Constant CONSTRUCTING_STATUS_LINE_ACT    = 13;
Constant PRINTING_BANNER_TEXT_ACT        = 14;

Constant READING_A_COMMAND_ACT           = 15;
Constant DECIDING_SCOPE_ACT              = 16;
Constant DECIDING_CONCEALED_POSSESS_ACT  = 17;
Constant DECIDING_WHETHER_ALL_INC_ACT    = 18;
Constant CLARIFYING_PARSERS_CHOICE_ACT   = 19;
Constant ASKING_WHICH_DO_YOU_MEAN_ACT    = 20;
Constant PRINTING_A_PARSER_ERROR_ACT     = 21;
Constant SUPPLYING_A_MISSING_NOUN_ACT    = 22;
Constant SUPPLYING_A_MISSING_SECOND_ACT  = 23;
Constant IMPLICITLY_TAKING_ACT           = 24;
Constant STARTING_VIRTUAL_MACHINE_ACT    = 25;

Constant AMUSING_A_VICTORIOUS_PLAYER_ACT = 26;
Constant PRINTING_PLAYERS_OBITUARY_ACT   = 27;
Constant DEALING_WITH_FINAL_QUESTION_ACT = 28;

Constant PRINTING_LOCALE_DESCRIPTION_ACT = 29;
Constant CHOOSING_NOTABLE_LOCALE_OBJ_ACT = 30;
Constant PRINTING_LOCALE_PARAGRAPH_ACT   = 31;

Constant PROCEDURAL_RB                   = 0;

Constant STARTUP_RB                      = 1;
Constant TURN_SEQUENCE_RB                = 2;
Constant SHUTDOWN_RB                     = 3;

Constant WHEN_PLAY_BEGINS_RB             = 5;
Constant WHEN_PLAY_ENDS_RB               = 6;
Constant WHEN_SCENE_BEGINS_RB            = 7;
Constant WHEN_SCENE_ENDS_RB              = 8;

Constant ACTION_PROCESSING_RB            = 10;
Constant SETTING_ACTION_VARIABLES_RB     = 11;
Constant SPECIFIC_ACTION_PROCESSING_RB   = 12;

Constant ACCESSIBILITY_RB                = 14;
Constant REACHING_INSIDE_RB              = 15;
Constant REACHING_OUTSIDE_RB             = 16;
Constant VISIBLE_RB                      = 17;

Constant PERSUADE_RB                     = 18;
Constant UNSUCCESSFUL_ATTEMPT_RB         = 19;

Constant AFTER_RB                        = 24;
Constant REPORT_RB                       = 25;

Constant UNKNOWN_TY = 1;
Constant VALUE_TY = 2;
Constant POINTER_VALUE_TY = 3;
Constant WORD_VALUE_TY = 4;
Constant ARITHMETIC_VALUE_TY = 5;
Constant ENUMERATED_VALUE_TY = 6;
Constant SAYABLE_VALUE_TY = 7;
Constant COMBINED_VALUE_TY = 8;
Constant OBJECT_TY = 9;
Constant NUMBER_TY = 10;
Constant TRUTH_STATE_TY = 11;
Constant TEXT_TY = 12;
Constant INDEXED_TEXT_TY = 13;
Constant UNICODE_CHARACTER_TY = 14;
Constant USE_OPTION_TY = 15;
Constant SNIPPET_TY = 16;
Constant TABLE_TY = 17;
Constant EQUATION_TY = 18;
Constant RULEBOOK_OUTCOME_TY = 19;
Constant UNDERSTANDING_TY = 20;
Constant INTERMEDIATE_TY = 21;
Constant NIL_TY = 22;
Constant KIND_VARIABLE_TY = 23;
Constant PHRASE_TY = 24;
Constant TUPLE_ENTRY_TY = 25;
Constant RELATION_TY = 26;
Constant RULE_TY = 27;
Constant RULEBOOK_TY = 28;
Constant ACTIVITY_TY = 29;
Constant LIST_OF_TY = 30;
Constant DESCRIPTION_OF_TY = 31;
Constant PROPERTY_TY = 32;
Constant TABLE_COLUMN_TY = 33;
Constant COMBINATION_TY = 34;
Constant DESCRIPTION_OF_ACTION_TY = 35;
Constant STORED_ACTION_TY = 36;
Constant ACTION_NAME_TY = 37;
Constant TIME_TY = 38;
Constant SCENE_TY = 39;
Constant FIGURE_NAME_TY = 40;
Constant SOUND_NAME_TY = 41;
Constant EXTERNAL_FILE_TY = 42;
Constant BASE_KIND_HWM = 50; ! Base kind high-water-mark


Constant STUCK_PE     = 1;
Constant UPTO_PE      = 2;
Constant NUMBER_PE    = 3;
Constant ANIMA_PE     = 4;
Constant CANTSEE_PE   = 5;
Constant TOOLIT_PE    = 6;
Constant NOTHELD_PE   = 7;
Constant MULTI_PE     = 8;
Constant MMULTI_PE    = 9;
Constant VAGUE_PE     = 10;
Constant EXCEPT_PE    = 11;
Constant VERB_PE      = 12;
Constant SCENERY_PE   = 13;
Constant ITGONE_PE    = 14;
Constant JUNKAFTER_PE = 15;
Constant TOOFEW_PE    = 16;
Constant NOTHING_PE   = 17;
Constant ASKSCOPE_PE  = 18;
Constant NOTINCONTEXT_PE = 19;
Constant BLANKLINE_PE = 20; ! Not formally a parser error, but used by I7 as if

Constant PARSING_REASON       = 0;
Constant TALKING_REASON       = 1;
Constant EACH_TURN_REASON     = 2;
Constant LOOPOVERSCOPE_REASON = 5;
Constant TESTSCOPE_REASON     = 6;

Constant ILLEGAL_TT         = 0;    ! Types of grammar token: illegal
Constant ELEMENTARY_TT      = 1;    !     (one of those below)
Constant PREPOSITION_TT     = 2;    !     e.g. 'into'
Constant ROUTINE_FILTER_TT  = 3;    !     e.g. noun=CagedCreature
Constant ATTR_FILTER_TT     = 4;    !     e.g. edible
Constant SCOPE_TT           = 5;    !     e.g. scope=Spells
Constant GPR_TT             = 6;    !     a general parsing routine

Constant NOUN_TOKEN         = 0;    ! The elementary grammar tokens, and
Constant HELD_TOKEN         = 1;    ! the numbers compiled by I6 to
Constant MULTI_TOKEN        = 2;    ! encode them
Constant MULTIHELD_TOKEN    = 3;
Constant MULTIEXCEPT_TOKEN  = 4;
Constant MULTIINSIDE_TOKEN  = 5;
Constant CREATURE_TOKEN     = 6;
Constant SPECIAL_TOKEN      = 7;
Constant NUMBER_TOKEN       = 8;
Constant TOPIC_TOKEN        = 9;
Constant ENDIT_TOKEN        = 15;   ! Value used to mean "end of grammar line"

Constant GPR_FAIL           = -1;   ! Return values from General Parsing
Constant GPR_PREPOSITION    = 0;    ! Routines
Constant GPR_NUMBER         = 1;
Constant GPR_MULTIPLE       = 2;
Constant GPR_REPARSE        = REPARSE_CODE;
Constant GPR_NOUN           = -256; ! Reparse, but as |NOUN_TOKEN| this time
Constant GPR_HELD           = GPR_NOUN + 1; ! And so on
Constant GPR_MULTI          = GPR_NOUN + 2;
Constant GPR_MULTIHELD      = GPR_NOUN + 3;
Constant GPR_MULTIEXCEPT    = GPR_NOUN + 4;
Constant GPR_MULTIINSIDE    = GPR_NOUN + 5;
Constant GPR_CREATURE       = GPR_NOUN + 6;

Constant NEWLINE_BIT        = $$0000000000000001; ! New-line after each entry
Constant INDENT_BIT         = $$0000000000000010; ! Indent each entry by depth
Constant FULLINV_BIT        = $$0000000000000100; ! Full inventory information after entry
Constant ENGLISH_BIT        = $$0000000000001000; ! English sentence style, with commas and and
Constant RECURSE_BIT        = $$0000000000010000; ! Recurse downwards with usual rules
Constant ALWAYS_BIT         = $$0000000000100000; ! Always recurse downwards
Constant TERSE_BIT          = $$0000000001000000; ! More terse English style
Constant PARTINV_BIT        = $$0000000010000000; ! Only brief inventory information after entry
Constant DEFART_BIT         = $$0000000100000000; ! Use the definite article in list
Constant WORKFLAG_BIT       = $$0000001000000000; ! At top level (only), only list objects
                                                  ! which have the "workflag" attribute
Constant ISARE_BIT          = $$0000010000000000; ! Print " is" or " are" before list
Constant CONCEAL_BIT        = $$0000100000000000; ! Omit objects with "concealed" or "scenery":
                                                  ! if WORKFLAG_BIT also set, then does not
                                                  ! apply at top level, but does lower down
Constant NOARTICLE_BIT      = $$0001000000000000; ! Print no articles, definite or not
Constant EXTRAINDENT_BIT    = $$0010000000000000; ! New in I7: extra indentation of 1 level
Constant CFIRSTART_BIT      = $$0100000000000000; ! Capitalise first article in list

Constant QUARTER_HOUR = 15;
Constant HALF_HOUR = 30;
Constant ONE_HOUR = 60;
Constant TWELVE_HOURS = 720;
Constant TWENTY_FOUR_HOURS = 1440;

Constant EMPTY_TEXT_VALUE "";

Array TheEmptyTable --> 0 0;

Array EMPTY_RULEBOOK -> $ff $ff $ff $ff;

[ Prop_Falsity reason obj; return 0; ];


#Ifndef MAX_SCORE;
Global MAX_SCORE = 0;
#Endif;

Attribute absent; ! Used to mark objects removed from play
Attribute animate; ! I6-level marker for I7 kind "person"
Attribute clothing; ! = I7 "wearable"
Attribute concealed; ! = I7 "undescribed"
Attribute container; ! I6-level marker for I7 kind "container"
Attribute door; ! I6-level marker for I7 kind "door"
Attribute edible; ! = I7 "edible" vs "inedible"
Attribute enterable; ! = I7 "enterable"
Attribute light; ! = I7 "lighted" vs "dark"
Attribute lockable; ! = I7 "lockable"
Attribute locked; ! = I7 "locked"
Attribute moved; ! = I7 "handled"
Attribute on; ! = I7 "switched on" vs "switched off"
Attribute open; ! = I7 "open" vs "closed"
Attribute openable; ! = I7 "openable"
Attribute scenery; ! = I7 "scenery"
Attribute static; ! = I7 "fixed in place" vs "portable"
Attribute supporter; ! I6-level marker for I7 kind "supporter"
Attribute switchable; ! I6-level marker for I7 kind "device"
Attribute talkable; ! Not currently used by I7, but retained for possible future use
Attribute transparent; ! = I7 "transparent" vs "opaque"
Attribute visited; ! = I7 "visited"
Attribute worn; ! marks that an object tree edge represents wearing

Attribute male; ! not directly used by I7, but available for languages with genders
Attribute female; ! = I7 "female" vs "male"
Attribute neuter; ! = I7 "neuter"
Attribute pluralname; ! = I7 "plural-named"
Attribute proper; ! = I7 "proper-named"
Attribute remove_proper; ! remember to remove proper again when using ChangePlayer next

Attribute privately_named; ! New in I7
Attribute mentioned; ! New in I7
Attribute pushable; ! New in I7

Attribute mark_as_room; ! Used in I7 to speed up testing "ofclass K1_room"
Attribute mark_as_thing; ! Used in I7 to speed up testing "ofclass K2_thing"

Attribute workflag; ! = I7 "marked for listing", but basically temporary workspace 
Attribute workflag2; ! new in I7 and also temporary workspace
Constant list_filter_permits = privately_named; ! another I7 listwriter convenience

Property add_to_scope; ! used as in I6 to place component parts in scope
Property article "a"; ! used as in I6 to implement articles
Property capacity 100; ! = I7 "carrying capacity"
Property component_child; ! new in I7: forest structure holding "part of" relation
Property component_parent; ! new in I7
Property component_sibling; ! new in I7
Property description; ! = I7 "description"
Property door_dir; ! used to implement two-sided doors, but holds direction object, not a property
Property door_to; ! used as in I6 to implement two-sided doors
Property found_in; ! used as in I6 to implement two-sided doors and backdrops
Property initial; ! = I7 "initial description"
Property list_together; ! used as in I6 to implement "grouping together" activity
Property map_region; ! new in I7
Property parse_name 0; ! used as in I6 to implement "Understand... as..." grammars
Property plural; ! used as in I6 to implement plural names for duplicate objects
Property regional_found_in; ! new in I7
Property room_index; ! new in I7: storage for route-finding
Property short_name 0; ! = I7 "printed name"
Property vector; ! new in I7: storage for route-finding
Property with_key; ! = I7 "matching key"

Property KD_Count; ! Instance count of the kind of the current object
Property IK1_Count; ! These are instance counts within kinds K1, K2, ...
Property IK2_Count; ! and it is efficient to declare the common ones with Property
Property IK4_Count; ! since this results in a slightly smaller story file
Property IK5_Count;
Property IK6_Count;
Property IK8_Count;

Property IK1_link; ! These are for linked lists used to make searches faster
Property IK2_link; ! and again it's memory-efficient to declare the common ones
Property IK5_link; ! 
Property IK6_link; ! 
Property IK8_link; ! 

Property articles; ! not used by I7, but an interesting hook in the parser
Property grammar; ! not used by I7, but an interesting hook in the parser
Property inside_description; ! not used by I7, but an interesting hook in the locale code
Property short_name_indef 0; ! not used by I7, but an interesting hook in the listmaker

Constant life = NULL;

Constant ActionCount = 139;

Fake_Action ListMiscellany;
Fake_Action Miscellany;
Fake_Action PluralFound;
Fake_Action TheSame;

	Constant RUCKSACK_CLASS = K15_player_s_holdall;


! [1]
Global location = InformLibrary; ! does not = I7 "location": see below
Global sline1; Global sline2;

! [2]
Global say__p = 1; Global say__pc = 0; Global say__n;
Global ct_0 = 0; Global ct_1 = 0;
Global los_rv = false;
Global subst__v; ! = I7 "substitution-variable"
Global parameter_object; ! = I7 "parameter-object" = I7 "container in question"
Array deferred_calling_list --> 16;
Global property_to_be_totalled; ! used to implement "total P of..."
Global property_loop_sign; ! $+1$ for increasing order, $-1$ for decreasing
Global suppress_scope_loops;
Global temporary_value; ! can be used anywhere side-effects can't occur
Global enable_rte = true; ! reporting of run-time problems is enabled

Constant BLOCKV_STACK_SIZE = 224;
Global blockv_sp = 0;
Array blockv_stack --> BLOCKV_STACK_SIZE;
Global IT_RE_Err = 0;

Array LocalParking --> 16;

! [3]
Global standard_interpreter = 0;
Global undo_flag;

! [4]
Global deadflag = 0;
Global story_complete = 0;
Global resurrect_please = false;

! [5]
Global not_yet_in_play = true; ! set false when first command received
Global turns = 1; ! = I7 "turn count"
Global the_time = NULL; ! = I7 "time of day"
Global time_rate = 1;

Constant NUMBER_SCENES_CREATED = 6;
Constant SCENE_ARRAY_SIZE = (NUMBER_SCENES_CREATED+2);
Array scene_started --> SCENE_ARRAY_SIZE;
Array scene_ended --> SCENE_ARRAY_SIZE;
Array scene_status --> SCENE_ARRAY_SIZE;
Array scene_endings --> SCENE_ARRAY_SIZE;
Array scene_latest_ending --> SCENE_ARRAY_SIZE;

! [6]
Global score; ! = I7 "score"
Global last_score; ! = I7 "last notified score"
Global notify_mode = 1; ! score notification on or off
Global left_hand_status_line = SL_Location; ! = I7 "left hand status line"
Global right_hand_status_line = SL_Score_Moves; ! = I7 "right hand status line"

! [7]
Global player; ! = I7 "player"
Global real_location; ! = I7 "location"
Global visibility_ceiling; ! highest object in tree visible to player
Global visibility_levels; ! distance in tree to that

Global SACK_OBJECT; ! current player's holdall item in use

! [8]
Global act_requester;
Global actor; ! = I7 "person asked" = I7 "person reaching"
Global actors_location; ! like real_location, but for the actor
Global actor_location; ! = I7 "actor-location"
Global action;
Global meta; ! action is out of world
Global inp1;
Global inp2;
Array  multiple_object --> MATCH_LIST_WORDS; ! multiple-object list (I6 table array)
Global toomany_flag; ! multiple-object list overflowed
Global multiflag; ! multiple-object being processed
Global multiple_object_item; ! item currently being processed in multiple-object list
Global noun; ! = I7 "noun"
Global second; ! = I7 "second noun"
Global keep_silent; ! true if current action is being tried silently
Global etype; ! parser error number if command not recognised
Global trace_actions = 0;

Global untouchable_object;
Global untouchable_silence;
Global touch_persona;

Global special_word; ! dictionary address of first word in "[text]" token
Global consult_from; ! word number of start of "[text]" token
Global consult_words; ! number of words in "[text]" token
Global parsed_number; ! value from any token not an object
Global special_number1; ! first value, if token not an object
Global special_number2; ! second value, if token not an object

Array  parser_results --> 16; ! for parser to write its results in
Global parser_trace = 0; ! normally 0, but 1 to 5 traces parser workings
Global pronoun_word; ! records which pronoun ("it", "them", ...) caused an error
Global pronoun_obj; ! and what object it was thought to refer to

Global players_command = 100; ! = I7 "player's command"
Global matched_text; ! = I7 "matched text"
Global reason_the_action_failed; ! = I7 "reason the action failed"
Global understand_as_mistake_number; ! which form of "Understand... as a mistake"
Global particular_possession; ! = I7 "particular possession"

! [9]
Global parser_action; ! written by the parser for the benefit of GPRs
Global parser_one;
Global parser_two;
Global parameters; ! number of I7 tokens parsed on the current line
Global action_to_be; ! (if the current line were accepted)
Global action_reversed; ! (parameters would be reversed in order)
Global wn; ! word number within "parse" buffer (from 1)
Global num_words; ! number of words in buffer
Global verb_word; ! dictionary address of command verb
Global verb_wordnum; ! word number of command verb

! [10]
Global scope_reason = PARSING_REASON; ! current reason for searching scope
Global scope_token; ! for "scope=Routine" grammar tokens
Global scope_error;
Global scope_stage; ! 1, 2 then 3
Global advance_warning; ! what a later-named thing will be
Global reason_code = NULL; ! for the I6 veneer

Global ats_flag = 0; ! for AddToScope routines
Global ats_hls;

! [11]
Global move_pushing;
Global move_from;
Global move_to;
Global move_by;
Global move_through;

! [12]
#Ifdef DEFAULT_BRIEF_DESCRIPTIONS;
Global lookmode = 1; ! 1 = BRIEF, 2 = VERBOSE, 3 = SUPERBRIEF
#Endif;
#Ifdef DEFAULT_VERBOSE_DESCRIPTIONS; 
Global lookmode = 2; ! 1 = BRIEF, 2 = VERBOSE, 3 = SUPERBRIEF
#Endif;
#Ifdef DEFAULT_SUPERBRIEF_DESCRIPTIONS; 
Global lookmode = 3; ! 1 = BRIEF, 2 = VERBOSE, 3 = SUPERBRIEF
#Endif;
#Ifndef lookmode;
Global lookmode = 2; ! 1 = BRIEF, 2 = VERBOSE, 3 = SUPERBRIEF
#Endif;
Global c_style; ! current list-writer style
Global c_depth; ! current recursion depth
Global c_iterator; ! current iteration function
Global lt_value; ! common value of list_together
Global listing_together; ! object number of one member of a group being listed together
Global listing_size; ! size of such a group
Global c_margin; ! current level of indentation printed by WriteListFrom()
Global inventory_stage = 1; ! 1 or 2 according to the context in which list_together uses

! [13]
Global clr_fg = 1; ! foreground colour
Global clr_bg = 1; ! background colour
Global clr_fgstatus = 1; ! foreground colour of statusline
Global clr_bgstatus = 1; ! background colour of statusline
Global clr_on; ! has colour been enabled by the player?
Global statuswin_current; ! if writing to top window

! [14]
Global statuswin_cursize = 0;
Global statuswin_size = 1;

! [15]
Global lm_act; Global lm_n; Global lm_o; Global lm_o2;

! [16]
Global debug_flag = 0;
Global debug_rules = 0;
Global debug_scenes = 0;
Global debug_rule_nesting;

#Ifdef TARGET_GLULX;


   [ IdentifyGlkObject phase type ref rock;
      if (phase == 0) { ! Zero out references to our objects.
	 if (FollowRulebook( 477 ) && RulebookSucceeded()) { rtrue; }
      }

      if (phase == 1) { ! Reset our windows, streams and filerefs.
	(Global_Vars-->39) = rock;
	(Global_Vars-->40) = ref;
         switch (type) {
            0: ! it's a window 
               	FollowRulebook( 478 );
	 1 : ! it's a stream
               	FollowRulebook( 479 );
    	   2 : ! it's a file reference
               	FollowRulebook( 480 );
         }
         return;
      }

      if (phase == 2) { ! Update our objects.
         if (FollowRulebook( 481 ) && RulebookSucceeded()) { rtrue; }
      }

   ];



  [ HandleGlkEvent ev context abortres newcmd cmdlen  ;
      context = 0; ! suppress ignored warning
      switch (ev-->0) {
	evtype_Redraw:
		if (FollowRulebook( 470 ) && RulebookSucceeded()) { rtrue; }

	evtype_Arrange:
		if (FollowRulebook( 471 ) && RulebookSucceeded()) { rtrue; }

	evtype_Timer:
		if (FollowRulebook( 469 ) && RulebookSucceeded()) { rtrue; }

	evtype_SoundNotify:
		if (FollowRulebook( 472 ) && RulebookSucceeded()) { rtrue; }

	evtype_Hyperlink: 
		FollowRulebook( 476 );
		if ( FollowRulebook( 482 ) && RulebookSucceeded())
		{ 
			FollowRulebook( 483 );
			FollowRulebook( 484 );
			if ( FollowRulebook( 485 ) ) 	return 2;
		} 
	
	evtype_CharInput:
		if (FollowRulebook( 474 ) && RulebookSucceeded()) { rtrue; }

	evtype_LineInput:
		if (FollowRulebook( 475 ) && RulebookSucceeded()) { return 2; }

	evtype_MouseInput:
		FollowRulebook( 473 );
		if ( FollowRulebook( 482 ) && RulebookSucceeded())
		{
			FollowRulebook( 483 );
			FollowRulebook( 484 );
			if ( FollowRulebook( 485 ) ) 	return 2;
		}  

	}

   ];



Global wait_flag = 0;

Array gg_event --> 4;
Array gg_arguments buffer 28;
Global gg_mainwin = 0;
Global gg_statuswin = 0;
Global gg_quotewin = 0;
Global gg_scriptfref = 0;
Global gg_scriptstr = 0;
Global gg_savestr = 0;
Global gg_commandstr = 0;
Global gg_command_reading = 0;      ! true if gg_commandstr is being replayed
Global gg_foregroundchan = 0;
Global gg_backgroundchan = 0;

Constant INPUT_BUFFER_LEN = 260;    ! No extra byte necessary
Constant MAX_BUFFER_WORDS = 20;
Constant PARSE_BUFFER_LEN = 61;

Array  buffer    buffer INPUT_BUFFER_LEN;
Array  buffer2   buffer INPUT_BUFFER_LEN;
Array  buffer3   buffer INPUT_BUFFER_LEN;
Array  parse     --> PARSE_BUFFER_LEN;
Array  parse2    --> PARSE_BUFFER_LEN;

#IFNDEF infglk_h; ! Standard Glulx definitions contributed by John Cater
Constant infglk_h;
!-------------------------------------------------------------------------------
!  infglk.h - an Inform library to allow easy access to glk functions
!    under glulx
!  Dynamically created by glk2inf.pl on 08/31/2006 at 19:20:21.
!  Send comments or suggestions to: katre@ruf.rice.edu
!-------------------------------------------------------------------------------
#Ifdef infglk_h;  ! remove "Constant declared but not used" warnings
#Endif;

Constant GLK_NULL 0;

! Constant definitions from glk.h
Constant gestalt_Version 0;
Constant gestalt_CharInput 1;
Constant gestalt_LineInput 2;
Constant gestalt_CharOutput 3;
Constant gestalt_CharOutput_CannotPrint 0;
Constant gestalt_CharOutput_ApproxPrint 1;
Constant gestalt_CharOutput_ExactPrint 2;
Constant gestalt_MouseInput 4;
Constant gestalt_Timer 5;
Constant gestalt_Graphics 6;
Constant gestalt_DrawImage 7;
Constant gestalt_Sound 8;
Constant gestalt_SoundVolume 9;
Constant gestalt_SoundNotify 10;
Constant gestalt_Hyperlinks 11;
Constant gestalt_HyperlinkInput 12;
Constant gestalt_SoundMusic 13;
Constant gestalt_GraphicsTransparency 14;
Constant gestalt_Unicode 15;
Constant evtype_None 0;
Constant evtype_Timer 1;
Constant evtype_CharInput 2;
Constant evtype_LineInput 3;
Constant evtype_MouseInput 4;
Constant evtype_Arrange 5;
Constant evtype_Redraw 6;
Constant evtype_SoundNotify 7;
Constant evtype_Hyperlink 8;
Constant keycode_Unknown $ffffffff;
Constant keycode_Left $fffffffe;
Constant keycode_Right $fffffffd;
Constant keycode_Up $fffffffc;
Constant keycode_Down $fffffffb;
Constant keycode_Return $fffffffa;
Constant keycode_Delete $fffffff9;
Constant keycode_Escape $fffffff8;
Constant keycode_Tab $fffffff7;
Constant keycode_PageUp $fffffff6;
Constant keycode_PageDown $fffffff5;
Constant keycode_Home $fffffff4;
Constant keycode_End $fffffff3;
Constant keycode_Func1 $ffffffef;
Constant keycode_Func2 $ffffffee;
Constant keycode_Func3 $ffffffed;
Constant keycode_Func4 $ffffffec;
Constant keycode_Func5 $ffffffeb;
Constant keycode_Func6 $ffffffea;
Constant keycode_Func7 $ffffffe9;
Constant keycode_Func8 $ffffffe8;
Constant keycode_Func9 $ffffffe7;
Constant keycode_Func10 $ffffffe6;
Constant keycode_Func11 $ffffffe5;
Constant keycode_Func12 $ffffffe4;
Constant keycode_MAXVAL 28;
Constant style_Normal 0;
Constant style_Emphasized 1;
Constant style_Preformatted 2;
Constant style_Header 3;
Constant style_Subheader 4;
Constant style_Alert 5;
Constant style_Note 6;
Constant style_BlockQuote 7;
Constant style_Input 8;
Constant style_User1 9;
Constant style_User2 10;
Constant style_NUMSTYLES 11;
Constant wintype_AllTypes 0;
Constant wintype_Pair 1;
Constant wintype_Blank 2;
Constant wintype_TextBuffer 3;
Constant wintype_TextGrid 4;
Constant wintype_Graphics 5;
Constant winmethod_Left $00;
Constant winmethod_Right $01;
Constant winmethod_Above $02;
Constant winmethod_Below $03;
Constant winmethod_DirMask $0f;
Constant winmethod_Fixed $10;
Constant winmethod_Proportional $20;
Constant winmethod_DivisionMask $f0;
Constant fileusage_Data $00;
Constant fileusage_SavedGame $01;
Constant fileusage_Transcript $02;
Constant fileusage_InputRecord $03;
Constant fileusage_TypeMask $0f;
Constant fileusage_TextMode $100;
Constant fileusage_BinaryMode $000;
Constant filemode_Write $01;
Constant filemode_Read $02;
Constant filemode_ReadWrite $03;
Constant filemode_WriteAppend $05;
Constant seekmode_Start 0;
Constant seekmode_Current 1;
Constant seekmode_End 2;
Constant stylehint_Indentation 0;
Constant stylehint_ParaIndentation 1;
Constant stylehint_Justification 2;
Constant stylehint_Size 3;
Constant stylehint_Weight 4;
Constant stylehint_Oblique 5;
Constant stylehint_Proportional 6;
Constant stylehint_TextColor 7;
Constant stylehint_BackColor 8;
Constant stylehint_ReverseColor 9;
Constant stylehint_NUMHINTS 10;
Constant stylehint_just_LeftFlush 0;
Constant stylehint_just_LeftRight 1;
Constant stylehint_just_Centered 2;
Constant stylehint_just_RightFlush 3;
Constant imagealign_InlineUp $01;
Constant imagealign_InlineDown $02;
Constant imagealign_InlineCenter $03;
Constant imagealign_MarginLeft $04;
Constant imagealign_MarginRight $05;

! The actual glk functions.
[ glk_exit _vararg_count ret;
! glk_exit ()
  ! And now the @glk call
  @glk 1 _vararg_count ret;
  return ret;
];

[ glk_set_interrupt_handler _vararg_count ret;
! glk_set_interrupt_handler (func)
  ! And now the @glk call
  @glk 2 _vararg_count ret;
  return ret;
];

[ glk_tick _vararg_count ret;
! glk_tick ()
  ! And now the @glk call
  @glk 3 _vararg_count ret;
  return ret;
];

[ glk_gestalt _vararg_count ret;
! glk_gestalt (sel val)
  ! And now the @glk call
  @glk 4 _vararg_count ret;
  return ret;
];

[ glk_gestalt_ext _vararg_count ret;
! glk_gestalt_ext (sel val arr arrlen)
  ! And now the @glk call
  @glk 5 _vararg_count ret;
  return ret;
];

[ glk_char_to_lower _vararg_count ret;
! glk_char_to_lower (ch)
  ! And now the @glk call
  @glk 160 _vararg_count ret;
  return ret;
];

[ glk_char_to_upper _vararg_count ret;
! glk_char_to_upper (ch)
  ! And now the @glk call
  @glk 161 _vararg_count ret;
  return ret;
];

[ glk_window_get_root _vararg_count ret;
! glk_window_get_root ()
  ! And now the @glk call
  @glk 34 _vararg_count ret;
  return ret;
];

[ glk_window_open _vararg_count ret;
! glk_window_open (split method size wintype rock)
  ! And now the @glk call
  @glk 35 _vararg_count ret;
  return ret;
];

[ glk_window_close _vararg_count ret;
! glk_window_close (win result)
  ! And now the @glk call
  @glk 36 _vararg_count ret;
  return ret;
];

[ glk_window_get_size _vararg_count ret;
! glk_window_get_size (win widthptr heightptr)
  ! And now the @glk call
  @glk 37 _vararg_count ret;
  return ret;
];

[ glk_window_set_arrangement _vararg_count ret;
! glk_window_set_arrangement (win method size keywin)
  ! And now the @glk call
  @glk 38 _vararg_count ret;
  return ret;
];

[ glk_window_get_arrangement _vararg_count ret;
! glk_window_get_arrangement (win methodptr sizeptr keywinptr)
  ! And now the @glk call
  @glk 39 _vararg_count ret;
  return ret;
];

[ glk_window_iterate _vararg_count ret;
! glk_window_iterate (win rockptr)
  ! And now the @glk call
  @glk 32 _vararg_count ret;
  return ret;
];

[ glk_window_get_rock _vararg_count ret;
! glk_window_get_rock (win)
  ! And now the @glk call
  @glk 33 _vararg_count ret;
  return ret;
];

[ glk_window_get_type _vararg_count ret;
! glk_window_get_type (win)
  ! And now the @glk call
  @glk 40 _vararg_count ret;
  return ret;
];

[ glk_window_get_parent _vararg_count ret;
! glk_window_get_parent (win)
  ! And now the @glk call
  @glk 41 _vararg_count ret;
  return ret;
];

[ glk_window_get_sibling _vararg_count ret;
! glk_window_get_sibling (win)
  ! And now the @glk call
  @glk 48 _vararg_count ret;
  return ret;
];

[ glk_window_clear _vararg_count ret;
! glk_window_clear (win)
  ! And now the @glk call
  @glk 42 _vararg_count ret;
  return ret;
];

[ glk_window_move_cursor _vararg_count ret;
! glk_window_move_cursor (win xpos ypos)
  ! And now the @glk call
  @glk 43 _vararg_count ret;
  return ret;
];

[ glk_window_get_stream _vararg_count ret;
! glk_window_get_stream (win)
  ! And now the @glk call
  @glk 44 _vararg_count ret;
  return ret;
];

[ glk_window_set_echo_stream _vararg_count ret;
! glk_window_set_echo_stream (win str)
  ! And now the @glk call
  @glk 45 _vararg_count ret;
  return ret;
];

[ glk_window_get_echo_stream _vararg_count ret;
! glk_window_get_echo_stream (win)
  ! And now the @glk call
  @glk 46 _vararg_count ret;
  return ret;
];

[ glk_set_window _vararg_count ret;
! glk_set_window (win)
  ! And now the @glk call
  @glk 47 _vararg_count ret;
  return ret;
];

[ glk_stream_open_file _vararg_count ret;
! glk_stream_open_file (fileref fmode rock)
  ! And now the @glk call
  @glk 66 _vararg_count ret;
  return ret;
];

[ glk_stream_open_memory _vararg_count ret;
! glk_stream_open_memory (buf buflen fmode rock)
  ! And now the @glk call
  @glk 67 _vararg_count ret;
  return ret;
];

[ glk_stream_close _vararg_count ret;
! glk_stream_close (str result)
  ! And now the @glk call
  @glk 68 _vararg_count ret;
  return ret;
];

[ glk_stream_iterate _vararg_count ret;
! glk_stream_iterate (str rockptr)
  ! And now the @glk call
  @glk 64 _vararg_count ret;
  return ret;
];

[ glk_stream_get_rock _vararg_count ret;
! glk_stream_get_rock (str)
  ! And now the @glk call
  @glk 65 _vararg_count ret;
  return ret;
];

[ glk_stream_set_position _vararg_count ret;
! glk_stream_set_position (str pos seekmode)
  ! And now the @glk call
  @glk 69 _vararg_count ret;
  return ret;
];

[ glk_stream_get_position _vararg_count ret;
! glk_stream_get_position (str)
  ! And now the @glk call
  @glk 70 _vararg_count ret;
  return ret;
];

[ glk_stream_set_current _vararg_count ret;
! glk_stream_set_current (str)
  ! And now the @glk call
  @glk 71 _vararg_count ret;
  return ret;
];

[ glk_stream_get_current _vararg_count ret;
! glk_stream_get_current ()
  ! And now the @glk call
  @glk 72 _vararg_count ret;
  return ret;
];

[ glk_put_char _vararg_count ret;
! glk_put_char (ch)
  ! And now the @glk call
  @glk 128 _vararg_count ret;
  return ret;
];

[ glk_put_char_stream _vararg_count ret;
! glk_put_char_stream (str ch)
  ! And now the @glk call
  @glk 129 _vararg_count ret;
  return ret;
];

[ glk_put_string _vararg_count ret;
! glk_put_string (s)
  ! And now the @glk call
  @glk 130 _vararg_count ret;
  return ret;
];

[ glk_put_string_stream _vararg_count ret;
! glk_put_string_stream (str s)
  ! And now the @glk call
  @glk 131 _vararg_count ret;
  return ret;
];

[ glk_put_buffer _vararg_count ret;
! glk_put_buffer (buf len)
  ! And now the @glk call
  @glk 132 _vararg_count ret;
  return ret;
];

[ glk_put_buffer_stream _vararg_count ret;
! glk_put_buffer_stream (str buf len)
  ! And now the @glk call
  @glk 133 _vararg_count ret;
  return ret;
];

[ glk_set_style _vararg_count ret;
! glk_set_style (styl)
  ! And now the @glk call
  @glk 134 _vararg_count ret;
  return ret;
];

[ glk_set_style_stream _vararg_count ret;
! glk_set_style_stream (str styl)
  ! And now the @glk call
  @glk 135 _vararg_count ret;
  return ret;
];

[ glk_get_char_stream _vararg_count ret;
! glk_get_char_stream (str)
  ! And now the @glk call
  @glk 144 _vararg_count ret;
  return ret;
];

[ glk_get_line_stream _vararg_count ret;
! glk_get_line_stream (str buf len)
  ! And now the @glk call
  @glk 145 _vararg_count ret;
  return ret;
];

[ glk_get_buffer_stream _vararg_count ret;
! glk_get_buffer_stream (str buf len)
  ! And now the @glk call
  @glk 146 _vararg_count ret;
  return ret;
];

[ glk_stylehint_set _vararg_count ret;
! glk_stylehint_set (wintype styl hint val)
  ! And now the @glk call
  @glk 176 _vararg_count ret;
  return ret;
];

[ glk_stylehint_clear _vararg_count ret;
! glk_stylehint_clear (wintype styl hint)
  ! And now the @glk call
  @glk 177 _vararg_count ret;
  return ret;
];

[ glk_style_distinguish _vararg_count ret;
! glk_style_distinguish (win styl1 styl2)
  ! And now the @glk call
  @glk 178 _vararg_count ret;
  return ret;
];

[ glk_style_measure _vararg_count ret;
! glk_style_measure (win styl hint result)
  ! And now the @glk call
  @glk 179 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_temp _vararg_count ret;
! glk_fileref_create_temp (usage rock)
  ! And now the @glk call
  @glk 96 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_by_name _vararg_count ret;
! glk_fileref_create_by_name (usage name rock)
  ! And now the @glk call
  @glk 97 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_by_prompt _vararg_count ret;
! glk_fileref_create_by_prompt (usage fmode rock)
  ! And now the @glk call
  @glk 98 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_from_fileref _vararg_count ret;
! glk_fileref_create_from_fileref (usage fref rock)
  ! And now the @glk call
  @glk 104 _vararg_count ret;
  return ret;
];

[ glk_fileref_destroy _vararg_count ret;
! glk_fileref_destroy (fref)
  ! And now the @glk call
  @glk 99 _vararg_count ret;
  return ret;
];

[ glk_fileref_iterate _vararg_count ret;
! glk_fileref_iterate (fref rockptr)
  ! And now the @glk call
  @glk 100 _vararg_count ret;
  return ret;
];

[ glk_fileref_get_rock _vararg_count ret;
! glk_fileref_get_rock (fref)
  ! And now the @glk call
  @glk 101 _vararg_count ret;
  return ret;
];

[ glk_fileref_delete_file _vararg_count ret;
! glk_fileref_delete_file (fref)
  ! And now the @glk call
  @glk 102 _vararg_count ret;
  return ret;
];

[ glk_fileref_does_file_exist _vararg_count ret;
! glk_fileref_does_file_exist (fref)
  ! And now the @glk call
  @glk 103 _vararg_count ret;
  return ret;
];

[ glk_select _vararg_count ret;
! glk_select (event)
  ! And now the @glk call
  @glk 192 _vararg_count ret;
  return ret;
];

[ glk_select_poll _vararg_count ret;
! glk_select_poll (event)
  ! And now the @glk call
  @glk 193 _vararg_count ret;
  return ret;
];

[ glk_request_timer_events _vararg_count ret;
! glk_request_timer_events (millisecs)
  ! And now the @glk call
  @glk 214 _vararg_count ret;
  return ret;
];

[ glk_request_line_event _vararg_count ret;
! glk_request_line_event (win buf maxlen initlen)
  ! And now the @glk call
  @glk 208 _vararg_count ret;
  return ret;
];

[ glk_request_char_event _vararg_count ret;
! glk_request_char_event (win)
  ! And now the @glk call
  @glk 210 _vararg_count ret;
  return ret;
];

[ glk_request_mouse_event _vararg_count ret;
! glk_request_mouse_event (win)
  ! And now the @glk call
  @glk 212 _vararg_count ret;
  return ret;
];

[ glk_cancel_line_event _vararg_count ret;
! glk_cancel_line_event (win event)
  ! And now the @glk call
  @glk 209 _vararg_count ret;
  return ret;
];

[ glk_cancel_char_event _vararg_count ret;
! glk_cancel_char_event (win)
  ! And now the @glk call
  @glk 211 _vararg_count ret;
  return ret;
];

[ glk_cancel_mouse_event _vararg_count ret;
! glk_cancel_mouse_event (win)
  ! And now the @glk call
  @glk 213 _vararg_count ret;
  return ret;
];

[ glk_buffer_to_lower_case_uni _vararg_count ret;
! glk_buffer_to_lower_case_uni (buf len numchars)
  ! And now the @glk call
  @glk 288 _vararg_count ret;
  return ret;
];

[ glk_buffer_to_upper_case_uni _vararg_count ret;
! glk_buffer_to_upper_case_uni (buf len numchars)
  ! And now the @glk call
  @glk 289 _vararg_count ret;
  return ret;
];

[ glk_buffer_to_title_case_uni _vararg_count ret;
! glk_buffer_to_title_case_uni (buf len numchars lowerrest)
  ! And now the @glk call
  @glk 290 _vararg_count ret;
  return ret;
];

[ glk_put_char_uni _vararg_count ret;
! glk_put_char_uni (ch)
  ! And now the @glk call
  @glk 296 _vararg_count ret;
  return ret;
];

[ glk_put_string_uni _vararg_count ret;
! glk_put_string_uni (s)
  ! And now the @glk call
  @glk 297 _vararg_count ret;
  return ret;
];

[ glk_put_buffer_uni _vararg_count ret;
! glk_put_buffer_uni (buf len)
  ! And now the @glk call
  @glk 298 _vararg_count ret;
  return ret;
];

[ glk_put_char_stream_uni _vararg_count ret;
! glk_put_char_stream_uni (str ch)
  ! And now the @glk call
  @glk 299 _vararg_count ret;
  return ret;
];

[ glk_put_string_stream_uni _vararg_count ret;
! glk_put_string_stream_uni (str s)
  ! And now the @glk call
  @glk 300 _vararg_count ret;
  return ret;
];

[ glk_put_buffer_stream_uni _vararg_count ret;
! glk_put_buffer_stream_uni (str buf len)
  ! And now the @glk call
  @glk 301 _vararg_count ret;
  return ret;
];

[ glk_get_char_stream_uni _vararg_count ret;
! glk_get_char_stream_uni (str)
  ! And now the @glk call
  @glk 304 _vararg_count ret;
  return ret;
];

[ glk_get_buffer_stream_uni _vararg_count ret;
! glk_get_buffer_stream_uni (str buf len)
  ! And now the @glk call
  @glk 305 _vararg_count ret;
  return ret;
];

[ glk_get_line_stream_uni _vararg_count ret;
! glk_get_line_stream_uni (str buf len)
  ! And now the @glk call
  @glk 306 _vararg_count ret;
  return ret;
];

[ glk_stream_open_file_uni _vararg_count ret;
! glk_stream_open_file_uni (fileref fmode rock)
  ! And now the @glk call
  @glk 312 _vararg_count ret;
  return ret;
];

[ glk_stream_open_memory_uni _vararg_count ret;
! glk_stream_open_memory_uni (buf buflen fmode rock)
  ! And now the @glk call
  @glk 313 _vararg_count ret;
  return ret;
];

[ glk_request_char_event_uni _vararg_count ret;
! glk_request_char_event_uni (win)
  ! And now the @glk call
  @glk 320 _vararg_count ret;
  return ret;
];

[ glk_request_line_event_uni _vararg_count ret;
! glk_request_line_event_uni (win buf maxlen initlen)
  ! And now the @glk call
  @glk 321 _vararg_count ret;
  return ret;
];

[ glk_image_draw _vararg_count ret;
! glk_image_draw (win image val1 val2)
  ! And now the @glk call
  @glk 225 _vararg_count ret;
  return ret;
];

[ glk_image_draw_scaled _vararg_count ret;
! glk_image_draw_scaled (win image val1 val2 width height)
  ! And now the @glk call
  @glk 226 _vararg_count ret;
  return ret;
];

[ glk_image_get_info _vararg_count ret;
! glk_image_get_info (image width height)
  ! And now the @glk call
  @glk 224 _vararg_count ret;
  return ret;
];

[ glk_window_flow_break _vararg_count ret;
! glk_window_flow_break (win)
  ! And now the @glk call
  @glk 232 _vararg_count ret;
  return ret;
];

[ glk_window_erase_rect _vararg_count ret;
! glk_window_erase_rect (win left top width height)
  ! And now the @glk call
  @glk 233 _vararg_count ret;
  return ret;
];

[ glk_window_fill_rect _vararg_count ret;
! glk_window_fill_rect (win color left top width height)
  ! And now the @glk call
  @glk 234 _vararg_count ret;
  return ret;
];

[ glk_window_set_background_color _vararg_count ret;
! glk_window_set_background_color (win color)
  ! And now the @glk call
  @glk 235 _vararg_count ret;
  return ret;
];

[ glk_schannel_create _vararg_count ret;
! glk_schannel_create (rock)
  ! And now the @glk call
  @glk 242 _vararg_count ret;
  return ret;
];

[ glk_schannel_destroy _vararg_count ret;
! glk_schannel_destroy (chan)
  ! And now the @glk call
  @glk 243 _vararg_count ret;
  return ret;
];

[ glk_schannel_iterate _vararg_count ret;
! glk_schannel_iterate (chan rockptr)
  ! And now the @glk call
  @glk 240 _vararg_count ret;
  return ret;
];

[ glk_schannel_get_rock _vararg_count ret;
! glk_schannel_get_rock (chan)
  ! And now the @glk call
  @glk 241 _vararg_count ret;
  return ret;
];

[ glk_schannel_play _vararg_count ret;
! glk_schannel_play (chan snd)
  ! And now the @glk call
  @glk 248 _vararg_count ret;
  return ret;
];

[ glk_schannel_play_ext _vararg_count ret;
! glk_schannel_play_ext (chan snd repeats notify)
  ! And now the @glk call
  @glk 249 _vararg_count ret;
  return ret;
];

[ glk_schannel_stop _vararg_count ret;
! glk_schannel_stop (chan)
  ! And now the @glk call
  @glk 250 _vararg_count ret;
  return ret;
];

[ glk_schannel_set_volume _vararg_count ret;
! glk_schannel_set_volume (chan vol)
  ! And now the @glk call
  @glk 251 _vararg_count ret;
  return ret;
];

[ glk_sound_load_hint _vararg_count ret;
! glk_sound_load_hint (snd flag)
  ! And now the @glk call
  @glk 252 _vararg_count ret;
  return ret;
];

[ glk_set_hyperlink _vararg_count ret;
! glk_set_hyperlink (linkval)
  ! And now the @glk call
  @glk 256 _vararg_count ret;
  return ret;
];

[ glk_set_hyperlink_stream _vararg_count ret;
! glk_set_hyperlink_stream (str linkval)
  ! And now the @glk call
  @glk 257 _vararg_count ret;
  return ret;
];

[ glk_request_hyperlink_event _vararg_count ret;
! glk_request_hyperlink_event (win)
  ! And now the @glk call
  @glk 258 _vararg_count ret;
  return ret;
];

[ glk_cancel_hyperlink_event _vararg_count ret;
! glk_cancel_hyperlink_event (win)
  ! And now the @glk call
  @glk 259 _vararg_count ret;
  return ret;
];
#ENDIF;

Constant GG_MAINWIN_ROCK        201;
Constant GG_STATUSWIN_ROCK      202;
Constant GG_QUOTEWIN_ROCK       203;
Constant GG_SAVESTR_ROCK        301;
Constant GG_SCRIPTSTR_ROCK      302;
Constant GG_COMMANDWSTR_ROCK    303;
Constant GG_COMMANDRSTR_ROCK    304;
Constant GG_SCRIPTFREF_ROCK     401;
Constant GG_FOREGROUNDCHAN_ROCK 410;
Constant GG_BACKGROUNDCHAN_ROCK 411;

#Stub HandleGlkEvent    2;
#Stub IdentifyGlkObject 4;
#Stub InitGlkWindow     1;

[ VM_PreInitialise res;
    @gestalt 4 2 res; ! Test if this interpreter has Glk...
    if (res == 0) quit; ! ...without which there would be nothing we could do

	unicode_gestalt_ok = false;
	if (glk_gestalt(gestalt_Unicode, 0))
		unicode_gestalt_ok = true;

    ! Set the VM's I/O system to be Glk.
    @setiosys 2 0;
];

[ VM_Initialise res sty i;
    @gestalt 4 2 res; ! Test if this interpreter has Glk...
    if (res == 0) quit; ! ...without which there would be nothing we could do

    ! First, we must go through all the Glk objects that exist, and see
    ! if we created any of them. One might think this strange, since the
    ! program has just started running, but remember that the player might
    ! have just typed "restart".

    GGRecoverObjects();

	! Sound channel initialisation, and RNG fixing, must be done now rather
	! than later in case InitGlkWindow() returns a non-zero value.

	if (glk_gestalt(gestalt_Sound, 0)) {
		if (gg_foregroundchan == 0)
			gg_foregroundchan = glk_schannel_create(GG_FOREGROUNDCHAN_ROCK);
		if (gg_backgroundchan == 0)
			gg_backgroundchan = glk_schannel_create(GG_BACKGROUNDCHAN_ROCK);
	}

	#ifdef FIX_RNG;
	@random 10000 i;
	i = -i-2000;
	print "[Random number generator seed is ", i, "]^";
	@setrandom i;
	#endif; ! FIX_RNG

    res = InitGlkWindow(0);
    if (res ~= 0) return;

    ! Now, gg_mainwin and gg_storywin might already be set. If not, set them.

    if (gg_mainwin == 0) {
        ! Open the story window.
        res = InitGlkWindow(GG_MAINWIN_ROCK);
        if (res == 0) {
        	! Left-justify the header style
			glk_stylehint_set(wintype_TextBuffer, style_Header, stylehint_Justification, 0);
			! Try to make emphasized type in italics and not boldface
			glk_stylehint_set(wintype_TextBuffer, style_Emphasized, stylehint_Weight, 0);
			glk_stylehint_set(wintype_TextBuffer, style_Emphasized, stylehint_Oblique, 1);
            gg_mainwin = glk_window_open(0, 0, 0, wintype_TextBuffer, GG_MAINWIN_ROCK);
		}
        if (gg_mainwin == 0) quit; ! If we can't even open one window, give in
    } else {
        ! There was already a story window. We should erase it.
        glk_window_clear(gg_mainwin);
    }

    if (gg_statuswin == 0) {
        res = InitGlkWindow(GG_STATUSWIN_ROCK);
        if (res == 0) {
            statuswin_cursize = statuswin_size;
			for (sty=0: sty<style_NUMSTYLES: sty++)
				glk_stylehint_set(wintype_TextGrid, sty, stylehint_ReverseColor, 1);
            gg_statuswin =
            	glk_window_open(gg_mainwin, winmethod_Fixed + winmethod_Above,
            		statuswin_cursize, wintype_TextGrid, GG_STATUSWIN_ROCK);
        }
    }
    ! It's possible that the status window couldn't be opened, in which case
    ! gg_statuswin is now zero. We must allow for that later on.

    glk_set_window(gg_mainwin);

    InitGlkWindow(1);
];

[ GGRecoverObjects id;
    ! If GGRecoverObjects() has been called, all these stored IDs are
    ! invalid, so we start by clearing them all out.
    ! (In fact, after a restoreundo, some of them may still be good.
    ! For simplicity, though, we assume the general case.)
    gg_mainwin = 0;
    gg_statuswin = 0;
    gg_quotewin = 0;
    gg_scriptfref = 0;
    gg_scriptstr = 0;
    gg_savestr = 0;
    statuswin_cursize = 0;
    gg_foregroundchan = 0;
    gg_backgroundchan = 0;
    #Ifdef DEBUG;
    gg_commandstr = 0;
    gg_command_reading = false;
    #Endif; ! DEBUG
    ! Also tell the game to clear its object references.
    IdentifyGlkObject(0);

    id = glk_stream_iterate(0, gg_arguments);
    while (id) {
        switch (gg_arguments-->0) {
            GG_SAVESTR_ROCK: gg_savestr = id;
            GG_SCRIPTSTR_ROCK: gg_scriptstr = id;
            #Ifdef DEBUG;
            GG_COMMANDWSTR_ROCK: gg_commandstr = id;
                                 gg_command_reading = false;
            GG_COMMANDRSTR_ROCK: gg_commandstr = id;
                                 gg_command_reading = true;
            #Endif; ! DEBUG
            default: IdentifyGlkObject(1, 1, id, gg_arguments-->0);
        }
        id = glk_stream_iterate(id, gg_arguments);
    }

    id = glk_window_iterate(0, gg_arguments);
    while (id) {
        switch (gg_arguments-->0) {
            GG_MAINWIN_ROCK: gg_mainwin = id;
            GG_STATUSWIN_ROCK: gg_statuswin = id;
            GG_QUOTEWIN_ROCK: gg_quotewin = id;
            default: IdentifyGlkObject(1, 0, id, gg_arguments-->0);
        }
        id = glk_window_iterate(id, gg_arguments);
    }

    id = glk_fileref_iterate(0, gg_arguments);
    while (id) {
        switch (gg_arguments-->0) {
            GG_SCRIPTFREF_ROCK: gg_scriptfref = id;
            default: IdentifyGlkObject(1, 2, id, gg_arguments-->0);
        }
        id = glk_fileref_iterate(id, gg_arguments);
    }

	if (glk_gestalt(gestalt_Sound, 0)) {
		id = glk_schannel_iterate(0, gg_arguments);
		while (id) {
			switch (gg_arguments-->0) {
				GG_FOREGROUNDCHAN_ROCK: gg_foregroundchan = id;
				GG_BACKGROUNDCHAN_ROCK: gg_backgroundchan = id;
			}
			id = glk_schannel_iterate(id, gg_arguments);
		}
		if (gg_foregroundchan ~= 0) { glk_schannel_stop(gg_foregroundchan); }
		if (gg_backgroundchan ~= 0) { glk_schannel_stop(gg_backgroundchan); }
	}

    ! Tell the game to tie up any loose ends.
    IdentifyGlkObject(2);
];

[ ENABLE_GLULX_ACCEL_R addr res;
	@gestalt 9 0 res;
	if (res == 0) return;
	addr = #classes_table;
	@accelparam 0 addr;
	@accelparam 1 INDIV_PROP_START;
	@accelparam 2 Class;
	@accelparam 3 Object;
	@accelparam 4 Routine;
	@accelparam 5 String;
	addr = #globals_array + WORDSIZE * #g$self;
	@accelparam 6 addr;
	@accelparam 7 NUM_ATTR_BYTES;
	addr = #cpv__start;
	@accelparam 8 addr;
	@accelfunc 1 Z__Region;
	@accelfunc 2 CP__Tab;
	@accelfunc 3 RA__Pr;
	@accelfunc 4 RL__Pr;
	@accelfunc 5 OC__Cl;
	@accelfunc 6 RV__Pr;
	@accelfunc 7 OP__Pr;
	rfalse;
];

[ VM_Describe_Release i;
	print "Release ";
	@aloads ROM_GAMERELEASE 0 i;
	print i;
	print " / Serial number ";
	for (i=0 : i<6 : i++) print (char) ROM_GAMESERIAL->i;
];

[ VM_KeyChar win nostat done res ix jx ch;
    jx = ch; ! squash compiler warnings
    if (win == 0) win = gg_mainwin;
    if (gg_commandstr ~= 0 && gg_command_reading ~= false) {
        done = glk_get_line_stream(gg_commandstr, gg_arguments, 31);
        if (done == 0) {
            glk_stream_close(gg_commandstr, 0);
            gg_commandstr = 0;
            gg_command_reading = false;
            ! fall through to normal user input.
        } else {
            ! Trim the trailing newline
            if (gg_arguments->(done-1) == 10) done = done-1;
            res = gg_arguments->0;
            if (res == '\') {
                res = 0;
                for (ix=1 : ix<done : ix++) {
                    ch = gg_arguments->ix;
                    if (ch >= '0' && ch <= '9') {
                        @shiftl res 4 res;
                        res = res + (ch-'0');
                    } else if (ch >= 'a' && ch <= 'f') {
                        @shiftl res 4 res;
                        res = res + (ch+10-'a');
                    } else if (ch >= 'A' && ch <= 'F') {
                        @shiftl res 4 res;
                        res = res + (ch+10-'A');
                    }
                }
            }
       		jump KCPContinue;
        }
    }
    done = false;
    glk_request_char_event(win);
    while (~~done) {
        glk_select(gg_event);
        switch (gg_event-->0) {
          5: ! evtype_Arrange
            if (nostat) {
                glk_cancel_char_event(win);
                res = $80000000;
                done = true;
                break;
            }
            DrawStatusLine();
          2: ! evtype_CharInput
            if (gg_event-->1 == win) {
                res = gg_event-->2;
                done = true;
                }
        }
        ix = HandleGlkEvent(gg_event, 1, gg_arguments);
        if (ix == 2) {
            res = gg_arguments-->0;
            done = true;
        } else if (ix == -1)  done = false;
    }
    if (gg_commandstr ~= 0 && gg_command_reading == false) {
        if (res < 32 || res >= 256 || (res == '\' or ' ')) {
            glk_put_char_stream(gg_commandstr, '\');
            done = 0;
            jx = res;
            for (ix=0 : ix<8 : ix++) {
                @ushiftr jx 28 ch;
                @shiftl jx 4 jx;
                ch = ch & $0F;
                if (ch ~= 0 || ix == 7) done = 1;
                if (done) {
                    if (ch >= 0 && ch <= 9) ch = ch + '0';
                    else                    ch = (ch - 10) + 'A';
                    glk_put_char_stream(gg_commandstr, ch);
                }
            }
        } else {
            glk_put_char_stream(gg_commandstr, res);
        }
        glk_put_char_stream(gg_commandstr, 10); ! newline
    }
  .KCPContinue;
    return res;
];

[ VM_KeyDelay tenths  key done ix;
    glk_request_char_event(gg_mainwin);
    glk_request_timer_events(tenths*100);
    while (~~done) {
        glk_select(gg_event);
        ix = HandleGlkEvent(gg_event, 1, gg_arguments);
        if (ix == 2) {
            key = gg_arguments-->0;
            done = true;
        }
        else if (ix >= 0 && gg_event-->0 == 1 or 2) {
            key = gg_event-->2;
            done = true;
        }
    }
    glk_cancel_char_event(gg_mainwin);
    glk_request_timer_events(0);
    return key;
];

[ VM_ReadKeyboard  a_buffer a_table done ix;
    if (gg_commandstr ~= 0 && gg_command_reading ~= false) {
        done = glk_get_line_stream(gg_commandstr, a_buffer+WORDSIZE,
        	(INPUT_BUFFER_LEN-WORDSIZE)-1);
        if (done == 0) {
            glk_stream_close(gg_commandstr, 0);
            gg_commandstr = 0;
            gg_command_reading = false;
            ! L__M(##CommandsRead, 5); would come after prompt
            ! fall through to normal user input.
        }
        else {
            ! Trim the trailing newline
            if ((a_buffer+WORDSIZE)->(done-1) == 10) done = done-1;
            a_buffer-->0 = done;
            VM_Style(INPUT_VMSTY);
            glk_put_buffer(a_buffer+WORDSIZE, done);
            VM_Style(NORMAL_VMSTY);
            print "^";
            jump KPContinue;
        }
    }
    done = false;
    glk_request_line_event(gg_mainwin, a_buffer+WORDSIZE, INPUT_BUFFER_LEN-WORDSIZE, 0);
    while (~~done) {
        glk_select(gg_event);
        switch (gg_event-->0) {
          5: ! evtype_Arrange
            DrawStatusLine();
          3: ! evtype_LineInput
            if (gg_event-->1 == gg_mainwin) {
                a_buffer-->0 = gg_event-->2;
                done = true;
            }
        }
        ix = HandleGlkEvent(gg_event, 0, a_buffer);
        if (ix == 2) done = true;
        else if (ix == -1) done = false;
    }
    if (gg_commandstr ~= 0 && gg_command_reading == false) {
        glk_put_buffer_stream(gg_commandstr, a_buffer+WORDSIZE, a_buffer-->0);
        glk_put_char_stream(gg_commandstr, 10); ! newline
    }
  .KPContinue;
    VM_Tokenise(a_buffer,a_table);
    ! It's time to close any quote window we've got going.
    if (gg_quotewin) {
        glk_window_close(gg_quotewin, 0);
        gg_quotewin = 0;
    }
    #ifdef ECHO_COMMANDS;
    print "** ";
    for (ix=WORDSIZE: ix<(a_buffer-->0)+WORDSIZE: ix++) print (char) a_buffer->ix;
    print "^";
    #endif; ! ECHO_COMMANDS
];

[ VM_CopyBuffer bto bfrom i;
    for (i=0: i<INPUT_BUFFER_LEN: i++) bto->i = bfrom->i;
];

[ VM_PrintToBuffer buf len a b c;
    if (b) {
        if (metaclass(a) == Object && a.#b == WORDSIZE
            && metaclass(a.b) == String)
            buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a.b);
		else if (metaclass(a) == Routine)
			buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a, b, c);
        else
            buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a, b);
    }
    else if (metaclass(a) == Routine)
        buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a, b, c);
    else
		buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a);
    if (buf-->0 > len) buf-->0 = len;
    return buf-->0;
];

[ VM_Tokenise buf tab
    cx numwords len bx ix wx wpos wlen val res dictlen entrylen;
    len = buf-->0;
    buf = buf+WORDSIZE;

    ! First, split the buffer up into words. We use the standard Infocom
    ! list of word separators (comma, period, double-quote).

    cx = 0;
    numwords = 0;
    while (cx < len) {
        while (cx < len && buf->cx == ' ') cx++;
        if (cx >= len) break;
        bx = cx;
        if (buf->cx == '.' or ',' or '"') cx++;
        else {
            while (cx < len && buf->cx ~= ' ' or '.' or ',' or '"') cx++;
        }
        tab-->(numwords*3+2) = (cx-bx);
        tab-->(numwords*3+3) = WORDSIZE+bx;
        numwords++;
        if (numwords >= MAX_BUFFER_WORDS) break;
    }
    tab-->0 = numwords;

    ! Now we look each word up in the dictionary.

    dictlen = #dictionary_table-->0;
    entrylen = DICT_WORD_SIZE + 7;

    for (wx=0 : wx<numwords : wx++) {
        wlen = tab-->(wx*3+2);
        wpos = tab-->(wx*3+3);

        ! Copy the word into the gg_tokenbuf array, clipping to DICT_WORD_SIZE
        ! characters and lower case.
        if (wlen > DICT_WORD_SIZE) wlen = DICT_WORD_SIZE;
        cx = wpos - WORDSIZE;
        for (ix=0 : ix<wlen : ix++) gg_tokenbuf->ix = VM_UpperToLowerCase(buf->(cx+ix));
        for (: ix<DICT_WORD_SIZE : ix++) gg_tokenbuf->ix = 0;

        val = #dictionary_table + WORDSIZE;
        @binarysearch gg_tokenbuf DICT_WORD_SIZE val entrylen dictlen 1 1 res;
        tab-->(wx*3+1) = res;
    }
];

[ LTI_Insert i ch  b y;

    ! Protect us from strict mode, as this isn't an array in quite the
    ! sense it expects
    b = buffer;

    ! Insert character ch into buffer at point i.
    ! Being careful not to let the buffer possibly overflow:
    y = b-->0;
    if (y > INPUT_BUFFER_LEN) y = INPUT_BUFFER_LEN;

    ! Move the subsequent text along one character:
    for (y=y+WORDSIZE : y>i : y--) b->y = b->(y-1);
    b->i = ch;

    ! And the text is now one character longer:
    if (b-->0 < INPUT_BUFFER_LEN) (b-->0)++;
];

[ VM_InvalidDictionaryAddress addr;
	if (addr < 0) rtrue;
	rfalse;
];

[ VM_DictionaryAddressToNumber w; return w; ];
[ VM_NumberToDictionaryAddress n; return n; ];

Array gg_tokenbuf -> DICT_WORD_SIZE;

[ GGWordCompare str1 str2 ix jx;
    for (ix=0 : ix<DICT_WORD_SIZE : ix++) {
        jx = (str1->ix) - (str2->ix);
        if (jx ~= 0) return jx;
    }
    return 0;
];

#Ifdef DEBUG;
[ DebugAction a str;
    if (a >= 4096) { print "<fake action ", a-4096, ">"; return; }
    if (a < 0 || a >= #identifiers_table-->7) print "<invalid action ", a, ">";
    else {
        str = #identifiers_table-->6;
        str = str-->a;
        if (str) print (string) str; else print "<unnamed action ", a, ">";
    }
];

[ DebugAttribute a str;
    if (a < 0 || a >= NUM_ATTR_BYTES*8) print "<invalid attribute ", a, ">";
    else {
        str = #identifiers_table-->4;
        str = str-->a;
        if (str) print (string) str; else print "<unnamed attribute ", a, ">";
    }
];
#Endif;

[ VM_CommandTableAddress i;
	return (#grammar_table)-->(i+1);
];

[ VM_PrintCommandWords i wd j dictlen entrylen;
    dictlen = #dictionary_table-->0;
    entrylen = DICT_WORD_SIZE + 7;
    for (j=0 : j<dictlen : j++) {
        wd = #dictionary_table + WORDSIZE + entrylen*j;
        if (DictionaryWordToVerbNum(wd) == i)
            print "'", (address) wd, "' ";
    }
];

[ VM_Seed_RNG n;
	@setrandom n;
];

[ VM_AllocateMemory amount i;
	@gestalt 7 0 i;
	if (i == 0) return i;
	@malloc amount i;
	return i;
];

[ VM_FreeMemory address i;
	@gestalt 7 0 i;
	if (i == 0) return;
	@mfree address;
];

[ VM_Picture resource_ID;
	if (glk_gestalt(gestalt_Graphics, 0)) {
		glk_image_draw(gg_mainwin, resource_ID, imagealign_InlineCenter, 0);
	} else {
		print "[Picture number ", resource_ID, " here.]^";
	}
];

[ VM_SoundEffect resource_ID;
	if (glk_gestalt(gestalt_Sound, 0)) {
		glk_schannel_play(gg_foregroundchan, resource_ID);
	} else {
		print "[Sound effect number ", resource_ID, " here.]^";
	}
];

[ VM_Style sty;
	switch (sty) {
		NORMAL_VMSTY:     glk_set_style(style_Normal);
		HEADER_VMSTY:     glk_set_style(style_Header);
		SUBHEADER_VMSTY:  glk_set_style(style_Subheader);
		NOTE_VMSTY:       glk_set_style(style_Note);
		ALERT_VMSTY:      glk_set_style(style_Alert);
		BLOCKQUOTE_VMSTY: glk_set_style(style_BlockQuote);
		INPUT_VMSTY:      glk_set_style(style_Input);
	}
];

[ VM_UpperToLowerCase c; return glk_char_to_lower(c); ];
[ VM_LowerToUpperCase c; return glk_char_to_upper(c); ];

! Glulx_PrintAnything()                    <nothing printed>
! Glulx_PrintAnything(0)                   <nothing printed>
! Glulx_PrintAnything("string");           print (string) "string";
! Glulx_PrintAnything('word')              print (address) 'word';
! Glulx_PrintAnything(obj)                 print (name) obj;
! Glulx_PrintAnything(obj, prop)           obj.prop();
! Glulx_PrintAnything(obj, prop, args...)  obj.prop(args...);
! Glulx_PrintAnything(func)                func();
! Glulx_PrintAnything(func, args...)       func(args...);

[ Glulx_PrintAnything _vararg_count obj mclass;
    if (_vararg_count == 0) return;
    @copy sp obj;
    _vararg_count--;
    if (obj == 0) return;

    if (obj->0 == $60) {
        ! Dictionary word. Metaclass() can't catch this case, so we do it manually
        print (address) obj;
        return;
    }

    mclass = metaclass(obj);
    switch (mclass) {
      nothing:
        return;
      String:
        print (string) obj;
        return;
      Routine:
        ! Call the function with all the arguments which are already
        ! on the stack.
        @call obj _vararg_count 0;
        return;
      Object:
        if (_vararg_count == 0) {
            print (name) obj;
        }
        else {
            ! Push the object back onto the stack, and call the
            ! veneer routine that handles obj.prop() calls.
            @copy obj sp;
            _vararg_count++;
            @call CA__Pr _vararg_count 0;
        }
        return;
    }
];

[ Glulx_PrintAnyToArray _vararg_count arr arrlen str oldstr len;
    @copy sp arr;
    @copy sp arrlen;
    _vararg_count = _vararg_count - 2;

    oldstr = glk_stream_get_current();
    str = glk_stream_open_memory(arr, arrlen, 1, 0);
    if (str == 0) return 0;

    glk_stream_set_current(str);

    @call Glulx_PrintAnything _vararg_count 0;

    glk_stream_set_current(oldstr);
    @copy $ffffffff sp;
    @copy str sp;
    @glk $0044 2 0; ! stream_close
    @copy sp len;
    @copy sp 0;
    return len;
];

Constant GG_ANYTOSTRING_LEN 66;
Array AnyToStrArr -> GG_ANYTOSTRING_LEN+1;

[ Glulx_ChangeAnyToCString _vararg_count ix len;
    ix = GG_ANYTOSTRING_LEN-2;
    @copy ix sp;
    ix = AnyToStrArr+1;
    @copy ix sp;
    ix = _vararg_count+2;
    @call Glulx_PrintAnyToArray ix len;
    AnyToStrArr->0 = $E0;
    if (len >= GG_ANYTOSTRING_LEN)
        len = GG_ANYTOSTRING_LEN-1;
    AnyToStrArr->(len+1) = 0;
    return AnyToStrArr;
];

[ VM_ClearScreen window;
    if (window == WIN_ALL or WIN_MAIN) {
        glk_window_clear(gg_mainwin);
        if (gg_quotewin) {
            glk_window_close(gg_quotewin, 0);
            gg_quotewin = 0;
        }
    }
    if (gg_statuswin && window == WIN_ALL or WIN_STATUS) glk_window_clear(gg_statuswin);
];

[ VM_ScreenWidth  id;
    id=gg_mainwin;
    if (gg_statuswin && statuswin_current) id = gg_statuswin;
    glk_window_get_size(id, gg_arguments, 0);
    return gg_arguments-->0;
];

[ VM_ScreenHeight;
    glk_window_get_size(gg_mainwin, 0, gg_arguments);
    return gg_arguments-->0;
];

[ VM_SetWindowColours f b window doclear  i fwd bwd swin;
    if (clr_on && f && b) {
        if (window) swin = 5-window; ! 4 for TextGrid, 3 for TextBuffer

        fwd = MakeColourWord(f);
        bwd = MakeColourWord(b);
        for (i=0 : i<style_NUMSTYLES: i++) {
            if (f == CLR_DEFAULT || b == CLR_DEFAULT) {  ! remove style hints
                glk_stylehint_clear(swin, i, stylehint_TextColor);
                glk_stylehint_clear(swin, i, stylehint_BackColor);
            } else {
                glk_stylehint_set(swin, i, stylehint_TextColor, fwd);
                glk_stylehint_set(swin, i, stylehint_BackColor, bwd);
            }
        }

        ! Now re-open the windows to apply the hints
        if (gg_statuswin) glk_window_close(gg_statuswin, 0);
        gg_statuswin = 0;

        if (doclear || ( window ~= 1 && (clr_fg ~= f || clr_bg ~= b) ) ) {
            glk_window_close(gg_mainwin, 0);
            gg_mainwin = glk_window_open(0, 0, 0, wintype_TextBuffer, GG_MAINWIN_ROCK);
            if (gg_scriptstr ~= 0)
                glk_window_set_echo_stream(gg_mainwin, gg_scriptstr);
        }

        gg_statuswin =
        	glk_window_open(gg_mainwin, winmethod_Fixed + winmethod_Above,
        		statuswin_cursize, wintype_TextGrid, GG_STATUSWIN_ROCK);
        if (statuswin_current && gg_statuswin) VM_MoveCursorInStatusLine(); else VM_MainWindow();

        if (window ~= 2) {
            clr_fgstatus = f;
            clr_bgstatus = b;
        }
        if (window ~= 1) {
            clr_fg = f;
            clr_bg = b;
        }
    }
];

[ VM_RestoreWindowColours; ! used after UNDO: compare I6 patch L61007
    if (clr_on) { ! check colour has been used
        VM_SetWindowColours(clr_fg, clr_bg, 2); ! make sure both sets of variables are restored
        VM_SetWindowColours(clr_fgstatus, clr_bgstatus, 1, true);
        VM_ClearScreen();
    }
];

[ MakeColourWord c;
    if (c > 9) return c;
    c = c-2;
    return $ff0000*(c&1) + $ff00*(c&2 ~= 0) + $ff*(c&4 ~= 0);
];

[ VM_MainWindow;
    glk_set_window(gg_mainwin); ! set_window
    statuswin_current=0;
];

[ VM_StatusLineHeight hgt;
    if (gg_statuswin == 0) return;
    if (hgt == statuswin_cursize) return;
    glk_window_set_arrangement(glk_window_get_parent(gg_statuswin), $12, hgt, 0);
    statuswin_cursize = hgt;
];

[ VM_MoveCursorInStatusLine line column;
    if (gg_statuswin == 0) return;
    glk_set_window(gg_statuswin);
    if (line == 0) { line = 1; column = 1; }
    glk_window_move_cursor(gg_statuswin, column-1, line-1);
    statuswin_current=1;
];

[ Box__Routine maxwid arr ix lines lastnl parwin;
    maxwid = 0; ! squash compiler warning
    lines = arr-->0;

    if (gg_quotewin == 0) {
        gg_arguments-->0 = lines;
        ix = InitGlkWindow(GG_QUOTEWIN_ROCK);
        if (ix == 0)
            gg_quotewin =
            	glk_window_open(gg_mainwin, winmethod_Fixed + winmethod_Above,
            		lines, wintype_TextBuffer, GG_QUOTEWIN_ROCK);
    } else {
        parwin = glk_window_get_parent(gg_quotewin);
        glk_window_set_arrangement(parwin, $12, lines, 0);
    }

    lastnl = true;
    if (gg_quotewin) {
        glk_window_clear(gg_quotewin);
        glk_set_window(gg_quotewin);
        lastnl = false;
    }

	VM_Style(BLOCKQUOTE_VMSTY);
    for (ix=0 : ix<lines : ix++) {
        print (string) arr-->(ix+1);
        if (ix < lines-1 || lastnl) new_line;
    }
	VM_Style(NORMAL_VMSTY);

    if (gg_quotewin) glk_set_window(gg_mainwin);
];

#Ifdef DEBUG;
[ GlkListSub id val;
    id = glk_window_iterate(0, gg_arguments);
    while (id) {
        print "Window ", id, " (", gg_arguments-->0, "): ";
        val = glk_window_get_type(id);
        switch (val) {
          1: print "pair";
          2: print "blank";
          3: print "textbuffer";
          4: print "textgrid";
          5: print "graphics";
          default: print "unknown";
        }
        val = glk_window_get_parent(id);
        if (val) print ", parent is window ", val;
        else     print ", no parent (root)";
        val = glk_window_get_stream(id);
        print ", stream ", val;
        val = glk_window_get_echo_stream(id);
        if (val) print ", echo stream ", val;
        print "^";
        id = glk_window_iterate(id, gg_arguments);
    }
    id = glk_stream_iterate(0, gg_arguments);
    while (id) {
        print "Stream ", id, " (", gg_arguments-->0, ")^";
        id = glk_stream_iterate(id, gg_arguments);
    }
    id = glk_fileref_iterate(0, gg_arguments);
    while (id) {
        print "Fileref ", id, " (", gg_arguments-->0, ")^";
        id = glk_fileref_iterate(id, gg_arguments);
    }
    if (glk_gestalt(gestalt_Sound, 0)) {
        id = glk_schannel_iterate(0, gg_arguments);
        while (id) {
            print "Soundchannel ", id, " (", gg_arguments-->0, ")^";
            id = glk_schannel_iterate(id, gg_arguments);
        }
    }
];

Verb meta 'glklist'

    *                                           -> Glklist;
#Endif;

[ VM_Undo result_code;
	@restoreundo result_code;
	return (~~result_code);
];

[ VM_Save_Undo result_code;
    @saveundo result_code;
    if (result_code == -1) { GGRecoverObjects(); return 2; }
    return (~~result_code);
];

[ QUIT_THE_GAME_R;
	if (actor ~= player) rfalse;
	GL__M(##Quit, 2); if (YesOrNo()~=0) quit;
];

[ RESTART_THE_GAME_R;
	if (actor ~= player) rfalse;
	GL__M(##Restart, 1);
	if (YesOrNo() ~= 0) {
		@restart;
		GL__M(##Restart, 2);
	}
];

[ RESTORE_THE_GAME_R res fref;
	if (actor ~= player) rfalse;
	fref = glk_fileref_create_by_prompt($01, $02, 0);
	if (fref == 0) jump RFailed;
	gg_savestr = glk_stream_open_file(fref, $02, GG_SAVESTR_ROCK);
	glk_fileref_destroy(fref);
	if (gg_savestr == 0) jump RFailed;
	@restore gg_savestr res;
	glk_stream_close(gg_savestr, 0);
	gg_savestr = 0;
	.RFailed;
	GL__M(##Restore, 1);
];

[ SAVE_THE_GAME_R res fref;
	if (actor ~= player) rfalse;
	fref = glk_fileref_create_by_prompt($01, $01, 0);
	if (fref == 0) jump SFailed;
	gg_savestr = glk_stream_open_file(fref, $01, GG_SAVESTR_ROCK);
	glk_fileref_destroy(fref);
	if (gg_savestr == 0) jump SFailed;
	@save gg_savestr res;
	if (res == -1) {
		! The player actually just typed "restore". We're going to print
		!  GL__M(##Restore,2); the Z-Code Inform library does this correctly
		! now. But first, we have to recover all the Glk objects; the values
		! in our global variables are all wrong.
		GGRecoverObjects();
		glk_stream_close(gg_savestr, 0); ! stream_close
		gg_savestr = 0;
		return GL__M(##Restore, 2);
	}
	glk_stream_close(gg_savestr, 0); ! stream_close
	gg_savestr = 0;
	if (res == 0) return GL__M(##Save, 2);
	.SFailed;
	GL__M(##Save, 1);
];

[ VERIFY_THE_STORY_FILE_R res;
	if (actor ~= player) rfalse;
	@verify res;
	if (res == 0) return GL__M(##Verify, 1);
	GL__M(##Verify, 2);
];

[ SWITCH_TRANSCRIPT_ON_R;
	if (actor ~= player) rfalse;
	if (gg_scriptstr ~= 0) return GL__M(##ScriptOn, 1);
	if (gg_scriptfref == 0) {
		gg_scriptfref = glk_fileref_create_by_prompt($102, $05, GG_SCRIPTFREF_ROCK);
		if (gg_scriptfref == 0) jump S1Failed;
	}
	! stream_open_file
	gg_scriptstr = glk_stream_open_file(gg_scriptfref, $05, GG_SCRIPTSTR_ROCK);
	if (gg_scriptstr == 0) jump S1Failed;
	glk_window_set_echo_stream(gg_mainwin, gg_scriptstr);
	GL__M(##ScriptOn, 2);
	VersionSub();
	return;
	.S1Failed;
	GL__M(##ScriptOn, 3);
];

[ SWITCH_TRANSCRIPT_OFF_R;
	if (actor ~= player) rfalse;
	if (gg_scriptstr == 0) return GL__M(##ScriptOff,1);
	GL__M(##ScriptOff, 2);
	glk_stream_close(gg_scriptstr, 0); ! stream_close
	gg_scriptstr = 0;
];

[ ANNOUNCE_STORY_FILE_VERSION_R ix;
	if (actor ~= player) rfalse;
	Banner();
	print "Identification number: ";
	for (ix=6: ix <= UUID_ARRAY->0: ix++) print (char) UUID_ARRAY->ix;
	print "^";
	@gestalt 1 0 ix;
	print "Interpreter version ", ix / $10000, ".", (ix & $FF00) / $100,
	".", ix & $FF, " / ";
	@gestalt 0 0 ix;
	print "VM ", ix / $10000, ".", (ix & $FF00) / $100, ".", ix & $FF, " / ";
	print "Library serial number ", (string) LibSerial, "^";
	#Ifdef LanguageVersion;
	print (string) LanguageVersion, "^";
	#Endif; ! LanguageVersion
	ShowExtensionVersions();
	say__p = 1;
];

[ DESCEND_TO_SPECIFIC_ACTION_R;
	indirect(#actions_table-->(action+1));
	rtrue;
];

#Endif;

#Ifdef TARGET_ZCODE;
Global top_object; ! largest valid number of any tree object
Global xcommsdir; ! true if command recording is on
Global transcript_mode; ! true if game scripting is on

Constant INPUT_BUFFER_LEN = 120; ! Length of buffer array

Array  buffer    -> 123;            ! Buffer for parsing main line of input
Array  buffer2   -> 123;            ! Buffers for supplementary questions
Array  buffer3   -> 123;            ! Buffer retaining input for "again"
Array  parse     buffer 63;         ! Parse table mirroring it
Array  parse2    buffer 63;         !

Global dict_start;
Global dict_entry_size;
Global dict_end;

[ VM_Initialise i;
	standard_interpreter = HDR_TERPSTANDARD-->0;
	transcript_mode = ((HDR_GAMEFLAGS-->0) & 1);

	dict_start = HDR_DICTIONARY-->0;
	dict_entry_size = dict_start->(dict_start->0 + 1);
	dict_start = dict_start + dict_start->0 + 4;
	dict_end = dict_start + ((dict_start - 2)-->0) * dict_entry_size;

	buffer->0  = INPUT_BUFFER_LEN;
	buffer2->0 = INPUT_BUFFER_LEN;
	buffer3->0 = INPUT_BUFFER_LEN;
	parse->0   = 15;
	parse2->0  = 15;

	top_object = #largest_object-255;

	#ifdef FIX_RNG;
	@random 10000 -> i;
	i = -i-2000;
	print "[Random number generator seed is ", i, "]^";
	@random i -> i;
	#endif; ! FIX_RNG	
];

[ ENABLE_GLULX_ACCEL_R;
	rfalse;
];

[ VM_Describe_Release i;
	print "Release ", (HDR_GAMERELEASE-->0) & $03ff, " / Serial number ";
	for (i=0 : i<6 : i++) print (char) HDR_GAMESERIAL->i;
];

[ VM_KeyChar win  key;
    if (win) @set_window win;
    @read_char 1 -> key;
    return key;
];

[ VM_KeyDelay tenths  key;
    @read_char 1 tenths VM_KeyDelay_Interrupt -> key;
    return key;
];
[ VM_KeyDelay_Interrupt; rtrue; ];

[ VM_ReadKeyboard  a_buffer a_table i;
    read a_buffer a_table;
    #ifdef ECHO_COMMANDS;
    print "** ";
    for (i=2: i<=(a_buffer->1)+1: i++) print (char) a_buffer->i;
    print "^";
    #ifnot;
    i=0;  ! suppress compiler warning
    #endif;

    #Iftrue (#version_number == 6);
    @output_stream -1;
    @loadb a_buffer 1 -> sp;
    @add a_buffer 2 -> sp;
    @print_table sp sp;
    new_line;
    @output_stream 1;
    #Endif;
];

[ VM_CopyBuffer bto bfrom i;
    for (i=0: i<INPUT_BUFFER_LEN: i++) bto->i = bfrom->i;
];

[ VM_PrintToBuffer buf len a b c;
    @output_stream 3 buf;
    switch (metaclass(a)) {
		String: print (string) a;
		Routine: a(b, c);
		Object, Class: if (b) PrintOrRun(a, b, true); else print (name) a;
    }
    @output_stream -3;
    if (buf-->0 > len) print "Error: Overflow in VM_PrintToBuffer.^";
    return buf-->0;
];

[ VM_Tokenise b p; b->(2 + b->1) = 0; @tokenise b p; ];

[ LTI_Insert i ch  b y;
    ! Protect us from strict mode, as this isn't an array in quite the
    ! sense it expects
    b = buffer;

    ! Insert character ch into buffer at point i.
    ! Being careful not to let the buffer possibly overflow:
    y = b->1;
    if (y > b->0) y = b->0;

    ! Move the subsequent text along one character:
    for (y=y+2 : y>i : y--) b->y = b->(y-1);
    b->i = ch;

    ! And the text is now one character longer:
    if (b->1 < b->0) (b->1)++;
];

[ VM_InvalidDictionaryAddress addr;
    if ((UnsignedCompare(addr, dict_start) < 0) ||
		(UnsignedCompare(addr, dict_end) >= 0) ||
		((addr - dict_start) % dict_entry_size ~= 0)) rtrue;
	rfalse;
];

[ VM_DictionaryAddressToNumber w; return (w-(HDR_DICTIONARY-->0 + 7))/9; ];
[ VM_NumberToDictionaryAddress n; return HDR_DICTIONARY-->0 + 7 + 9*n; ];

[ VM_CommandTableAddress i;
	return (HDR_STATICMEMORY-->0)-->i;
];

[ VM_PrintCommandWords i da j;
    da = HDR_DICTIONARY-->0;
    for (j=0 : j<(da+5)-->0 : j++)
        if (da->(j*9 + 14) == $ff-i)
        	print "'", (address) VM_NumberToDictionaryAddress(j), "' ";
];

#Ifdef DEBUG;
[ DebugAction a anames;
    if (a >= 4096) { print "<fake action ", a-4096, ">"; return; }
    anames = #identifiers_table;
    anames = anames + 2*(anames-->0) + 2*48;
    print (string) anames-->a;
];

[ DebugAttribute a anames;
    if (a < 0 || a >= 48) print "<invalid attribute ", a, ">";
    else {
        anames = #identifiers_table; anames = anames + 2*(anames-->0);
        print (string) anames-->a;
    }
];
#Endif;

[ VM_Seed_RNG n;
	if (n > 0) n = -n;
	@random n -> n;
];

[ VM_AllocateMemory amount;
	return 0;
];

[ VM_FreeMemory address;
];

[ VM_Picture resource_ID;
	#IFTRUE #version_number == 6; ! Z-machine version 6
	@draw_picture resource_ID;
	#ENDIF;
];

[ VM_SoundEffect resource_ID;
	#IFTRUE #version_number == 6; ! Z-machine version 6
	@sound_effect resource_ID;
	#ENDIF;
];

[ VM_Style sty;
	switch (sty) {
		NORMAL_VMSTY, NOTE_VMSTY: style roman;
		HEADER_VMSTY, SUBHEADER_VMSTY, ALERT_VMSTY: style bold;
	}
];

[ VM_UpperToLowerCase c;
   switch (c) {
     'A' to 'Z': c = c + 32;
     202, 204, 212, 214, 221: c--;
     217, 218: c = c - 2;
     158 to 160, 167 to 169, 208 to 210: c = c - 3;
     186 to 190, 196 to 200: c = c - 5 ;
     175 to 180: c = c - 6;
   }
   return c;
];

[ VM_LowerToUpperCase c;
   switch (c) {
     'a' to 'z': c = c - 32;
     201, 203, 211, 213, 220: c++;
     215, 216: c = c + 2;
     155 to 157, 164 to 166, 205 to 207: c = c + 3;
     181 to 185, 191 to 195: c = c + 5 ;
     169 to 174: c = c + 6;
   }
   return c;
];

[ VM_ClearScreen window;
    switch (window) {
		WIN_ALL:    @erase_window -1; statuswin_cursize = 0;
		WIN_STATUS: @erase_window 1;
		WIN_MAIN:   @erase_window 0;
    }
];

#Iftrue (#version_number == 6);
[ VM_ScreenWidth  width charw;
    @get_wind_prop 1 3 -> width;
    @get_wind_prop 1 13 -> charw;
    charw = charw & $FF;
    return (width+charw-1) / charw;
];
#Ifnot;
[ VM_ScreenWidth; return (HDR_SCREENWCHARS->0); ];
#Endif;

[ VM_ScreenHeight; return (HDR_SCREENHLINES->0); ];

[ VM_SetWindowColours f b window;
    if (clr_on && f && b) {
        if (window == 0) {  ! if setting both together, set reverse
            clr_fgstatus = b;
            clr_bgstatus = f;
            }
        if (window == 1) {
            clr_fgstatus = f;
            clr_bgstatus = b;
        }
        if (window == 0 or 2) {
            clr_fg = f;
            clr_bg = b;
        }
        if (statuswin_current)
            @set_colour clr_fgstatus clr_bgstatus;
        else
            @set_colour clr_fg clr_bg;
    }
];

[ VM_RestoreWindowColours; ! compare I6 library patch L61007
    if (clr_on) { ! check colour has been used
        VM_SetWindowColours(clr_fg, clr_bg, 2); ! make sure both sets of variables are restored
        VM_SetWindowColours(clr_fgstatus, clr_bgstatus, 1, true);
        VM_ClearScreen();
    }
    #Iftrue (#version_number == 6); ! request screen update
    (0-->8) = (0-->8) | $$00000100;
    #Endif;
];

[ VM_MainWindow;
    if (statuswin_current) {
        if (clr_on && clr_bgstatus > 1) @set_colour clr_fg clr_bg;
        else style roman;
        @set_window 0;
    }
    statuswin_current = false;
];

[ VM_MoveCursorInStatusLine line column; ! 1-based position on text grid
    if (~~statuswin_current) {
         @set_window 1;
         if (clr_on && clr_bgstatus > 1) @set_colour clr_fgstatus clr_bgstatus;
         else                            style reverse;
    }
    if (line == 0) {
        line = 1;
        column = 1;
    }
    #Iftrue (#version_number == 6);
    Z6_MoveCursor(line, column);
    #Ifnot;
    @set_cursor line column;
    #Endif;
	statuswin_current = true;
];

#Iftrue (#version_number == 6);
[ Z6_MoveCursor line column  charw charh; ! 1-based position on text grid
	@get_wind_prop 1 13 -> charw; ! font size
	@log_shift charw $FFF8 -> charh;
	charw = charw / $100;
	line = 1 + charh*(line-1);
	column = 1 + charw*(column-1);
	@set_cursor line column;
];
#Endif;

#Iftrue (#version_number == 6);
[ VM_StatusLineHeight height  wx wy x y charh;
    ! Split the window. Standard 1.0 interpreters should keep the window 0
    ! cursor in the same absolute position, but older interpreters,
    ! including Infocom's don't - they keep the window 0 cursor in the
    ! same position relative to its origin. We therefore compensate
    ! manually.
    @get_wind_prop 0 0 -> wy; @get_wind_prop 0 1 -> wx;
    @get_wind_prop 0 13 -> charh; @log_shift charh $FFF8 -> charh;
    @get_wind_prop 0 4 -> y; @get_wind_prop 0 5 -> x;
    height = height * charh;
    @split_window height;
    y = y - height + wy - 1;
    if (y < 1) y = 1;
    x = x + wx - 1;
    @set_cursor y x 0;
    statuswin_cursize = height;
];
#Ifnot;
[ VM_StatusLineHeight height;
    if (statuswin_cursize ~= height)
        @split_window height;
    statuswin_cursize = height;
];
#Endif;

#Iftrue (#version_number == 6);
[ Z6_DrawStatusLine width x charw scw;
	(0-->8) = (0-->8) &~ $$00000100;
	@push say__p; @push say__pc;
	BeginActivity(CONSTRUCTING_STATUS_LINE_ACT);
	VM_StatusLineHeight(statuswin_size);
	! Now clear the window. This isn't totally trivial. Our approach is to select the
	! fixed space font, measure its width, and print an appropriate
	! number of spaces. We round up if the screen isn't a whole number
	! of characters wide, and rely on window 1 being set to clip by default.
	VM_MoveCursorInStatusLine(1, 1);
	@set_font 4 -> x;
	width = VM_ScreenWidth();
	spaces width;
	ClearParagraphing();
	if (ForActivity(CONSTRUCTING_STATUS_LINE_ACT) == false) {
		! Back to standard font for the display. We use output_stream 3 to
		! measure the space required, the aim being to get 50 characters
		! worth of space for the location name.
		VM_MoveCursorInStatusLine(1, 2);
		@set_font 1 -> x;
		switch (metaclass(left_hand_status_line)) {
			String: print (string) left_hand_status_line;
			Routine: left_hand_status_line();
		}
		@get_wind_prop 1 3 -> width;
		@get_wind_prop 1 13 -> charw;
		charw = charw & $FF;
		@output_stream 3 StorageForShortName;
		print (PrintText) right_hand_status_line;
		@output_stream -3; scw = HDR_PIXELSTO3-->0 + charw;
		x = 1+width-scw;
		@set_cursor 1 x; print (PrintText) right_hand_status_line;
	}
	! Reselect roman, as Infocom's interpreters go funny if reverse is selected twice.
	VM_MainWindow();
	ClearParagraphing();
	EndActivity(CONSTRUCTING_STATUS_LINE_ACT);
	@pull say__pc; @pull say__p;
];
#Endif;

[ VM_Undo result_code;
	@restore_undo result_code;
	return result_code;
];

[ VM_Save_Undo result_code;
    @save_undo result_code;
	return result_code;
];

[ QUIT_THE_GAME_R; if (actor ~= player) rfalse;
	GL__M(##Quit,2); if (YesOrNo()~=0) quit; ];

[ RESTART_THE_GAME_R;
	if (actor ~= player) rfalse;
	GL__M(##Restart,1);
	if (YesOrNo()~=0) { @restart; GL__M(##Restart,2); }
];

[ RESTORE_THE_GAME_R;
	if (actor ~= player) rfalse;
	restore Rmaybe;
	return GL__M(##Restore,1);
	.RMaybe; GL__M(##Restore,2);
];

[ SAVE_THE_GAME_R flag;
	if (actor ~= player) rfalse;
	#IFV5;
	@save -> flag;
	switch (flag) {
		0: GL__M(##Save,1);
		1: GL__M(##Save,2);
		2: GL__M(##Restore,2);
	}
	#IFNOT;
	save Smaybe;
	return GL__M(##Save,1);
	.SMaybe; GL__M(##Save,2);
	#ENDIF;
];

[ VERIFY_THE_STORY_FILE_R;
	if (actor ~= player) rfalse;
	@verify ?Vmaybe;
	jump Vwrong;
	.Vmaybe; return GL__M(##Verify,1);
	.Vwrong;
	GL__M(##Verify,2);
];

[ SWITCH_TRANSCRIPT_ON_R;
	if (actor ~= player) rfalse;
	transcript_mode = ((0-->8) & 1);
	if (transcript_mode) return GL__M(##ScriptOn,1);
	@output_stream 2;
	if (((0-->8) & 1) == 0) return GL__M(##ScriptOn,3);
	GL__M(##ScriptOn,2); VersionSub();
	transcript_mode = true;
];

[ SWITCH_TRANSCRIPT_OFF_R;
	if (actor ~= player) rfalse;
	transcript_mode = ((0-->8) & 1);
	if (transcript_mode == false) return GL__M(##ScriptOff,1);
	GL__M(##ScriptOff,2);
	@output_stream -2;
	if ((0-->8) & 1) return GL__M(##ScriptOff,3);
	transcript_mode = false;
];

[ ANNOUNCE_STORY_FILE_VERSION_R ix;
	if (actor ~= player) rfalse;
	Banner();
	print "Identification number: ";
	for (ix=6: ix <= UUID_ARRAY->0: ix++) print (char) UUID_ARRAY->ix;
	print "^";
	ix = 0; ! shut up compiler warning
	if (standard_interpreter > 0) {
		print "Standard interpreter ",
			standard_interpreter/256, ".", standard_interpreter%256,
			" (", HDR_TERPNUMBER->0;
		#Iftrue (#version_number == 6);
		print (char) '.', HDR_TERPVERSION->0;
		#Ifnot;
		print (char) HDR_TERPVERSION->0;
		#Endif;
		print ") / ";
	} else {
		print "Interpreter ", HDR_TERPNUMBER->0, " Version ";
		#Iftrue (#version_number == 6);
		print HDR_TERPVERSION->0;
		#Ifnot;
		print (char) HDR_TERPVERSION->0;
		#Endif;
		print " / ";
	}
	print "Library serial number ", (string) LibSerial, "^";
	#Ifdef LanguageVersion;
	print (string) LanguageVersion, "^";
	#Endif; ! LanguageVersion
	#ifdef ShowExtensionVersions;
	ShowExtensionVersions();
	#endif;
	say__p = 1;
];

[ DESCEND_TO_SPECIFIC_ACTION_R;
	indirect(#actions_table-->action);
	rtrue;
];

[ OhLookItsReal; ];
[ OhLookItsRoom; ];
[ OhLookItsThing; ];

[ OC__Cl obj cla j a n objflag;

!	if (cla > 4) OhLookItsReal();
!	if (cla == K1_room) OhLookItsRoom();
!	if (cla == K2_thing) OhLookItsThing();

	@jl obj 1 ?NotObj;
	@jg obj max_z_object ?NotObj;
	@inc objflag;
	@je cla K1_room ?~NotRoom;
	@test_attr obj mark_as_room ?rtrue;
	@rfalse;
	.NotRoom;
	@je cla K2_thing ?~NotObj;
	@test_attr obj mark_as_thing ?rtrue;
	@rfalse;
	.NotObj;

	@je cla Object Class ?ObjOrClass;
	@je cla Routine String ?RoutOrStr;

	@jin cla 1 ?~Mistake;

	@jz objflag ?rfalse;
	@get_prop_addr obj 2 -> a;
	@jz a ?rfalse;
	@get_prop_len a -> n;

	@div n 2 -> n;
	.Loop;
	@loadw a j -> sp;
	@je sp cla ?rtrue;
	@inc j;
	@jl j n ?Loop;
	@rfalse;

	.ObjOrClass;
	@jz objflag ?rfalse;
	@je cla Object ?JustObj;

	! So now cla is Class
	@jg obj String ?~rtrue;
	@jin obj Class ?rtrue;
	@rfalse;

	.JustObj;
	! So now cla is Object
	@jg obj String ?~rfalse;
	@jin obj Class ?rfalse;
	@rtrue;

	.RoutOrStr;
	@jz objflag ?~rfalse;
	@call_2s Z__Region obj -> sp;
	@inc sp;
	@je sp cla ?rtrue;
	@rfalse;

	.Mistake;
	RT__Err("apply 'ofclass' for", cla, -1);
	rfalse;
];

[ Unsigned__Compare x y u v;
	@je x y ?rfalse; ! i.e., return 0
	@jl x 0 ?XNegative;
	! So here x >= 0 and x ~= y
	@jl y 0 ?XPosYNeg;

	! Here x >=0, y >= 0, x ~= y

	@jg x y ?rtrue; ! i.e., return 1
	@ret -1;

	.XPosYNeg;
	! Here x >= 0, y < 0, x ~= y
	@ret -1;

	.XNegative;
	@jl y 0 ?~rtrue; ! if x < 0, y >= 0, return 1
	
	! Here x < 0, y < 0, x ~= y
	@jg x y ?rtrue;
	@ret -1;
];

[ RT__ChLDW base offset;
    @loadw base offset -> sp;
    @ret sp;
];

#Endif;

Object Compass "compass" has concealed;

Constant AGAIN1__WD     = 'again';
Constant AGAIN2__WD     = 'g//';
Constant AGAIN3__WD     = 'again';
Constant OOPS1__WD      = 'oops';
Constant OOPS2__WD      = 'o//';
Constant OOPS3__WD      = 'oops';
Constant UNDO1__WD      = 'undo';
Constant UNDO2__WD      = 'undo';
Constant UNDO3__WD      = 'undo';

Constant ALL1__WD       = 'all';
Constant ALL2__WD       = 'each';
Constant ALL3__WD       = 'every';
Constant ALL4__WD       = 'everything';
Constant ALL5__WD       = 'both';
Constant AND1__WD       = 'and';
Constant AND2__WD       = 'and';
Constant AND3__WD       = 'and';
Constant BUT1__WD       = 'but';
Constant BUT2__WD       = 'except';
Constant BUT3__WD       = 'but';
Constant ME1__WD        = 'me';
Constant ME2__WD        = 'myself';
Constant ME3__WD        = 'self';
Constant OF1__WD        = 'of';
Constant OF2__WD        = 'of';
Constant OF3__WD        = 'of';
Constant OF4__WD        = 'of';
Constant OTHER1__WD     = 'another';
Constant OTHER2__WD     = 'other';
Constant OTHER3__WD     = 'other';
Constant THEN1__WD      = 'then';
Constant THEN2__WD      = 'then';
Constant THEN3__WD      = 'then';

Constant NO1__WD        = 'n//';
Constant NO2__WD        = 'no';
Constant NO3__WD        = 'no';
Constant YES1__WD       = 'y//';
Constant YES2__WD       = 'yes';
Constant YES3__WD       = 'yes';

Constant AMUSING__WD    = 'amusing';
Constant FULLSCORE1__WD = 'fullscore';
Constant FULLSCORE2__WD = 'full';
Constant QUIT1__WD      = 'q//';
Constant QUIT2__WD      = 'quit';
Constant RESTART__WD    = 'restart';
Constant RESTORE__WD    = 'restore';

Array LanguagePronouns table

  ! word        possible GNAs                   connected
  !             to follow:                      to:
  !             a     i
  !             s  p  s  p
  !             mfnmfnmfnmfn

    'it'      $$001000111000                    NULL
    'him'     $$100000000000                    NULL
    'her'     $$010000000000                    NULL
    'them'    $$000111000111                    NULL;

Array LanguageDescriptors table

  ! word        possible GNAs   descriptor      connected
  !             to follow:      type:           to:
  !             a     i
  !             s  p  s  p
  !             mfnmfnmfnmfn

    'my'      $$111111111111    POSSESS_PK      0
    'this'    $$111111111111    POSSESS_PK      0
    'these'   $$000111000111    POSSESS_PK      0
    'that'    $$111111111111    POSSESS_PK      1
    'those'   $$000111000111    POSSESS_PK      1
    'his'     $$111111111111    POSSESS_PK      'him'
    'her'     $$111111111111    POSSESS_PK      'her'
    'their'   $$111111111111    POSSESS_PK      'them'
    'its'     $$111111111111    POSSESS_PK      'it'
    'the'     $$111111111111    DEFART_PK       NULL
    'a//'     $$111000111000    INDEFART_PK     NULL
    'an'      $$111000111000    INDEFART_PK     NULL
    'some'    $$000111000111    INDEFART_PK     NULL
    'lit'     $$111111111111    light           NULL
    'lighted' $$111111111111    light           NULL
    'unlit'   $$111111111111    (-light)        NULL;

Array LanguageNumbers table
    'one' 1 'two' 2 'three' 3 'four' 4 'five' 5
    'six' 6 'seven' 7 'eight' 8 'nine' 9 'ten' 10
    'eleven' 11 'twelve' 12 'thirteen' 13 'fourteen' 14 'fifteen' 15
    'sixteen' 16 'seventeen' 17 'eighteen' 18 'nineteen' 19 'twenty' 20
    'twenty-one' 21 'twenty-two' 22 'twenty-three' 23 'twenty-four' 24
	'twenty-five' 25 'twenty-six' 26 'twenty-seven' 27 'twenty-eight' 28
	'twenty-nine' 29 'thirty' 30
;

[ LanguageNumber n f;
    if (n == 0)    { print "zero"; rfalse; }
    if (n < 0)     { print "minus "; n = -n; }
#Iftrue (WORDSIZE == 4);
    if (n >= 1000000000) {
        if (f == 1) print ", ";
    	print (LanguageNumber) n/1000000000, " billion"; n = n%1000000000; f = 1;
    }
    if (n >= 1000000) {
        if (f == 1) print ", ";
    	print (LanguageNumber) n/1000000, " million"; n = n%1000000; f = 1;
    }
#Endif;
    if (n >= 1000) {
        if (f == 1) print ", ";
    	print (LanguageNumber) n/1000, " thousand"; n = n%1000; f = 1;
    }
    if (n >= 100)  {
        if (f == 1) print ", ";
        print (LanguageNumber) n/100, " hundred"; n = n%100; f = 1;
    }
    if (n == 0) rfalse;
    #Ifdef DIALECT_US;
    if (f == 1) print " ";
    #Ifnot;
    if (f == 1) print " and ";
    #Endif;
    switch (n) {
      1:    print "one";
      2:    print "two";
      3:    print "three";
      4:    print "four";
      5:    print "five";
      6:    print "six";
      7:    print "seven";
      8:    print "eight";
      9:    print "nine";
      10:   print "ten";
      11:   print "eleven";
      12:   print "twelve";
      13:   print "thirteen";
      14:   print "fourteen";
      15:   print "fifteen";
      16:   print "sixteen";
      17:   print "seventeen";
      18:   print "eighteen";
      19:   print "nineteen";
      20 to 99: switch (n/10) {
        2:  print "twenty";
        3:  print "thirty";
        4:  print "forty";
        5:  print "fifty";
        6:  print "sixty";
        7:  print "seventy";
        8:  print "eighty";
        9:  print "ninety";
        }
        if (n%10 ~= 0) print "-", (LanguageNumber) n%10;
    }
];

[ LanguageTimeOfDay hours mins i;
    i = hours%12;
    if (i == 0) i = 12;
    if (i < 10) print " ";
    print i, ":", mins/10, mins%10;
    if ((hours/12) > 0) print " pm"; else print " am";
];

[ LanguageDirection d;
	print (name) d;
];

[ LanguageToInformese; ];

Constant LanguageAnimateGender   = male;
Constant LanguageInanimateGender = neuter;

Constant LanguageContractionForms = 2;     ! English has two:
                                           ! 0 = starting with a consonant
                                           ! 1 = starting with a vowel

[ LanguageContraction text;
    if (text->0 == 'a' or 'e' or 'i' or 'o' or 'u'
                or 'A' or 'E' or 'I' or 'O' or 'U') return 1;
    return 0;
];

Array LanguageArticles -->

 !   Contraction form 0:     Contraction form 1:
 !   Cdef   Def    Indef     Cdef   Def    Indef

     "The " "the " "a "      "The " "the " "an "          ! Articles 0
     "The " "the " "some "   "The " "the " "some ";       ! Articles 1

                   !             a           i
                   !             s     p     s     p
                   !             m f n m f n m f n m f n

Array LanguageGNAsToArticles --> 0 0 0 1 1 1 0 0 0 1 1 1;

[ LanguageVerb i;
    switch (i) {
      'i//','inv','inventory':
               print "take inventory";
      'l//':   print "look";
      'x//':   print "examine";
      'z//':   print "wait";
      default: rfalse;
    }
    rtrue;
];

[ LanguageVerbLikesAdverb w;
    if (w == 'look' or 'go' or 'push' or 'walk')
        rtrue;
    rfalse;
];

[ LanguageVerbMayBeName w;
    if (w == 'long' or 'short' or 'normal'
                    or 'brief' or 'full' or 'verbose')
        rtrue;
    rfalse;
];

Constant NKEY__TX       = "N = next subject";
Constant PKEY__TX       = "P = previous";
Constant QKEY1__TX      = "  Q = resume game";
Constant QKEY2__TX      = "Q = previous menu";
Constant RKEY__TX       = "RETURN = read subject";

Constant NKEY1__KY      = 'N';
Constant NKEY2__KY      = 'n';
Constant PKEY1__KY      = 'P';
Constant PKEY2__KY      = 'p';
Constant QKEY1__KY      = 'Q';
Constant QKEY2__KY      = 'q';

Constant SCORE__TX      = "Score: ";
Constant MOVES__TX      = "Moves: ";
Constant TIME__TX       = "Time: ";
Global CANTGO__TX     = "You can't go that way.";
Global FORMER__TX     = "your former self";
Global YOURSELF__TX   = "yourself";
Constant YOU__TX        = "You";
Constant DARKNESS__TX   = "Darkness";

Constant THOSET__TX     = "those things";
Constant THAT__TX       = "that";
Constant OR__TX         = " or ";
Constant NOTHING__TX    = "nothing";
Constant NOTHING2__TX    = "Nothing";
Global IS__TX         = " is";
Global ARE__TX        = " are";
Global IS2__TX        = "is ";
Global ARE2__TX       = "are ";
Global IS3__TX        = "is";
Global ARE3__TX       = "are";
Constant AND__TX        = " and ";
#ifdef SERIAL_COMMA;
Constant LISTAND__TX   = ", and ";
Constant LISTAND2__TX  = " and ";
#ifnot;
Constant LISTAND__TX   = " and ";
Constant LISTAND2__TX  = " and ";
#endif; ! SERIAL_COMMA
Constant WHOM__TX       = "whom ";
Constant WHICH__TX      = "which ";
Constant COMMA__TX      = ", ";

[ ThatorThose obj;      ! Used in the accusative
    if (obj == player)            { print "you"; return; }
    if (obj has pluralname)       { print "those"; return; }
    if (obj has animate) {
        if (obj has female)       { print "her"; return; }
        else
            if (obj hasnt neuter) { print "him"; return; }
    }
    print "that";
];

[ ItorThem obj;
    if (obj == player)            { print "yourself"; return; }
    if (obj has pluralname)       { print "them"; return; }
    if (obj has animate) {
        if (obj has female)       { print "her"; return; }
        else
            if (obj hasnt neuter) { print "him"; return; }
    }
    print "it";
];

[ IsorAre obj;
    if (obj has pluralname || obj == player) print "are"; else print "is";
];

[ HasorHave obj;
    if (obj has pluralname || obj == player) print "have"; else print "has";
];

[ CThatorThose obj;     ! Used in the nominative
    if (obj == player)            { print "You"; return; }
    if (obj has pluralname)       { print "Those"; return; }
    if (obj has animate) {
        if (obj has female)       { print "She"; return; }
        else
            if (obj hasnt neuter) { print "He"; return; }
    }
    print "That";
];

[ CTheyreorThats obj;
    if (obj == player)             { print "You're"; return; }
    if (obj has pluralname)        { print "They're"; return; }
    if (obj has animate) {
        if (obj has female)        { print "She's"; return; }
        else if (obj hasnt neuter) { print "He's"; return; }
    }
    print "That's";
];

[ HisHerTheir o; if (o has pluralname) { print "their"; return; }
	if (o has female) { print "her"; return; }
	if (o has neuter) { print "its"; return; }
	print "his";
];

[ HimHerItself o; if (o has pluralname) { print "theirselves"; return; }
	if (o has female) { print "herself"; return; }
	if (o has neuter) { print "itself"; return; }
	print "himself";
];

[ LanguageLM n x1 x2;
  say__p = 1;
  Answer,Ask:
            "There is no reply.";
! Ask:      see Answer
  Attack:   "Violence isn't the answer to this one.";
  Burn:     "This dangerous act would achieve little.";
  Buy:      "Nothing is on sale.";
  Climb:    "I don't think much is to be achieved by that.";
  Close: switch (n) {
        1:  print_ret (ctheyreorthats) x1, " not something you can close.";
        2:  print_ret (ctheyreorthats) x1, " already closed.";
        3:  "You close ", (the) x1, ".";
		4:	print (The) actor, " closes ", (the) x1, ".^";
		5:	print (The) x1, " close"; if (x1 hasnt pluralname) print "s";
			print ".^";
    }
  Consult: switch (n) {
  		1:	"You discover nothing of interest in ", (the) x1, ".";
  		2:	print (The) actor, " looks at ", (the) x1, ".^";
    }
  Cut:      "Cutting ", (thatorthose) x1, " up would achieve little.";
  Disrobe: switch (n) {
        1:  "You're not wearing ", (thatorthose) x1, ".";
        2:  "You take off ", (the) x1, ".";
		3:	print (The) actor, " takes off ", (the) x1, ".^";
    }
  Drink:    "There's nothing suitable to drink here.";
  Drop: switch (n) {
        1:  if (x1 has pluralname) print (The) x1, " are "; else print (The) x1, " is ";
            "already here.";
        2:  "You haven't got ", (thatorthose) x1, ".";
        3:  print "(first taking ", (the) x1, " off)^"; say__p = 0; return;
        4:  "Dropped.";
        5:	"There is no more room on ", (the) x1, ".";
        6:	"There is no more room in ", (the) x1, ".";
        7:	print (The) actor, " puts down ", (the) x1, ".^";
    }
  Eat: switch (n) {
        1:  print_ret (ctheyreorthats) x1, " plainly inedible.";
        2:  "You eat ", (the) x1, ". Not bad.";
        3:	print (The) actor, " eats ", (the) x1, ".^";
    }
  Enter: switch (n) {
        1:  print "But you're already ";
            if (x1 has supporter) print "on "; else print "in ";
            print_ret (the) x1, ".";
        2:  if (x1 has pluralname) print "They're"; else print "That's";
            print " not something you can ";
            switch (verb_word) {
              'stand':  "stand on.";
              'sit':    "sit down on.";
              'lie':    "lie down on.";
              default:  "enter.";
            }
        3:  "You can't get into the closed ", (name) x1, ".";
        4:  "You can only get into something free-standing.";
        5:  print "You get ";
            if (x1 has supporter) print "onto "; else print "into ";
            print_ret (the) x1, ".";
        6:  print "(getting ";
            if (x1 has supporter) print "off "; else print "out of ";
            print (the) x1; print ")^"; say__p = 0; return;
        7:  ! say__p = 0;
            if (x1 has supporter) "(getting onto ", (the) x1, ")";
            if (x1 has container) "(getting into ", (the) x1, ")";
            "(entering ", (the) x1, ")";
		8:	print (The) actor, " gets into ", (the) x1, ".^";
        9:  print (The) actor, " gets onto ", (the) x1, ".^";
    }
  Examine: switch (n) {
        1:  "Darkness, noun.  An absence of light to see by.";
        2:  "You see nothing special about ", (the) x1, ".";
        3:  print (The) x1, " ", (isorare) x1, " currently switched ";
            if (x1 has on) "on."; else "off.";
		4:	print (The) actor, " looks closely at ", (the) x1, ".^";
		5:	"You see nothing unexpected in that direction.";
	}
  Exit: switch (n) {
        1:  "But you aren't in anything at the moment.";
        2:  "You can't get out of the closed ", (name) x1, ".";
        3:  print "You get ";
            if (x1 has supporter) print "off "; else print "out of ";
            print_ret (the) x1, ".";
        4:  print "But you aren't ";
            if (x1 has supporter) print "on "; else print "in ";
            print_ret (the) x1, ".";
		5:	print (The) actor, " gets off ", (the) x1, ".^";
		6:	print (The) actor, " gets out of ", (the) x1, ".^";
    }
  GetOff:   "But you aren't on ", (the) x1, " at the moment.";
  Give: switch (n) {
        1:  "You aren't holding ", (the) x1, ".";
        2:  "You juggle ", (the) x1, " for a while, but don't achieve much.";
        3:  print (The) x1;
            if (x1 has pluralname) print " don't"; else print " doesn't";
            " seem interested.";
        4:  print (The) x1;
            if (x1 has pluralname) print " aren't";
            else print " isn't";
            " able to receive things.";
		5:	"You give ", (the) x1, " to ", (the) second, ".";
		6: print (The) actor, " gives ", (the) x1, " to you.^";
		7: print (The) actor, " gives ", (the) x1, " to ", (the) second, ".^";
    }
  Go: switch (n) {
        1:  print "You'll have to get ";
            if (x1 has supporter) print "off "; else print "out of ";
            print_ret (the) x1, " first.";
        2:  print_ret (string) CANTGO__TX;   ! "You can't go that way."
        6:  print "You can't, since ", (the) x1;
            if (x1 has pluralname) " lead nowhere."; else " leads nowhere.";
		7:	"You'll have to say which compass direction to go in.";
		8:	print (The) actor, " goes up";
		9:	print (The) actor, " goes down";
		10:	print (The) actor, " goes ", (name) x1;
		11:	print (The) actor, " arrives from above";
		12:	print (The) actor, " arrives from below";
		13:	print (The) actor, " arrives from the ", (name) x1;
		14:	print (The) actor, " arrives";
		15:	print (The) actor, " arrives at ", (the) x1, " from above";
		16:	print (The) actor, " arrives at ", (the) x1, " from below";
		17:	print (The) actor, " arrives at ", (the) x1, " from the ", (name) x2;
		18:	print (The) actor, " goes through ", (the) x1;
		19:	print (The) actor, " arrives from ", (the) x1;
		20:	print "on ", (the) x1;
		21:	print "in ", (the) x1;
		22:	print ", pushing ", (the) x1, " in front, and you along too";
		23:	print ", pushing ", (the) x1, " in front";
		24:	print ", pushing ", (the) x1, " away";
		25:	print ", pushing ", (the) x1, " in";
		26:	print ", taking you along";
		27: print "(first getting off ", (the) x1, ")^"; say__p = 0; return;
		28: print "(first opening ", (the) x1, ")^"; say__p = 0; return;
    }
  Insert: switch (n) {
        1:  "You need to be holding ", (the) x1, " before you can put ", (itorthem) x1,
            " into something else.";
        2:  print_ret (Cthatorthose) x1, " can't contain things.";
        3:  print_ret (The) x1, " ", (isorare) x1, " closed.";
        4:  "You'll need to take ", (itorthem) x1, " off first.";
        5:  "You can't put something inside itself.";
        6:  print "(first taking ", (itorthem) x1, " off)^"; say__p = 0; return;
        7:  "There is no more room in ", (the) x1, ".";
        8:  "Done.";
        9:  "You put ", (the) x1, " into ", (the) second, ".";
       10:  print (The) actor, " puts ", (the) x1, " into ", (the) second, ".^";
    }
  Inv: switch (n) {
        1:  "You are carrying nothing.";
        2:  print "You are carrying";
        3:  print ":^";
        4:  print ".^";
        5:	print (The) x1, " looks through ", (HisHerTheir) x1, " possessions.^";
    }
  Jump:     "You jump on the spot, fruitlessly.";
  Kiss:     "Keep your mind on the game.";
  Listen:   "You hear nothing unexpected.";
  ListMiscellany: switch (n) {
        1:  print " (providing light)";
        2:  print " (closed)";
        4:  print " (empty)";
        6:  print " (closed and empty)";
        3:  print " (closed and providing light)";
        5:  print " (empty and providing light)";
        7:  #ifdef SERIAL_COMMA;
        	print " (closed, empty, and providing light)";
        	#ifnot;
        	print " (closed, empty and providing light)";
        	#endif;
        8:  print " (providing light and being worn";
        9:  print " (providing light";
        10: print " (being worn";
        11: print " (";
        12: print "open";
        13: print "open but empty";
        14: print "closed";
        15: print "closed and locked";
        16: print " and empty";
        17: print " (empty)";
        18: print " containing ";
        19: print " (on ";
        20: print ", on top of ";
        21: print " (in ";
        22: print ", inside ";
    }
  LMode1:   " is now in its ~brief~ printing mode, which gives long descriptions
             of places never before visited and short descriptions otherwise.";
  LMode2:   " is now in its ~verbose~ mode, which always gives long descriptions
             of locations (even if you've been there before).";
  LMode3:   " is now in its ~superbrief~ mode, which always gives short descriptions
             of locations (even if you haven't been there before).";
  Lock: switch (n) {
        1:  if (x1 has pluralname) print "They don't "; else print "That doesn't ";
            "seem to be something you can lock.";
        2:  print_ret (ctheyreorthats) x1, " locked at the moment.";
        3:  "First you'll have to close ", (the) x1, ".";
        4:  if (x1 has pluralname) print "Those don't "; else print "That doesn't ";
            "seem to fit the lock.";
        5:  "You lock ", (the) x1, ".";
        6:	print (The) actor, " locks ", (the) x1, ".^";
    }
  Look: switch (n) {
        1:  print " (on ", (the) x1, ")";
        2:  print " (in ", (the) x1, ")";
        3:  print " (as ", (object) x1, ")";
        4:  print "On ", (the) x1, " ";
            WriteListFrom(child(x1),
              ENGLISH_BIT+RECURSE_BIT+PARTINV_BIT+TERSE_BIT+CONCEAL_BIT+ISARE_BIT);
            ".";
        5,6:
            if (x1 ~= location) {
                if (x1 has supporter) print "On "; else print "In ";
                print (the) x1, " you";
            }
            else print "You";
            print " can ";
            if (n == 5) print "also ";
            print "see ";
            WriteListFrom(child(x1),
              ENGLISH_BIT+RECURSE_BIT+PARTINV_BIT+TERSE_BIT+CONCEAL_BIT+WORKFLAG_BIT);
            if (x1 ~= location) "."; else " here.";
        7:  "You see nothing unexpected in that direction.";
        8:  if (x1 has supporter) print " (on "; else print " (in ";
        	print (the) x1, ")";
		9:	print (The) actor, " looks around.^";
    }
  LookUnder: switch (n) {
        1:  "But it's dark.";
        2:  "You find nothing of interest.";
		3:	print (The) actor, " looks under ", (the) x1, ".^";
    }
  Mild:     "Quite.";
  Miscellany: switch (n) {
        1:  "(considering the first sixteen objects only)^";
        2:  "Nothing to do!";
        3:  print " You have died ";
        4:  print " You have won ";
        5:  print "^Would you like to RESTART, RESTORE a saved game";
            #Ifdef DEATH_MENTION_UNDO;
            print ", UNDO your last move";
            #Endif;
            #ifdef SERIAL_COMMA;
            print ",";
            #endif;
            " or QUIT?";
        6:  "[Your interpreter does not provide ~undo~.  Sorry!]";
            #Ifdef TARGET_ZCODE;
        7:  "~Undo~ failed.  [Not all interpreters provide it.]";
            #Ifnot; ! TARGET_GLULX
        7:  "[You cannot ~undo~ any further.]";
            #Endif; ! TARGET_
        8:  "Please give one of the answers above.";
        9:  "It is now pitch dark in here!";
        10: "I beg your pardon?";
        11: "[You can't ~undo~ what hasn't been done!]";
        12: "[Can't ~undo~ twice in succession. Sorry!]";
        13: "[Previous turn undone.]";
        14: "Sorry, that can't be corrected.";
        15: "Think nothing of it.";
        16: "~Oops~ can only correct a single word.";
        17: "It is pitch dark, and you can't see a thing.";
        18: print "yourself";
        19: "As good-looking as ever.";
        20: "To repeat a command like ~frog, jump~, just say ~again~, not ~frog, again~.";
        21: "You can hardly repeat that.";
        22: "You can't begin with a comma.";
        23: "You seem to want to talk to someone, but I can't see whom.";
        24: "You can't talk to ", (the) x1, ".";
        25: "To talk to someone, try ~someone, hello~ or some such.";
        26: "(first taking ", (the) x1, ")";
        27: "I didn't understand that sentence.";
        28: print "I only understood you as far as wanting to ";
        29: "I didn't understand that number.";
        30: "You can't see any such thing.";
        31: "You seem to have said too little!";
        32: "You aren't holding that!";
        33: "You can't use multiple objects with that verb.";
        34: "You can only use multiple objects once on a line.";
        35: "I'm not sure what ~", (address) pronoun_word, "~ refers to.";
        36: "You excepted something not included anyway!";
        37: "You can only do that to something animate.";
            #Ifdef DIALECT_US;
        38: "That's not a verb I recognize.";
            #Ifnot;
        38: "That's not a verb I recognise.";
            #Endif;
        39: "That's not something you need to refer to in the course of this game.";
        40: "You can't see ~", (address) pronoun_word, "~ (", (the) pronoun_obj,
            ") at the moment.";
        41: "I didn't understand the way that finished.";
        42: if (x1 == 0) print "None"; else print "Only ", (number) x1;
            print " of those ";
            if (x1 == 1) print "is"; else print "are";
            " available.";
        43: "Nothing to do!";
        44: "There are none at all available!";
        45: print "Who do you mean, ";
        46: print "Which do you mean, ";
        47: "Sorry, you can only have one item here. Which exactly?";
        48: print "Whom do you want";
            if (actor ~= player) print " ", (the) actor;
            print " to "; PrintCommand(); print "?^";
        49: print "What do you want";
            if (actor ~= player) print " ", (the) actor;
            print " to "; PrintCommand(); print "?^";
        50: print "Your score has just gone ";
            if (x1 > 0) print "up"; else { x1 = -x1; print "down"; }
            print " by ", (number) x1, " point";
            if (x1 > 1) print "s";
        51: "(Since something dramatic has happened, your list of commands has been cut short.)";
        52: "^Type a number from 1 to ", x1, ", 0 to redisplay or press ENTER.";
        53: "^[Please press SPACE.]";
        54: "[Comment recorded.]";
        55: "[Comment NOT recorded.]";
        56: print ".^";
        57: print "?^";
        58: print (The) actor, " ", (IsOrAre) actor, " unable to do that.^";
		59:	"You must supply a noun.";
		60:	"You may not supply a noun.";
		61:	"You must name an object.";
		62:	"You may not name an object.";
		63:	"You must name a second object.";
		64:	"You may not name a second object.";
		65:	"You must supply a second noun.";
		66:	"You may not supply a second noun.";
		67:	"You must name something more substantial.";
		68:	print "(", (The) actor, " first taking ", (the) x1, ")^";
        69: "(first taking ", (the) x1, ")";
        70: "The use of UNDO is forbidden in this game.";
        71: print (string) DARKNESS__TX;
  		72: print (The) x1;
            if (x1 has pluralname) print " have"; else print " has";
            " better things to do.";
        73: "That noun did not make sense in this context.";
        74: print "[That command asks to do something outside of play, so it can
        	only make sense from you to me. ", (The) x1, " cannot be asked to do this.]^";
        75:  print " The End ";
    }
  No,Yes:   "That was a rhetorical question.";
  NotifyOff:
            "Score notification off.";
  NotifyOn: "Score notification on.";
  Open: switch (n) {
        1:  print_ret (ctheyreorthats) x1, " not something you can open.";
        2:  if (x1 has pluralname) print "They seem "; else print "It seems ";
            "to be locked.";
        3:  print_ret (ctheyreorthats) x1, " already open.";
        4:  print "You open ", (the) x1, ", revealing ";
            if (WriteListFrom(child(x1), ENGLISH_BIT+TERSE_BIT+CONCEAL_BIT) == 0) "nothing.";
            ".";
        5:  "You open ", (the) x1, ".";
		6:	print (The) actor, " opens ", (the) x1, ".^";
		7:	print (The) x1, " open";
			if (x1 hasnt pluralname) print "s";
			print ".^";
    }
  Pronouns: switch (n) {
        1:  print "At the moment, ";
        2:  print "means ";
        3:  print "is unset";
        4:  "no pronouns are known to the game.";
        5:  ".";
    }
  Pull,Push,Turn: switch (n) {
        1:  if (x1 has pluralname) print "Those are "; else print "It is ";
            "fixed in place.";
        2:  "You are unable to.";
        3:  "Nothing obvious happens.";
        4:  "That would be less than courteous.";
		5:	print (The) actor, " pulls ", (the) x1, ".^";
		6:	print (The) actor, " pushes ", (the) x1, ".^";
		7:	print (The) actor, " turns ", (the) x1, ".^";
    }
! Push: see Pull
  PushDir: switch (n) {
        1:  print (The) x1, " cannot be pushed from place to place.^";
        2:  "That's not a direction.";
        3:  "Not that way you can't.";
    }
  PutOn: switch (n) {
        1:  "You need to be holding ", (the) x1, " before you can put ",
                (itorthem) x1, " on top of something else.";
        2:  "You can't put something on top of itself.";
        3:  "Putting things on ", (the) x1, " would achieve nothing.";
        4:  "You lack the dexterity.";
        5:  print "(first taking ", (itorthem) x1, " off)^"; say__p = 0; return;
        6:  "There is no more room on ", (the) x1, ".";
        7:  "Done.";
        8:  "You put ", (the) x1, " on ", (the) second, ".";
        9:  print (The) actor, " puts ", (the) x1, " on ", (the) second, ".^";
    }
  Quit: switch (n) {
        1:  print "Please answer yes or no.";
        2:  print "Are you sure you want to quit? ";
    }
  Remove: switch (n) {
        1:  if (x1 has pluralname) print "They are"; else print "It is";
            " unfortunately closed.";
        2:  if (x1 has pluralname) print "But they aren't"; else print "But it isn't";
            " there now.";
        3:  "Removed.";
    }
  Restart: switch (n) {
        1:  print "Are you sure you want to restart? ";
        2:  "Failed.";
    }
  Restore: switch (n) {
        1:  "Restore failed.";
        2:  "Ok.";
    }
  Rub:      "You achieve nothing by this.";
  Save: switch (n) {
        1:  "Save failed.";
        2:  "Ok.";
    }
  Score: switch (n) {
        1:  if (deadflag) print "In that game you scored "; else print "You have so far scored ";
            print score, " out of a possible ", MAX_SCORE, ", in ", turns, " turn";
            if (turns ~= 1) print "s";
            return;
        2:  "There is no score in this story.";
        3:	print ", earning you the rank of ";
    }
  ScriptOff: switch (n) {
        1:  "Transcripting is already off.";
        2:  "^End of transcript.";
        3:  "Attempt to end transcript failed.";
    }
  ScriptOn: switch (n) {
        1:  "Transcripting is already on.";
        2:  "Start of a transcript of";
        3:  "Attempt to begin transcript failed.";
    }
  Search: switch (n) {
        1:  "But it's dark.";
        2:  "There is nothing on ", (the) x1, ".";
        3:  print "On ", (the) x1, " ";
            WriteListFrom(child(x1), ENGLISH_BIT+TERSE_BIT+CONCEAL_BIT+ISARE_BIT);
            ".";
        4:  "You find nothing of interest.";
        5:  "You can't see inside, since ", (the) x1, " ", (isorare) x1, " closed.";
        6:  print_ret (The) x1, " ", (isorare) x1, " empty.";
        7:  print "In ", (the) x1, " ";
            WriteListFrom(child(x1), ENGLISH_BIT+TERSE_BIT+CONCEAL_BIT+ISARE_BIT);
            ".";
		8:	print (The) actor, " searches ", (the) x1, ".^";
    }
  SetTo:    "No, you can't set ", (thatorthose) x1, " to anything.";
  Show: switch (n) {
        1:  "You aren't holding ", (the) x1, ".";
        2:  print_ret (The) x1, " ", (isorare) x1, " unimpressed.";
    }
  Sing:     "Your singing is abominable.";
  Sleep:    "You aren't feeling especially drowsy.";
  Smell:    "You smell nothing unexpected.";
            #Ifdef DIALECT_US;
  Sorry:    "Oh, don't apologize.";
            #Ifnot;
  Sorry:    "Oh, don't apologise.";
            #Endif;
  Squeeze: switch (n) {
        1:  "Keep your hands to yourself.";
        2:  "You achieve nothing by this.";
		3:	print (The) actor, " squeezes ", (the) x1, ".^";
    }
  Strong:   "Real adventurers do not use such language.";
  Swing:    "There's nothing sensible to swing here.";
  SwitchOff: switch (n) {
        1:  print_ret (ctheyreorthats) x1, " not something you can switch.";
        2:  print_ret (ctheyreorthats) x1, " already off.";
        3:  "You switch ", (the) x1, " off.";
		4:	print (The) actor, " switches ", (the) x1, " off.^";
    }
  SwitchOn: switch (n) {
        1:  print_ret (ctheyreorthats) x1, " not something you can switch.";
        2:  print_ret (ctheyreorthats) x1, " already on.";
        3:  "You switch ", (the) x1, " on.";
		4:	print (The) actor, " switches ", (the) x1, " on.^";
    }
  Take: switch (n) {
        1:  "Taken.";
        2:  "You are always self-possessed.";
        3:  "I don't suppose ", (the) x1, " would care for that.";
        4:  print "You'd have to get ";
            if (x1 has supporter) print "off "; else print "out of ";
            print_ret (the) x1, " first.";
        5:  "You already have ", (thatorthose) x1, ".";
        6:  if (noun has pluralname) print "Those seem "; else print "That seems ";
            "to belong to ", (the) x1, ".";
        7:  if (noun has pluralname) print "Those seem "; else print "That seems ";
            "to be a part of ", (the) x1, ".";
        8:  print_ret (Cthatorthose) x1, " ", (isorare) x1,
            "n't available.";
        9:  print_ret (The) x1, " ", (isorare) x1, "n't open.";
        10: if (x1 has pluralname) print "They're "; else print "That's ";
            "hardly portable.";
        11: if (x1 has pluralname) print "They're "; else print "That's ";
            "fixed in place.";
        12: "You're carrying too many things already.";
        13: print "(putting ", (the) x1, " into ", (the) x2,
            " to make room)^"; say__p = 0; return;
        14: "You can't reach into ", (the) x1, ".";
        15: "You cannot carry ", (the) x1, ".";
        16: print (The) actor, " picks up ", (the) x1, ".^";
    }
  Taste:    "You taste nothing unexpected.";
  Tell: switch (n) {
        1:  "You talk to yourself a while.";
        2:  "This provokes no reaction.";
    }
  Think:    "What a good idea.";
  ThrowAt: switch (n) {
        1:  "Futile.";
        2:  "You lack the nerve when it comes to the crucial moment.";
    }
  Tie:		"You would achieve nothing by this.";
  Touch: switch (n) {
        1:  "Keep your hands to yourself!";
        2:  "You feel nothing unexpected.";
        3:  "If you think that'll help.";
		4:	print (The) actor, " touches ", (himheritself) x1, ".^";
		5:	print (The) actor, " touches you.^";
		6:	print (The) actor, " touches ", (the) x1, ".^";
    }
! Turn: see Pull.
  Unlock:  switch (n) {
        1:  if (x1 has pluralname) print "They don't "; else print "That doesn't ";
            "seem to be something you can unlock.";
        2:  print_ret (ctheyreorthats) x1, " unlocked at the moment.";
        3:  if (x1 has pluralname) print "Those don't "; else print "That doesn't ";
            "seem to fit the lock.";
        4:  "You unlock ", (the) x1, ".";
        5:	print (The) actor, " unlocks ", (the) x1, ".^";
    }
  Verify: switch (n) {
        1:  "The game file has verified as intact.";
        2:  "The game file did not verify as intact, and may be corrupt.";
    }
  Wait: switch (n) {
        1:  "Time passes.";
        2:	print (The) actor, " waits.^";
    }
  Wake:     "The dreadful truth is, this is not a dream.";
  WakeOther:"That seems unnecessary.";
  Wave: switch (n) {
        1:  "But you aren't holding ", (thatorthose) x1, ".";
        2:  "You look ridiculous waving ", (the) x1, ".";
		3:	print (The) actor, " waves ", (the) x1, ".^";
    }
  WaveHands:"You wave, feeling foolish.";
  Wear: switch (n) {
        1:  "You can't wear ", (thatorthose) x1, "!";
        2:  "You're not holding ", (thatorthose) x1, "!";
        3:  "You're already wearing ", (thatorthose) x1, "!";
        4:  "You put on ", (the) x1, ".";
		5:	print (The) actor, " puts on ", (the) x1, ".^";
    }
! Yes:  see No.
];

[ L__M act n x1 x2 rv flag;
    @push sw__var;
    sw__var = act;
    if (n == 0) n = 1;
    @push action;
    lm_act = act;
    lm_n = n;
    lm_o = x1;
    lm_o2 = x2;
    switch (act) {
    	##Miscellany: rv =  ((((PHR_717_r0 ())))) ;
    	##ListMiscellany: rv =  ((((PHR_718_r1 ())))) ;
    	default: rv =  ((((PHR_719_r2 ())))) ;
    }
    action = sw__var;
    if (rv == false) rv = RunRoutines(LibraryMessages, before);
    @pull action;
    if (rv == false) LanguageLM(n, x1, x2);
    @pull sw__var;
];


Default LanguageCases 1;
#Ifndef LibraryMessages; Object LibraryMessages; #Endif;

Object thedark "(darkness object)";

[ OffersLight obj j;
    while (obj) {
		if (obj has light) rtrue;
		objectloop (j in obj) if (HasLightSource(j)) rtrue;
		if ((obj has container) && (obj hasnt open) && (obj hasnt transparent)) rfalse;
		if ((obj provides component_parent) && (obj.component_parent))
			obj = obj.component_parent;
		else
			obj = parent(obj);
	}
    rfalse;
];

[ HasLightSource i j ad sr po;
	if (i == 0) rfalse;
    if (i has light) rtrue;
    if ((IsSeeThrough(i)) && (~~(HidesLightSource(i))))
        objectloop (j in i)
            if (HasLightSource(j)) rtrue;
    ad = i.&add_to_scope;
    if (parent(i) ~= 0 && ad ~= 0) {
        if (metaclass(ad-->0) == Routine) {
            ats_hls = 0; ats_flag = 1;
            sr = scope_reason; po = parser_one;
            scope_reason = LOOPOVERSCOPE_REASON; parser_one = 0;
            RunRoutines(i, add_to_scope);
            scope_reason = sr; parser_one = po;
            ats_flag = 0; if (ats_hls == 1) rtrue;
        }
        else {
            for (j=0 : (WORDSIZE*j)<i.#add_to_scope : j++)
                if ((ad-->j) && (HasLightSource(ad-->j) == 1)) rtrue;
        }
    }
    if (ComponentHasLight(i)) rtrue;
    rfalse;
];

[ ComponentHasLight o obj next_obj;
	if (o provides component_child) {
		obj = o.component_child;
		while (obj) {
			next_obj = obj.component_sibling;
			if (obj has light) rtrue;
			if (HasLightSource(obj)) rtrue;
			if ((obj provides component_child) && (ComponentHasLight(obj))) rtrue;
			obj = next_obj;
		}
	}
	rfalse;
];

[ HidesLightSource obj;
    if (obj == player) rfalse;
    if (obj has transparent or supporter) rfalse;
    if (obj has animate) rfalse;
    if (obj has container) return (obj hasnt open);
    return (obj hasnt enterable);
];

Global lightflag = false;

[ ADJUST_LIGHT_R previous_light_condition;
    previous_light_condition = lightflag;
    lightflag = OffersLight(parent(player));

    if ((previous_light_condition == false) && (lightflag == false)) {
    	location = thedark;
    	rfalse;
    }

    if ((previous_light_condition == false) && (lightflag == true)) {
        location = real_location;
        CarryOutActivity(PRINTING_NEWS_OF_LIGHT_ACT);
        rfalse;
    }

    if ((previous_light_condition == true) && (lightflag == false)) {
        location = thedark;
		DivideParagraphPoint();
		BeginActivity(PRINTING_NEWS_OF_DARKNESS_ACT);
		if (ForActivity(PRINTING_NEWS_OF_DARKNESS_ACT) == false) L__M(##Miscellany, 9);
		EndActivity(PRINTING_NEWS_OF_DARKNESS_ACT);
		rfalse;
    }

    if ((previous_light_condition == true) && (lightflag == true)) {
    	location = real_location;
    	rfalse;
    }

    rfalse;
];

[ SilentlyConsiderLight;
    lightflag = OffersLight(parent(player));
	if (lightflag) location = real_location; else location = thedark;
	rfalse;
];

[ IsSeeThrough obj;
    if ((obj has supporter)
    	|| (obj has transparent)
    	|| (obj has animate)
    	|| ((obj has container) && (obj has open)))
        rtrue;
   rfalse;
];

[ VisibilityParent o;
    if (o && (o has container) && (o hasnt open) && (o hasnt transparent)) return nothing;
	if (o) o = CoreOfParentOfCoreOf(o);
    return o;
];

[ FindVisibilityLevels lc up;
	if (location == thedark) {
		visibility_ceiling = thedark;
		visibility_levels = 0;	
	} else {
		visibility_ceiling = player;
		while (true) {
			up = VisibilityParent(visibility_ceiling);
			if (up == 0) break;
			visibility_ceiling = up;
			lc++;
		}
		visibility_levels = lc;
	}
];

[ ScopeCeiling pos c;
	if (pos == player && location == thedark) return thedark;
	c = parent(pos);
	if (c == 0) return pos;
	while (VisibilityParent(c)) c = VisibilityParent(c);
	return c;
];

[ ObjectIsUntouchable item silent_flag flag2 p save_sp decision;
	if ((p ~= player) && (LocationOf(p) ~= LocationOf(player)) &&
		((item ofclass K4_door) || (item ofclass K7_backdrop))) {
		decision = false;
	} else {
		untouchable_object = item; untouchable_silence = silent_flag;
		touch_persona = p; if (p == actor) touch_persona = 0;
		save_sp = say__p; say__p = 0;
		if (ProcessRulebook(ACCESSIBILITY_RB, 0, true)) {
			if (RulebookSucceeded()) decision = false;
			else decision = true;
		} else decision = false;
		if (say__p == false) say__p = save_sp;
	}
	untouchable_silence = 0;
	return decision;
];

[ ACCESS_THROUGH_BARRIERS_R ancestor i j external p;
	p = touch_persona; if (p == 0) p = actor;

	ancestor = CommonAncestor(p, untouchable_object);
	if ((ancestor == 0) && (LocationOf(untouchable_object) == nothing)
		&& ((untouchable_object ofclass K4_door or K7_backdrop) == false)) {
		if (touch_persona == 0) GL__M(##Take,8,untouchable_object);
		RulebookFails();
		rtrue;
	}

	! First, a barrier between the player and the ancestor.

	if (CoreOf(p) ~= ancestor) {
		i = parent(CoreOf(p)); j = CoreOf(i); external = false;
		if (j ~= i) { i = j; external = true; }
		while (i~=ancestor && i) {
			if ((external == false)
				&& (ProcessRulebook(REACHING_OUTSIDE_RB, i))
				&& (RulebookFailed())) rtrue; ! Barrier
			i = parent(CoreOf(i)); j = CoreOf(i); external = false;
			if (j ~= i) { i = j; external = true; }
		}
	}

	! Second, a barrier between the item and the ancestor.

	if (CoreOf(untouchable_object) ~= ancestor) {
		! We can always get to the core of the item.
		i = CoreOf(untouchable_object);
		! This will be on the inside of its parent, if its parent is a
		! container, so there should be no exemption.
		i = parent(i); external = false;
		! j = CoreOf(i); if (j ~= i) { i = j; external = true; }
		while (i~=ancestor && i) {
			if ((external == false) &&
				(ProcessRulebook(REACHING_INSIDE_RB, i)) &&
				(RulebookFailed())) rtrue; ! Barrier
			i = CoreOf(i);
			if (i == ancestor) break;
			i = parent(i); j = CoreOf(i); external = false;
			if (j ~= i) { i = j; external = true; }
		}
	}

	RulebookSucceeds(); ! No barrier
	rtrue;
];

[ CANT_REACH_INSIDE_CLOSED_R;
	if (parameter_object has container && parameter_object hasnt open) {
		if (touch_persona == 0) GL__M(##Take,9,parameter_object);
		RulebookFails(); rtrue;
	}
	rfalse;
];

[ CANT_REACH_OUTSIDE_CLOSED_R;
	if (parameter_object has container && parameter_object hasnt open) {
		if (touch_persona == 0) GL__M(##Take,9,parameter_object);
		RulebookFails(); rtrue;
	}
	rfalse;
];

[ CANT_REACH_INSIDE_ROOMS_R;
	if (parameter_object && parameter_object ofclass K1_room) {
		if (touch_persona == 0) GL__M(##Take,14,parameter_object);
		RulebookFails(); rtrue;
	}
	rfalse;
];


Constant REQUISITION_STACK_SIZE = 3*211;
Array requisition_stack --> REQUISITION_STACK_SIZE;
Global requisition_stack_pointer = 0;

[ RequisitionStack len top addr;
	top = requisition_stack_pointer + len;
	if (top > REQUISITION_STACK_SIZE) return false;
	addr = requisition_stack + requisition_stack_pointer*WORDSIZE;
	! print "Allocating ", addr, " at pointer ", requisition_stack_pointer, "^";
	requisition_stack_pointer = top;
	return addr;
];

[ FreeStack addr;
	if (addr == 0) return;
	requisition_stack_pointer = (addr - requisition_stack)/WORDSIZE;
];

Global MarkedObjectArray = 0;
Global MarkedObjectLength = 0;

[ WriteListOfMarkedObjects style
	obj common_parent first mixed_parentage length;

	objectloop (obj ofclass Object && obj has workflag2) {
		length++;
		if (first == nothing) { first = obj; common_parent = parent(obj); }
		else { if (parent(obj) ~= common_parent) mixed_parentage = true; }
	}
	if (mixed_parentage) common_parent = nothing;

	if (length == 0) {
    	if (style & ISARE_BIT ~= 0) print (string) IS3__TX, " ", (string) NOTHING__TX;
    	else if (style & CFIRSTART_BIT ~= 0) print (string) NOTHING2__TX;
		else print (string) NOTHING__TX;
	} else {
		@push MarkedObjectArray; @push MarkedObjectLength;
		MarkedObjectArray = RequisitionStack(length);
		MarkedObjectLength = length;
		if (MarkedObjectArray == 0) return RunTimeProblem(RTP_LISTWRITERMEMORY); 

		if (common_parent) {
			ObjectTreeCoalesce(child(common_parent));
			length = 0;
			objectloop (obj in common_parent) ! object tree order
				if (obj has workflag2) MarkedObjectArray-->length++ = obj;
		} else {
			length = 0;
			objectloop (obj ofclass Object) ! object number order
				if (obj has workflag2) MarkedObjectArray-->length++ = obj;
		}

		WriteListFrom(first, style, 0, false, MarkedListIterator);

		FreeStack(MarkedObjectArray);
		@pull MarkedObjectLength; @pull MarkedObjectArray;
	}
	return;
];

Constant SEEK_ITF = 0;
Constant ADVANCE_ITF = 1;
Constant COALESCE_ITF = 2;
Constant START_ITF = 3;

! Constant DBLW; ! Uncomment this to provide debugging information at run-time

[ MarkedListIterator obj depth required_lt function i;
    if (obj == nothing) return nothing;
    switch(function) {
    	START_ITF: return MarkedObjectArray-->0;
    	COALESCE_ITF: return MarkedListCoalesce();
    	SEEK_ITF, ADVANCE_ITF:
			for (i=0: i<MarkedObjectLength: i++)
				if (MarkedObjectArray-->i == obj) {
					if (function == ADVANCE_ITF) i++;
					for (:i<MarkedObjectLength: i++) {
						obj = MarkedObjectArray-->i;
						if ((required_lt) && (obj.list_together ~= required_lt)) continue;
						if ((c_style & WORKFLAG_BIT) && (depth==0) && (obj hasnt workflag))
							continue;
						if ((c_style & CONCEAL_BIT) &&
							((obj has concealed) || (obj has scenery))) continue;
						return obj;
					}
					return nothing;
				}
	}
	return nothing;
];

[ MarkedListCoalesce o i lt l swap m;
	for (i=0: i<MarkedObjectLength: i++) {
		lt = (MarkedObjectArray-->i).list_together;
		if (lt ~= 0) {
			! Find first object in list after contiguous run with this list_together value:
			for (i++: (i<MarkedObjectLength)&&((MarkedObjectArray-->i).list_together==lt): i++) ;
			! If the contiguous run extends to end of list, the list is now perfect:
			if (i == MarkedObjectLength) return MarkedObjectArray-->0;
			! And otherwise we look to see if any future entries belong in the earlier run:
			for (l=i+1: l<MarkedObjectLength: l++)
				if ((MarkedObjectArray-->l).list_together == lt) {
					! Yes, they do: so we perform a rotation to insert it before element i:
					swap = MarkedObjectArray-->l;
					for (m=l: m>i: m--) MarkedObjectArray-->m = MarkedObjectArray-->(m-1);
					MarkedObjectArray-->i = swap;
					! And now the run is longer:
					i++;
					if (i == MarkedObjectLength) return MarkedObjectArray-->0;
				}
			i--;
		}
	}
	return MarkedObjectArray-->0;
];

Global list_filter_routine;

[ ObjectTreeIterator obj depth required_lt function;
    if ((obj == nothing) || (parent(obj) == nothing)) return nothing;
	if (function == START_ITF) return child(parent(obj));
	if (function == COALESCE_ITF) return ObjectTreeCoalesce(obj);
    if (function == ADVANCE_ITF) obj = sibling(obj);
    for (:: obj = sibling(obj)) {
        if (obj == nothing) return nothing;
		if ((required_lt) && (obj.list_together ~= required_lt)) continue;
		if ((c_style & WORKFLAG_BIT) && (depth==0) && (obj hasnt workflag)) continue;
		if (obj hasnt list_filter_permits) continue;
		if ((c_style & CONCEAL_BIT) &&
			((obj has concealed) || (obj has scenery))) continue;
		return obj;
    }
];

[ ObjectTreeCoalesce obj memb lt later;
	#Ifdef DBLW; print "^^Sorting out: "; DiagnoseSortList(obj); #Endif;
	.StartAgain;
	for (memb=obj: memb~=nothing: memb=sibling(memb)) {
		lt = memb.list_together;
		if (lt ~= 0) {
			! Find first object in list after contiguous run with this list_together value:
			for (memb=sibling(memb): (memb) && (memb.list_together == lt): memb = sibling(memb)) ;
			! If the contiguous run extends to end of list, the list is now perfect:
			if (memb == 0) return obj;
			! And otherwise we look to see if any future entries belong in the earlier run:
			for (later=sibling(memb): later: later=sibling(later))
				if (later.list_together == lt) {
					! Yes, they do: so we perform a regrouping of the list and start again:
					obj = GroupChildren(parent(obj), list_together, lt);
					#Ifdef DBLW; print "^^Sorted to: "; DiagnoseSortList(obj); #Endif;
					jump StartAgain;
				}
		}
	}
	return obj;
];
#Ifdef DBLW;
[ DiagnoseSortList obj memb;
    for (memb=child(obj): memb~=nothing: memb=sibling(memb)) print memb, " --> "; new_line;
];
#Endif;

[ WriteListFrom first style depth noactivity iter a ol;
	@push c_iterator; @push c_style; @push c_depth; @push c_margin;
    if (iter) c_iterator = iter; else c_iterator = ObjectTreeIterator;
    c_style = style; c_depth = depth;
	c_margin = 0; if (style & EXTRAINDENT_BIT) c_margin = 1;

	objectloop (a ofclass Object) {
		give a list_filter_permits;
		if ((list_filter_routine) && (list_filter_routine(a) == false))
			give a ~list_filter_permits;
	}

    first = c_iterator(first, depth, 0, START_ITF);
	if (first == nothing) {
        print (string) NOTHING__TX;
        if (style & NEWLINE_BIT ~= 0) new_line;
    } else {
		if ((noactivity) || (iter)) {
			WriteListR(first, c_depth, true);
			say__p = 1;
		} else {
			objectloop (ol provides list_together) ol.list_together = 0;
			CarryOutActivity(LISTING_CONTENTS_ACT, parent(first));
		}
	}

    @pull c_margin; @pull c_depth; @pull c_style; @pull c_iterator;
];

[ STANDARD_CONTENTS_LISTING_R;
	WriteListFrom(child(parameter_object), c_style, c_depth, true);
];

#Ifdef DBLW;
Global DBLW_no_classes; Global DBLW_no_objs;
[ DebugPartition partition_class_sizes partition_classes first depth i k o;
	print "[Length of list is ", DBLW_no_objs, " with ", k, " plural.]^";
	print "[Partitioned into ", DBLW_no_classes, " equivalence classes.]^";
    for (i=1: i<=DBLW_no_classes : i++) {
    	print "Class ", i, " has size ", partition_class_sizes->i, "^";
	}
	for (k=0, o=first: k<DBLW_no_objs : k++, o = c_iterator(o, depth, lt_value, ADVANCE_ITF)) {
    	print "Entry ", k, " has class ", partition_classes->k,
    		" represented by ", o, " with L=", o.list_together, "^";
	}
];
#Endif;

[ PartitionList first no_objs depth partition_classes partition_class_sizes
	i k l n m;
    for (i=0: i<no_objs: i++) partition_classes->i = 0;
    n = 1;
    for (i=first, k=0: k<no_objs: i=c_iterator(i, depth, lt_value, ADVANCE_ITF), k++)
        if (partition_classes->k == 0) {
            partition_classes->k = n; partition_class_sizes->n = 1;
            for (l=c_iterator(i, depth, lt_value, ADVANCE_ITF), m=k+1:
            	(l~=0) && (m<no_objs):
            	l=c_iterator(l, depth, lt_value, ADVANCE_ITF), m++) {
                if ((partition_classes->m == 0) && (ListEqual(i, l))) {
                    if (partition_class_sizes->n < 255) (partition_class_sizes->n)++;
                    partition_classes->m = n;
                }
            }
            if (n < 255) n++;
        }
    n--;
	#Ifdef DBLW;
	DBLW_no_classes = n; DBLW_no_objs = no_objs;
	DebugPartition(partition_class_sizes, partition_classes, first, depth);
	#Endif;
    return n;
];

[ ListEqual o1 o2;
	if ((o1.plural == 0) || (o2.plural == 0)) rfalse;
 	if (child(o1) ~= 0 && WillRecurs(o1) ~= 0) rfalse;
    if (child(o2) ~= 0 && WillRecurs(o2) ~= 0) rfalse;
    if (c_style & (FULLINV_BIT + PARTINV_BIT) ~= 0) {
        if ((o1 hasnt worn && o2 has worn) || (o2 hasnt worn && o1 has worn)) rfalse;
        if ((o1 hasnt light && o2 has light) || (o2 hasnt light && o1 has light)) rfalse;
        if (o1 has container) {
            if (o2 hasnt container) rfalse;
            if ((o1 has open && o2 hasnt open) || (o2 has open && o1 hasnt open))
                rfalse;
        }
        else if (o2 has container)
            rfalse;
    }
    return Identical(o1, o2);
];

[ WillRecurs o;
    if (c_style & ALWAYS_BIT ~= 0) rtrue;
    if (c_style & RECURSE_BIT == 0) rfalse;
    if ((o has supporter) || ((o has container) && (o has open or transparent))) rtrue;
    rfalse;
];

[ NumberOfGroupsInList o no_classes depth partition_classes partition_class_sizes
	no_groups cl memb k current_lt lt;
	no_groups = no_classes;
    for (cl=1, memb=o, k=0: cl<=no_classes: cl++) {
    	! Advance to first member of class number cl
        while (partition_classes->k ~= cl) {
            k++; memb = c_iterator(memb, depth, lt_value, ADVANCE_ITF);
        }
        if (memb) { ! In case of accidents, but should always happen
        	lt = memb.list_together;
            if ((lt ~= lt_value) && (lt ofclass Routine or String) && (lt == current_lt))
            	no_groups--;
            current_lt = lt;
        }
    }
 	#Ifdef DBLW; print "[There are ", no_groups, " groups.]^"; #Endif;
	return no_groups;
];

[ WriteListR o depth from_start
	partition_classes partition_class_sizes
	cl memb index k2 l m no_classes q groups_to_do current_lt;
    if (o == nothing) return; ! An empty list: no output

    if (from_start) {
    	o = c_iterator(o, depth, 0, COALESCE_ITF); ! Coalesce list and choose new start
	}
    o = c_iterator(o, depth, 0, SEEK_ITF); ! Find first entry in list from o
    if (o == nothing) return;

	! Count index = length of list
    for (memb=o, index=0: memb: memb=c_iterator(memb, depth, lt_value, ADVANCE_ITF)) index++;

    if (c_style & ISARE_BIT ~= 0) {
        if (index == 1 && o hasnt pluralname) print (string) IS3__TX;
        else                              print (string) ARE3__TX;
        if (c_style & NEWLINE_BIT ~= 0)   print ":^";
        else                              print (char) ' ';
        c_style = c_style - ISARE_BIT;
    }

    partition_classes = RequisitionStack(index/WORDSIZE + 2);
    partition_class_sizes = RequisitionStack(index/WORDSIZE + 2);
    if ((partition_classes == 0) || (partition_class_sizes == 0))
    	return RunTimeProblem(RTP_LISTWRITERMEMORY);

	no_classes =
		PartitionList(o, index, depth, partition_classes, partition_class_sizes);

	groups_to_do =
		NumberOfGroupsInList(o, no_classes, depth, partition_classes, partition_class_sizes);

    for (cl=1, memb=o, index=0, current_lt=0: groups_to_do>0: cl++) {
		! Set memb to first object of partition class cl
        while (partition_classes->index ~= cl) {
        	index++; memb=c_iterator(memb, depth, lt_value, ADVANCE_ITF);
            if (memb==0) { print "*** Error in list-writer ***^"; break; }
        }

    	#Ifdef DBLW;
		! DebugPartition(partition_class_sizes, partition_classes, o, depth);
		print "^[Class ", cl, " of ", no_classes, ": first object ", memb,
			" (", memb.list_together, "); groups_to_do ", groups_to_do, ",
			current_lt=", current_lt, " listing_size=", listing_size,
			" lt_value=", lt_value, " memb.list_together=", memb.list_together, "]^";
    	#Endif;

		if ((memb.list_together == lt_value) ||
        	(~~(memb.list_together ofclass Routine or String))) current_lt = 0;
		else {
            if (memb.list_together == current_lt) continue;
            
            ! Otherwise this class begins a new group
            @push listing_size;
            q = memb; listing_size = 1; l = index; m = cl;
			while (m < no_classes && q.list_together == memb.list_together) {
				m++;
				while (partition_classes->l ~= m) {
					l++; q = c_iterator(q, depth, lt_value, ADVANCE_ITF);
				}
				if (q.list_together == memb.list_together) listing_size++;
			}

			if (listing_size > 1) {
				! The new group contains more than one partition class
				WriteMultiClassGroup(cl, memb, depth, partition_class_sizes);
				current_lt = memb.list_together;
				jump GroupComplete;
			}
			current_lt = 0;
			@pull listing_size;
		}

		WriteSingleClassGroup(cl, memb, depth, partition_class_sizes->cl);

		.GroupComplete;
		groups_to_do--;
        if (c_style & ENGLISH_BIT ~= 0) {
            if (groups_to_do == 1) {
                if (cl <= 1) print (string) LISTAND2__TX;
                else print (string) LISTAND__TX;
            }
            if (groups_to_do > 1) print (string) COMMA__TX;
        }
    }

    FreeStack(partition_class_sizes);
    FreeStack(partition_classes);
]; ! end of WriteListR

[ WriteMultiClassGroup cl memb depth partition_class_sizes q k2 l;
	! Save the style, because the activity below is allowed to change it
	q = c_style;
	if (c_style & INDENT_BIT ~= 0) PrintSpaces(2*(depth+c_margin));

	BeginActivity(GROUPING_TOGETHER_ACT, memb);

	if (ForActivity(GROUPING_TOGETHER_ACT, memb)) {
		c_style = c_style &~ NEWLINE_BIT;
	} else {

		if (memb.list_together ofclass String) {
			! Set k2 to the number of objects covered by the group
			k2 = 0;
			for (l=0 : l<listing_size : l++) k2 = k2 + partition_class_sizes->(l+cl);
			EnglishNumber(k2); print " ";
			print (string) memb.list_together;
			if (c_style & ENGLISH_BIT ~= 0) print " (";
			if (c_style & INDENT_BIT ~= 0)  print ":^";
		} else {
			inventory_stage = 1;
			parser_one = memb; parser_two = depth + c_margin;
			if (RunRoutines(memb, list_together) == 1) jump Omit__Sublist2;
		}

		c_margin++;
		@push lt_value; @push listing_together; @push listing_size;
		
		lt_value = memb.list_together; listing_together = memb;
		#Ifdef DBLW; print "^^DOWN lt_value = ", lt_value, " listing_together = ", memb, "^^";
		@push DBLW_no_classes; @push DBLW_no_objs; #Endif;
		WriteListR(memb, depth, false); 
		#Ifdef DBLW; print "^^UP^^"; @pull DBLW_no_objs; @pull DBLW_no_classes; #Endif;

		@pull listing_size; @pull listing_together; @pull lt_value;
		c_margin--;
		
		if (memb.list_together ofclass String) {
			if (q & ENGLISH_BIT ~= 0) print ")";
		} else {
			inventory_stage = 2;
			parser_one = memb; parser_two = depth+c_margin;
			RunRoutines(memb, list_together);
		}
		.Omit__Sublist2;
	}
  
	EndActivity(GROUPING_TOGETHER_ACT, memb);

	! If the NEWLINE_BIT has been forced by the activity, act now
	! before it vanishes...
	if (q & NEWLINE_BIT ~= 0 && c_style & NEWLINE_BIT == 0) new_line;

	! ...when the original style is restored again:
	c_style = q;
];

[ WriteSingleClassGroup cl memb depth size q;
	q = c_style;
    if (c_style & INDENT_BIT) PrintSpaces(2*(depth+c_margin));
	if (size == 1) {
		if (c_style & NOARTICLE_BIT ~= 0) print (name) memb;
		else {
			if (c_style & DEFART_BIT) {
				if ((cl == 1) && (c_style & CFIRSTART_BIT)) print (The) memb;
				else print (the) memb;
			} else {
				if ((cl == 1) && (c_style & CFIRSTART_BIT)) print (CIndefArt) memb;
				else print (a) memb;
			}
		}
	} else {
		if (c_style & DEFART_BIT) {
			if ((cl == 1) && (c_style & CFIRSTART_BIT)) PrefaceByArticle(memb, 0, size);
			else PrefaceByArticle(memb, 1, size);
		}
		@push listing_size; listing_size = size;
		CarryOutActivity(PRINTING_A_NUMBER_OF_ACT, memb);
		@pull listing_size;
	}
	if ((size > 1) && (memb hasnt pluralname)) {
		give memb pluralname;
		WriteAfterEntry(memb, depth);
		give memb ~pluralname;
	} else WriteAfterEntry(memb, depth);
	c_style = q;
];

[ WriteAfterEntry o depth
    p recurse_flag parenth_flag eldest_child child_count combo;

    inventory_stage = 2;
    if (c_style & PARTINV_BIT) {
        BeginActivity(PRINTING_ROOM_DESC_DETAILS_ACT);
        if (ForActivity(PRINTING_ROOM_DESC_DETAILS_ACT) == false) {

        combo = 0;
        if (o has light && location hasnt light) combo=combo+1;
        if (o has container && o hasnt open)     combo=combo+2;
        if ((o has container && (o has open || o has transparent))
            && (child(o)==0))                    combo=combo+4;
        if (combo) L__M(##ListMiscellany, combo, o);
        }
        EndActivity(PRINTING_ROOM_DESC_DETAILS_ACT);
    }   ! end of PARTINV_BIT processing

    if (c_style & FULLINV_BIT) {
        if (o has light && o has worn) { L__M(##ListMiscellany, 8, o);  parenth_flag = true; }
        else {
            if (o has light)           { L__M(##ListMiscellany, 9, o);  parenth_flag = true; }
            if (o has worn)            { L__M(##ListMiscellany, 10, o); parenth_flag = true; }
        }

        if (o has container)
            if (o has openable) {
                if (parenth_flag) {
                	#Ifdef SERIAL_COMMA; print ","; #Endif;
                	print (string) AND__TX;
                } else            L__M(##ListMiscellany, 11, o);
                if (o has open)
                    if (child(o)) L__M(##ListMiscellany, 12, o);
                    else          L__M(##ListMiscellany, 13, o);
                else
                    if (o has lockable && o has locked) L__M(##ListMiscellany, 15, o);
                    else                                L__M(##ListMiscellany, 14, o);
                parenth_flag = true;
            }
            else
                if (child(o)==0 && o has transparent)
                    if (parenth_flag) L__M(##ListMiscellany, 16, o);
                    else              L__M(##ListMiscellany, 17, o);

        if (parenth_flag) print ")";
    }   ! end of FULLINV_BIT processing

	child_count = 0;
	eldest_child = nothing;
	objectloop (p in o)
		if ((c_style & CONCEAL_BIT == 0) || (p hasnt concealed && p hasnt scenery))
			if (p has list_filter_permits) {
				child_count++;
				if (eldest_child == nothing) eldest_child = p;
			}

    if (child_count && (c_style & ALWAYS_BIT)) {
        if (c_style & ENGLISH_BIT) L__M(##ListMiscellany, 18, o);
        recurse_flag = true;
    }
    
    if (child_count && (c_style & RECURSE_BIT)) {
        if (o has supporter) {
            if (c_style & ENGLISH_BIT) {
                if (c_style & TERSE_BIT) L__M(##ListMiscellany, 19, o);
                else                     L__M(##ListMiscellany, 20, o);
                if (o has animate)       print (string) WHOM__TX;
                else                     print (string) WHICH__TX;
            }
            recurse_flag = true;
        }
        if (o has container && (o has open || o has transparent)) {
            if (c_style & ENGLISH_BIT) {
                if (c_style & TERSE_BIT) L__M(##ListMiscellany, 21, o);
                else                     L__M(##ListMiscellany, 22, o);
                if (o has animate)       print (string) WHOM__TX;
                else                     print (string) WHICH__TX;
            }
            recurse_flag = true;
        }
    }

    if (recurse_flag && (c_style & ENGLISH_BIT))
        if (child_count > 1 || eldest_child has pluralname) print (string) ARE2__TX;
        else                                                print (string) IS2__TX;

    if (c_style & NEWLINE_BIT) new_line;

    if (recurse_flag) {
        o = child(o);
        @push lt_value; @push listing_together; @push listing_size;
        @push c_iterator;
        c_iterator = ObjectTreeIterator;
        lt_value = 0;   listing_together = 0;   listing_size = 0;
        WriteListR(o, depth+1, true);
        @pull c_iterator;
        @pull listing_size; @pull listing_together; @pull lt_value;
        if (c_style & TERSE_BIT) print ")";
    }
];

[ SayPhraseName closure;
	if (closure == 0) print "nothing";
	else print (string) closure-->2;
];

[ KindAtomic kind;
	if ((kind >= 0) && (kind < BASE_KIND_HWM)) return kind;
	return kind-->0;
];

[ KindBaseArity kind;
	if ((kind >= 0) && (kind < BASE_KIND_HWM)) return 0;
	return kind-->1;
];

[ KindBaseTerm kind n;
	if ((kind >= 0) && (kind < BASE_KIND_HWM)) return UNKNOWN_TY;
	return kind-->(2+n);
];

[ DigitToValue c n;
	n = c-'0';
	if ((n<0) || (n>9)) return -1;
	return n;
];

[ GenerateRandomNumber n m s;
	if (n==m) return n;
	if (n>m) { s = n; n = m; m = s; }
	n--;
	return random(m-n) + n;
];
Constant R_DecimalNumber = GenerateRandomNumber;
Constant R_PrintTimeOfDay = GenerateRandomNumber;

[ GroupChildren par prop value;
    while (child(par) ~= 0) {
        if (child(par).prop ~= value) move child(par) to out_obj;
        else move child(par) to in_obj;
    }
    while (child(in_obj) ~= 0)  move child(in_obj) to par;
    while (child(out_obj) ~= 0) move child(out_obj) to par;
    return child(par);
];

[ PrintSpaces n;
    while (n > 0) {
        print " ";
        n = n - 1;
    }
];

[ RunRoutines obj prop;
    if (obj == thedark) obj = real_location;
    if ((obj.&prop == 0) && (prop >= INDIV_PROP_START)) rfalse;
    return obj.prop();
];

[ SwapWorkflags obj lst;
	objectloop (obj ofclass Object) {
		lst = false;
		if (obj has workflag2) lst = true;
		give obj ~workflag2;
		if (obj has workflag) give obj workflag2;
		give obj ~workflag;
		if (lst) give obj workflag;
	}
];

Constant NO_USE_OPTIONS = 23;
[ TestUseOption UO;
    if (UO == 1) rtrue;
    if (UO == 2) rtrue;
    if (UO == 3) rtrue;
    if (UO == 9) rtrue;
    rfalse;
];
[ PrintUseOption UO;
    switch(UO) {
        0: print "ineffectual option";
        1: print "dynamic memory allocation option [8192]";
        2: print "maximum indexed text length option [1024]";
        3: print "maximum things understood at once option [100]";
        4: print "American dialect option";
        5: print "serial comma option";
        6: print "full-length room descriptions option";
        7: print "abbreviated room descriptions option";
        8: print "memory economy option";
        9: print "authorial modesty option";
        10: print "no scoring option";
        11: print "command line echoing option";
        12: print "undo prevention option";
        13: print "predictable randomisation option";
        14: print "fast route-finding option";
        15: print "slow route-finding option";
        16: print "numbered rules option";
        17: print "telemetry recordings option";
        18: print "no deprecated features option";
        19: print "VERBOSE room descriptions option";
        20: print "BRIEF room descriptions option";
        21: print "SUPERBRIEF room descriptions option";
        22: print "Manual Pronouns option";
    }
];


[ IntegerDivide A B;
	if (B == 0) { RunTimeProblem(RTP_DIVZERO); rfalse; }
	return A/B;
];

[ IntegerRemainder A B;
	if (B == 0) { RunTimeProblem(RTP_DIVZERO); rfalse; }
	return A%B;
];

[ UnsignedCompare x y u v;
    if (x == y) return 0;
    if (x < 0 && y >= 0) return 1;
    if (x >= 0 && y < 0) return -1;
    u = x&~WORD_HIGHBIT; v= y&~WORD_HIGHBIT;
    if (u > v) return 1;
    return -1;
];

[ ZRegion addr;
    switch (metaclass(addr)) {
		nothing: return 0;
		Object, Class: return 1;
		Routine: return 2;
		String: return 3;
    }
];

[ GL__M a b c d;
	if ((actor ~= player) || (untouchable_silence)) rtrue;
	return L__M(a,b,c,d); ];
[ AGL__M a b c d;
	if (untouchable_silence) rtrue;
	return L__M(a,b,c,d); ];


Object InformParser "(Inform Parser)" has proper;

Global best_etype;                  ! Preferred error number so far
Global nextbest_etype;              ! Preferred one, if ASKSCOPE_PE disallowed

Global parser_inflection;           ! A property (usually "name") to find object names in

Array pattern --> 32;               ! For the current pattern match
Global pcount;                      ! and a marker within it
Array pattern2 --> 32;              ! And another, which stores the best match
Global pcount2;                     ! so far

Array  line_ttype-->32;             ! For storing an analysed grammar line
Array  line_tdata-->32;
Array  line_token-->32;

Global nsns;                        ! Number of special_numbers entered so far

Global params_wanted;               ! Number of parameters needed (which may change in parsing)

Global inferfrom;                   ! The point from which the rest of the command must be inferred
Global inferword;                   ! And the preposition inferred
Global dont_infer;                  ! Another dull flag

Global cobj_flag = 0;

Global oops_from;                   ! The "first mistake" word number
Global saved_oops;                  ! Used in working this out
Array  oops_workspace -> 64;        ! Used temporarily by "oops" routine

Global held_back_mode;              ! Flag: is there some input from last time
Global hb_wn;                       ! left over?  (And a save value for wn.)
                                    ! (Used for full stops and "then".)

Global usual_grammar_after;         ! Point from which usual grammar is parsed (it may vary from
                                    ! the above if user's routines match multi-word verbs)

Constant PATTERN_NULL = $ffff;      ! Entry for a token producing no text

Global found_ttype;                 ! Used to break up tokens into type
Global found_tdata;                 ! and data (by AnalyseToken)
Global token_filter;                ! For noun filtering by user routines

Global length_of_noun;              ! Set by NounDomain to no of words in noun

Global lookahead;                   ! The token after the one now being matched

Global multi_mode;                  ! Multiple mode
Global multi_wanted;                ! Number of things needed in multitude
Global multi_had;                   ! Number of things actually found
Global multi_context;               ! What token the multi-obj was accepted for

Global indef_mode;                  ! "Indefinite" mode - ie, "take a brick"
                                    ! is in this mode
Global indef_type;                  ! Bit-map holding types of specification
Global indef_wanted;                ! Number of items wanted (INDEF_ALL_WANTED for all)
Constant INDEF_ALL_WANTED = 32767;
Global indef_guess_p;               ! Plural-guessing flag
Global indef_owner;                 ! Object which must hold these items
Global indef_cases;                 ! Possible gender and numbers of them
Global indef_possambig;             ! Has a possibly dangerous assumption
                                    ! been made about meaning of a descriptor?
Global indef_nspec_at;              ! Word at which a number like "two" was parsed
                                    ! (for backtracking)
Global allow_plurals;               ! Whether plurals presently allowed or not

Global take_all_rule;               ! Slightly different rules apply to "take all" than other uses
                                    ! of multiple objects, to make adjudication produce more
                                    ! pragmatically useful results
                                    ! (Not a flag: possible values 0, 1, 2)

Global dict_flags_of_noun;          ! Of the noun currently being parsed
                                    ! (a bitmap in #dict_par1 format)
Global pronoun__word;               ! Saved value
Global pronoun__obj;                ! Saved value

Constant comma_word = 'comma,';     ! An "untypeable word" used to substitute
                                    ! for commas in parse buffers

Array  match_list --> MATCH_LIST_WORDS;    ! An array of matched objects so far
Array  match_classes --> MATCH_LIST_WORDS; ! An array of equivalence classes for them
Array  match_scores --> MATCH_LIST_WORDS;  ! An array of match scores for them
Global number_matched;              ! How many items in it?  (0 means none)
Global number_of_classes;           ! How many equivalence classes?
Global match_length;                ! How many words long are these matches?
Global match_from;                  ! At what word of the input do they begin?

#Ifdef TARGET_ZCODE;
[ WordCount; return parse->1; ];
[ WordAddress wordnum; return buffer + parse->(wordnum*4+1); ];
[ WordLength wordnum; return parse->(wordnum*4); ];
[ MoveWord at1 b2 at2 x y;
    x = at1*2-1; y = at2*2-1;
    parse-->x++ = b2-->y++;
    parse-->x = b2-->y;
];
#Ifnot;
[ WordCount; return parse-->0; ];
[ WordAddress wordnum; return buffer + parse-->(wordnum*3); ];
[ WordLength wordnum; return parse-->(wordnum*3-1); ];
[ MoveWord at1 b2 at2 x y;
    x = at1*3-2; y = at2*3-2;
    parse-->x++ = b2-->y++;
    parse-->x++ = b2-->y++;
    parse-->x = b2-->y;
];
#Endif;

[ WordFrom w p i j wc;
	#Ifdef TARGET_ZCODE; wc = p->1; i = w*2-1;
	#Ifnot; wc = p-->0; i = w*3-2; #Endif;
    if ((w < 1) || (w > wc)) return 0;
    j = p-->i;
    if (j == ',//') j = comma_word;
    if (j == './/') j = THEN1__WD;
    return j;
];

[ NextWord i j wc;
	#Ifdef TARGET_ZCODE; wc = parse->1; i = wn*2-1;
	#Ifnot; wc = parse-->0; i = wn*3-2; #Endif;
    wn++;
    if ((wn < 2) || (wn > wc+1)) return 0;
    j = parse-->i;
    if (j == ',//') j = comma_word;
    if (j == './/') j = THEN1__WD;
    return j;
];

[ NextWordStopped wc;
	#Ifdef TARGET_ZCODE; wc = parse->1; #Ifnot; wc = parse-->0; #Endif;
	if ((wn < 1) || (wn > wc)) { wn++; return -1; }
    return NextWord();
];

[ PrintSnippet snip from to i w1 w2;
	w1 = snip/100; w2 = w1 + (snip%100) - 1;
	if ((w2<w1) || (w1<1) || (w2>WordCount())) {
		if ((w1 == 1) && (w2 == 0)) rfalse;
		return RunTimeProblem(RTP_SAYINVALIDSNIPPET, w1, w2);
	}
	from = WordAddress(w1); to = WordAddress(w2) + WordLength(w2) - 1;
	for (i=from: i<=to: i++) print (char) i->0;
];

[ SpliceSnippet snip t i w1 w2 nextw at endsnippet newlen;
	w1 = snip/100; w2 = w1 + (snip%100) - 1;
	if ((w2<w1) || (w1<1)) {
		if ((w1 == 1) && (w2 == 0)) return;
		return RunTimeProblem(RTP_SPLICEINVALIDSNIPPET, w1, w2);
	}
	@push say__p; @push say__pc;
	nextw = w2 + 1;
	at = WordAddress(w1) - buffer;
	if (nextw <= WordCount()) endsnippet = 100*nextw + (WordCount() - nextw + 1);
	buffer2-->0 = 120;
	newlen = VM_PrintToBuffer(buffer2, 120, SpliceSnippet__TextPrinter, t, endsnippet);
	for (i=0: (i<newlen) && (at+i<120): i++) buffer->(at+i) = buffer2->(WORDSIZE+i);
	#Ifdef TARGET_ZCODE; buffer->1 = at+i; #ifnot; buffer-->0 = at+i; #endif;
	for (:at+i<120:i++) buffer->(at+i) = ' ';
	VM_Tokenise(buffer, parse);
	players_command = 100 + WordCount();
	@pull say__pc; @pull say__p;
];

[ SpliceSnippet__TextPrinter t endsnippet;
	PrintText(t);
	if (endsnippet) { print " "; PrintSnippet(endsnippet); }
];

[ SnippetIncludes test snippet w1 w2 wlen i j;
	w1 = snippet/100; w2 = w1 + (snippet%100) - 1;
	if ((w2<w1) || (w1<1)) {
		if ((w1 == 1) && (w2 == 0)) rfalse;
		return RunTimeProblem(RTP_INCLUDEINVALIDSNIPPET, w1, w2);
	}
	if (metaclass(test) == Routine) {
		wlen = snippet%100;
		for (i=w1, j=wlen: j>0: i++, j--) {
			if (((test)(i, 0)) ~= GPR_FAIL) return i*100+wn-i;
		}
	}
	rfalse;
];

[ SnippetMatches snippet topic_gpr rv;
	wn=1;
	if (topic_gpr == 0) rfalse;
	if (metaclass(topic_gpr) == Routine) {
		rv = (topic_gpr)(snippet/100, snippet%100);
		if (rv ~= GPR_FAIL) rtrue;
		rfalse;
	}
	RunTimeProblem(RTP_BADTOPIC);
	rfalse;
];

[ UnpackGrammarLine line_address i size;
    for (i=0 : i<32 : i++) {
        line_token-->i = ENDIT_TOKEN;
        line_ttype-->i = ELEMENTARY_TT;
        line_tdata-->i = ENDIT_TOKEN;
    }
#Ifdef TARGET_ZCODE;
    action_to_be = 256*(line_address->0) + line_address->1;
    action_reversed = ((action_to_be & $400) ~= 0);
    action_to_be = action_to_be & $3ff;
    line_address--;
    size = 3;
#Ifnot; ! GLULX
    @aloads line_address 0 action_to_be;
    action_reversed = (((line_address->2) & 1) ~= 0);
    line_address = line_address - 2;
    size = 5;
#Endif;
    params_wanted = 0;
    for (i=0 : : i++) {
        line_address = line_address + size;
        if (line_address->0 == ENDIT_TOKEN) break;
        line_token-->i = line_address;
        AnalyseToken(line_address);
        if (found_ttype ~= PREPOSITION_TT) params_wanted++;
        line_ttype-->i = found_ttype;
        line_tdata-->i = found_tdata;
    }
    return line_address + 1;
];

[ AnalyseToken token;
    if (token == ENDIT_TOKEN) {
        found_ttype = ELEMENTARY_TT;
        found_tdata = ENDIT_TOKEN;
        return;
    }
    found_ttype = (token->0) & $$1111;
    found_tdata = (token+1)-->0;
];

[ DictionaryWordToVerbNum dword verbnum;
#Ifdef TARGET_ZCODE;
	verbnum = $ff-(dword->#dict_par2);
#Ifnot; ! GLULX
	dword = dword + #dict_par2 - 1;
    @aloads dword 0 verbnum;
    verbnum = $ffff-verbnum;
#Endif;
	return verbnum;
];

[ KeyboardPrimitive a_buffer a_table;
#Ifdef DEBUG; #Iftrue (3 > 0);
	return TestKeyboardPrimitive(a_buffer, a_table);
#Endif; #Endif;
	return VM_ReadKeyboard(a_buffer, a_table);
];

[ Keyboard  a_buffer a_table  nw i w w2 x1 x2;
	sline1 = score; sline2 = turns;

	while (true) {
		! Save the start of the buffer, in case "oops" needs to restore it
		for (i=0 : i<64 : i++) oops_workspace->i = a_buffer->i;
	
		! In case of an array entry corruption that shouldn't happen, but would be
		! disastrous if it did:
		#Ifdef TARGET_ZCODE;
		a_buffer->0 = INPUT_BUFFER_LEN;
		a_table->0 = 15;  ! Allow to split input into this many words
		#Endif; ! TARGET_
	
		! Print the prompt, and read in the words and dictionary addresses
		PrintPrompt();
		DrawStatusLine();
		KeyboardPrimitive(a_buffer, a_table);
	
		! Set nw to the number of words
		#Ifdef TARGET_ZCODE; nw = a_table->1; #Ifnot; nw = a_table-->0; #Endif;
	
		! If the line was blank, get a fresh line
		if (nw == 0) {
			@push etype; etype = BLANKLINE_PE;
			players_command = 100;
			BeginActivity(PRINTING_A_PARSER_ERROR_ACT);
			if (ForActivity(PRINTING_A_PARSER_ERROR_ACT) == false) L__M(##Miscellany,10);
			EndActivity(PRINTING_A_PARSER_ERROR_ACT);
			@pull etype;
			continue;
		}
	
		! Unless the opening word was OOPS, return
		! Conveniently, a_table-->1 is the first word on both the Z-machine and Glulx
	
		w = a_table-->1;
		if (w == OOPS1__WD or OOPS2__WD or OOPS3__WD) {
			if (oops_from == 0) { L__M(##Miscellany, 14); continue; }
			if (nw == 1) { L__M(##Miscellany, 15); continue; }
			if (nw > 2) { L__M(##Miscellany, 16); continue; }
		
			! So now we know: there was a previous mistake, and the player has
			! attempted to correct a single word of it.
		
			for (i=0 : i<INPUT_BUFFER_LEN : i++) buffer2->i = a_buffer->i;
			#Ifdef TARGET_ZCODE;
			x1 = a_table->9;  ! Start of word following "oops"
			x2 = a_table->8;  ! Length of word following "oops"
			#Ifnot; ! TARGET_GLULX
			x1 = a_table-->6; ! Start of word following "oops"
			x2 = a_table-->5; ! Length of word following "oops"
			#Endif; ! TARGET_
		
			! Repair the buffer to the text that was in it before the "oops"
			! was typed:
			for (i=0 : i<64 : i++) a_buffer->i = oops_workspace->i;
			VM_Tokenise(a_buffer,a_table);
		
			! Work out the position in the buffer of the word to be corrected:
			#Ifdef TARGET_ZCODE;
			w = a_table->(4*oops_from + 1); ! Start of word to go
			w2 = a_table->(4*oops_from);    ! Length of word to go
			#Ifnot; ! TARGET_GLULX
			w = a_table-->(3*oops_from);      ! Start of word to go
			w2 = a_table-->(3*oops_from - 1); ! Length of word to go
			#Endif; ! TARGET_
		
			! Write spaces over the word to be corrected:
			for (i=0 : i<w2 : i++) a_buffer->(i+w) = ' ';
		
			if (w2 < x2) {
				! If the replacement is longer than the original, move up...
				for (i=INPUT_BUFFER_LEN-1 : i>=w+x2 : i--)
					a_buffer->i = a_buffer->(i-x2+w2);
		
				! ...increasing buffer size accordingly.
				#Ifdef TARGET_ZCODE;
				a_buffer->1 = (a_buffer->1) + (x2-w2);
				#Ifnot; ! TARGET_GLULX
				a_buffer-->0 = (a_buffer-->0) + (x2-w2);
				#Endif; ! TARGET_
			}
		
			! Write the correction in:
			for (i=0 : i<x2 : i++) a_buffer->(i+w) = buffer2->(i+x1);
		
			VM_Tokenise(a_buffer, a_table);
			#Ifdef TARGET_ZCODE; nw = a_table->1; #Ifnot; nw = a_table-->0; #Endif;
		
			return nw;
		}

		! Undo handling
	
		if ((w == UNDO1__WD or UNDO2__WD or UNDO3__WD) && (nw==1)) {
			Perform_Undo();
			continue;
		}
		i = VM_Save_Undo();
		#ifdef PREVENT_UNDO; undo_flag = 0; #endif;
		#ifndef PREVENT_UNDO; undo_flag = 2; #endif;
		if (i == -1) undo_flag = 0;
		if (i == 0) undo_flag = 1;
		if (i == 2) {
			VM_RestoreWindowColours();
			VM_Style(SUBHEADER_VMSTY);
			SL_Location(); print "^";
			! print (name) location, "^";
			VM_Style(NORMAL_VMSTY);
			L__M(##Miscellany, 13);
			continue;
		}
		return nw;
	}
];

[ Parser__parse
	syntax line num_lines line_address i j k token l m;

	cobj_flag = 0;
	parser_results-->ACTION_PRES = 0;
	parser_results-->NO_INPS_PRES = 0;
	parser_results-->INP1_PRES = 0;
	parser_results-->INP2_PRES = 0;
	meta = false;

    if (held_back_mode == 1) {
        held_back_mode = 0;
        VM_Tokenise(buffer, parse);
        jump ReParse;
    }

  .ReType;

	cobj_flag = 0;
	actors_location = ScopeCeiling(player);
    BeginActivity(READING_A_COMMAND_ACT); if (ForActivity(READING_A_COMMAND_ACT)==false) {
		Keyboard(buffer,parse);
		players_command = 100 + WordCount();
		num_words = WordCount();
    } if (EndActivity(READING_A_COMMAND_ACT)) jump ReType;

  .ReParse;

    parser_inflection = name;

    ! Initially assume the command is aimed at the player, and the verb
    ! is the first word

    num_words = WordCount();
    wn = 1;

    #Ifdef LanguageToInformese;
    LanguageToInformese();
    ! Re-tokenise:
    VM_Tokenise(buffer,parse);
    #Endif; ! LanguageToInformese

    num_words = WordCount();

    k=0;
    #Ifdef DEBUG;
    if (parser_trace >= 2) {
        print "[ ";
        for (i=0 : i<num_words : i++) {

            #Ifdef TARGET_ZCODE;
            j = parse-->(i*2 + 1);
            #Ifnot; ! TARGET_GLULX
            j = parse-->(i*3 + 1);
            #Endif; ! TARGET_
            k = WordAddress(i+1);
            l = WordLength(i+1);
            print "~"; for (m=0 : m<l : m++) print (char) k->m; print "~ ";

            if (j == 0) print "?";
            else {
                #Ifdef TARGET_ZCODE;
                if (UnsignedCompare(j, HDR_DICTIONARY-->0) >= 0 &&
                    UnsignedCompare(j, HDR_HIGHMEMORY-->0) < 0)
                     print (address) j;
                else print j;
                #Ifnot; ! TARGET_GLULX
                if (j->0 == $60) print (address) j;
                else print j;
                #Endif; ! TARGET_
            }
            if (i ~= num_words-1) print " / ";
        }
        print " ]^";
    }
    #Endif; ! DEBUG
    verb_wordnum = 1;
    actor = player;
    actors_location = ScopeCeiling(player);
    usual_grammar_after = 0;

  .AlmostReParse;

    scope_token = 0;
    action_to_be = NULL;

    ! Begin from what we currently think is the verb word

  .BeginCommand;

    wn = verb_wordnum;
    verb_word = NextWordStopped();

    ! If there's no input here, we must have something like "person,".

    if (verb_word == -1) {
        best_etype = STUCK_PE;
        jump GiveError;
    }

    ! Now try for "again" or "g", which are special cases: don't allow "again" if nothing
    ! has previously been typed; simply copy the previous text across

    if (verb_word == AGAIN2__WD or AGAIN3__WD) verb_word = AGAIN1__WD;
    if (verb_word == AGAIN1__WD) {
        if (actor ~= player) {
            L__M(##Miscellany, 20);
            jump ReType;
        }
        #Ifdef TARGET_ZCODE;
        if (buffer3->1 == 0) {
            L__M(##Miscellany, 21);
            jump ReType;
        }
        #Ifnot; ! TARGET_GLULX
        if (buffer3-->0 == 0) {
            L__M(##Miscellany, 21);
            jump ReType;
        }
        #Endif; ! TARGET_
        for (i=0 : i<INPUT_BUFFER_LEN : i++) buffer->i = buffer3->i;
        VM_Tokenise(buffer,parse);
		num_words = WordCount();
    	players_command = 100 + WordCount();
		jump ReParse;
    }

    ! Save the present input in case of an "again" next time

    if (verb_word ~= AGAIN1__WD)
        for (i=0 : i<INPUT_BUFFER_LEN : i++) buffer3->i = buffer->i;

    if (usual_grammar_after == 0) {
        j = verb_wordnum;
        i = RunRoutines(actor, grammar); 
        #Ifdef DEBUG;
        if (parser_trace >= 2 && actor.grammar ~= 0 or NULL)
            print " [Grammar property returned ", i, "]^";
        #Endif; ! DEBUG

        if ((i ~= 0 or 1) && (VM_InvalidDictionaryAddress(i))) {
            usual_grammar_after = verb_wordnum; i=-i;
        }

        if (i == 1) {
            parser_results-->ACTION_PRES = action;
            parser_results-->NO_INPS_PRES = 0;
            parser_results-->INP1_PRES = noun;
            parser_results-->INP2_PRES = second;
            if (noun) parser_results-->NO_INPS_PRES = 1;
            if (second) parser_results-->NO_INPS_PRES = 2;
            rtrue;
        }
        if (i ~= 0) { verb_word = i; wn--; verb_wordnum--; }
        else { wn = verb_wordnum; verb_word = NextWord(); }
    }
    else usual_grammar_after = 0;

    #Ifdef LanguageIsVerb;
    if (verb_word == 0) {
        i = wn; verb_word = LanguageIsVerb(buffer, parse, verb_wordnum);
        wn = i;
    }
    #Endif; ! LanguageIsVerb

    ! If the first word is not listed as a verb, it must be a direction
    ! or the name of someone to talk to

    if (verb_word == 0 || ((verb_word->#dict_par1) & 1) == 0) {

        ! So is the first word an object contained in the special object "compass"
        ! (i.e., a direction)?  This needs use of NounDomain, a routine which
        ! does the object matching, returning the object number, or 0 if none found,
        ! or REPARSE_CODE if it has restructured the parse table so the whole parse
        ! must be begun again...

        wn = verb_wordnum; indef_mode = false; token_filter = 0; parameters = 0;
        @push actor; @push action; @push action_to_be;
        actor = player; meta = false; action = ##Go; action_to_be = ##Go;
        l = NounDomain(compass, 0, 0);
        @pull action_to_be; @pull action; @pull actor;
        if (l == REPARSE_CODE) jump ReParse;

        ! If it is a direction, send back the results:
        ! action=GoSub, no of arguments=1, argument 1=the direction.

        if ((l~=0) && (l ofclass K3_direction)) {
            parser_results-->ACTION_PRES = ##Go;
            parser_results-->NO_INPS_PRES = 1;
            parser_results-->INP1_PRES = l;
            jump LookForMore;
        }

    } ! end of first-word-not-a-verb

	! Only check for a comma (a "someone, do something" command) if we are
	! not already in the middle of one.  (This simplification stops us from
	! worrying about "robot, wizard, you are an idiot", telling the robot to
	! tell the wizard that she is an idiot.)
	
	if (actor == player) {
		for (j=2 : j<=num_words : j++) {
			i=NextWord();
			if (i == comma_word) jump Conversation;
		}
	}
	jump NotConversation;
	
	! NextWord nudges the word number wn on by one each time, so we've now
	! advanced past a comma.  (A comma is a word all on its own in the table.)
	
	.Conversation;
	
	j = wn - 1;
	if (j == 1) {
		L__M(##Miscellany, 22);
		jump ReType;
	}
	
	! Use NounDomain (in the context of "animate creature") to see if the
	! words make sense as the name of someone held or nearby
	
	wn = 1; lookahead = HELD_TOKEN;
	scope_reason = TALKING_REASON;
	l = NounDomain(player,actors_location,6);
	scope_reason = PARSING_REASON;
	if (l == REPARSE_CODE) jump ReParse;
	if (l == 0) {
		if (verb_word && ((verb_word->#dict_par1) & 1)) jump NotConversation;
		L__M(##Miscellany, 23);
		jump ReType;
	}
	
	.Conversation2;
	
	! The object addressed must at least be "talkable" if not actually "animate"
	! (the distinction allows, for instance, a microphone to be spoken to,
	! without the parser thinking that the microphone is human).
	
	if (l hasnt animate && l hasnt talkable) {
		L__M(##Miscellany, 24, l);
		jump ReType;
	}
	
	! Check that there aren't any mystery words between the end of the person's
	! name and the comma (eg, throw out "dwarf sdfgsdgs, go north").
	
	if (wn ~= j) {
		if (verb_word && ((verb_word->#dict_par1) & 1)) jump NotConversation;
		L__M(##Miscellany, 25);
		jump ReType;
	}
	
	! The player has now successfully named someone.  Adjust "him", "her", "it":
	
	PronounNotice(l);
	
	! Set the global variable "actor", adjust the number of the first word,
	! and begin parsing again from there.
	
	verb_wordnum = j + 1;
	
	! Stop things like "me, again":
	
	if (l == player) {
		wn = verb_wordnum;
		if (NextWordStopped() == AGAIN1__WD or AGAIN2__WD or AGAIN3__WD) {
			L__M(##Miscellany, 20);
			jump ReType;
		}
	}
	
	actor = l;
	actors_location = ScopeCeiling(l);
	#Ifdef DEBUG;
	if (parser_trace >= 1)
		print "[Actor is ", (the) actor, " in ", (name) actors_location, "]^";
	#Endif; ! DEBUG
	jump BeginCommand;

	.NotConversation;
	if (verb_word == 0 || ((verb_word->#dict_par1) & 1) == 0) {
		if (actor == player) {
			verb_word = UnknownVerb(verb_word);
			if (verb_word ~= 0) jump VerbAccepted;
		}
		best_etype = VERB_PE;
		jump GiveError;
	}
	.VerbAccepted;

    ! We now definitely have a verb, not a direction, whether we got here by the
    ! "take ..." or "person, take ..." method.  Get the meta flag for this verb:

    meta = ((verb_word->#dict_par1) & 2)/2;

    ! You can't order other people to "full score" for you, and so on...

    if (meta == 1 && actor ~= player) {
        best_etype = VERB_PE;
        meta = 0;
        jump GiveError;
    }

    ! Now let i be the corresponding verb number...

    i = DictionaryWordToVerbNum(verb_word);

    ! ...then look up the i-th entry in the verb table, whose address is at word
    ! 7 in the Z-machine (in the header), so as to get the address of the syntax
    ! table for the given verb...

    #Ifdef TARGET_ZCODE;
    syntax = (HDR_STATICMEMORY-->0)-->i;
    #Ifnot; ! TARGET_GLULX
    syntax = (#grammar_table)-->(i+1);
    #Endif; ! TARGET_

    ! ...and then see how many lines (ie, different patterns corresponding to the
    ! same verb) are stored in the parse table...

    num_lines = (syntax->0) - 1;

    ! ...and now go through them all, one by one.
    ! To prevent pronoun_word 0 being misunderstood,

    pronoun_word = NULL; pronoun_obj = NULL;

    #Ifdef DEBUG;
    if (parser_trace >= 1)
    	print "[Parsing for the verb '", (address) verb_word, "' (", num_lines+1, " lines)]^";
    #Endif; ! DEBUG

    best_etype = STUCK_PE; nextbest_etype = STUCK_PE;
    multiflag = false;

    ! "best_etype" is the current failure-to-match error - it is by default
    ! the least informative one, "don't understand that sentence".
    ! "nextbest_etype" remembers the best alternative to having to ask a
    ! scope token for an error message (i.e., the best not counting ASKSCOPE_PE).
    ! multiflag is used here to prevent inappropriate MULTI_PE errors
    ! in addition to its unrelated duties passing information to action routines

    line_address = syntax + 1;

    for (line=0 : line<=num_lines : line++) {

        for (i=0 : i<32 : i++) {
            line_token-->i = ENDIT_TOKEN;
            line_ttype-->i = ELEMENTARY_TT;
            line_tdata-->i = ENDIT_TOKEN;
        }

        ! Unpack the syntax line from Inform format into three arrays; ensure that
        ! the sequence of tokens ends in an ENDIT_TOKEN.

        line_address = UnpackGrammarLine(line_address);

        #Ifdef DEBUG;
        if (parser_trace >= 1) {
            if (parser_trace >= 2) new_line;
            print "[line ", line; DebugGrammarLine();
            print "]^";
        }
        #Endif; ! DEBUG

        ! We aren't in "not holding" or inferring modes, and haven't entered
        ! any parameters on the line yet, or any special numbers; the multiple
        ! object is still empty.

        inferfrom = 0;
        parameters = 0;
        nsns = 0; special_word = 0;
        multiple_object-->0 = 0;
        multi_context = 0;
        etype = STUCK_PE;

        ! Put the word marker back to just after the verb

        wn = verb_wordnum+1;

        advance_warning = -1; indef_mode = false;
        for (i=0,m=false,pcount=0 : line_token-->pcount ~= ENDIT_TOKEN : pcount++) {
            scope_token = 0;

            if (line_ttype-->pcount ~= PREPOSITION_TT) i++;

            if (line_ttype-->pcount == ELEMENTARY_TT) {
                if (line_tdata-->pcount == MULTI_TOKEN) m = true;
                if (line_tdata-->pcount == MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN  && i == 1) {
                    ! First non-preposition is "multiexcept" or
                    ! "multiinside", so look ahead.

                    #Ifdef DEBUG;
                    if (parser_trace >= 2) print " [Trying look-ahead]^";
                    #Endif; ! DEBUG

                    ! We need this to be followed by 1 or more prepositions.

                    pcount++;
                    if (line_ttype-->pcount == PREPOSITION_TT) {
                        ! skip ahead to a preposition word in the input
                        do {
                            l = NextWord();
                        } until ((wn > num_words) ||
                                 (l && (l->#dict_par1) & 8 ~= 0));
                        
                        if (wn > num_words) {
                            #Ifdef DEBUG;
                            if (parser_trace >= 2)
                                print " [Look-ahead aborted: prepositions missing]^";
                            #Endif;
                            jump LineFailed;
                        }
                        
                        do {
                            if (PrepositionChain(l, pcount) ~= -1) {
                                ! advance past the chain
                                if ((line_token-->pcount)->0 & $20 ~= 0) {
                                    pcount++;
                                    while ((line_token-->pcount ~= ENDIT_TOKEN) &&
                                           ((line_token-->pcount)->0 & $10 ~= 0))
                                        pcount++;
                                } else {
                                    pcount++;
                                }
                            } else {
                                ! try to find another preposition word
                                do {
                                    l = NextWord();
                                } until ((wn >= num_words) ||
                                         (l && (l->#dict_par1) & 8 ~= 0));
                                
                                if (l && (l->#dict_par1) & 8) continue;
                                
                                ! lookahead failed
                                #Ifdef DEBUG;
                                if (parser_trace >= 2)
                                    print " [Look-ahead aborted: prepositions don't match]^";
                                #endif;
                                jump LineFailed;
                            }
                            l = NextWord();
                        } until (line_ttype-->pcount ~= PREPOSITION_TT);
                        
                        ! put back the non-preposition we just read
                        wn--;

                        if ((line_ttype-->pcount == ELEMENTARY_TT) &&
                        	(line_tdata-->pcount == NOUN_TOKEN)) {
                            l = Descriptors();  ! skip past THE etc
                            if (l~=0) etype=l;  ! don't allow multiple objects
                        	k = parser_results-->INP1_PRES; @push k; @push parameters;
                        	parameters = 1; parser_results-->INP1_PRES = 0;
                            l = NounDomain(actors_location, actor, NOUN_TOKEN);
                            @pull parameters; @pull k; parser_results-->INP1_PRES = k;
                            #Ifdef DEBUG;
                            if (parser_trace >= 2) {
                                print " [Advanced to ~noun~ token: ";
                                if (l == REPARSE_CODE) print "re-parse request]^";
                                else {
                                	if (l == 1) print "but multiple found]^";
                                	if (l == 0) print "error ", etype, "]^";
                                	if (l >= 2) print (the) l, "]^";
                                }
                            }
                            #Endif; ! DEBUG
                            if (l == REPARSE_CODE) jump ReParse;
                            if (l >= 2) advance_warning = l;
                        }
                    }
                    break;
                }
            }
        }

        ! Slightly different line-parsing rules will apply to "take multi", to
        ! prevent "take all" behaving correctly but misleadingly when there's
        ! nothing to take.

        take_all_rule = 0;
        if (m && params_wanted == 1 && action_to_be == ##Take)
            take_all_rule = 1;

        ! And now start again, properly, forearmed or not as the case may be.
        ! As a precaution, we clear all the variables again (they may have been
        ! disturbed by the call to NounDomain, which may have called outside
        ! code, which may have done anything!).

        inferfrom = 0;
        parameters = 0;
        nsns = 0; special_word = 0;
        multiple_object-->0 = 0;
        etype = STUCK_PE;
        wn = verb_wordnum+1;

        for (pcount=1 : : pcount++) {
            pattern-->pcount = PATTERN_NULL; scope_token = 0;

            token = line_token-->(pcount-1);
            lookahead = line_token-->pcount;

            #Ifdef DEBUG;
            if (parser_trace >= 2)
                print " [line ", line, " token ", pcount, " word ", wn, " : ", (DebugToken) token,
                  "]^";
            #Endif; ! DEBUG

            if (token ~= ENDIT_TOKEN) {
                scope_reason = PARSING_REASON;
                AnalyseToken(token);

                l = ParseToken(found_ttype, found_tdata, pcount-1, token);
                while ((l >= GPR_NOUN) && (l < -1)) l = ParseToken(ELEMENTARY_TT, l + 256);
                scope_reason = PARSING_REASON;

                if (l == GPR_PREPOSITION) {
                    if (found_ttype~=PREPOSITION_TT && (found_ttype~=ELEMENTARY_TT ||
                        found_tdata~=TOPIC_TOKEN)) params_wanted--;
                    l = true;
                }
                else
                    if (l < 0) l = false;
                    else
                        if (l ~= GPR_REPARSE) {
                            if (l == GPR_NUMBER) {
                                if (nsns == 0) special_number1 = parsed_number;
                                else special_number2 = parsed_number;
                                nsns++; l = 1;
                            }
                            if (l == GPR_MULTIPLE) l = 0;
                            parser_results-->(parameters+INP1_PRES) = l;
                            parameters++;
                            pattern-->pcount = l;
                            l = true;
                        }

                #Ifdef DEBUG;
                if (parser_trace >= 3) {
                    print "  [token resulted in ";
                    if (l == REPARSE_CODE) print "re-parse request]^";
                    if (l == 0) print "failure with error type ", etype, "]^";
                    if (l == 1) print "success]^";
                }
                #Endif; ! DEBUG

                if (l == REPARSE_CODE) jump ReParse;
                if (l == false) break;
            }
            else {

                ! If the player has entered enough already but there's still
                ! text to wade through: store the pattern away so as to be able to produce
                ! a decent error message if this turns out to be the best we ever manage,
                ! and in the mean time give up on this line

                ! However, if the superfluous text begins with a comma or "then" then
                ! take that to be the start of another instruction

                if (wn <= num_words) {
                    l = NextWord();
                    if (l == THEN1__WD or THEN2__WD or THEN3__WD or comma_word) {
                        held_back_mode = 1; hb_wn = wn-1;
                    }
                    else {
                        for (m=0 : m<32 : m++) pattern2-->m = pattern-->m;
                        pcount2 = pcount;
                        etype = UPTO_PE;
                        break;
                    }
                }

                ! Now, we may need to revise the multiple object because of the single one
                ! we now know (but didn't when the list was drawn up).

                if (parameters >= 1 && parser_results-->INP1_PRES == 0) {
                    l = ReviseMulti(parser_results-->INP2_PRES);
                    if (l ~= 0) { etype = l; parser_results-->ACTION_PRES = action_to_be; break; }
                }
                if (parameters >= 2 && parser_results-->INP2_PRES == 0) {
                    l = ReviseMulti(parser_results-->INP1_PRES);
                    if (l ~= 0) { etype = l; break; }
                }

                ! To trap the case of "take all" inferring only "yourself" when absolutely
                ! nothing else is in the vicinity...

                if (take_all_rule == 2 && parser_results-->INP1_PRES == actor) {
                    best_etype = NOTHING_PE;
                    jump GiveError;
                }

                #Ifdef DEBUG;
                if (parser_trace >= 1) print "[Line successfully parsed]^";
                #Endif; ! DEBUG

                ! The line has successfully matched the text.  Declare the input error-free...

                oops_from = 0;

                ! ...explain any inferences made (using the pattern)...

                if (inferfrom ~= 0) {
                	PrintInferredCommand(inferfrom);
                    ClearParagraphing();
                }

                ! ...copy the action number, and the number of parameters...

                parser_results-->ACTION_PRES = action_to_be;
                parser_results-->NO_INPS_PRES = parameters;

                ! ...reverse first and second parameters if need be...

                if (action_reversed && parameters == 2) {
                    i = parser_results-->INP1_PRES;
                    parser_results-->INP1_PRES = parser_results-->INP2_PRES;
                    parser_results-->INP2_PRES = i;
                    if (nsns == 2) {
                        i = special_number1; special_number1 = special_number2;
                        special_number2 = i;
                    }
                }

                ! ...and to reset "it"-style objects to the first of these parameters, if
                ! there is one (and it really is an object)...

                if (parameters > 0 && parser_results-->INP1_PRES >= 2)
                    PronounNotice(parser_results-->INP1_PRES);

                ! ...and return from the parser altogether, having successfully matched
                ! a line.

                if (held_back_mode == 1) {
                    wn=hb_wn;
                    jump LookForMore;
                }
                rtrue;

            } ! end of if(token ~= ENDIT_TOKEN) else
        } ! end of for(pcount++)

        .LineFailed;
        ! The line has failed to match.
        ! We continue the outer "for" loop, trying the next line in the grammar.

        if (etype > best_etype) best_etype = etype;
        if (etype ~= ASKSCOPE_PE && etype > nextbest_etype) nextbest_etype = etype;

        ! ...unless the line was something like "take all" which failed because
        ! nothing matched the "all", in which case we stop and give an error now.

        if (take_all_rule == 2 && etype==NOTHING_PE) break;

    } ! end of for(line++)

    ! The grammar is exhausted: every line has failed to match.

  .GiveError;

    etype = best_etype;
    if (actor ~= player) {
        if (usual_grammar_after ~= 0) {
            verb_wordnum = usual_grammar_after;
            jump AlmostReParse;
        }
        wn = verb_wordnum;
        special_word = NextWord();
        if (special_word == comma_word) {
            special_word = NextWord();
            verb_wordnum++;
        }
        parser_results-->ACTION_PRES = ##Answer;
        parser_results-->NO_INPS_PRES = 2;
        parser_results-->INP1_PRES = actor;
        parser_results-->INP2_PRES = 1; special_number1 = special_word;
        actor = player;
        consult_from = verb_wordnum; consult_words = num_words-consult_from+1;
        rtrue;
    }

    ! If the player was the actor (eg, in "take dfghh") the error must be printed,
    ! and fresh input called for.  In three cases the oops word must be jiggled.

    if ((etype ofclass Routine) || (etype ofclass String)) {
        if (ParserError(etype) ~= 0) jump ReType;
    } else {
		if (verb_wordnum == 0 && etype == CANTSEE_PE) etype = VERB_PE;
		players_command = 100 + WordCount(); ! The snippet variable ``player's command''
        BeginActivity(PRINTING_A_PARSER_ERROR_ACT);
        if (ForActivity(PRINTING_A_PARSER_ERROR_ACT)) jump SkipParserError;
    }
    pronoun_word = pronoun__word; pronoun_obj = pronoun__obj;

    if (etype == STUCK_PE) {    L__M(##Miscellany, 27); oops_from = 1; }
    if (etype == UPTO_PE) {     L__M(##Miscellany, 28);
        for (m=0 : m<32 : m++) pattern-->m = pattern2-->m;
        pcount = pcount2; PrintCommand(0); L__M(##Miscellany, 56);
    }
    if (etype == NUMBER_PE)     L__M(##Miscellany, 29);
    if (etype == CANTSEE_PE) {  L__M(##Miscellany, 30); oops_from=saved_oops; }
    if (etype == TOOLIT_PE)     L__M(##Miscellany, 31);
    if (etype == NOTHELD_PE) {  L__M(##Miscellany, 32); oops_from=saved_oops; }
    if (etype == MULTI_PE)      L__M(##Miscellany, 33);
    if (etype == MMULTI_PE)     L__M(##Miscellany, 34);
    if (etype == VAGUE_PE)      L__M(##Miscellany, 35);
    if (etype == EXCEPT_PE)     L__M(##Miscellany, 36);
    if (etype == ANIMA_PE)      L__M(##Miscellany, 37);
    if (etype == VERB_PE)       L__M(##Miscellany, 38);
    if (etype == SCENERY_PE)    L__M(##Miscellany, 39);
    if (etype == ITGONE_PE) {
        if (pronoun_obj == NULL)
                                L__M(##Miscellany, 35);
        else                    L__M(##Miscellany, 40);
    }
    if (etype == JUNKAFTER_PE)  L__M(##Miscellany, 41);
    if (etype == TOOFEW_PE)     L__M(##Miscellany, 42, multi_had);
    if (etype == NOTHING_PE) {
        if (parser_results-->ACTION_PRES == ##Remove &&
        	parser_results-->INP2_PRES ofclass Object) {
            noun = parser_results-->INP2_PRES; ! ensure valid for messages
            if (noun has animate) L__M(##Take, 6, noun);
            else if (noun hasnt container or supporter) L__M(##Insert, 2, noun);
            else if (noun has container && noun hasnt open) L__M(##Take, 9, noun);
            else if (children(noun)==0) L__M(##Search, 6, noun);
            else parser_results-->ACTION_PRES = 0;
            }
        if (parser_results-->ACTION_PRES ~= ##Remove) {
            if (multi_wanted==100)  L__M(##Miscellany, 43);
            else                    L__M(##Miscellany, 44);
        }
    }
    if (etype == ASKSCOPE_PE) {
        scope_stage = 3;
        if (indirect(scope_error) == -1) {
            best_etype = nextbest_etype;
            if (~~((etype ofclass Routine) || (etype ofclass String)))
            	EndActivity(PRINTING_A_PARSER_ERROR_ACT);
            jump GiveError;
        }
    }
    if (etype == NOTINCONTEXT_PE) L__M(##Miscellany, 73);

    .SkipParserError;
    if ((etype ofclass Routine) || (etype ofclass String)) jump ReType;
    say__p = 1;
    EndActivity(PRINTING_A_PARSER_ERROR_ACT);

    ! And go (almost) right back to square one...

    jump ReType;

    ! ...being careful not to go all the way back, to avoid infinite repetition
    ! of a deferred command causing an error.

    ! At this point, the return value is all prepared, and we are only looking
    ! to see if there is a "then" followed by subsequent instruction(s).

  .LookForMore;

    if (wn > num_words) rtrue;

    i = NextWord();
    if (i == THEN1__WD or THEN2__WD or THEN3__WD or comma_word) {
        if (wn > num_words) {
           held_back_mode = false;
           return;
        }
        i = WordAddress(verb_wordnum);
        j = WordAddress(wn);
        for (: i<j : i++) i->0 = ' ';
        i = NextWord();
        if (i == AGAIN1__WD or AGAIN2__WD or AGAIN3__WD) {
            ! Delete the words "then again" from the again buffer,
            ! in which we have just realised that it must occur:
            ! prevents an infinite loop on "i. again"

            i = WordAddress(wn-2)-buffer;
            if (wn > num_words) j = INPUT_BUFFER_LEN-1;
            else j = WordAddress(wn)-buffer;
            for (: i<j : i++) buffer3->i = ' ';
        }
        VM_Tokenise(buffer,parse);
        held_back_mode = true;
        return;
    }
    best_etype = UPTO_PE;
    jump GiveError;

]; ! end of Parser__parse

[ ParseTokenStopped x y;
	if (wn>WordCount()) return GPR_FAIL;
	return ParseToken(x,y);
];

Global parsetoken_nesting = 0;
[ ParseToken given_ttype given_tdata token_n token  i t rv;
	if (parsetoken_nesting > 0) {
		! save match globals
		@push match_from; @push token_filter; @push match_length;
		@push number_of_classes; @push oops_from;
		for (i=0: i<number_matched: i++) {
			t = match_list-->i; @push t;
			t = match_classes-->i; @push t;
			t = match_scores-->i; @push t;
		}
		@push number_matched;
	 }

	parsetoken_nesting++;
	rv = ParseToken__(given_ttype, given_tdata, token_n, token);
	parsetoken_nesting--;

	if (parsetoken_nesting > 0) {
		! restore match globals
		@pull number_matched;
		for (i=0: i<number_matched: i++) {
 			@pull t; match_scores-->i = t;
			@pull t; match_classes-->i = t;
			@pull t; match_list-->i = t;
   		}
		@pull oops_from; @pull number_of_classes;
		@pull match_length; @pull token_filter; @pull match_from;
	}
	return rv;
];

[ ParseToken__ given_ttype given_tdata token_n token
	l o i j k and_parity single_object desc_wn many_flag
	token_allows_multiple prev_indef_wanted;

    token_filter = 0;
    parser_inflection = name;

    switch (given_ttype) {
      ELEMENTARY_TT:
        switch (given_tdata) {
          SPECIAL_TOKEN:
            l = TryNumber(wn);
            special_word = NextWord();
            #Ifdef DEBUG;
            if (l ~= -1000)
                if (parser_trace >= 3) print "  [Read special as the number ", l, "]^";
            #Endif; ! DEBUG
            if (l == -1000) {
                #Ifdef DEBUG;
                if (parser_trace >= 3) print "  [Read special word at word number ", wn, "]^";
                #Endif; ! DEBUG
                l = special_word;
            }
            parsed_number = l;
            return GPR_NUMBER;

          NUMBER_TOKEN:
            l=TryNumber(wn++);
            if (l == -1000) {
                etype = NUMBER_PE;
                return GPR_FAIL;
            }
            #Ifdef DEBUG;
            if (parser_trace>=3) print "  [Read number as ", l, "]^";
            #Endif; ! DEBUG
            parsed_number = l;
            return GPR_NUMBER;

          CREATURE_TOKEN:
            if (action_to_be == ##Answer or ##Ask or ##AskFor or ##Tell)
                scope_reason = TALKING_REASON;

          TOPIC_TOKEN:
            consult_from = wn;
            if ((line_ttype-->(token_n+1) ~= PREPOSITION_TT) &&
               (line_token-->(token_n+1) ~= ENDIT_TOKEN))
                RunTimeError(13);
            do o = NextWordStopped();
            until (o == -1 || PrepositionChain(o, token_n+1) ~= -1);
            wn--;
            consult_words = wn-consult_from;
            if (consult_words == 0) return GPR_FAIL;
            if (action_to_be == ##Ask or ##Answer or ##Tell) {
                o = wn; wn = consult_from; parsed_number = NextWord();
                wn = o; return 1;
            }
            if (o==-1 && (line_ttype-->(token_n+1) == PREPOSITION_TT))
                return GPR_FAIL;    ! don't infer if required preposition is absent
            return GPR_PREPOSITION;
        }

      PREPOSITION_TT:
        ! Is it an unnecessary alternative preposition, when a previous choice
        ! has already been matched?
        if ((token->0) & $10) return GPR_PREPOSITION;

        ! If we've run out of the player's input, but still have parameters to
        ! specify, we go into "infer" mode, remembering where we are and the
        ! preposition we are inferring...

        if (wn > num_words) {
            if (inferfrom==0 && parameters<params_wanted) {
                inferfrom = pcount; inferword = token;
                pattern-->pcount = REPARSE_CODE + VM_DictionaryAddressToNumber(given_tdata);
            }

            ! If we are not inferring, then the line is wrong...

            if (inferfrom == 0) return -1;

            ! If not, then the line is right but we mark in the preposition...

            pattern-->pcount = REPARSE_CODE + VM_DictionaryAddressToNumber(given_tdata);
            return GPR_PREPOSITION;
        }

        o = NextWord();

        pattern-->pcount = REPARSE_CODE + VM_DictionaryAddressToNumber(o);

        ! Whereas, if the player has typed something here, see if it is the
        ! required preposition... if it's wrong, the line must be wrong,
        ! but if it's right, the token is passed (jump to finish this token).

        if (o == given_tdata) return GPR_PREPOSITION;
        if (PrepositionChain(o, token_n) ~= -1) return GPR_PREPOSITION;
        return -1;

      GPR_TT:
        l = indirect(given_tdata);
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Outside parsing routine returned ", l, "]^";
        #Endif; ! DEBUG
        return l;

      SCOPE_TT:
        scope_token = given_tdata;
        scope_stage = 1;
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Scope routine called at stage 1]^";
        #Endif; ! DEBUG
        l = indirect(scope_token);
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Scope routine returned multiple-flag of ", l, "]^";
        #Endif; ! DEBUG
        if (l == 1) given_tdata = MULTI_TOKEN; else given_tdata = NOUN_TOKEN;

      ATTR_FILTER_TT:
        token_filter = 1 + given_tdata;
        given_tdata = NOUN_TOKEN;

      ROUTINE_FILTER_TT:
        token_filter = given_tdata;
        given_tdata = NOUN_TOKEN;

    } ! end of switch(given_ttype)

    token = given_tdata;

    ! There are now three possible ways we can be here:
    !     parsing an elementary token other than "special" or "number";
    !     parsing a scope token;
    !     parsing a noun-filter token (either by routine or attribute).
    !
    ! In each case, token holds the type of elementary parse to
    ! perform in matching one or more objects, and
    ! token_filter is 0 (default), an attribute + 1 for an attribute filter
    ! or a routine address for a routine filter.

    token_allows_multiple = false;
    if (token == MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)
        token_allows_multiple = true;

    many_flag = false; and_parity = true; dont_infer = false;

    ! We expect to find a list of objects next in what the player's typed.

  .ObjectList;

    #Ifdef DEBUG;
    if (parser_trace >= 3) print "  [Object list from word ", wn, "]^";
    #Endif; ! DEBUG

    ! Take an advance look at the next word: if it's "it" or "them", and these
    ! are unset, set the appropriate error number and give up on the line
    ! (if not, these are still parsed in the usual way - it is not assumed
    ! that they still refer to something in scope)

    o = NextWord(); wn--;

    pronoun_word = NULL; pronoun_obj = NULL;
    l = PronounValue(o);
    if (l ~= 0) {
        pronoun_word = o; pronoun_obj = l;
        if (l == NULL) {
            ! Don't assume this is a use of an unset pronoun until the
            ! descriptors have been checked, because it might be an
            ! article (or some such) instead

            for (l=1 : l<=LanguageDescriptors-->0 : l=l+4)
                if (o == LanguageDescriptors-->l) jump AssumeDescriptor;
            pronoun__word = pronoun_word; pronoun__obj = pronoun_obj;
            etype = VAGUE_PE;
            if (parser_trace >= 3) print "  [Stop: unset pronoun]^";
            return GPR_FAIL;
        }
    }

  .AssumeDescriptor;

    if (o == ME1__WD or ME2__WD or ME3__WD) { pronoun_word = o; pronoun_obj = player; }

    allow_plurals = true; desc_wn = wn;

  .TryAgain;

    ! First, we parse any descriptive words (like "the", "five" or "every"):
    l = Descriptors(token_allows_multiple);
    if (l ~= 0) { etype = l; return 0; }

  .TryAgain2;

    ! This is an actual specified object, and is therefore where a typing error
    ! is most likely to occur, so we set:

    oops_from = wn;

    ! So, two cases.  Case 1: token not equal to "held" (so, no implicit takes)
    ! but we may well be dealing with multiple objects

    ! In either case below we use NounDomain, giving it the token number as
    ! context, and two places to look: among the actor's possessions, and in the
    ! present location.  (Note that the order depends on which is likeliest.)

    if (token ~= HELD_TOKEN) {
        i = multiple_object-->0;
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Calling NounDomain on location and actor]^";
        #Endif; ! DEBUG
        l = NounDomain(actors_location, actor, token);
        if (l == REPARSE_CODE) return l;                  ! Reparse after Q&A
        if (indef_wanted == INDEF_ALL_WANTED && l == 0 && number_matched == 0)
            l = 1;  ! ReviseMulti if TAKE ALL FROM empty container

        if (token_allows_multiple && ~~multiflag) {
            if (best_etype==MULTI_PE) best_etype=STUCK_PE;
            multiflag = true;
        }
        if (l == 0) {
            if (indef_possambig) {
                ResetDescriptors();
                wn = desc_wn;
                jump TryAgain2;
            }
            if (etype == MULTI_PE or TOOFEW_PE && multiflag) etype = STUCK_PE;
            etype=CantSee();
            jump FailToken;
        } ! Choose best error

        #Ifdef DEBUG;
        if (parser_trace >= 3) {
            if (l > 1) print "  [ND returned ", (the) l, "]^";
            else {
                print "  [ND appended to the multiple object list:^";
                k = multiple_object-->0;
                for (j=i+1 : j<=k : j++)
                    print "  Entry ", j, ": ", (The) multiple_object-->j,
                          " (", multiple_object-->j, ")^";
                print "  List now has size ", k, "]^";
            }
        }
        #Endif; ! DEBUG

        if (l == 1) {
            if (~~many_flag) many_flag = true;
            else {                                ! Merge with earlier ones
                k = multiple_object-->0;            ! (with either parity)
                multiple_object-->0 = i;
                for (j=i+1 : j<=k : j++) {
                    if (and_parity) MultiAdd(multiple_object-->j);
                    else            MultiSub(multiple_object-->j);
                }
                #Ifdef DEBUG;
                if (parser_trace >= 3)
                	print "  [Merging ", k-i, " new objects to the ", i, " old ones]^";
                #Endif; ! DEBUG
            }
        }
        else {
            ! A single object was indeed found

            if (match_length == 0 && indef_possambig) {
                ! So the answer had to be inferred from no textual data,
                ! and we know that there was an ambiguity in the descriptor
                ! stage (such as a word which could be a pronoun being
                ! parsed as an article or possessive).  It's worth having
                ! another go.

                ResetDescriptors();
                wn = desc_wn;
                jump TryAgain2;
            }

            if ((token == CREATURE_TOKEN) && (CreatureTest(l) == 0)) {
                etype = ANIMA_PE;
                jump FailToken;
            } !  Animation is required

            if (~~many_flag) single_object = l;
            else {
                if (and_parity) MultiAdd(l); else MultiSub(l);
                #Ifdef DEBUG;
                if (parser_trace >= 3) print "  [Combining ", (the) l, " with list]^";
                #Endif; ! DEBUG
            }
        }
    }

    else {

    ! Case 2: token is "held" (which fortunately can't take multiple objects)
    ! and may generate an implicit take

        l = NounDomain(actor,actors_location,token);       ! Same as above...
        if (l == REPARSE_CODE) return l;
        if (l == 0) {
            if (indef_possambig) {
                ResetDescriptors();
                wn = desc_wn;
                jump TryAgain2;
            }
            etype = CantSee(); jump FailToken;            ! Choose best error
        }

        ! ...until it produces something not held by the actor.  Then an implicit
        ! take must be tried.  If this is already happening anyway, things are too
        ! confused and we have to give up (but saving the oops marker so as to get
        ! it on the right word afterwards).
        ! The point of this last rule is that a sequence like
        !
        !     > read newspaper
        !     (taking the newspaper first)
        !     The dwarf unexpectedly prevents you from taking the newspaper!
        !
        ! should not be allowed to go into an infinite repeat - read becomes
        ! take then read, but take has no effect, so read becomes take then read...
        ! Anyway for now all we do is record the number of the object to take.

        o = parent(l);
        if (o ~= actor) {
            #Ifdef DEBUG;
            if (parser_trace >= 3) print "  [Allowing object ", (the) l, " for now]^";
            #Endif; ! DEBUG
        }
        single_object = l;
    } ! end of if (token ~= HELD_TOKEN) else

    ! The following moves the word marker to just past the named object...

    wn = oops_from + match_length;

    ! Object(s) specified now: is that the end of the list, or have we reached
    ! "and", "but" and so on?  If so, create a multiple-object list if we
    ! haven't already (and are allowed to).

  .NextInList;

    o = NextWord();

    if (o == AND1__WD or AND2__WD or AND3__WD or BUT1__WD or BUT2__WD or BUT3__WD or comma_word) {

        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Read connective '", (address) o, "']^";
        #Endif; ! DEBUG

        if (~~token_allows_multiple) {
            if (multiflag) jump PassToken; ! give UPTO_PE error
            etype=MULTI_PE;
            jump FailToken;
        }

        if (o == BUT1__WD or BUT2__WD or BUT3__WD) and_parity = 1-and_parity;

        if (~~many_flag) {
            multiple_object-->0 = 1;
            multiple_object-->1 = single_object;
            many_flag = true;
            #Ifdef DEBUG;
            if (parser_trace >= 3) print "  [Making new list from ", (the) single_object, "]^";
            #Endif; ! DEBUG
        }
        dont_infer = true; inferfrom=0;           ! Don't print (inferences)
        jump ObjectList;                          ! And back around
    }

    wn--;   ! Word marker back to first not-understood word

    ! Happy or unhappy endings:

  .PassToken;

    if (many_flag) {
        single_object = GPR_MULTIPLE;
        multi_context = token;
    }
    else {
        if (indef_mode == 1 && indef_type & PLURAL_BIT ~= 0) {
            if (indef_wanted < INDEF_ALL_WANTED && indef_wanted > 1) {
                multi_had = 1; multi_wanted = indef_wanted;
                etype = TOOFEW_PE;
                jump FailToken;
            }
        }
    }
    return single_object;

  .FailToken;

    ! If we were only guessing about it being a plural, try again but only
    ! allowing singulars (so that words like "six" are not swallowed up as
    ! Descriptors)

    if (allow_plurals && indef_guess_p == 1) {
        #Ifdef DEBUG;
        if (parser_trace >= 4) print "   [Retrying singulars after failure ", etype, "]^";
        #Endif;
        prev_indef_wanted = indef_wanted;
        allow_plurals = false;
        wn = desc_wn;
        jump TryAgain;
    }

    if ((indef_wanted > 0 || prev_indef_wanted > 0) && (~~multiflag)) etype = MULTI_PE;

    return GPR_FAIL;

]; ! end of ParseToken__

Constant OTHER_BIT  =   1;     !  These will be used in Adjudicate()
Constant MY_BIT     =   2;     !  to disambiguate choices
Constant THAT_BIT   =   4;
Constant PLURAL_BIT =   8;
Constant LIT_BIT    =  16;
Constant UNLIT_BIT  =  32;

[ ResetDescriptors;
    indef_mode = 0; indef_type = 0; indef_wanted = 0; indef_guess_p = 0;
    indef_possambig = false;
    indef_owner = nothing;
    indef_cases = $$111111111111;
    indef_nspec_at = 0;
];

[ ArticleDescriptors  o x flag cto type n;
    if (wn > num_words) return 0;

    for (flag=true : flag :) {
        o = NextWordStopped(); flag = false;

       for (x=1 : x<=LanguageDescriptors-->0 : x=x+4)
            if (o == LanguageDescriptors-->x) {
                type = LanguageDescriptors-->(x+2);
                if (type == DEFART_PK or INDEFART_PK) flag = true;
            }
    }
    wn--;
    return 0;
];

[ Descriptors  o x flag cto type n;
    ResetDescriptors();
    if (wn > num_words) return 0;

    for (flag=true : flag :) {
        o = NextWordStopped(); flag = false;

       for (x=1 : x<=LanguageDescriptors-->0 : x=x+4)
            if (o == LanguageDescriptors-->x) {
                flag = true;
                type = LanguageDescriptors-->(x+2);
                if (type ~= DEFART_PK) indef_mode = true;
                indef_possambig = true;
                indef_cases = indef_cases & (LanguageDescriptors-->(x+1));

                if (type == POSSESS_PK) {
                    cto = LanguageDescriptors-->(x+3);
                    switch (cto) {
                      0: indef_type = indef_type | MY_BIT;
                      1: indef_type = indef_type | THAT_BIT;
                      default:
                        indef_owner = PronounValue(cto);
                        if (indef_owner == NULL) indef_owner = InformParser;
                    }
                }

                if (type == light)  indef_type = indef_type | LIT_BIT;
                if (type == -light) indef_type = indef_type | UNLIT_BIT;
            }

        if (o == OTHER1__WD or OTHER2__WD or OTHER3__WD) {
            indef_mode = 1; flag = 1;
            indef_type = indef_type | OTHER_BIT;
        }
        if (o == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD) {
            indef_mode = 1; flag = 1; indef_wanted = INDEF_ALL_WANTED;
            if (take_all_rule == 1) take_all_rule = 2;
            indef_type = indef_type | PLURAL_BIT;
        }
        if (allow_plurals) {
        	if (NextWordStopped() ~= -1) { wn--; n = TryNumber(wn-1); } else { n=0; wn--; }
            if (n == 1) { indef_mode = 1; flag = 1; }
            if (n > 1) {
                indef_guess_p = 1;
                indef_mode = 1; flag = 1; indef_wanted = n;
                indef_nspec_at = wn-1;
                indef_type = indef_type | PLURAL_BIT;
            }
        }
        if (flag == 1 && NextWordStopped() ~= OF1__WD or OF2__WD or OF3__WD or OF4__WD)
            wn--;  ! Skip 'of' after these
    }
    wn--;
    return 0;
];

[ SafeSkipDescriptors;
	@push indef_mode; @push indef_type; @push indef_wanted;
	@push indef_guess_p; @push indef_possambig; @push indef_owner;
	@push indef_cases; @push indef_nspec_at;
	
	Descriptors();
	
	@pull indef_nspec_at; @pull indef_cases;
	@pull indef_owner; @pull indef_possambig; @pull indef_guess_p;
	@pull indef_wanted; @pull indef_type; @pull indef_mode;
];

[ PrepositionChain wd index;
    if (line_tdata-->index == wd) return wd;
    if ((line_token-->index)->0 & $20 == 0) return -1;
    do {
        if (line_tdata-->index == wd) return wd;
        index++;
    } until ((line_token-->index == ENDIT_TOKEN) || (((line_token-->index)->0 & $10) == 0));
    return -1;
];

[ CreatureTest obj;
    if (obj has animate) rtrue;
    if (obj hasnt talkable) rfalse;
    if (action_to_be == ##Ask or ##Answer or ##Tell or ##AskFor) rtrue;
    rfalse;
];

[ NounDomain domain1 domain2 context
	first_word i j k l answer_words marker;
    #Ifdef DEBUG;
    if (parser_trace >= 4) {
        print "   [NounDomain called at word ", wn, "^";
        print "   ";
        if (indef_mode) {
            print "seeking indefinite object: ";
            if (indef_type & OTHER_BIT)  print "other ";
            if (indef_type & MY_BIT)     print "my ";
            if (indef_type & THAT_BIT)   print "that ";
            if (indef_type & PLURAL_BIT) print "plural ";
            if (indef_type & LIT_BIT)    print "lit ";
            if (indef_type & UNLIT_BIT)  print "unlit ";
            if (indef_owner ~= 0) print "owner:", (name) indef_owner;
            new_line;
            print "   number wanted: ";
            if (indef_wanted == INDEF_ALL_WANTED) print "all"; else print indef_wanted;
            new_line;
            print "   most likely GNAs of names: ", indef_cases, "^";
        }
        else print "seeking definite object^";
    }
    #Endif; ! DEBUG

    match_length = 0; number_matched = 0; match_from = wn;

    SearchScope(domain1, domain2, context);

    #Ifdef DEBUG;
    if (parser_trace >= 4) print "   [ND made ", number_matched, " matches]^";
    #Endif; ! DEBUG

    wn = match_from+match_length;

    ! If nothing worked at all, leave with the word marker skipped past the
    ! first unmatched word...

    if (number_matched == 0) { wn++; rfalse; }

    ! Suppose that there really were some words being parsed (i.e., we did
    ! not just infer).  If so, and if there was only one match, it must be
    ! right and we return it...

    if (match_from <= num_words) {
        if (number_matched == 1) {
            i=match_list-->0;
            return i;
        }

        ! ...now suppose that there was more typing to come, i.e. suppose that
        ! the user entered something beyond this noun.  If nothing ought to follow,
        ! then there must be a mistake, (unless what does follow is just a full
        ! stop, and or comma)

        if (wn <= num_words) {
            i = NextWord(); wn--;
            if (i ~=  AND1__WD or AND2__WD or AND3__WD or comma_word
                   or THEN1__WD or THEN2__WD or THEN3__WD
                   or BUT1__WD or BUT2__WD or BUT3__WD) {
                if (lookahead == ENDIT_TOKEN) rfalse;
            }
        }
    }

    ! Now look for a good choice, if there's more than one choice...

    number_of_classes = 0;

    if (number_matched == 1) i = match_list-->0;
    if (number_matched > 1) {
		i = true;
	    if (number_matched > 1)
	    	for (j=0 : j<number_matched-1 : j++)
				if (Identical(match_list-->j, match_list-->(j+1)) == false)
					i = false;
		if (i) dont_infer = true;
        i = Adjudicate(context);
        if (i == -1) rfalse;
        if (i == 1) rtrue;       !  Adjudicate has made a multiple
                             !  object, and we pass it on
    }

    ! If i is non-zero here, one of two things is happening: either
    ! (a) an inference has been successfully made that object i is
    !     the intended one from the user's specification, or
    ! (b) the user finished typing some time ago, but we've decided
    !     on i because it's the only possible choice.
    ! In either case we have to keep the pattern up to date,
    ! note that an inference has been made and return.
    ! (Except, we don't note which of a pile of identical objects.)

    if (i ~= 0) {
    	if (dont_infer) return i;
        if (inferfrom == 0) inferfrom=pcount;
        pattern-->pcount = i;
        return i;
    }

    ! If we get here, there was no obvious choice of object to make.  If in
    ! fact we've already gone past the end of the player's typing (which
    ! means the match list must contain every object in scope, regardless
    ! of its name), then it's foolish to give an enormous list to choose
    ! from - instead we go and ask a more suitable question...

    if (match_from > num_words) jump Incomplete;

    ! Now we print up the question, using the equivalence classes as worked
    ! out by Adjudicate() so as not to repeat ourselves on plural objects...

	BeginActivity(ASKING_WHICH_DO_YOU_MEAN_ACT);
	if (ForActivity(ASKING_WHICH_DO_YOU_MEAN_ACT)) jump SkipWhichQuestion;
	j = 1; marker = 0;
	for (i=1 : i<=number_of_classes : i++) {
		while (((match_classes-->marker) ~= i) && ((match_classes-->marker) ~= -i))
			marker++;
		if (match_list-->marker hasnt animate) j = 0;
	}
	if (j) L__M(##Miscellany, 45); else L__M(##Miscellany, 46);

    j = number_of_classes; marker = 0;
    for (i=1 : i<=number_of_classes : i++) {
        while (((match_classes-->marker) ~= i) && ((match_classes-->marker) ~= -i)) marker++;
        k = match_list-->marker;

        if (match_classes-->marker > 0) print (the) k; else print (a) k;

        if (i < j-1)  print (string) COMMA__TX;
        if (i == j-1) {
			#Ifdef SERIAL_COMMA;
			if (j ~= 2) print ",";
        	#Endif; ! SERIAL_COMMA
        	print (string) OR__TX;
        }
    }
    L__M(##Miscellany, 57);

	.SkipWhichQuestion; EndActivity(ASKING_WHICH_DO_YOU_MEAN_ACT);

    ! ...and get an answer:

  .WhichOne;
    #Ifdef TARGET_ZCODE;
    for (i=2 : i<INPUT_BUFFER_LEN : i++) buffer2->i = ' ';
    #Endif; ! TARGET_ZCODE
    answer_words=Keyboard(buffer2, parse2);

    ! Conveniently, parse2-->1 is the first word in both ZCODE and GLULX.
    first_word = (parse2-->1);

    ! Take care of "all", because that does something too clever here to do
    ! later on:

    if (first_word == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD) {
        if (context == MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN) {
            l = multiple_object-->0;
            for (i=0 : i<number_matched && l+i<MATCH_LIST_WORDS : i++) {
                k = match_list-->i;
                multiple_object-->(i+1+l) = k;
            }
            multiple_object-->0 = i+l;
            rtrue;
        }
        L__M(##Miscellany, 47);
        jump WhichOne;
    }

	! Look for a comma, and interpret this as a fresh conversation command
	! if so:

	for (i=1 : i<=answer_words : i++)
		if (WordFrom(i, parse2) == comma_word) {
            VM_CopyBuffer(buffer, buffer2);
            jump RECONSTRUCT_INPUT;		
		}

    ! If the first word of the reply can be interpreted as a verb, then
    ! assume that the player has ignored the question and given a new
    ! command altogether.
    ! (This is one time when it's convenient that the directions are
    ! not themselves verbs - thus, "north" as a reply to "Which, the north
    ! or south door" is not treated as a fresh command but as an answer.)

    #Ifdef LanguageIsVerb;
    if (first_word == 0) {
        j = wn; first_word = LanguageIsVerb(buffer2, parse2, 1); wn = j;
    }
    #Endif; ! LanguageIsVerb
    if (first_word ~= 0) {
        j = first_word->#dict_par1;
        if ((0 ~= j&1) && ~~LanguageVerbMayBeName(first_word)) {
            VM_CopyBuffer(buffer, buffer2);
            jump RECONSTRUCT_INPUT;
        }
    }

    ! Now we insert the answer into the original typed command, as
    ! words additionally describing the same object
    ! (eg, > take red button
    !      Which one, ...
    !      > music
    ! becomes "take music red button".  The parser will thus have three
    ! words to work from next time, not two.)

    #Ifdef TARGET_ZCODE;
    k = WordAddress(match_from) - buffer; l=buffer2->1+1;
    for (j=buffer + buffer->0 - 1 : j>=buffer+k+l : j--) j->0 = 0->(j-l);
    for (i=0 : i<l : i++) buffer->(k+i) = buffer2->(2+i);
    buffer->(k+l-1) = ' ';
    buffer->1 = buffer->1 + l;
    if (buffer->1 >= (buffer->0 - 1)) buffer->1 = buffer->0;
    #Ifnot; ! TARGET_GLULX
    k = WordAddress(match_from) - buffer;
    l = (buffer2-->0) + 1;
    for (j=buffer+INPUT_BUFFER_LEN-1 : j>=buffer+k+l : j--) j->0 = j->(-l);
    for (i=0 : i<l : i++) buffer->(k+i) = buffer2->(WORDSIZE+i);
    buffer->(k+l-1) = ' ';
    buffer-->0 = buffer-->0 + l;
    if (buffer-->0 > (INPUT_BUFFER_LEN-WORDSIZE)) buffer-->0 = (INPUT_BUFFER_LEN-WORDSIZE);
    #Endif; ! TARGET_

    ! Having reconstructed the input, we warn the parser accordingly
    ! and get out.

	.RECONSTRUCT_INPUT;

	num_words = WordCount();
    wn = 1;
    #Ifdef LanguageToInformese;
    LanguageToInformese();
    ! Re-tokenise:
    VM_Tokenise(buffer,parse);
    #Endif; ! LanguageToInformese
	num_words = WordCount();
    players_command = 100 + WordCount();
    actors_location = ScopeCeiling(player);
	FollowRulebook(Activity_after_rulebooks-->READING_A_COMMAND_ACT, true);

    return REPARSE_CODE;

    ! Now we come to the question asked when the input has run out
    ! and can't easily be guessed (eg, the player typed "take" and there
    ! were plenty of things which might have been meant).

  .Incomplete;

    if (context == CREATURE_TOKEN) L__M(##Miscellany, 48);
    else                           L__M(##Miscellany, 49);

    #Ifdef TARGET_ZCODE;
    for (i=2 : i<INPUT_BUFFER_LEN : i++) buffer2->i=' ';
    #Endif; ! TARGET_ZCODE
    answer_words = Keyboard(buffer2, parse2);

    first_word=(parse2-->1);
    #Ifdef LanguageIsVerb;
    if (first_word==0) {
        j = wn; first_word=LanguageIsVerb(buffer2, parse2, 1); wn = j;
    }
    #Endif; ! LanguageIsVerb

    ! Once again, if the reply looks like a command, give it to the
    ! parser to get on with and forget about the question...

    if (first_word ~= 0) {
        j = first_word->#dict_par1;
        if (0 ~= j&1) {
            VM_CopyBuffer(buffer, buffer2);
            return REPARSE_CODE;
        }
    }

    ! ...but if we have a genuine answer, then:
    !
    ! (1) we must glue in text suitable for anything that's been inferred.

    if (inferfrom ~= 0) {
        for (j=inferfrom : j<pcount : j++) {
            if (pattern-->j == PATTERN_NULL) continue;
            #Ifdef TARGET_ZCODE;
            i = 2+buffer->1; (buffer->1)++; buffer->(i++) = ' ';
            #Ifnot; ! TARGET_GLULX
            i = WORDSIZE + buffer-->0;
            (buffer-->0)++; buffer->(i++) = ' ';
            #Endif; ! TARGET_

            #Ifdef DEBUG;
            if (parser_trace >= 5)
            	print "[Gluing in inference with pattern code ", pattern-->j, "]^";
            #Endif; ! DEBUG

            ! Conveniently, parse2-->1 is the first word in both ZCODE and GLULX.

            parse2-->1 = 0;

            ! An inferred object.  Best we can do is glue in a pronoun.
            ! (This is imperfect, but it's very seldom needed anyway.)

            if (pattern-->j >= 2 && pattern-->j < REPARSE_CODE) {
                PronounNotice(pattern-->j);
                for (k=1 : k<=LanguagePronouns-->0 : k=k+3)
                    if (pattern-->j == LanguagePronouns-->(k+2)) {
                        parse2-->1 = LanguagePronouns-->k;
                        #Ifdef DEBUG;
                        if (parser_trace >= 5)
                        	print "[Using pronoun '", (address) parse2-->1, "']^";
                        #Endif; ! DEBUG
                        break;
                    }
            }
            else {
                ! An inferred preposition.
                parse2-->1 = VM_NumberToDictionaryAddress(pattern-->j - REPARSE_CODE);
                #Ifdef DEBUG;
                if (parser_trace >= 5)
                	print "[Using preposition '", (address) parse2-->1, "']^";
                #Endif; ! DEBUG
            }

            ! parse2-->1 now holds the dictionary address of the word to glue in.

            if (parse2-->1 ~= 0) {
                k = buffer + i;
                #Ifdef TARGET_ZCODE;
                @output_stream 3 k;
                 print (address) parse2-->1;
                @output_stream -3;
                k = k-->0;
                for (l=i : l<i+k : l++) buffer->l = buffer->(l+2);
                i = i + k; buffer->1 = i-2;
                #Ifnot; ! TARGET_GLULX
                k = Glulx_PrintAnyToArray(buffer+i, INPUT_BUFFER_LEN-i, parse2-->1);
                i = i + k; buffer-->0 = i - WORDSIZE;
                #Endif; ! TARGET_
            }
        }
    }

    ! (2) we must glue the newly-typed text onto the end.

    #Ifdef TARGET_ZCODE;
    i = 2+buffer->1; (buffer->1)++; buffer->(i++) = ' ';
    for (j=0 : j<buffer2->1 : i++,j++) {
        buffer->i = buffer2->(j+2);
        (buffer->1)++;
        if (buffer->1 == INPUT_BUFFER_LEN) break;
    }
    #Ifnot; ! TARGET_GLULX
    i = WORDSIZE + buffer-->0;
    (buffer-->0)++; buffer->(i++) = ' ';
    for (j=0 : j<buffer2-->0 : i++,j++) {
        buffer->i = buffer2->(j+WORDSIZE);
        (buffer-->0)++;
        if (buffer-->0 == INPUT_BUFFER_LEN) break;
    }
    #Endif; ! TARGET_

    ! (3) we fill up the buffer with spaces, which is unnecessary, but may
    !     help incorrectly-written interpreters to cope.

    #Ifdef TARGET_ZCODE;
    for (: i<INPUT_BUFFER_LEN : i++) buffer->i = ' ';
    #Endif; ! TARGET_ZCODE

    return REPARSE_CODE;

]; ! end of NounDomain

[ Adjudicate context i j k good_ones last n ultimate flag offset;
    #Ifdef DEBUG;
    if (parser_trace >= 4) {
        print "   [Adjudicating match list of size ", number_matched,
        	" in context ", context, "^";
        print "   ";
        if (indef_mode) {
            print "indefinite type: ";
            if (indef_type & OTHER_BIT)  print "other ";
            if (indef_type & MY_BIT)     print "my ";
            if (indef_type & THAT_BIT)   print "that ";
            if (indef_type & PLURAL_BIT) print "plural ";
            if (indef_type & LIT_BIT)    print "lit ";
            if (indef_type & UNLIT_BIT)  print "unlit ";
            if (indef_owner ~= 0) print "owner:", (name) indef_owner;
            new_line;
            print "   number wanted: ";
            if (indef_wanted == INDEF_ALL_WANTED) print "all"; else print indef_wanted;
            new_line;
            print "   most likely GNAs of names: ", indef_cases, "^";
        }
        else print "definite object^";
    }
    #Endif; ! DEBUG

    j = number_matched-1; good_ones = 0; last = match_list-->0;
    for (i=0 : i<=j : i++) {
        n = match_list-->i;
        match_scores-->i = good_ones;
        ultimate = ScopeCeiling(n);

        if (context==HELD_TOKEN && parent(n)==actor)
        {   good_ones++; last=n; }
        if (context==MULTI_TOKEN && ultimate==ScopeCeiling(actor)
            && n~=actor && n hasnt concealed && n hasnt scenery) 
        {   good_ones++; last=n; }
        if (context==MULTIHELD_TOKEN && parent(n)==actor)
        {   good_ones++; last=n; }

        if (context==MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)
        {   if (advance_warning==-1)
            {   if (context==MULTIEXCEPT_TOKEN)
                {   good_ones++; last=n;
                 }
                if (context==MULTIINSIDE_TOKEN)
                {   if (parent(n)~=actor) { good_ones++; last=n; }
                 }
            }
            else
            {   if (context==MULTIEXCEPT_TOKEN && n~=advance_warning)
                {   good_ones++; last=n; }
                if (context==MULTIINSIDE_TOKEN && n in advance_warning)
                {   good_ones++; last=n; }
            }
         }
        if (context==CREATURE_TOKEN && CreatureTest(n)==1)
        {   good_ones++; last=n; }
        
        match_scores-->i = 1000*(good_ones - match_scores-->i);
    }
    if (good_ones == 1) return last;

    ! If there is ambiguity about what was typed, but it definitely wasn't
    ! animate as required, then return anything; higher up in the parser
    ! a suitable error will be given.  (This prevents a question being asked.)

    if (context == CREATURE_TOKEN && good_ones == 0) return match_list-->0;

    if (indef_mode == 0) indef_type=0;

    ScoreMatchL(context);
    if (number_matched == 0) return -1;

    if (indef_mode == 0) {
        !  Is there now a single highest-scoring object?
        i = SingleBestGuess();
        if (i >= 0) {

            #Ifdef DEBUG;
            if (parser_trace >= 4) print "   Single best-scoring object returned.]^";
            #Endif; ! DEBUG
            return i;
        }
    }

    if (indef_mode == 1 && indef_type & PLURAL_BIT ~= 0) {
        if (context ~= MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN
                     or MULTIINSIDE_TOKEN) {
            etype = MULTI_PE;
            return -1;
        }
        i = 0; offset = multiple_object-->0;
        for (j=BestGuess(): j~=-1 && i<indef_wanted && i+offset<MATCH_LIST_WORDS-1:
        	j=BestGuess()) {
            flag = 0;
            BeginActivity(DECIDING_WHETHER_ALL_INC_ACT, j);
            if ((ForActivity(DECIDING_WHETHER_ALL_INC_ACT, j)) == 0) {

                if (j hasnt concealed && j hasnt worn) flag = 1;
            
                if (context == MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN && parent(j) ~= actor)
                    flag = 0;

                if (action_to_be == ##Take or ##Remove && parent(j) == actor)
                    flag = 0;

                k = ChooseObjects(j, flag);

                if (k == 1)
                    flag = 1;
                else {
                    if (k == 2) flag = 0;
                }
            } else {
                flag = 0; if (RulebookSucceeded()) flag = 1;
            }
            EndActivity(DECIDING_WHETHER_ALL_INC_ACT, j);
            if (flag == 1) {
                i++; multiple_object-->(i+offset) = j;
                #Ifdef DEBUG;
                if (parser_trace >= 4) print "   Accepting it^";
                #Endif; ! DEBUG
            }
            else {
                i = i;
                #Ifdef DEBUG;
                if (parser_trace >= 4) print "   Rejecting it^";
                #Endif; ! DEBUG
            }
        }
        if (i < indef_wanted && indef_wanted < INDEF_ALL_WANTED) {
            etype = TOOFEW_PE; multi_wanted = indef_wanted;
            multi_had=i;
            return -1;
        }
        multiple_object-->0 = i+offset;
        multi_context = context;
        #Ifdef DEBUG;
        if (parser_trace >= 4)
            print "   Made multiple object of size ", i, "]^";
        #Endif; ! DEBUG
        return 1;
    }

    for (i=0 : i<number_matched : i++) match_classes-->i = 0;

    n = 1;
    for (i=0 : i<number_matched : i++)
        if (match_classes-->i == 0) {
            match_classes-->i = n++; flag = 0;
            for (j=i+1 : j<number_matched : j++)
                if (match_classes-->j == 0 && Identical(match_list-->i, match_list-->j) == 1) {
                    flag=1;
                    match_classes-->j = match_classes-->i;
                }
            if (flag == 1) match_classes-->i = 1-n;
        }
     n--; number_of_classes = n;

    #Ifdef DEBUG;
    if (parser_trace >= 4) {
        print "   Grouped into ", n, " possibilities by name:^";
        for (i=0 : i<number_matched : i++)
            if (match_classes-->i > 0)
                print "   ", (The) match_list-->i, " (", match_list-->i, ")  ---  group ",
                  match_classes-->i, "^";
    }
    #Endif; ! DEBUG

    if (indef_mode == 0) {
        if (n > 1) {
            k = -1;
            for (i=0 : i<number_matched : i++) {
                if (match_scores-->i > k) {
                    k = match_scores-->i;
                    j = match_classes-->i; j = j*j;
                    flag = 0;
                }
                else
                    if (match_scores-->i == k) {
                        if ((match_classes-->i) * (match_classes-->i) ~= j)
                            flag = 1;
                    }
            }

        if (flag) {
            #Ifdef DEBUG;
            if (parser_trace >= 4) print "   Unable to choose best group, so ask player.]^";
            #Endif; ! DEBUG
            return 0;
        }
        #Ifdef DEBUG;
        if (parser_trace >= 4) print "   Best choices are all from the same group.^";
        #Endif; ! DEBUG
        }
    }

    !  When the player is really vague, or there's a single collection of
    !  indistinguishable objects to choose from, choose the one the player
    !  most recently acquired, or if the player has none of them, then
    !  the one most recently put where it is.

    if (n == 1) dont_infer = true;
    return BestGuess();

]; ! Adjudicate

[ ReviseMulti second_p  i low;
    #Ifdef DEBUG;
    if (parser_trace >= 4)
    	print "   Revising multiple object list of size ", multiple_object-->0,
     	" with 2nd ", (name) second_p, "^";
    #Endif; ! DEBUG

    if (multi_context == MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN) {
        for (i=1,low=0 : i<=multiple_object-->0 : i++) {
            if ( (multi_context==MULTIEXCEPT_TOKEN && multiple_object-->i ~= second_p) ||
                 (multi_context==MULTIINSIDE_TOKEN && multiple_object-->i in second_p)) {
                low++;
                multiple_object-->low = multiple_object-->i;
            }
        }
        multiple_object-->0 = low;
    }

    if (multi_context == MULTI_TOKEN && action_to_be == ##Take) {
        #Ifdef DEBUG;
        if (parser_trace >= 4) print "   Token 2 plural case: number with actor ", low, "^";
        #Endif; ! DEBUG
        if (take_all_rule == 2) {
            for (i=1,low=0 : i<=multiple_object-->0 : i++) {
                if (ScopeCeiling(multiple_object-->i) == ScopeCeiling(actor)) {
                    low++;
                    multiple_object-->low = multiple_object-->i;
                }
            }
            multiple_object-->0 = low;
        }
    }

    i = multiple_object-->0;
    #Ifdef DEBUG;
    if (parser_trace >= 4) print "   Done: new size ", i, "^";
    #Endif; ! DEBUG
    if (i == 0) return NOTHING_PE;
    return 0;
];

[ MakeMatch obj quality i;
    #Ifdef DEBUG;
    if (parser_trace >= 6) print "    Match with quality ",quality,"^";
    #Endif; ! DEBUG
    if (token_filter ~= 0 && ConsultNounFilterToken(obj) == 0) {
        #Ifdef DEBUG;
        if (parser_trace >= 6) print "    Match filtered out: token filter ", token_filter, "^";
        #Endif; ! DEBUG
        rtrue;
    }
    if (quality < match_length) rtrue;
    if (quality > match_length) { match_length = quality; number_matched = 0; }
    else {
        if (number_matched >= MATCH_LIST_WORDS) rtrue;
        for (i=0 : i<number_matched : i++)
            if (match_list-->i == obj) rtrue;
    }
    match_list-->number_matched++ = obj;
    #Ifdef DEBUG;
    if (parser_trace >= 6) print "    Match added to list^";
    #Endif; ! DEBUG
];

[ ConsultNounFilterToken obj;
    if (token_filter ofclass Routine) {
	    noun = obj;
    	return indirect(token_filter);
    }
    if (obj has (token_filter-1)) rtrue;
    rfalse;
];

Constant SCORE__CHOOSEOBJ = 1000;
Constant SCORE__IFGOOD = 500;
Constant SCORE__UNCONCEALED = 100;
Constant SCORE__BESTLOC = 60;
Constant SCORE__NEXTBESTLOC = 40;
Constant SCORE__NOTCOMPASS = 20;
Constant SCORE__NOTSCENERY = 10;
Constant SCORE__NOTACTOR = 5;
Constant SCORE__GNA = 1;
Constant SCORE__DIVISOR = 20;

Constant PREFER_HELD;
[ ScoreMatchL context its_owner its_score obj i j threshold met a_s l_s;
!   if (indef_type & OTHER_BIT ~= 0) threshold++;
    if (indef_type & MY_BIT ~= 0)    threshold++;
    if (indef_type & THAT_BIT ~= 0)  threshold++;
    if (indef_type & LIT_BIT ~= 0)   threshold++;
    if (indef_type & UNLIT_BIT ~= 0) threshold++;
    if (indef_owner ~= nothing)      threshold++;

    #Ifdef DEBUG;
    if (parser_trace >= 4) print "   Scoring match list: indef mode ", indef_mode, " type ",
      indef_type, ", satisfying ", threshold, " requirements:^";
    #Endif; ! DEBUG

    #ifdef PREFER_HELD;
    a_s = SCORE__BESTLOC; l_s = SCORE__NEXTBESTLOC;
    if (action_to_be == ##Take or ##Remove) {
        a_s = SCORE__NEXTBESTLOC; l_s = SCORE__BESTLOC;
    }
    context = context;  ! silence warning
    #ifnot;
    a_s = SCORE__NEXTBESTLOC; l_s = SCORE__BESTLOC;
    if (context == HELD_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN) {
        a_s = SCORE__BESTLOC; l_s = SCORE__NEXTBESTLOC;
    }
    #endif; ! PREFER_HELD

    for (i=0 : i<number_matched : i++) {
        obj = match_list-->i; its_owner = parent(obj); its_score=0; met=0;

        !      if (indef_type & OTHER_BIT ~= 0
        !          &&  obj ~= itobj or himobj or herobj) met++;
        if (indef_type & MY_BIT ~= 0 && its_owner == actor) met++;
        if (indef_type & THAT_BIT ~= 0 && its_owner == actors_location) met++;
        if (indef_type & LIT_BIT ~= 0 && obj has light) met++;
        if (indef_type & UNLIT_BIT ~= 0 && obj hasnt light) met++;
        if (indef_owner ~= 0 && its_owner == indef_owner) met++;

        if (met < threshold) {
            #Ifdef DEBUG;
            if (parser_trace >= 4)
            	print "   ", (The) match_list-->i, " (", match_list-->i, ") in ",
            	    (the) its_owner, " is rejected (doesn't match descriptors)^";
            #Endif; ! DEBUG
            match_list-->i = -1;
        }
        else {
            its_score = 0;
            if (obj hasnt concealed) its_score = SCORE__UNCONCEALED;

            if (its_owner == actor) its_score = its_score + a_s;
            else
                if (its_owner == actors_location) its_score = its_score + l_s;
                else
                    if (its_owner ~= compass) its_score = its_score + SCORE__NOTCOMPASS;

            its_score = its_score + SCORE__CHOOSEOBJ * ChooseObjects(obj, 2);

            if (obj hasnt scenery) its_score = its_score + SCORE__NOTSCENERY;
            if (obj ~= actor) its_score = its_score + SCORE__NOTACTOR;

            !   A small bonus for having the correct GNA,
            !   for sorting out ambiguous articles and the like.

            if (indef_cases & (PowersOfTwo_TB-->(GetGNAOfObject(obj))))
                its_score = its_score + SCORE__GNA;

            match_scores-->i = match_scores-->i + its_score;
            #Ifdef DEBUG;
            if (parser_trace >= 4) print "     ", (The) match_list-->i, " (", match_list-->i,
              ") in ", (the) its_owner, " : ", match_scores-->i, " points^";
            #Endif; ! DEBUG
        }
     }

    for (i=0 : i<number_matched : i++) {
        while (match_list-->i == -1) {
            if (i == number_matched-1) { number_matched--; break; }
            for (j=i : j<number_matched-1 : j++) {
                match_list-->j = match_list-->(j+1);
                match_scores-->j = match_scores-->(j+1);
            }
            number_matched--;
        }
    }
];

[ BestGuess  earliest its_score best i;
    earliest = 0; best = -1;
    for (i=0 : i<number_matched : i++) {
        if (match_list-->i >= 0) {
            its_score = match_scores-->i;
            if (its_score > best) { best = its_score; earliest = i; }
        }
    }
    #Ifdef DEBUG;
    if (parser_trace >= 4)
      if (best < 0) print "   Best guess ran out of choices^";
      else print "   Best guess ", (the) match_list-->earliest,
      	" (", match_list-->earliest, ")^";
    #Endif; ! DEBUG
    if (best < 0) return -1;
    i = match_list-->earliest;
    match_list-->earliest = -1;
    return i;
];

[ SingleBestGuess  earliest its_score best i;
    earliest = -1; best = -1000;
    for (i=0 : i<number_matched : i++) {
        its_score = match_scores-->i;
        if (its_score == best) earliest = -1;
        if (its_score > best) { best = its_score; earliest = match_list-->i; }
    }
    return earliest;
];

[ Identical o1 o2 p1 p2 n1 n2 i j flag;
    if (o1 == o2) rtrue;  ! This should never happen, but to be on the safe side
    if (o1 == 0 || o2 == 0) rfalse;  ! Similarly
    if (o1 ofclass K3_direction || o2 ofclass K3_direction) rfalse; ! Saves time

    !  What complicates things is that o1 or o2 might have a parsing routine,
    !  so the parser can't know from here whether they are or aren't the same.
    !  If they have different parsing routines, we simply assume they're
    !  different.  If they have the same routine (which they probably got from
    !  a class definition) then the decision process is as follows:
    !
    !     the routine is called (with self being o1, not that it matters)
    !       with noun and second being set to o1 and o2, and action being set
    !       to the fake action TheSame.  If it returns -1, they are found
    !       identical; if -2, different; and if >=0, then the usual method
    !       is used instead.

    if (o1.parse_name ~= 0 || o2.parse_name ~= 0) {
      if (o1.parse_name ~= o2.parse_name) rfalse;
      parser_action = ##TheSame; parser_one = o1; parser_two = o2;
      j = wn; i = RunRoutines(o1,parse_name); wn = j;
      if (i == -1) rtrue;
      if (i == -2) rfalse;
    }

    !  This is the default algorithm: do they have the same words in their
    !  "name" (i.e. property no. 1) properties.  (Note that the following allows
    !  for repeated words and words in different orders.)

    p1 = o1.&1; n1 = (o1.#1)/WORDSIZE;
    p2 = o2.&1; n2 = (o2.#1)/WORDSIZE;

    !  for (i=0 : i<n1 : i++) { print (address) p1-->i, " "; } new_line;
    !  for (i=0 : i<n2 : i++) { print (address) p2-->i, " "; } new_line;

    for (i=0 : i<n1 : i++) {
        flag = 0;
        for (j=0 : j<n2 : j++)
            if (p1-->i == p2-->j) flag = 1;
        if (flag == 0) rfalse;
    }

    for (j=0 : j<n2 : j++) {
        flag = 0;
        for (i=0 : i<n1 : i++)
            if (p1-->i == p2-->j) flag = 1;
        if (flag == 0) rfalse;
    }

    !  print "Which are identical!^";
    rtrue;
];

[ PrintInferredCommand from singleton_noun;
	singleton_noun = FALSE;
	if ((from ~= 0) && (from == pcount-1) &&
		(pattern-->from > 1) && (pattern-->from < REPARSE_CODE))
			singleton_noun = TRUE;

	if (singleton_noun) {
		BeginActivity(CLARIFYING_PARSERS_CHOICE_ACT, pattern-->from);
		if (ForActivity(CLARIFYING_PARSERS_CHOICE_ACT, pattern-->from) == 0) {
			print "("; PrintCommand(from); print ")^";
		}
		EndActivity(CLARIFYING_PARSERS_CHOICE_ACT, pattern-->from);
	} else {
		print "("; PrintCommand(from); print ")^";
	}
];

[ PrintCommand from i k spacing_flag;
    if (from == 0) {
        i = verb_word;
        if (LanguageVerb(i) == 0)
            if (PrintVerb(i) == 0) print (address) i;
        from++; spacing_flag = true;
    }
    for (k=from : k<pcount : k++) {
        i = pattern-->k;
        if (i == PATTERN_NULL) continue;
        if (spacing_flag) print (char) ' ';
        if (i == 0) { print (string) THOSET__TX; jump TokenPrinted; }
        if (i == 1) { print (string) THAT__TX;   jump TokenPrinted; }
        if (i >= REPARSE_CODE)
            print (address) VM_NumberToDictionaryAddress(i-REPARSE_CODE);
        else
            if (i ofclass K3_direction)
                print (LanguageDirection) i; ! the direction name as adverb
            else
                print (the) i;
      .TokenPrinted;
        spacing_flag = true;
    }
];

[ CantSee  i w e;
    saved_oops=oops_from;

    if (scope_token ~= 0) {
        scope_error = scope_token; return ASKSCOPE_PE;
    }

    wn--; w = NextWord();
    e = CANTSEE_PE;
    if (w == pronoun_word) {
		w = NextWordStopped(); wn--;
		if ((w == -1) || (line_token-->(pcount) ~= ENDIT_TOKEN)) {
	    	AnalyseToken(line_token-->(pcount-1));
			!DebugToken(pcount-1); print " ", found_ttype, "^";
			if (found_ttype == ROUTINE_FILTER_TT or ATTR_FILTER_TT)
				e = NOTINCONTEXT_PE;
			else {
				pronoun__word = pronoun_word; pronoun__obj = pronoun_obj;
				e = ITGONE_PE;
			}
		}
    }
    
    if (etype > e) return etype;
    return e;
];

[ MultiAdd o i j;
    i = multiple_object-->0;
    if (i == MATCH_LIST_WORDS-1) { toomany_flag = 1; rtrue; }
    for (j=1 : j<=i : j++)
        if (o == multiple_object-->j) rtrue;
    i++;
    multiple_object-->i = o;
    multiple_object-->0 = i;
];

[ MultiSub o i j k;
    i = multiple_object-->0;
    for (j=1 : j<=i : j++)
        if (o == multiple_object-->j) {
            for (k=j : k<=i : k++) multiple_object-->k = multiple_object-->(k+1);
            multiple_object-->0 = --i;
            return 0;
        }
    return VAGUE_PE;
];

[ MultiFilter attr  i j o;
	.MFiltl;
    i = multiple_object-->0;
    for (j=1 : j<=i : j++) {
        o = multiple_object-->j;
        if (o hasnt attr) { MultiSub(o); jump Mfiltl; }
    }
];

[ PlaceInScope O opts; ! If opts is set, do not place contents in scope
	wn = match_from;
	if (opts == false) DoScopeActionAndRecurse(O);
	else DoScopeAction(O);
	return;
];

[ AddToScope obj;
    if (ats_flag >= 2) DoScopeActionAndRecurse(obj, 0, ats_flag-2);
    if (ats_flag == 1) { if (HasLightSource(obj)==1) ats_hls = 1; }
];

[ TestScope obj act a al sr x y;
    x = parser_one; y = parser_two;
    parser_one = obj; parser_two = 0; a = actor; al = actors_location;
    sr = scope_reason; scope_reason = TESTSCOPE_REASON;
    if (act == 0) actor = player; else actor = act;
    actors_location = ScopeCeiling(actor);
    SearchScope(actors_location, actor, 0); scope_reason = sr; actor = a;
    actors_location = al; parser_one = x; x = parser_two; parser_two = y;
    return x;
];

[ LoopOverScope routine act x y a al;
    x = parser_one; y = scope_reason; a = actor; al = actors_location;
    parser_one = routine;
    if (act == 0) actor = player; else actor = act;
    actors_location = ScopeCeiling(actor);
    scope_reason = LOOPOVERSCOPE_REASON;
    SearchScope(actors_location, actor, 0);
    parser_one = x; scope_reason = y; actor = a; actors_location = al;
];

[ SearchScope domain1 domain2 context i;
	if (domain1 == 0) return;
	! (a)
    if (scope_token) {
        scope_stage = 2;
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Scope routine called at stage 2]^";
        #Endif;
        if (indirect(scope_token) ~= 0) rtrue;
    }
	! (b)
    BeginActivity(DECIDING_SCOPE_ACT, actor);
    if (ForActivity(DECIDING_SCOPE_ACT, actor) == false) {
		! (c.1)
		if ((scope_reason == PARSING_REASON) && (context == MULTIINSIDE_TOKEN) &&
			(advance_warning ~= -1)) {
			if (IsSeeThrough(advance_warning) == 1)
			    ScopeWithin(advance_warning, 0, context);
		} else {
			! (c.2)
			if ((scope_reason == PARSING_REASON) && (context ~= CREATURE_TOKEN) &&
				(indef_mode == 0) && (domain1 == actors_location))
					ScopeWithin(compass);
			! (c.3)
			if (domain1 has supporter or container) DoScopeAction(domain1);
			ScopeWithin(domain1, domain2, context);
			! (c.4)
			if (domain2) {
				if (domain2 has supporter or container) DoScopeAction(domain2);
				ScopeWithin(domain2, 0, context);
			}
		}
		! (c.5)
		if (thedark == domain1 or domain2) {
			DoScopeActionAndRecurse(actor, actor, context);
			if (parent(actor) has supporter or container)
				DoScopeActionAndRecurse(parent(actor), parent(actor), context);
		}
    }
    EndActivity(DECIDING_SCOPE_ACT, actor);
];

[ ScopeWithin domain nosearch context obj next_obj;
    if (domain == 0) rtrue;

    ! Look through the objects in the domain, avoiding "objectloop" in case
    ! movements occur.
    obj = child(domain);
    while (obj) {
        next_obj = sibling(obj);
        if ((domain == actor) || (TestConcealment(domain, obj) == false))
            DoScopeActionAndRecurse(obj, nosearch, context);
        obj = next_obj;
    }
];

[ DoScopeActionAndRecurse domain nosearch context i ad n obj next_obj;
	DoScopeAction(domain);

 	! (a)
    if ((domain ~= nosearch) &&
        ((domain ofclass K1_room or K8_person) || (IsSeeThrough(domain) == 1))) {
		obj = child(domain);
		while (obj) {
			next_obj = sibling(obj);
			if ((domain == actor) || (TestConcealment(domain, obj) == false))
				DoScopeActionAndRecurse(obj, nosearch, context);
			obj = next_obj;
		}
	}

	! (b)
	if (domain provides component_child) {
		obj = domain.component_child;
		while (obj) {
			next_obj = obj.component_sibling;
			if ((domain == actor) || (TestConcealment(domain, obj) == false))
				DoScopeActionAndRecurse(obj, 0, context);
			obj = next_obj;
		}
	}

    ! (c)
    ad = domain.&add_to_scope;
    if (ad ~= 0) {
        ! Test if the property value is not an object.
        #Ifdef TARGET_ZCODE;
        i = (UnsignedCompare(ad-->0, top_object) > 0);
        #Ifnot; ! TARGET_GLULX
        i = (((ad-->0)->0) ~= $70);
        #Endif; ! TARGET_

        if (i) {
            ats_flag = 2+context;
            RunRoutines(domain, add_to_scope);
            ats_flag = 0;
        }
        else {
            n = domain.#add_to_scope;
            for (i=0 : (WORDSIZE*i)<n : i++)
                if (ad-->i)
                    DoScopeActionAndRecurse(ad-->i, 0, context);
        }
    }
];

[ DoScopeAction item;

    #Ifdef DEBUG;
    if (parser_trace >= 6)
        print "[DSA on ", (the) item, " with reason = ", scope_reason,
            " p1 = ", parser_one, " p2 = ", parser_two, "]^";
    #Endif; ! DEBUG

    @push parser_one; @push scope_reason;

	switch(scope_reason) {
		TESTSCOPE_REASON: if (item == parser_one) parser_two = 1;
		LOOPOVERSCOPE_REASON: if (parser_one ofclass Routine) indirect(parser_one, item);
		PARSING_REASON, TALKING_REASON: MatchTextAgainstObject(item);
    }

    @pull scope_reason; @pull parser_one;
];

[ MatchTextAgainstObject item i;
	if (match_from <= num_words) { ! If there's any text to match, that is
		wn = match_from;
		i = NounWord();
		if ((i == 1) && (player == item)) MakeMatch(item, 1); ! "me"
		if ((i >= 2) && (i < 128) && (LanguagePronouns-->i == item)) MakeMatch(item, 1);
	}

	! Construing the current word as the start of a noun, can it refer to the
	! object?

	wn = match_from;
	if (TryGivenObject(item) > 0)
		if (indef_nspec_at > 0 && match_from ~= indef_nspec_at) {
			! This case arises if the player has typed a number in
			! which is hypothetically an indefinite descriptor:
			! e.g. "take two clubs".  We have just checked the object
			! against the word "clubs", in the hope of eventually finding
			! two such objects.  But we also backtrack and check it
			! against the words "two clubs", in case it turns out to
			! be the 2 of Clubs from a pack of cards, say.  If it does
			! match against "two clubs", we tear up our original
			! assumption about the meaning of "two" and lapse back into
			! definite mode.

			wn = indef_nspec_at;
			if (TryGivenObject(item) > 0) {
				match_from = indef_nspec_at;
				ResetDescriptors();
			}
			wn = match_from;
		}
];

[ TryGivenObject obj nomatch threshold k w j;
    #Ifdef DEBUG;
    if (parser_trace >= 5) print "    Trying ", (the) obj, " (", obj, ") at word ", wn, "^";
    #Endif; ! DEBUG

	if (nomatch && obj == 0) return 0;

! if (nomatch) print "*** TryGivenObject *** on ", (the) obj, " at wn = ", wn, "^";

    dict_flags_of_noun = 0;

!  If input has run out then always match, with only quality 0 (this saves
!  time).

    if (wn > num_words) {
    	if (nomatch) return 0;
        if (indef_mode ~= 0)
            dict_flags_of_noun = $$01110000;  ! Reject "plural" bit
        MakeMatch(obj,0);
        #Ifdef DEBUG;
        if (parser_trace >= 5) print "    Matched (0)^";
        #Endif; ! DEBUG
        return 1;
    }

!  Ask the object to parse itself if necessary, sitting up and taking notice
!  if it says the plural was used:

    if (obj.parse_name~=0) {
        parser_action = NULL; j=wn;
        k = RunRoutines(obj,parse_name);
        if (k > 0) {
            wn=j+k;

          .MMbyPN;

            if (parser_action == ##PluralFound)
                dict_flags_of_noun = dict_flags_of_noun | 4;

            if (dict_flags_of_noun & 4) {
                if (~~allow_plurals) k = 0;
                else {
                    if (indef_mode == 0) {
                        indef_mode = 1; indef_type = 0; indef_wanted = 0;
                    }
                    indef_type = indef_type | PLURAL_BIT;
                    if (indef_wanted == 0) indef_wanted = INDEF_ALL_WANTED;
                }
            }

            #Ifdef DEBUG;
            if (parser_trace >= 5) print "    Matched (", k, ")^";
            #Endif; ! DEBUG
            if (nomatch == false) MakeMatch(obj,k);
            return k;
        }
        if (k == 0) jump NoWordsMatch;
    }

    ! The default algorithm is simply to count up how many words pass the
    ! Refers test:

    parser_action = NULL;

    w = NounWord();

    if (w == 1 && player == obj) { k=1; jump MMbyPN; }

    if (w >= 2 && w < 128 && (LanguagePronouns-->w == obj)) { k = 1; jump MMbyPN; }

    if (Refers(obj, wn-1) == 0) {
        .NoWordsMatch;
        if (indef_mode ~= 0) { k = 0; parser_action = NULL; jump MMbyPN; }
        rfalse;
    }

	threshold = 1;
	dict_flags_of_noun = (w->#dict_par1) & $$01110100;
	w = NextWord();
	while (Refers(obj, wn-1)) {
		threshold++;
		if (w)
		   dict_flags_of_noun = dict_flags_of_noun | ((w->#dict_par1) & $$01110100);
		w = NextWord();
	}

    k = threshold;
    jump MMbyPN;
];

[ Refers obj wnum   wd k l m;
    if (obj == 0) rfalse;

    #Ifdef LanguageRefers;
    k = LanguageRefers(obj,wnum); if (k >= 0) return k;
    #Endif; ! LanguageRefers

    k = wn; wn = wnum; wd = NextWordStopped(); wn = k;

    if (parser_inflection >= 256) {
        k = indirect(parser_inflection, obj, wd);
        if (k >= 0) return k;
        m = -k;
    }
    else
        m = parser_inflection;
    k = obj.&m; l = (obj.#m)/WORDSIZE-1;
    for (m=0 : m<=l : m++)
        if (wd == k-->m) rtrue;
    rfalse;
];

[ WordInProperty wd obj prop k l m;
    k = obj.&prop; l = (obj.#prop)/WORDSIZE-1;
    for (m=0 : m<=l : m++)
        if (wd == k-->m) rtrue;
    rfalse;
];

[ NounWord i j s;
    i = NextWord();
    if (i == 0) rfalse;
    if (i == ME1__WD or ME2__WD or ME3__WD) return 1;
    s = LanguagePronouns-->0;
    for (j=1 : j<=s : j=j+3)
        if (i == LanguagePronouns-->j)
            return j+2;
    if ((i->#dict_par1)&128 == 0) rfalse;
    return i;
];

[ TryNumber wordnum   i j c num len mul tot d digit;
    i = wn; wn = wordnum; j = NextWord(); wn = i;
    j = NumberWord(j); ! Test for verbal forms ONE to TWENTY
    if (j >= 1) return j;

    #Ifdef TARGET_ZCODE;
    i = wordnum*4+1; j = parse->i; num = j+buffer; len = parse->(i-1);
    #Ifnot; ! TARGET_GLULX
    i = wordnum*3; j = parse-->i; num = j+buffer; len = parse-->(i-1);
    #Endif; ! TARGET_

    if (len >= 4) mul=1000;
    if (len == 3) mul=100;
    if (len == 2) mul=10;
    if (len == 1) mul=1;

    tot = 0; c = 0; len = len-1;

    for (c=0 : c<=len : c++) {
        digit=num->c;
        if (digit == '0') { d = 0; jump digok; }
        if (digit == '1') { d = 1; jump digok; }
        if (digit == '2') { d = 2; jump digok; }
        if (digit == '3') { d = 3; jump digok; }
        if (digit == '4') { d = 4; jump digok; }
        if (digit == '5') { d = 5; jump digok; }
        if (digit == '6') { d = 6; jump digok; }
        if (digit == '7') { d = 7; jump digok; }
        if (digit == '8') { d = 8; jump digok; }
        if (digit == '9') { d = 9; jump digok; }
        return -1000;
     .digok;
        tot = tot+mul*d; mul = mul/10;
    }
    if (len > 3) tot=10000;
    return tot;
];

[ I7_ExtendedTryNumber wordnum i j;
	i = wn; wn = wordnum; j = NextWordStopped(); wn = i;
	switch (j) {
		'twenty-one': return 21;
		'twenty-two': return 22;
		'twenty-three': return 23;
		'twenty-four': return 24;
		'twenty-five': return 25;
		'twenty-six': return 26;
		'twenty-seven': return 27;
		'twenty-eight': return 28;
		'twenty-nine': return 29;
		'thirty': return 30;
		default: return TryNumber(wordnum);
	}
];

[ GetGender person;
    if (person hasnt female) rtrue;
    rfalse;
];

[ GetGNAOfObject obj case gender;
    if (obj hasnt animate) case = 6;
    if (obj has male) gender = male;
    if (obj has female) gender = female;
    if (obj has neuter) gender = neuter;
    if (gender == 0) {
        if (case == 0) gender = LanguageAnimateGender;
        else gender = LanguageInanimateGender;
    }
    if (gender == female)   case = case + 1;
    if (gender == neuter)   case = case + 2;
    if (obj has pluralname) case = case + 3;
    return case;
];

[ DetectPluralWord at n i w swn outcome;
	swn = wn; wn = at;
	for (i=0:i<n:i++) {
		w = NextWordStopped();
		if (w == 0 or THEN1__WD or COMMA_WORD or -1) break;
		if ((w->#dict_par1) & $$00000100) {
			parser_action = ##PluralFound;
			outcome = true;
		}
	}
	wn = swn;
	return outcome;
];

[ SetPronoun dword value x;
    for (x=1 : x<=LanguagePronouns-->0 : x=x+3)
        if (LanguagePronouns-->x == dword) {
            LanguagePronouns-->(x+2) = value; return;
        }
    RunTimeError(14);
];

[ PronounValue dword x;
    for (x=1 : x<=LanguagePronouns-->0 : x=x+3)
        if (LanguagePronouns-->x == dword)
            return LanguagePronouns-->(x+2);
    return 0;
];

[ ResetVagueWords obj; PronounNotice(obj); ];

[ PronounNotice obj x bm;
    if (obj == player) return;

    bm = PowersOfTwo_TB-->(GetGNAOfObject(obj));

    for (x=1 : x<=LanguagePronouns-->0 : x=x+3)
        if (bm & (LanguagePronouns-->(x+1)) ~= 0)
            LanguagePronouns-->(x+2) = obj;
];

[ PronounNoticeHeldObjects x;
#IFNDEF MANUAL_PRONOUNS;
	objectloop(x in player) PronounNotice(x);
#ENDIF;
	x = 0; ! To prevent a "not used" error
	rfalse;
];

[ YesOrNo i j;
    for (::) {
        #Ifdef TARGET_ZCODE;
        if (location == nothing || parent(player) == nothing) read buffer parse;
        else read buffer parse DrawStatusLine;
        j = parse->1;
        #Ifnot; ! TARGET_GLULX;
        KeyboardPrimitive(buffer, parse);
        j = parse-->0;
        #Endif; ! TARGET_
        if (j) { ! at least one word entered
            i = parse-->1;
            if (i == YES1__WD or YES2__WD or YES3__WD) rtrue;
            if (i == NO1__WD or NO2__WD or NO3__WD) rfalse;
        }
        L__M(##Quit, 1); print "> ";
    }
];

[ NumberWord o i n;
    n = LanguageNumbers-->0;
    for (i=1 : i<=n : i=i+2)
        if (o == LanguageNumbers-->i) return LanguageNumbers-->(i+1);
    return 0;
];

!Constant COBJ_DEBUG;

! the highest value returned by CheckDPMR (see the Standard Rules)
Constant HIGHEST_DPMR_SCORE = 4;

Array alt_match_list --> (MATCH_LIST_WORDS+1);

#ifdef TARGET_GLULX;
[ COBJ__Copy words from to  i;
	for (i=0: i<words: i++)
		to-->i = from-->i;
];
#ifnot;
[ COBJ__Copy words from to  bytes;
	bytes = words * 2;
	@copy_table from to bytes;
];
#endif;

! swap alt_match_list with match_list/number_matched
[ COBJ__SwapMatches i x;
	! swap the counts
	x = number_matched;
	number_matched = alt_match_list-->0;
	alt_match_list-->0 = x;
	! swap the values
	if (x < number_matched) x = number_matched;
	for (i=x: i>0: i--) {
		x = match_list-->(i-1);
		match_list-->(i-1) = alt_match_list-->i;
		alt_match_list-->i = x;
	}
];

[ ChooseObjects obj code  l i swn spcount;
	if (code<2) rfalse;

	if (cobj_flag == 1) {
		.CodeOne;
		if (parameters > 0) {
			#ifdef COBJ_DEBUG;
			print "[scoring ", (the) obj, " (second)]^";
			#endif;
			return ScoreDabCombo(parser_results-->INP1_PRES, obj);
		} else {
			#ifdef COBJ_DEBUG;
			print "[scoring ", (the) obj, " (first) in ",
				alt_match_list-->0, " combinations]^";
			#endif;
			l = 0;
			for (i=1: i<=alt_match_list-->0: i++) {
				spcount = ScoreDabCombo(obj, alt_match_list-->i);
				if (spcount == HIGHEST_DPMR_SCORE) {
					#ifdef COBJ_DEBUG;
					print "[scored ", spcount, " - best possible]^";
					#endif;
					return spcount;
				}
				if (spcount>l) l = spcount;
			}
			return l;
		}
	}
	if (cobj_flag == 2) {
		.CodeTwo;
		#ifdef COBJ_DEBUG;
		print "[scoring ", (the) obj, " (simple); parameters = ", parameters,
			" aw = ", advance_warning, "]^";
		#endif;
		@push action_to_be;
		if (parameters==0) {
			if (advance_warning > 0)
				l = ScoreDabCombo(obj, advance_warning);
			else
				l = ScoreDabCombo(obj, 0);
		} else {
			l = ScoreDabCombo(parser_results-->INP1_PRES, obj);
		}
		@pull action_to_be;
		return l;
	}

	#ifdef COBJ_DEBUG;
	print "[choosing a cobj strategy: ";
	#endif;
	swn = wn;
	spcount = pcount;
	while (line_ttype-->pcount == PREPOSITION_TT) pcount++;
	if (line_ttype-->pcount == ELEMENTARY_TT) {
		while (wn <= num_words) {
			l = NextWordStopped(); wn--;
			if ( (l ~= -1 or 0) && (l->#dict_par1) &8 ) { wn++; continue; }	! if preposition
			if (l == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD) { wn++; continue; }
			SafeSkipDescriptors();
			! save the current match state
			@push match_length; @push token_filter; @push match_from;
			alt_match_list-->0 = number_matched;
			COBJ__Copy(number_matched, match_list, alt_match_list+WORDSIZE);
			! now get all the matches for the second noun
			match_length = 0; number_matched = 0; match_from = wn;
			token_filter = 0;
			SearchScope(actor, actors_location, line_tdata-->pcount);
			#ifdef COBJ_DEBUG;
			print number_matched, " possible second nouns]^";
			#endif;
			wn = swn;
			cobj_flag = 1;
			! restore match variables
			COBJ__SwapMatches();
			@pull match_from; @pull token_filter; @pull match_length;
			pcount = spcount;
			jump CodeOne;
		}
	}
	pcount = spcount;
	wn = swn;	
	
	#ifdef COBJ_DEBUG;
	print "nothing interesting]^";
	#endif;
	cobj_flag = 2;
	jump CodeTwo;
];

[ ScoreDabCombo a b  result;
	@push action; @push act_requester; @push noun; @push second;
	action = action_to_be;
	act_requester = player;
	if (action_reversed) { noun = b; second = a; }
	else { noun = a; second = b; }
	result = CheckDPMR();
	@pull second; @pull noun; @pull act_requester; @pull action;
	#ifdef COBJ_DEBUG;
	print "[", (the) a, " / ", (the) b, " => ", result, "]^";
	#endif;
	return result;
];

[ DefaultTopic; return GPR_FAIL; ];



[ ParserError error_type;
	if (error_type ofclass String or Routine) PrintSingleParagraph(error_type);
	rfalse;
];

Object InformLibrary "(Inform Library)" has proper;

Array Protect_I7_Arrays --> 16339 12345;

Global EarlyInTurnSequence;

[ Main;
	#ifdef TARGET_ZCODE; max_z_object = #largest_object - 255; #endif;
	ProcessRulebook(STARTUP_RB);
	#ifdef DEBUG; InternalTestCases(); #endif;
	while (true) {
		while (deadflag == false) {
			EarlyInTurnSequence = true;
			action = ##Wait; meta = false; noun = nothing; second = nothing;
			actor = player;
			FollowRulebook(TURN_SEQUENCE_RB);
		}
		if (FollowRulebook(SHUTDOWN_RB) == false) return;
	}
];

[ VIRTUAL_MACHINE_STARTUP_R;
	ProcessRulebook(Activity_before_rulebooks-->STARTING_VIRTUAL_MACHINE_ACT);
	ProcessRulebook(Activity_for_rulebooks-->STARTING_VIRTUAL_MACHINE_ACT);
	ProcessRulebook(Activity_after_rulebooks-->STARTING_VIRTUAL_MACHINE_ACT);

	VM_Initialise();

	print "^^^";
	rfalse;
];

Constant PLAYER_OBJECT_INIS = 0;
Constant START_OBJECT_INIS = 1;
Constant START_ROOM_INIS = 2;
Constant START_TIME_INIS = 3;
Constant DONE_INIS = 4;

Array InitialSituation --> I97_dursley I120_bed I118_dursley_s_bedroom 540 0;



[ INITIALISE_MEMORY_R;
	#ifdef TARGET_GLULX; VM_PreInitialise(); #Endif;
	#Ifdef LanguageInitialise; LanguageInitialise(); #Endif;

	not_yet_in_play = true;
	#ifdef I7_LOOKMODE; lookmode = I7_LOOKMODE; #endif;
	player = InitialSituation-->PLAYER_OBJECT_INIS;
	the_time = InitialSituation-->START_TIME_INIS;
	real_location = nothing;
	location = nothing;

	CreatePropertyOffsets();
	HeapInitialise(); ! Create a completely unused memory allocation heap
	InitialHeapAllocation(); ! Allocate empty blocks for variables, properties, and such
	CreateBlockConstants(); ! Allocate and fill in blocks for constant values
	DistributeBlockConstants(); ! Ensure these exist in multiple independent copies when needed
	CreateDynamicRelations(); ! Create relation structures on the heap

	rfalse;
];

[ SEED_RANDOM_NUMBER_GENERATOR_R i;
	if (0) VM_Seed_RNG(0);
	for (i=1: i<=100: i++) random(i);
	rfalse;
];

[ POSITION_PLAYER_IN_MODEL_R player_to_be;

	player = selfobj;
	player_to_be = InitialSituation-->PLAYER_OBJECT_INIS;
	
	location = LocationOf(player_to_be);
	if (location == 0) {
		location = InitialSituation-->START_ROOM_INIS;
		if (InitialSituation-->START_OBJECT_INIS)
			move player_to_be to InitialSituation-->START_OBJECT_INIS;
		else move player_to_be to location;
	}

	if (player_to_be ~= player) { remove selfobj; ChangePlayer(player_to_be); }

	real_location = location; SilentlyConsiderLight();

	NOTE_OBJECT_ACQUISITIONS_R(); MoveFloatingObjects();
	
	actor = player; act_requester = nothing; actors_location = real_location; action = ##Wait;

	InitialSituation-->DONE_INIS = true;
	rfalse;
];

Constant ACTION_PRES = 0;
Constant NO_INPS_PRES = 1;
Constant INP1_PRES = 2;
Constant INP2_PRES = 3; ! Parser.i6t code assumes this is INP1_PRES + 1

[ PARSE_COMMAND_R;
	if (EarlyInTurnSequence == false) rfalse; ! Prevent use outside top level
	not_yet_in_play = false;

	Parser__parse();
	TreatParserResults();
	rfalse;
];

[ TreatParserResults;
	if (parser_results-->ACTION_PRES == ##MistakeAction) meta = true;

	if (parser_results-->ACTION_PRES == ##Tell &&
		parser_results-->INP1_PRES == player && actor ~= player) {
		parser_results-->ACTION_PRES = ##Ask;
		parser_results-->INP1_PRES = actor; actor = player;
	}
];

[ GENERATE_ACTION_R i j k l;
	if (EarlyInTurnSequence == false) rfalse; ! Prevent use outside top level
	EarlyInTurnSequence = false;

	action = parser_results-->ACTION_PRES;
	act_requester = nothing; if (actor ~= player) act_requester = player;

	inp1 = 0; inp2 = 0; multiflag = false;
	if (parser_results-->NO_INPS_PRES >= 1) {
		inp1 = parser_results-->INP1_PRES; if (inp1 == 0) multiflag = true;
	}
	if (parser_results-->NO_INPS_PRES >= 2) {
		inp2 = parser_results-->INP2_PRES; if (inp2 == 0) multiflag = true;
	}

	if (inp1 == 1) {
		noun = nothing; ! noun = special_number1;
	} else noun = inp1;
	if (inp2 == 1) {
		second = nothing;
		! if (inp1 == 1) second = special_number2; else second = special_number1;
	} else second = inp2;

	if (multiflag) {
		if (multiple_object-->0 == 0) { L__M(##Miscellany, 2); return; }
		if (toomany_flag) { toomany_flag = false; L__M(##Miscellany, 1); }
		GenerateMultipleActions();
		multiflag = false;
	} else BeginAction(action, noun, second);

	if ((actor ~= player) || (act_requester)) action = ##Wait;
	actor = player; act_requester = 0;

	if (meta) { RulebookSucceeds(); rtrue; }
	rfalse;
];

[ GenerateMultipleActions initial_location k item;
	initial_location = location;
	for (k=1: k<=multiple_object-->0: k++) {
		item = multiple_object-->k;
		RunParagraphOn();
		if (inp1 == 0) { inp1 = item; BeginAction(action, item, second, item); inp1 = 0; }
		else { inp2 = item; BeginAction(action, noun, item, item); inp2 = 0; }
		if (deadflag) return;
		if (location ~= initial_location) { L__M(##Miscellany, 51); return; }
	}
];

[ TIMED_EVENTS_R i event_timer fire rule;
	for (i=1: i<=(TimedEventsTable-->0): i++)
		if ((rule=TimedEventsTable-->i) ~= 0) {
			event_timer = TimedEventTimesTable-->i; fire = false;
			if (event_timer<0) {
				(TimedEventTimesTable-->i)++;
				if (TimedEventTimesTable-->i == 0) fire = true;
			} else {
				if ((the_time >= event_timer) && (the_time < event_timer+30)) fire = true;
			}
			if (fire) {
				TimedEventsTable-->i = 0;
				ProcessRulebook(rule);
			}
		}
	rfalse;
];

[ SetTimedEvent rule event_time absolute_time i b;
	for (i=1: i<=(TimedEventsTable-->0): i++) {
		if (rule == TimedEventsTable-->i) { b=i; break; }
		if ((b==0) && (TimedEventsTable-->i == 0)) b=i;
	}
	if (b==0) return RunTimeProblem(RTP_TOOMANYEVENTS);
	TimedEventsTable-->b = rule;
	if (absolute_time) TimedEventTimesTable-->b = event_time;
	else TimedEventTimesTable-->b = -event_time;
];

Global time_step;

[ SetTime t s;
    the_time = t; time_rate = s; time_step = 0;
    if (s < 0) time_step = 0-s;
];

[ ADVANCE_TIME_R;
    turns++;
    if (the_time ~= NULL) {
        if (time_rate >= 0) the_time = the_time+time_rate;
        else {
            time_step--;
            if (time_step == 0) {
                the_time++;
                time_step = -time_rate;
            }
        }
        the_time = the_time % TWENTY_FOUR_HOURS;
    }
	rfalse;
];

[ NOTE_OBJECT_ACQUISITIONS_R obj;
    objectloop (obj in player) give obj moved;
    objectloop (obj has concealed)
    	if (IndirectlyContains(player, obj)) give obj ~concealed;
    #Ifdef RUCKSACK_CLASS;
	objectloop (obj in player)
		if (obj ofclass RUCKSACK_CLASS)
			SACK_OBJECT = obj;
	objectloop (obj ofclass RUCKSACK_CLASS && obj provides component_parent
		&& obj.component_parent == player)
		SACK_OBJECT = obj;
	#Endif;
	rfalse;
];

[ RESURRECT_PLAYER_IF_ASKED_R;
	if (resurrect_please) {
		RulebookSucceeds(); resurrect_please = false;
		deadflag = 0; story_complete = false; rtrue;
	}
	rfalse;
];

[ ASK_FINAL_QUESTION_R;
	print "^";
	while (true) {
		CarryOutActivity(DEALING_WITH_FINAL_QUESTION_ACT);
		DivideParagraphPoint();
    }
];

[ READ_FINAL_ANSWER_R;
	DrawStatusLine();
	KeyboardPrimitive(buffer, parse);
	players_command = 100 + WordCount();
	num_words = WordCount();
	wn = 1;
	rfalse;
];

[ IMMEDIATELY_RESTART_VM_R; @restart; ];

[ IMMEDIATELY_RESTORE_SAVED_R; actor = player; RESTORE_THE_GAME_R(); ];

[ IMMEDIATELY_QUIT_R; @quit; ];

[ IMMEDIATELY_UNDO_R;
	if (not_yet_in_play == false) turns++;
	Perform_Undo();
	if (not_yet_in_play == false) turns--;
];

[ PRINT_OBITUARY_HEADLINE_R;
    print "^^    ";
    VM_Style(ALERT_VMSTY);
    print "***";
    if (deadflag == 1) L__M(##Miscellany, 3);
    if (deadflag == 2) L__M(##Miscellany, 4);
    if (deadflag == 3) L__M(##Miscellany, 75);
    if (deadflag ~= 0 or 1 or 2 or 3)  {
        print " ";
        if (deadflag ofclass Routine) (deadflag)();
		if (deadflag ofclass String) print (string) deadflag;
        print " ";
    }
    print "***";
    VM_Style(NORMAL_VMSTY);
    print "^^"; #Ifndef NO_SCORE; print "^"; #Endif;
    rfalse;
];

[ PRINT_FINAL_SCORE_R;
	#Ifndef NO_SCORING; ANNOUNCE_SCORE_R(); #Endif;
	rfalse;
];

[ DISPLAY_FINAL_STATUS_LINE_R;
	sline1 = score; sline2 = turns;
	rfalse;
];


Constant p3_printed_name = short_name;
Constant p4_printed_plural_name = plural;
Constant p5_indefinite_article = article;
Constant p6_description = description;
Constant p7_map_region = map_region;
Constant p8_initial_appearance = initial;
Constant p10_other_side = door_to;
Constant p11_carrying_capacity = capacity;
Constant p12_matching_key = with_key;
Constant p16_plural_named = pluralname;
Constant p18_proper_named = proper;
Constant p20_privately_named = privately_named;
Constant p22_lighted = light;
Constant p24_visited = visited;
Constant p26_lit = light;
Constant p28_edible = edible;
Constant p30_fixed_in_place = static;
Constant p32_scenery = scenery;
Constant p33_wearable = clothing;
Constant p34_pushable_between_rooms = pushable;
Constant p35_handled = moved;
Constant p37_undescribed = concealed;
Constant p38_marked_for_listing = workflag;
Constant p40_mentioned = mentioned;
Constant p42_enterable = enterable;
Constant p44_transparent = transparent;
Constant p45_open = open;
Constant p47_openable = openable;
Constant p49_lockable = lockable;
Constant p50_locked = locked;
Constant p52_female = female;
Constant p54_neuter = neuter;
Constant p55_switched_on = on;
Constant p81 = worn;
Constant p82 = vector;
Constant p83 = room_index;
Constant p84 = door_dir;
Constant p85 = door_to;
Constant p86 = found_in;
Constant p87 = absent;
Constant p88 = list_together;
Constant p89 = cap_short_name;
Constant p90 = mark_as_room;
Constant p91 = mark_as_thing;
Constant p92 = component_parent;
Constant p93 = component_child;
Constant p94 = component_sibling;
Constant p95 = regional_found_in;
Constant p96 = IK1_Count;
Constant p97 = IK1_Link;
Constant p98 = IK2_Count;
Constant p99 = IK2_Link;
Constant p100 = IK3_Count;
Constant p101 = IK3_Link;
Constant p102 = IK4_Count;
Constant p103 = IK4_Link;
Constant p104 = IK5_Count;
Constant p105 = IK5_Link;
Constant p106 = IK6_Count;
Constant p107 = IK6_Link;
Constant p108 = IK7_Count;
Constant p109 = IK7_Link;
Constant p110 = IK8_Count;
Constant p111 = IK8_Link;
Constant p112 = IK9_Count;
Constant p113 = IK9_Link;
Constant p114 = IK10_Count;
Constant p115 = IK10_Link;
Constant p116 = IK11_Count;
Constant p117 = IK11_Link;
Constant p118 = IK12_Count;
Constant p119 = IK12_Link;
Constant p120 = IK13_Count;
Constant p121 = IK13_Link;
Constant p122 = IK14_Count;
Constant p123 = IK14_Link;
Constant p124 = IK15_Count;
Constant p125 = IK15_Link;
Constant p126 = IK16_Count;
Constant p127 = IK16_Link;
Constant p128 = IK17_Count;
Constant p129 = IK17_Link;
Constant p130 = IK18_Count;
Constant p131 = IK18_Link;
Constant p132 = IK19_Count;
Constant p133 = IK19_Link;
Constant p134 = IK20_Count;
Constant p135 = IK20_Link;
Constant p136 = IK21_Count;
Constant p137 = IK21_Link;
Constant p138 = IK22_Count;
Constant p139 = IK22_Link;
Constant p140 = IK23_Count;
Constant p141 = IK23_Link;
Constant p142 = IK24_Count;
Constant p143 = IK24_Link;
Constant p144 = IK25_Count;
Constant p145 = IK25_Link;
Constant p146 = IK26_Count;
Constant p147 = IK26_Link;
Constant p148 = IK27_Count;
Constant p149 = IK27_Link;
Constant p150 = IK28_Count;
Constant p151 = IK28_Link;
Constant p152 = IK29_Count;
Constant p153 = IK29_Link;
Constant p154 = IK30_Count;
Constant p155 = IK30_Link;
Constant p156 = IK31_Count;
Constant p157 = IK31_Link;
Constant p158 = IK32_Count;
Constant p159 = IK32_Link;
Constant p160 = IK33_Count;
Constant p161 = IK33_Link;
Constant p162 = IK34_Count;
Constant p163 = IK34_Link;
Constant p164 = IK35_Count;
Constant p165 = IK35_Link;
Constant p166 = IK36_Count;
Constant p167 = IK36_Link;
Constant p168 = IK37_Count;
Constant p169 = IK37_Link;
Constant p170 = IK38_Count;
Constant p171 = IK38_Link;
Constant p172 = IK39_Count;
Constant p173 = IK39_Link;
Constant p174 = IK40_Count;
Constant p175 = IK40_Link;
Constant p176 = IK41_Count;
Constant p177 = IK41_Link;
Constant p178 = IK42_Count;
Constant p179 = IK42_Link;
Constant p180 = IK43_Count;
Constant p181 = IK43_Link;
Constant p182 = IK44_Count;
Constant p183 = IK44_Link;
Constant p184 = IK45_Count;
Constant p185 = IK45_Link;
Constant p186 = IK46_Count;
Constant p187 = IK46_Link;
Constant p188 = IK47_Count;
Constant p189 = IK47_Link;
Constant p190 = IK48_Count;
Constant p191 = IK48_Link;
Constant p192 = IK49_Count;
Constant p193 = IK49_Link;
Constant p194 = IK50_Count;
Constant p195 = IK50_Link;
Constant p196 = IK51_Count;
Constant p197 = IK51_Link;
Constant p198 = IK52_Count;
Constant p199 = IK52_Link;
Constant p200 = IK53_Count;
Constant p201 = IK53_Link;
Constant p202 = IK54_Count;
Constant p203 = IK54_Link;
Constant p204 = KD_Count;
Constant p205 = name;
Constant p206 = parse_name;
Constant p207 = action_bitmap;

Attribute p60_large;
Attribute p61_small;
Attribute p62_medium;
Attribute p63_huge;
Attribute p64_ambiguously_plural;
Attribute p67_seen;
Attribute p69_familiar;
Attribute p71_inuse;
Attribute p75_posture_friendly;
Attribute p77_occupied;
Constant FBNA_PROP_NUMBER = p57_recurring;
Object property_numberspace_forcer
    with p57_recurring false
;

Array property_metadata -->
    ! offset 0: property p0_specification
    "specification" NULL
    ! offset 2: property p1_indefinite_appearance_tex
    "indefinite appearance text" NULL
    ! offset 4: property p2_variable_initial_value
    "variable initial value" K1_room K2_thing K3_direction K9_region NULL
    ! offset 10: property short_name
    "printed name" K1_room K2_thing K3_direction K9_region NULL
    ! offset 16: property plural
    "printed plural name" K1_room K2_thing K3_direction K9_region NULL
    ! offset 22: property article
    "indefinite article" K1_room K2_thing K3_direction K9_region NULL
    ! offset 28: property description
    "description" K1_room K2_thing NULL
    ! offset 32: property map_region
    "map region" K1_room NULL
    ! offset 35: property initial
    "initial appearance" K2_thing NULL
    ! offset 38: property p9_opposite
    "opposite" K3_direction NULL
    ! offset 41: property door_to
    "other side" K4_door NULL
    ! offset 44: property capacity
    "carrying capacity" K5_container K6_supporter K8_person NULL
    ! offset 49: property with_key
    "matching key" K2_thing K4_door K5_container NULL
    ! offset 54: property p13_openyesno
    "openyesno" K4_door NULL
    ! offset 57: property p14_calling_number
    "calling number" K29_telephone NULL
    ! offset 60: property p15_owner
    "owner" K29_telephone NULL
    ! offset 63: property pluralname
    "plural-named" K1_room K2_thing K3_direction K9_region NULL
    ! offset 69: property proper
    "proper-named" K1_room K2_thing K3_direction K9_region NULL
    ! offset 75: property privately_named
    "privately-named" K1_room K2_thing K3_direction K9_region NULL
    ! offset 81: property light
    "lighted" K1_room K2_thing NULL
    ! offset 85: property visited
    "visited" K1_room NULL
    ! offset 88: property light
    "lit" K1_room K2_thing NULL
    ! offset 92: property edible
    "edible" K2_thing NULL
    ! offset 95: property static
    "fixed in place" K2_thing NULL
    ! offset 98: property scenery
    "scenery" K2_thing NULL
    ! offset 101: property clothing
    "wearable" K2_thing NULL
    ! offset 104: property pushable
    "pushable between rooms" K2_thing NULL
    ! offset 107: property moved
    "handled" K2_thing NULL
    ! offset 110: property concealed
    "undescribed" K2_thing NULL
    ! offset 113: property workflag
    "marked for listing" K2_thing K3_direction NULL
    ! offset 117: property mentioned
    "mentioned" K2_thing NULL
    ! offset 120: property enterable
    "enterable" K5_container K6_supporter NULL
    ! offset 124: property transparent
    "transparent" K5_container NULL
    ! offset 127: property open
    "open" K4_door K5_container NULL
    ! offset 131: property openable
    "openable" K4_door K5_container NULL
    ! offset 135: property lockable
    "lockable" K4_door K5_container NULL
    ! offset 139: property locked
    "locked" K4_door K5_container NULL
    ! offset 143: property female
    "female" K8_person NULL
    ! offset 146: property neuter
    "neuter" K2_thing K8_person NULL
    ! offset 150: property on
    "switched on" K13_device NULL
    ! offset 153: property p57_recurring
    "recurring" NULL
    ! offset 155: property p59_underlying
    "underlying" K2_thing NULL
    ! offset 158: property p60_large
    "large" K2_thing NULL
    ! offset 161: property p61_small
    "small" K2_thing NULL
    ! offset 164: property p62_medium
    "medium" K2_thing NULL
    ! offset 167: property p63_huge
    "huge" K2_thing NULL
    ! offset 170: property p64_ambiguously_plural
    "ambiguously plural" K2_thing NULL
    ! offset 173: property p66_cost
    "cost" K2_thing NULL
    ! offset 176: property p67_seen
    "seen" K2_thing NULL
    ! offset 179: property p69_familiar
    "familiar" K2_thing NULL
    ! offset 182: property p71_inuse
    "inuse" K29_telephone NULL
    ! offset 185: property p72_other_party
    "other party" K8_person NULL
    ! offset 188: property p73_posture
    "posture" K5_container K6_supporter K8_person NULL
    ! offset 193: property p74_posture_permission
    "posture-permission" NULL
    ! offset 195: property p75_posture_friendly
    "posture-friendly" K1_room NULL
    ! offset 198: property p77_occupied
    "occupied" K40_broom NULL
    ! offset 201: property p78_foodlevel
    "foodlevel" K44_food NULL
    ! offset 204: property p79_drinklevel
    "drinklevel" K45_cup NULL
    ! offset 207: property p80_venture
    "venture" NULL
    ! offset 209: property worn
    "<nameless>" NULL
    ! offset 211: property vector
    "<nameless>" NULL
    ! offset 213: property room_index
    "<nameless>" NULL
    ! offset 215: property door_dir
    "<nameless>" NULL
    ! offset 217: property door_to
    "<nameless>" K4_door NULL
    ! offset 220: property found_in
    "<nameless>" NULL
    ! offset 222: property absent
    "<nameless>" NULL
    ! offset 224: property list_together
    "<nameless>" NULL
    ! offset 226: property cap_short_name
    "<nameless>" NULL
    ! offset 228: property mark_as_room
    "<nameless>" NULL
    ! offset 230: property mark_as_thing
    "<nameless>" NULL
    ! offset 232: property component_parent
    "<nameless>" NULL
    ! offset 234: property component_child
    "<nameless>" NULL
    ! offset 236: property component_sibling
    "<nameless>" NULL
    ! offset 238: property regional_found_in
    "<nameless>" NULL
    ! offset 240: property IK1_Count
    "<nameless>" NULL
    ! offset 242: property IK1_Link
    "<nameless>" NULL
    ! offset 244: property IK2_Count
    "<nameless>" NULL
    ! offset 246: property IK2_Link
    "<nameless>" NULL
    ! offset 248: property IK3_Count
    "<nameless>" NULL
    ! offset 250: property IK3_Link
    "<nameless>" NULL
    ! offset 252: property IK4_Count
    "<nameless>" NULL
    ! offset 254: property IK4_Link
    "<nameless>" NULL
    ! offset 256: property IK5_Count
    "<nameless>" NULL
    ! offset 258: property IK5_Link
    "<nameless>" NULL
    ! offset 260: property IK6_Count
    "<nameless>" NULL
    ! offset 262: property IK6_Link
    "<nameless>" NULL
    ! offset 264: property IK7_Count
    "<nameless>" NULL
    ! offset 266: property IK7_Link
    "<nameless>" NULL
    ! offset 268: property IK8_Count
    "<nameless>" NULL
    ! offset 270: property IK8_Link
    "<nameless>" NULL
    ! offset 272: property IK9_Count
    "<nameless>" NULL
    ! offset 274: property IK9_Link
    "<nameless>" NULL
    ! offset 276: property IK10_Count
    "<nameless>" NULL
    ! offset 278: property IK10_Link
    "<nameless>" NULL
    ! offset 280: property IK11_Count
    "<nameless>" NULL
    ! offset 282: property IK11_Link
    "<nameless>" NULL
    ! offset 284: property IK12_Count
    "<nameless>" NULL
    ! offset 286: property IK12_Link
    "<nameless>" NULL
    ! offset 288: property IK13_Count
    "<nameless>" NULL
    ! offset 290: property IK13_Link
    "<nameless>" NULL
    ! offset 292: property IK14_Count
    "<nameless>" NULL
    ! offset 294: property IK14_Link
    "<nameless>" NULL
    ! offset 296: property IK15_Count
    "<nameless>" NULL
    ! offset 298: property IK15_Link
    "<nameless>" NULL
    ! offset 300: property IK16_Count
    "<nameless>" NULL
    ! offset 302: property IK16_Link
    "<nameless>" NULL
    ! offset 304: property IK17_Count
    "<nameless>" NULL
    ! offset 306: property IK17_Link
    "<nameless>" NULL
    ! offset 308: property IK18_Count
    "<nameless>" NULL
    ! offset 310: property IK18_Link
    "<nameless>" NULL
    ! offset 312: property IK19_Count
    "<nameless>" NULL
    ! offset 314: property IK19_Link
    "<nameless>" NULL
    ! offset 316: property IK20_Count
    "<nameless>" NULL
    ! offset 318: property IK20_Link
    "<nameless>" NULL
    ! offset 320: property IK21_Count
    "<nameless>" NULL
    ! offset 322: property IK21_Link
    "<nameless>" NULL
    ! offset 324: property IK22_Count
    "<nameless>" NULL
    ! offset 326: property IK22_Link
    "<nameless>" NULL
    ! offset 328: property IK23_Count
    "<nameless>" NULL
    ! offset 330: property IK23_Link
    "<nameless>" NULL
    ! offset 332: property IK24_Count
    "<nameless>" NULL
    ! offset 334: property IK24_Link
    "<nameless>" NULL
    ! offset 336: property IK25_Count
    "<nameless>" NULL
    ! offset 338: property IK25_Link
    "<nameless>" NULL
    ! offset 340: property IK26_Count
    "<nameless>" NULL
    ! offset 342: property IK26_Link
    "<nameless>" NULL
    ! offset 344: property IK27_Count
    "<nameless>" NULL
    ! offset 346: property IK27_Link
    "<nameless>" NULL
    ! offset 348: property IK28_Count
    "<nameless>" NULL
    ! offset 350: property IK28_Link
    "<nameless>" NULL
    ! offset 352: property IK29_Count
    "<nameless>" NULL
    ! offset 354: property IK29_Link
    "<nameless>" NULL
    ! offset 356: property IK30_Count
    "<nameless>" NULL
    ! offset 358: property IK30_Link
    "<nameless>" NULL
    ! offset 360: property IK31_Count
    "<nameless>" NULL
    ! offset 362: property IK31_Link
    "<nameless>" NULL
    ! offset 364: property IK32_Count
    "<nameless>" NULL
    ! offset 366: property IK32_Link
    "<nameless>" NULL
    ! offset 368: property IK33_Count
    "<nameless>" NULL
    ! offset 370: property IK33_Link
    "<nameless>" NULL
    ! offset 372: property IK34_Count
    "<nameless>" NULL
    ! offset 374: property IK34_Link
    "<nameless>" NULL
    ! offset 376: property IK35_Count
    "<nameless>" NULL
    ! offset 378: property IK35_Link
    "<nameless>" NULL
    ! offset 380: property IK36_Count
    "<nameless>" NULL
    ! offset 382: property IK36_Link
    "<nameless>" NULL
    ! offset 384: property IK37_Count
    "<nameless>" NULL
    ! offset 386: property IK37_Link
    "<nameless>" NULL
    ! offset 388: property IK38_Count
    "<nameless>" NULL
    ! offset 390: property IK38_Link
    "<nameless>" NULL
    ! offset 392: property IK39_Count
    "<nameless>" NULL
    ! offset 394: property IK39_Link
    "<nameless>" NULL
    ! offset 396: property IK40_Count
    "<nameless>" NULL
    ! offset 398: property IK40_Link
    "<nameless>" NULL
    ! offset 400: property IK41_Count
    "<nameless>" NULL
    ! offset 402: property IK41_Link
    "<nameless>" NULL
    ! offset 404: property IK42_Count
    "<nameless>" NULL
    ! offset 406: property IK42_Link
    "<nameless>" NULL
    ! offset 408: property IK43_Count
    "<nameless>" NULL
    ! offset 410: property IK43_Link
    "<nameless>" NULL
    ! offset 412: property IK44_Count
    "<nameless>" NULL
    ! offset 414: property IK44_Link
    "<nameless>" NULL
    ! offset 416: property IK45_Count
    "<nameless>" NULL
    ! offset 418: property IK45_Link
    "<nameless>" NULL
    ! offset 420: property IK46_Count
    "<nameless>" NULL
    ! offset 422: property IK46_Link
    "<nameless>" NULL
    ! offset 424: property IK47_Count
    "<nameless>" NULL
    ! offset 426: property IK47_Link
    "<nameless>" NULL
    ! offset 428: property IK48_Count
    "<nameless>" NULL
    ! offset 430: property IK48_Link
    "<nameless>" NULL
    ! offset 432: property IK49_Count
    "<nameless>" NULL
    ! offset 434: property IK49_Link
    "<nameless>" NULL
    ! offset 436: property IK50_Count
    "<nameless>" NULL
    ! offset 438: property IK50_Link
    "<nameless>" NULL
    ! offset 440: property IK51_Count
    "<nameless>" NULL
    ! offset 442: property IK51_Link
    "<nameless>" NULL
    ! offset 444: property IK52_Count
    "<nameless>" NULL
    ! offset 446: property IK52_Link
    "<nameless>" NULL
    ! offset 448: property IK53_Count
    "<nameless>" NULL
    ! offset 450: property IK53_Link
    "<nameless>" NULL
    ! offset 452: property IK54_Count
    "<nameless>" NULL
    ! offset 454: property IK54_Link
    "<nameless>" NULL
    ! offset 456: property KD_Count
    "<nameless>" NULL
    ! offset 458: property name
    "<nameless>" NULL
    ! offset 460: property parse_name
    "<nameless>" NULL
    ! offset 462: property action_bitmap
    "<nameless>" NULL
;

Constant attributed_property_offsets_SIZE 48;
Array attributed_property_offsets --> attributed_property_offsets_SIZE;
Constant valued_property_offsets_SIZE (100 + 208 + INDIV_PROP_START-48);
Array valued_property_offsets --> valued_property_offsets_SIZE;

[ CreatePropertyOffsets i;
    for (i=0: i<attributed_property_offsets_SIZE: i++)attributed_property_offsets-->i = -1;
    for (i=0: i<valued_property_offsets_SIZE: i++)valued_property_offsets-->i = -1;
    valued_property_offsets-->p0_specification = 0;
    valued_property_offsets-->p1_indefinite_appearance_tex = 2;
    valued_property_offsets-->p2_variable_initial_value = 4;
    valued_property_offsets-->short_name = 10;
    valued_property_offsets-->plural = 16;
    valued_property_offsets-->article = 22;
    valued_property_offsets-->description = 28;
    valued_property_offsets-->map_region = 32;
    valued_property_offsets-->initial = 35;
    valued_property_offsets-->p9_opposite = 38;
    valued_property_offsets-->door_to = 41;
    valued_property_offsets-->capacity = 44;
    valued_property_offsets-->with_key = 49;
    valued_property_offsets-->p13_openyesno = 54;
    valued_property_offsets-->p14_calling_number = 57;
    valued_property_offsets-->p15_owner = 60;
    attributed_property_offsets-->pluralname = 63;
    attributed_property_offsets-->proper = 69;
    attributed_property_offsets-->privately_named = 75;
    attributed_property_offsets-->light = 81;
    attributed_property_offsets-->visited = 85;
    attributed_property_offsets-->light = 88;
    attributed_property_offsets-->edible = 92;
    attributed_property_offsets-->static = 95;
    attributed_property_offsets-->scenery = 98;
    attributed_property_offsets-->clothing = 101;
    attributed_property_offsets-->pushable = 104;
    attributed_property_offsets-->moved = 107;
    attributed_property_offsets-->concealed = 110;
    attributed_property_offsets-->workflag = 113;
    attributed_property_offsets-->mentioned = 117;
    attributed_property_offsets-->enterable = 120;
    attributed_property_offsets-->transparent = 124;
    attributed_property_offsets-->open = 127;
    attributed_property_offsets-->openable = 131;
    attributed_property_offsets-->lockable = 135;
    attributed_property_offsets-->locked = 139;
    attributed_property_offsets-->female = 143;
    attributed_property_offsets-->neuter = 146;
    attributed_property_offsets-->on = 150;
    valued_property_offsets-->p57_recurring = 153;
    valued_property_offsets-->p59_underlying = 155;
    attributed_property_offsets-->p60_large = 158;
    attributed_property_offsets-->p61_small = 161;
    attributed_property_offsets-->p62_medium = 164;
    attributed_property_offsets-->p63_huge = 167;
    attributed_property_offsets-->p64_ambiguously_plural = 170;
    valued_property_offsets-->p66_cost = 173;
    attributed_property_offsets-->p67_seen = 176;
    attributed_property_offsets-->p69_familiar = 179;
    attributed_property_offsets-->p71_inuse = 182;
    valued_property_offsets-->p72_other_party = 185;
    valued_property_offsets-->p73_posture = 188;
    valued_property_offsets-->p74_posture_permission = 193;
    attributed_property_offsets-->p75_posture_friendly = 195;
    attributed_property_offsets-->p77_occupied = 198;
    valued_property_offsets-->p78_foodlevel = 201;
    valued_property_offsets-->p79_drinklevel = 204;
    valued_property_offsets-->p80_venture = 207;
    attributed_property_offsets-->worn = 209;
    valued_property_offsets-->vector = 211;
    valued_property_offsets-->room_index = 213;
    valued_property_offsets-->door_dir = 215;
    valued_property_offsets-->door_to = 217;
    valued_property_offsets-->found_in = 220;
    attributed_property_offsets-->absent = 222;
    valued_property_offsets-->list_together = 224;
    valued_property_offsets-->cap_short_name = 226;
    attributed_property_offsets-->mark_as_room = 228;
    attributed_property_offsets-->mark_as_thing = 230;
    valued_property_offsets-->component_parent = 232;
    valued_property_offsets-->component_child = 234;
    valued_property_offsets-->component_sibling = 236;
    valued_property_offsets-->regional_found_in = 238;
    valued_property_offsets-->IK1_Count = 240;
    valued_property_offsets-->IK1_Link = 242;
    valued_property_offsets-->IK2_Count = 244;
    valued_property_offsets-->IK2_Link = 246;
    valued_property_offsets-->IK3_Count = 248;
    valued_property_offsets-->IK3_Link = 250;
    valued_property_offsets-->IK4_Count = 252;
    valued_property_offsets-->IK4_Link = 254;
    valued_property_offsets-->IK5_Count = 256;
    valued_property_offsets-->IK5_Link = 258;
    valued_property_offsets-->IK6_Count = 260;
    valued_property_offsets-->IK6_Link = 262;
    valued_property_offsets-->IK7_Count = 264;
    valued_property_offsets-->IK7_Link = 266;
    valued_property_offsets-->IK8_Count = 268;
    valued_property_offsets-->IK8_Link = 270;
    valued_property_offsets-->IK9_Count = 272;
    valued_property_offsets-->IK9_Link = 274;
    valued_property_offsets-->IK10_Count = 276;
    valued_property_offsets-->IK10_Link = 278;
    valued_property_offsets-->IK11_Count = 280;
    valued_property_offsets-->IK11_Link = 282;
    valued_property_offsets-->IK12_Count = 284;
    valued_property_offsets-->IK12_Link = 286;
    valued_property_offsets-->IK13_Count = 288;
    valued_property_offsets-->IK13_Link = 290;
    valued_property_offsets-->IK14_Count = 292;
    valued_property_offsets-->IK14_Link = 294;
    valued_property_offsets-->IK15_Count = 296;
    valued_property_offsets-->IK15_Link = 298;
    valued_property_offsets-->IK16_Count = 300;
    valued_property_offsets-->IK16_Link = 302;
    valued_property_offsets-->IK17_Count = 304;
    valued_property_offsets-->IK17_Link = 306;
    valued_property_offsets-->IK18_Count = 308;
    valued_property_offsets-->IK18_Link = 310;
    valued_property_offsets-->IK19_Count = 312;
    valued_property_offsets-->IK19_Link = 314;
    valued_property_offsets-->IK20_Count = 316;
    valued_property_offsets-->IK20_Link = 318;
    valued_property_offsets-->IK21_Count = 320;
    valued_property_offsets-->IK21_Link = 322;
    valued_property_offsets-->IK22_Count = 324;
    valued_property_offsets-->IK22_Link = 326;
    valued_property_offsets-->IK23_Count = 328;
    valued_property_offsets-->IK23_Link = 330;
    valued_property_offsets-->IK24_Count = 332;
    valued_property_offsets-->IK24_Link = 334;
    valued_property_offsets-->IK25_Count = 336;
    valued_property_offsets-->IK25_Link = 338;
    valued_property_offsets-->IK26_Count = 340;
    valued_property_offsets-->IK26_Link = 342;
    valued_property_offsets-->IK27_Count = 344;
    valued_property_offsets-->IK27_Link = 346;
    valued_property_offsets-->IK28_Count = 348;
    valued_property_offsets-->IK28_Link = 350;
    valued_property_offsets-->IK29_Count = 352;
    valued_property_offsets-->IK29_Link = 354;
    valued_property_offsets-->IK30_Count = 356;
    valued_property_offsets-->IK30_Link = 358;
    valued_property_offsets-->IK31_Count = 360;
    valued_property_offsets-->IK31_Link = 362;
    valued_property_offsets-->IK32_Count = 364;
    valued_property_offsets-->IK32_Link = 366;
    valued_property_offsets-->IK33_Count = 368;
    valued_property_offsets-->IK33_Link = 370;
    valued_property_offsets-->IK34_Count = 372;
    valued_property_offsets-->IK34_Link = 374;
    valued_property_offsets-->IK35_Count = 376;
    valued_property_offsets-->IK35_Link = 378;
    valued_property_offsets-->IK36_Count = 380;
    valued_property_offsets-->IK36_Link = 382;
    valued_property_offsets-->IK37_Count = 384;
    valued_property_offsets-->IK37_Link = 386;
    valued_property_offsets-->IK38_Count = 388;
    valued_property_offsets-->IK38_Link = 390;
    valued_property_offsets-->IK39_Count = 392;
    valued_property_offsets-->IK39_Link = 394;
    valued_property_offsets-->IK40_Count = 396;
    valued_property_offsets-->IK40_Link = 398;
    valued_property_offsets-->IK41_Count = 400;
    valued_property_offsets-->IK41_Link = 402;
    valued_property_offsets-->IK42_Count = 404;
    valued_property_offsets-->IK42_Link = 406;
    valued_property_offsets-->IK43_Count = 408;
    valued_property_offsets-->IK43_Link = 410;
    valued_property_offsets-->IK44_Count = 412;
    valued_property_offsets-->IK44_Link = 414;
    valued_property_offsets-->IK45_Count = 416;
    valued_property_offsets-->IK45_Link = 418;
    valued_property_offsets-->IK46_Count = 420;
    valued_property_offsets-->IK46_Link = 422;
    valued_property_offsets-->IK47_Count = 424;
    valued_property_offsets-->IK47_Link = 426;
    valued_property_offsets-->IK48_Count = 428;
    valued_property_offsets-->IK48_Link = 430;
    valued_property_offsets-->IK49_Count = 432;
    valued_property_offsets-->IK49_Link = 434;
    valued_property_offsets-->IK50_Count = 436;
    valued_property_offsets-->IK50_Link = 438;
    valued_property_offsets-->IK51_Count = 440;
    valued_property_offsets-->IK51_Link = 442;
    valued_property_offsets-->IK52_Count = 444;
    valued_property_offsets-->IK52_Link = 446;
    valued_property_offsets-->IK53_Count = 448;
    valued_property_offsets-->IK53_Link = 450;
    valued_property_offsets-->IK54_Count = 452;
    valued_property_offsets-->IK54_Link = 454;
    valued_property_offsets-->KD_Count = 456;
    valued_property_offsets-->name = 458;
    valued_property_offsets-->parse_name = 460;
    valued_property_offsets-->action_bitmap = 462;
];


Constant NUMBER_RULEBOOKS_CREATED = 573;
Constant V0_printing_the_name_of_some = 0;
Constant V1_printing_the_plural_name_ = 1;
Constant V2_printing_a_number_of_some = 2;
Constant V3_printing_room_description = 3;
Constant V4_listing_contents_of_somet = 4;
Constant V5_grouping_together_somethi = 5;
Constant V6_writing_a_paragraph_about = 6;
Constant V7_listing_nondescript_items = 7;
Constant V8_printing_the_name_of_a_da = 8;
Constant V9_printing_the_description_ = 9;
Constant V10_printing_the_announcemen = 10;
Constant V11_printing_the_announcemen = 11;
Constant V12_printing_a_refusal_to_ac = 12;
Constant V13_constructing_the_status_ = 13;
Constant V14_printing_the_banner_text = 14;
Constant V15_reading_a_command = 15;
Constant V16_deciding_the_scope_of_so = 16;
Constant V17_deciding_the_concealed_p = 17;
Constant V18_deciding_whether_all_inc = 18;
Constant V19_clarifying_the_parser_s_ = 19;
Constant V20_asking_which_do_you_mean = 20;
Constant V21_printing_a_parser_error = 21;
Constant V22_supplying_a_missing_noun = 22;
Constant V23_supplying_a_missing_seco = 23;
Constant V24_implicitly_taking_someth = 24;
Constant V25_starting_the_virtual_mac = 25;
Constant V26_amusing_a_victorious_pla = 26;
Constant V27_printing_the_player_s_ob = 27;
Constant V28_handling_the_final_quest = 28;
Constant V29_printing_the_locale_desc = 29;
Constant V30_choosing_notable_locale_ = 30;
Constant V31_printing_a_locale_paragr = 31;
Constant V32_displaying = 32;

Array Activity_before_rulebooks --> 29 32 35 38 41 44 47 50 53 56 59 62 65 68 71 74 77 80 83 86 89 92 95 98 101 104 107 110 113 116 119 122 385 NULL;

Array Activity_for_rulebooks --> 30 33 36 39 42 45 48 51 54 57 60 63 66 69 72 75 78 81 84 87 90 93 96 99 102 105 108 111 114 117 120 123 386 NULL;

Array Activity_after_rulebooks --> 31 34 37 40 43 46 49 52 55 58 61 64 67 70 73 76 79 82 85 88 91 94 97 100 103 106 109 112 115 118 121 124 387 NULL;

Array Activity_atb_rulebooks -> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 $ff;


Constant RELS_SYMMETRIC $8000;
Constant RELS_EQUIVALENCE $4000;
Constant RELS_X_UNIQUE $2000;
Constant RELS_Y_UNIQUE $1000;
Constant RELS_TEST $0800;
Constant RELS_ASSERT_TRUE $0400;
Constant RELS_ASSERT_FALSE $0200;
Constant RELS_SHOW $0100;
Constant RELS_ROUTE_FIND $0080;
Constant RELS_ROUTE_FIND_COUNT $0040;
Constant RELS_LOOKUP_ANY $0008;
Constant RELS_LOOKUP_ALL_X $0004;
Constant RELS_LOOKUP_ALL_Y $0002;
Constant RELS_LIST $0001;
#Iftrue (WORDSIZE == 2);
Constant REL_BLOCK_HEADER ($100*5 + $$1101);
#Ifnot;
Constant REL_BLOCK_HEADER ($100*6 + $$1101)*$10000;
#Endif;


[ PrintSceneName value;
    switch(value) {
        I66_entire_game: print "Entire Game";
        I92_uncle_vernon_s_scene: print "Uncle Vernon's Scene";
        I238_work: print "Work";
        I264_customercall: print "customercall";
        I276_mrmason_call: print "Mrmason call";
        I328_living_room_cut_scene: print "Living-room cut scene";
        default: print "<illegal scene>";
    }
];

[ A_PrintSceneName value;
    return (value % 6)+1;
];
[ B_PrintSceneName value;
    return ((value+4) % 6)+1;
];
[ R_PrintSceneName a b;
    if (a == 0 && b == 0) return (random(6));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ PrintFigureName value;
    switch(value) {
        I65_figure_of_cover: print "Figure of cover";
        default: print "<illegal figure name>";
    }
];

[ A_PrintFigureName value;
    return (value % 1)+1;
];
[ B_PrintFigureName value;
    return ((value+-1) % 1)+1;
];
[ R_PrintFigureName a b;
    if (a == 0 && b == 0) return (random(1));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ PrintSoundName value;
    switch(value) {
        I88_sound_of_intro_one: print "Sound of intro one";
        I89_sound_of_intro_two: print "Sound of intro two";
        I90_sound_of_intro_three: print "Sound of intro three";
        I91_sound_of_intro_four: print "Sound of intro four";
        default: print "<illegal sound name>";
    }
];

[ A_PrintSoundName value;
    return (value % 4)+1;
];
[ B_PrintSoundName value;
    return ((value+2) % 4)+1;
];
[ R_PrintSoundName a b;
    if (a == 0 && b == 0) return (random(4));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ PrintExternalFileName value;
    switch(value) {
        default: print "<illegal external file>";
    }
];

[ A_PrintExternalFileName value;
    return (value % 0)+1;
];
[ B_PrintExternalFileName value;
    return ((value+-2) % 0)+1;
];
[ R_PrintExternalFileName a b;
    if (a == 0 && b == 0) return (random(0));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ T57 value;
    switch(value) {
        I68_didn_t_understand_error: print "didn't understand error";
        I69_only_understood_as_far_a: print "only understood as far as error";
        I70_didn_t_understand_that_n: print "didn't understand that number error";
        I71_can_only_do_that_to_some: print "can only do that to something animate error";
        I72_can_t_see_any_such_thing: print "can't see any such thing error";
        I73_said_too_little_error: print "said too little error";
        I74_aren_t_holding_that_erro: print "aren't holding that error";
        I75_can_t_use_multiple_objec: print "can't use multiple objects error";
        I76_can_only_use_multiple_ob: print "can only use multiple objects error";
        I77_not_sure_what_it_refers_: print "not sure what it refers to error";
        I78_excepted_something_not_i: print "excepted something not included error";
        I79_not_a_verb_i_recognise_e: print "not a verb I recognise error";
        I80_not_something_you_need_t: print "not something you need to refer to error";
        I81_can_t_see_it_at_the_mome: print "can't see it at the moment error";
        I82_didn_t_understand_the_wa: print "didn't understand the way that finished error";
        I83_not_enough_of_those_avai: print "not enough of those available error";
        I84_nothing_to_do_error: print "nothing to do error";
        I85_noun_did_not_make_sense_: print "noun did not make sense in that context error";
        I86_referred_to_a_determinat: print "referred to a determination of scope error";
        I87_i_beg_your_pardon_error: print "I beg your pardon error";
        default: print "<illegal command parser error>";
    }
];

[ A_T57 value;
    return (value % 20)+1;
];
[ B_T57 value;
    return ((value+18) % 20)+1;
];
[ R_T57 a b;
    if (a == 0 && b == 0) return (random(20));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ T72 value;
    switch(value) {
        I111_implicit: print "implicit";
        I112_explicit: print "explicit";
        default: print "<illegal protocol type>";
    }
];

[ A_T72 value;
    return (value % 2)+1;
];
[ B_T72 value;
    return ((value+0) % 2)+1;
];
[ R_T72 a b;
    if (a == 0 && b == 0) return (random(2));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ T74 value;
    switch(value) {
        I115_seated: print "seated";
        I116_standing: print "standing";
        I117_reclining: print "reclining";
        default: print "<illegal posture>";
    }
];

[ A_T74 value;
    return (value % 3)+1;
];
[ B_T74 value;
    return ((value+1) % 3)+1;
];
[ R_T74 a b;
    if (a == 0 && b == 0) return (random(3));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ T90 value;
    switch(value) {
        I209_uneaten: print "uneaten";
        I210_half_eaten: print "half-eaten";
        I211_eaten: print "eaten";
        default: print "<illegal foodlevel>";
    }
];

[ A_T90 value;
    return (value % 3)+1;
];
[ B_T90 value;
    return ((value+1) % 3)+1;
];
[ R_T90 a b;
    if (a == 0 && b == 0) return (random(3));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ T93 value;
    switch(value) {
        I218_overflowing: print "overflowing";
        I219_half_empty: print "half-empty";
        I220_droplets: print "droplets";
        default: print "<illegal drinklevel>";
    }
];

[ A_T93 value;
    return (value % 3)+1;
];
[ B_T93 value;
    return ((value+1) % 3)+1;
];
[ R_T93 a b;
    if (a == 0 && b == 0) return (random(3));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ T96 value;
    switch(value) {
        I266_success: print "success";
        I267_failure: print "failure";
        I268_incomplete: print "incomplete";
        I269_pending: print "pending";
        I270_half_complete: print "half-complete";
        default: print "<illegal venture>";
    }
];

[ A_T96 value;
    return (value % 5)+1;
];
[ B_T96 value;
    return ((value+3) % 5)+1;
];
[ R_T96 a b;
    if (a == 0 && b == 0) return (random(5));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ T65 value which rem ran;
    if (value == 0) jump Use_LP_0;
    if ((value - 0) > 493) jump Use_LP_5;
    if ((value - 0) == 493) jump Use_LP_4;
    if ((value - 0) > 29) jump Use_LP_3;
    if ((value - 0) == 29) jump Use_LP_2;
    if ((value - 0) > 1) jump Use_LP_1;
    if ((value - 0) >= 1) jump Use_LP_0;
    jump Use_LP_0;
    return;

    ! 2 galleones, with offset=0, multiplier=493

    .Use_LP_5;
    rem = value%493;
    value = value/493;
    if ((value<0) && (value/1 == 0)) print "-";
    print value/1;
    if (value<0) value=-value;
    ! Ran is 1000, OM is 493
    if (rem > 0) {
        print ".";
        if (rem > 0) {
            ran = rem*10/493; print ran; rem = rem - ran*493/10;
        }
        if (rem > 0) {
            ran = rem*100/493; print ran; rem = rem - ran*493/100;
        }
        if (rem > 0) {
            ran = rem*1000/493; print ran; rem = rem - ran*493/1000;
        }
    }
    print " ";
    print "galleones";
    return;

    ! 1 galleone, with offset=0, multiplier=493

    .Use_LP_4;
    rem = value%493;
    value = value/493;
    if ((value<0) && (value/1 == 0)) print "-";
    print value/1;
    if (value<0) value=-value;
    ! Ran is 1000, OM is 493
    if (rem > 0) {
        print ".";
        if (rem > 0) {
            ran = rem*10/493; print ran; rem = rem - ran*493/10;
        }
        if (rem > 0) {
            ran = rem*100/493; print ran; rem = rem - ran*493/100;
        }
        if (rem > 0) {
            ran = rem*1000/493; print ran; rem = rem - ran*493/1000;
        }
    }
    print " ";
    print "galleone";
    return;

    ! 2 sicklees, with offset=0, multiplier=29

    .Use_LP_3;
    rem = value%29;
    value = value/29;
    if ((value<0) && (value/1 == 0)) print "-";
    print value/1;
    if (value<0) value=-value;
    ! Ran is 100, OM is 29
    if (rem > 0) {
        print ".";
        if (rem > 0) {
            ran = rem*10/29; print ran; rem = rem - ran*29/10;
        }
        if (rem > 0) {
            ran = rem*100/29; print ran; rem = rem - ran*29/100;
        }
    }
    print " ";
    print "sicklees";
    return;

    ! 1 sicklee, with offset=0, multiplier=29

    .Use_LP_2;
    rem = value%29;
    value = value/29;
    if ((value<0) && (value/1 == 0)) print "-";
    print value/1;
    if (value<0) value=-value;
    ! Ran is 100, OM is 29
    if (rem > 0) {
        print ".";
        if (rem > 0) {
            ran = rem*10/29; print ran; rem = rem - ran*29/10;
        }
        if (rem > 0) {
            ran = rem*100/29; print ran; rem = rem - ran*29/100;
        }
    }
    print " ";
    print "sicklee";
    return;

    ! 2 knutes, with offset=0, multiplier=1

    .Use_LP_1;
    if ((value<0) && (value/1 == 0)) print "-";
    print value/1;
    if (value<0) value=-value;
    ! Ran is 1, OM is 1
    if (rem > 0) {
        print ".";
        ran = 1;
        while ((rem % 10 == 0) && (rem > 0)) { rem=rem/10; ran=ran/10; }
        while (rem < ran/10) { print "0"; ran=ran/10; }
        print rem;
    }
    print " ";
    print "knutes";
    return;

    ! 1 knute, with offset=0, multiplier=1

    .Use_LP_0;
    if ((value<0) && (value/1 == 0)) print "-";
    print value/1;
    if (value<0) value=-value;
    ! Ran is 1, OM is 1
    if (rem > 0) {
        print ".";
        ran = 1;
        while ((rem % 10 == 0) && (rem > 0)) { rem=rem/10; ran=ran/10; }
        while (rem < ran/10) { print "0"; ran=ran/10; }
        print rem;
    }
    print " ";
    print "knute";
    return;
];

[ R_T65 a b;
    if (a == 0 && b == 0) return (random(MAX_POSITIVE_NUMBER));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ PrintKindValuePair k v;
    k = KindAtomic(k);
      switch(k) {
        2: print (DA_Number) v;
        3: print (DA_Number) v;
        4: print (DA_Number) v;
        5: print (DA_Number) v;
        6: print (DA_Number) v;
        7: print (DA_Number) v;
        8: print (DA_Number) v;
        9: print (PrintShortName) v;
        10: print (DecimalNumber) v;
        11: print (DA_TruthState) v;
        12: print (PrintText) v;
        13: print (INDEXED_TEXT_TY_Say) v;
        14: print (DecimalNumber) v;
        15: print (PrintUseOption) v;
        16: print (PrintSnippet) v;
        17: print (PrintTableName) v;
        18: print (DA_Number) v;
        19: print (RulebookOutcomePrintingRule) v;
        20: print (DecimalNumber) v;
        22: print (DecimalNumber) v;
        24: print (SayPhraseName) v;
        25: print (DecimalNumber) v;
        26: print (RELATION_TY_Say) v;
        27: print (RulePrintingRule) v;
        28: print (RulePrintingRule) v;
        29: print (DecimalNumber) v;
        30: print (LIST_OF_TY_Say) v;
        31: print (DecimalNumber) v;
        32: print (PROPERTY_TY_Say) v;
        33: print (DecimalNumber) v;
        34: print (COMBINATION_TY_Say) v;
        35: print (DecimalNumber) v;
        36: print (STORED_ACTION_TY_Say) v;
        37: print (SayActionName) v;
        38: print (PrintTimeOfDay) v;
        39: print (PrintSceneName) v;
        40: print (PrintFigureName) v;
        41: print (PrintSoundName) v;
        42: print (PrintExternalFileName) v;
        43: print (T57) v;
        44: print (T65) v;
        45: print (T72) v;
        46: print (T74) v;
        47: print (T90) v;
        48: print (T93) v;
        49: print (T96) v;
        default: print v;
    }
];
[ DefaultValueOfKOV sk k;
    k = KindAtomic(sk);
    switch(k) {
        9: return nothing;
        10: return 0;
        11: return false;
        12: return EMPTY_TEXT_VALUE;
        13: return BlkValueCreate(k, 0, sk);
        14: return 32;
        15: return 0;
        16: return 101;
        17: return TheEmptyTable;
        18: return 0;
        19: return ;
        20: return DefaultTopic;
        22: return ;
        24: return Default_Value_0;
        25: return ;
        26: return BlkValueCreate(k, 0, sk);
        27: return LITTLE_USED_DO_NOTHING_R;
        28: return 0;
        29: return PRINTING_THE_NAME_ACT;
        30: return BlkValueCreate(k, 0, sk);
        31: return Prop_Falsity;
        32: return ;
        33: return ;
        34: return BlkValueCreate(k, 0, sk);
        35: return ;
        36: return BlkValueCreate(k, 0, sk);
        37: return ##Wait;
        38: return 540;
        39: return I66_entire_game;
        40: return I65_figure_of_cover;
        41: return I88_sound_of_intro_one;
        42: return ;
        43: return I68_didn_t_understand_error;
        44: return 0;
        45: return I111_implicit;
        46: return I115_seated;
        47: return I209_uneaten;
        48: return I218_overflowing;
        49: return I266_success;
        default: return 0;
    }
];
[ KOVComparisonFunction k;
    k = KindAtomic(k);
    switch(k) {
        9: return UnsignedCompare;
        11: return UnsignedCompare;
        12: return UnsignedCompare;
        13: return BlkValueCompare;
        14: return UnsignedCompare;
        15: return UnsignedCompare;
        16: return UnsignedCompare;
        17: return UnsignedCompare;
        18: return UnsignedCompare;
        19: return UnsignedCompare;
        20: return UnsignedCompare;
        22: return UnsignedCompare;
        24: return UnsignedCompare;
        25: return UnsignedCompare;
        26: return BlkValueCompare;
        27: return UnsignedCompare;
        28: return UnsignedCompare;
        29: return UnsignedCompare;
        30: return BlkValueCompare;
        31: return UnsignedCompare;
        32: return UnsignedCompare;
        33: return UnsignedCompare;
        34: return BlkValueCompare;
        35: return UnsignedCompare;
        36: return BlkValueCompare;
        37: return UnsignedCompare;
        39: return UnsignedCompare;
        40: return UnsignedCompare;
        41: return UnsignedCompare;
        42: return UnsignedCompare;
        default: return 0;
    }
];
[ KOVDomainSize k;
    k = KindAtomic(k);
    switch(k) {
        39: return 6;
        40: return 1;
        41: return 4;
        42: return 0;
        43: return 20;
        45: return 2;
        46: return 3;
        47: return 3;
        48: return 3;
        49: return 5;
        default: return 0;
    }
];
[ KOVIsBlockValue k;
    k = KindAtomic(k);
    if (k == 13 or 26 or 30 or 34 or 36) rtrue;
    rfalse;
];
[ KOVSupportFunction k;
    k = KindAtomic(k);
    switch(k) {
        13: return INDEXED_TEXT_TY_Support;
        26: return RELATION_TY_Support;
        30: return LIST_OF_TY_Support;
        34: return COMBINATION_TY_Support;
        36: return STORED_ACTION_TY_Support;
    }
    rfalse;
];

[ I7_Kind_Name k;
    if (k == K1_room) print "room";
    if (k == K2_thing) print "thing";
    if (k == K3_direction) print "direction";
    if (k == K4_door) print "door";
    if (k == K5_container) print "container";
    if (k == K6_supporter) print "supporter";
    if (k == K7_backdrop) print "backdrop";
    if (k == K8_person) print "person";
    if (k == K9_region) print "region";
    if (k == K10_man) print "man";
    if (k == K11_woman) print "woman";
    if (k == K12_animal) print "animal";
    if (k == K13_device) print "device";
    if (k == K14_vehicle) print "vehicle";
    if (k == K15_player_s_holdall) print "player's holdall";
    if (k == K16_npcm) print "npcm";
    if (k == K17_npcf) print "npcf";
    if (k == K18_shirt) print "shirt";
    if (k == K19_pants) print "pants";
    if (k == K20_multiroad) print "multiroad";
    if (k == K21_rideable_animal) print "rideable animal";
    if (k == K22_rideable_vehicle) print "rideable vehicle";
    if (k == K23_wizard_coin) print "wizard coin";
    if (k == K24_knut) print "Knut";
    if (k == K25_sickle) print "sickle";
    if (k == K26_galleon) print "galleon";
    if (k == K27_number_unlockable) print "number unlockable";
    if (k == K28_subject) print "subject";
    if (k == K29_telephone) print "telephone";
    if (k == K30_clothing) print "clothing";
    if (k == K31_suit) print "suit";
    if (k == K32_muumuu) print "muumuu";
    if (k == K33_tutu) print "tutu";
    if (k == K34_tie) print "tie";
    if (k == K35_stairs) print "stairs";
    if (k == K36_paraphenalia) print "Paraphenalia";
    if (k == K37_bag) print "Bag";
    if (k == K38_sock) print "sock";
    if (k == K39_pencil) print "pencil";
    if (k == K40_broom) print "broom";
    if (k == K41_book) print "book";
    if (k == K42_toy) print "toy";
    if (k == K43_road) print "road";
    if (k == K44_food) print "food";
    if (k == K45_cup) print "cup";
    if (k == K46_piece_of_toast) print "piece of toast";
    if (k == K47_outdoors) print "outdoors";
    if (k == K48_person_in_cloak) print "person in cloak";
    if (k == K49_chair) print "chair";
    if (k == K50_writeable) print "writeable";
    if (k == K51_penquill) print "penquill";
    if (k == K52_small_roll) print "small roll";
    if (k == K53_pound_coin) print "pound coin";
    if (k == K54_photo) print "photo";
];

Constant RBNO_0 = "allow access";
Constant RBNO_1 = "deny access";
Constant RBNO_2 = "there is sufficient light";
Constant RBNO_3 = "there is insufficient light";
Constant RBNO_4 = "persuasion succeeds";
Constant RBNO_5 = "persuasion fails";
Constant RBNO_6 = "it is very likely";
Constant RBNO_7 = "it is likely";
Constant RBNO_8 = "it is possible";
Constant RBNO_9 = "it is unlikely";
Constant RBNO_10 = "it is very unlikely";
Constant RBNO_11 = "it does not";
Constant RBNO_12 = "it does";
[ RulebookOutcomePrintingRule rbno;
    print (string) rbno; rfalse;
];



Array KindHierarchy --> K0_kind (0) K1_room (0) K2_thing (0) K3_direction (0) K4_door (2) K5_container (2) K6_supporter (2) K7_backdrop (2) K8_person (2) K9_region (0) K10_man (8) K11_woman (8) K12_animal (8) K13_device (2) K14_vehicle (5) K15_player_s_holdall (5) K16_npcm (8) K17_npcf (11) K18_shirt (2) K19_pants (2) K20_multiroad (1) K21_rideable_animal (12) K22_rideable_vehicle (6) K23_wizard_coin (2) K24_knut (23) K25_sickle (23) K26_galleon (23) K27_number_unlockable (5) K28_subject (2) K29_telephone (2) K30_clothing (2) K31_suit (30) K32_muumuu (30) K33_tutu (30) K34_tie (30) K35_stairs (4) K36_paraphenalia (2) K37_bag (36) K38_sock (36) K39_pencil (36) K40_broom (22) K41_book (2) K42_toy (2) K43_road (1) K44_food (2) K45_cup (2) K46_piece_of_toast (44) K47_outdoors (1) K48_person_in_cloak (8) K49_chair (6) K50_writeable (2) K51_penquill (2) K52_small_roll (44) K53_pound_coin (2) K54_photo (2) ;
Constant IK1_First = I102_darknesss;
Constant IK2_First = I119_bedroomwindow;
Constant IK3_First = I46_north;
Constant IK4_First = I137_bedroomdoor;
Constant IK5_First = I120_bed;
Constant IK6_First = I131_bedside_table;
Constant IK7_First = nothing;
Constant IK8_First = I97_dursley;
Constant IK9_First = I99_dursley_s_house;
Constant IK10_First = nothing;
Constant IK11_First = I202_petunia;
Constant IK12_First = nothing;
Constant IK13_First = I144_tap1;
Constant IK14_First = I233_car;
Constant IK15_First = nothing;
Constant IK16_First = I221_dudley;
Constant IK17_First = I202_petunia;
Constant IK18_First = X204;
Constant IK19_First = X203;
Constant IK20_First = I200_garden;
Constant IK21_First = nothing;
Constant IK22_First = I183_lily_sbroom;
Constant IK23_First = nothing;
Constant IK24_First = nothing;
Constant IK25_First = nothing;
Constant IK26_First = nothing;
Constant IK27_First = I228_suitcase;
Constant IK28_First = nothing;
Constant IK29_First = I258_office_phone;
Constant IK30_First = I130_pyjamas;
Constant IK31_First = X134;
Constant IK32_First = X135;
Constant IK33_First = X136;
Constant IK34_First = nothing;
Constant IK35_First = I146_atticstairs;
Constant IK36_First = I154_few_bits_of_rubbish;
Constant IK37_First = X155;
Constant IK38_First = X158;
Constant IK39_First = X162;
Constant IK40_First = I183_lily_sbroom;
Constant IK41_First = I190_howto_spoil_your_childr;
Constant IK42_First = X187;
Constant IK43_First = I240_highway;
Constant IK44_First = X214;
Constant IK45_First = I216_coffee_cup;
Constant IK46_First = X214;
Constant IK47_First = nothing;
Constant IK48_First = nothing;
Constant IK49_First = I272_office_chair;
Constant IK50_First = I282_notepad;
Constant IK51_First = I284_pen;
Constant IK52_First = X296;
Constant IK53_First = X299;
Constant IK54_First = X313;
Constant No_Directions = 12;
! Table of direction object alias constants:
Constant DirectionObject_0 = I46_north;
Constant DirectionObject_1 = I47_northeast;
Constant DirectionObject_2 = I48_northwest;
Constant DirectionObject_3 = I49_south;
Constant DirectionObject_4 = I50_southeast;
Constant DirectionObject_5 = I51_southwest;
Constant DirectionObject_6 = I52_east;
Constant DirectionObject_7 = I53_west;
Constant DirectionObject_8 = I54_up;
Constant DirectionObject_9 = I55_down;
Constant DirectionObject_10 = in_obj;
Constant DirectionObject_11 = out_obj;
Array Map_Storage -->
 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I102_darknesss
 0 0 I137_bedroomdoor 0 0 0 0 0 0 0 0 0 ! Exits from: I118_dursley_s_bedroom
 0 I344_dudley_s_second_room_s_ I330_dudley_s_bedroom_door 0 I137_bedroomdoor 0 0 I350_bathroom I146_atticstairs I139_staircase 0 0 ! Exits from: I138_landing
 I149_broomcupboard_door I141_toilets 0 I318_living_room_door 0 I302_dining_room_door I232_front_door I197_kitchendoor I139_staircase 0 0 0 ! Exits from: I140_hall
 0 0 0 0 0 I140_hall 0 0 0 0 0 0 ! Exits from: I141_toilets
 0 0 0 0 0 0 0 0 0 I146_atticstairs 0 0 ! Exits from: I147_attic
 0 0 0 I149_broomcupboard_door 0 0 0 0 0 0 0 0 ! Exits from: I148_broomcupboard
 0 0 0 0 0 0 I197_kitchendoor 0 0 0 0 0 ! Exits from: I198_kitchen
 I240_highway 0 0 0 0 0 I355_privet_drive I232_front_door 0 0 0 0 ! Exits from: I200_garden
 0 0 0 I200_garden 0 0 I285_street I244_grunnings_carpark 0 0 0 0 ! Exits from: I240_highway
 0 0 0 0 0 0 I240_highway 0 I251_officestairs 0 0 0 ! Exits from: I244_grunnings_carpark
 I255_office_door 0 0 0 0 0 0 0 0 I251_officestairs 0 0 ! Exits from: I252_corridor
 0 0 0 I255_office_door 0 0 0 0 0 0 0 0 ! Exits from: I254_work_office
 0 0 0 0 0 0 I286_bakery_door I240_highway 0 0 0 0 ! Exits from: I285_street
 0 0 0 0 0 0 0 I286_bakery_door 0 0 0 0 ! Exits from: I287_bakers
 0 I302_dining_room_door 0 0 0 0 I303_door_from_dining_room_t 0 0 0 0 0 ! Exits from: I301_dining_room
 I318_living_room_door 0 0 0 0 0 0 I303_door_from_dining_room_t 0 0 0 0 ! Exits from: I304_living_room
 0 0 0 0 I330_dudley_s_bedroom_door 0 0 0 0 0 0 0 ! Exits from: I329_dudley_s_bedroom
 0 0 0 0 0 I344_dudley_s_second_room_s_ 0 0 0 0 0 0 ! Exits from: I343_dudley_s_second_room
 0 0 0 0 0 0 I138_landing 0 0 0 0 0 ! Exits from: I350_bathroom
 0 0 0 0 0 0 0 I200_garden 0 0 0 0 ! Exits from: I355_privet_drive
;

Class VPH_Class;
Array KOV_representatives --> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ValuePropertyHolder_39 0 0 0 0 0 0 0 0 0 0 ;
VPH_Class ValuePropertyHolder_39
    with value_range 6
    with p57_recurring KOVP_39_P57
    with description KOVP_39_P6
    with p80_venture KOVP_39_P80
;
! Storage for property p57_recurring of kind SCENE_TY
Array KOVP_39_P57 table 0 0 (true) (false) (false) (false) (false) (false) ;
! Storage for property description of kind SCENE_TY
Array KOVP_39_P6 table 0 0 (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) ;
! Storage for property p80_venture of kind SCENE_TY
Array KOVP_39_P80 table 0 0 (I268_incomplete) (I268_incomplete) (I268_incomplete) (I268_incomplete) (I268_incomplete) (I268_incomplete) ;
Class K0_kind 
    has ~pluralname
    has ~proper
    with short_name EMPTY_TEXT_VALUE
    with plural EMPTY_TEXT_VALUE
    with article EMPTY_TEXT_VALUE
;

Class K1_room 
    class K0_kind
    with description EMPTY_TEXT_VALUE
    with map_region nothing
    has ~privately_named
    has light
    has ~visited
    has p75_posture_friendly
;

Class K20_multiroad 
    class K1_room
;

Class K43_road 
    class K1_room
;

Class K47_outdoors 
    class K1_room
;

Class K2_thing 
    class K0_kind
    has ~privately_named
    has ~light
    has ~edible
    has ~static
    has ~concealed
    has ~workflag
    has mentioned
    has neuter
    has p62_medium
    has ~p64_ambiguously_plural
    has ~p67_seen
    has ~p69_familiar
    with component_parent nothing
    with component_child nothing
    with component_sibling nothing
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    has ~scenery
    has ~clothing
    has ~pushable
    has ~moved
    with description EMPTY_TEXT_VALUE
    with initial EMPTY_TEXT_VALUE
    with with_key nothing
    with p59_underlying nothing
    has ~p60_large
    has ~p61_small
    has ~p63_huge
    with p66_cost 0
;

Class K6_supporter 
    class K2_thing

    	has transparent supporter

    with plural "supporters"
    with capacity 100
    has static
    has ~enterable
    with p73_posture I115_seated
;

Class K22_rideable_vehicle 
    class K6_supporter

    	with before [; Go: return 1; ],

    with plural "rideable vehicles"
    has static
    has enterable
;

Class K40_broom 
    class K22_rideable_vehicle
    with plural "brooms"
    has ~static
    has ~p77_occupied
    with parse_name Parse_Name_GV143
;

Class K49_chair 
    class K6_supporter
    with plural "chairs"
    has enterable
;

Class K8_person 
    class K2_thing

    	has transparent animate
    	with before NULL,

    with plural "people"
    with capacity 100
    has ~female
    has ~neuter
    with p73_posture I116_standing
    with parse_name Parse_Name_GV145
    with p72_other_party nothing
;

Class K10_man 
    class K8_person
    with plural "men"
    has ~female
    has ~neuter
;

Class K11_woman 
    class K8_person
    with plural "women"
    has female
    has ~neuter
;

Class K17_npcf 
    class K11_woman
    with plural "npcfs"
;

Class K12_animal 
    class K8_person
    with plural "animals"
;

Class K21_rideable_animal 
    class K12_animal

    	has enterable supporter,
    	with before [; Go: return 1; ],

    with plural "rideable animals"
    has static
;

Class K16_npcm 
    class K8_person
    with plural "npcms"
;

Class K48_person_in_cloak 
    class K8_person
    with plural "people in cloaks"
;

Class K4_door 
    class K2_thing
     has door, 
    with plural "doors"
    with description text_routine_0
    with p13_openyesno 0
    has static
    has ~pushable
    has ~open
    has openable
    has ~lockable
    has ~locked
    with parse_name Parse_Name_GV135
    with door_to nothing
    with with_key nothing
;

Class K35_stairs 
    class K4_door
    with plural "stairss"
    has open
    has ~openable
    with parse_name Parse_Name_GV142
;

Class K5_container 
    class K2_thing
     has container, 
    with plural "containers"
    with capacity 100
    has ~transparent
    has open
    has ~openable
    has ~lockable
    has ~locked
    has ~enterable
    with with_key nothing
    with p73_posture I115_seated
;

Class K14_vehicle 
    class K5_container
    with plural "vehicles"
    has static
    has enterable
;

Class K15_player_s_holdall 
    class K5_container
    with plural "player's holdalls"
    has ~static
    has openable
;

Class K27_number_unlockable 
    class K5_container
    with plural "number unlockables"
    has ~open
    has openable
    has locked
;

Class K7_backdrop 
    class K2_thing
    with plural "backdrops"
    has static
    has scenery
    has ~pushable
;

Class K13_device 
    class K2_thing
     has switchable, 
    with plural "devices"
    has ~on
;

Class K18_shirt 
    class K2_thing
    with plural "shirts"
    has clothing
;

Class K19_pants 
    class K2_thing
    with plural "pantss"
    has clothing
;

Class K23_wizard_coin 
    class K2_thing
    with plural "wizard coins"
;

Class K24_knut 
    class K23_wizard_coin
    with plural "Knuts"
    with p66_cost 1
;

Class K25_sickle 
    class K23_wizard_coin
    with plural "sickles"
    with p66_cost 29
;

Class K26_galleon 
    class K23_wizard_coin
    with plural "galleons"
    with p66_cost 493
;

Class K28_subject 
    class K2_thing
    with plural "subjects"
    has p69_familiar
;

Class K29_telephone 
    class K2_thing
    with plural "telephones"
    has ~p71_inuse
    with parse_name Parse_Name_GV120
    with p14_calling_number 0
    with p15_owner selfobj
;

Class K30_clothing 
    class K2_thing
    with plural "clothings"
    has clothing
;

Class K31_suit 
    class K30_clothing
    with plural "suits"
    with parse_name Parse_Name_GV133
;

Class K32_muumuu 
    class K30_clothing
    with plural "muumuus"
;

Class K33_tutu 
    class K30_clothing
    with plural "tutus"
;

Class K34_tie 
    class K30_clothing
    with plural "ties"
;

Class K36_paraphenalia 
    class K2_thing
    with plural "Paraphenalias"
;

Class K37_bag 
    class K36_paraphenalia
    with plural "bags"
;

Class K38_sock 
    class K36_paraphenalia
    with plural "socks"
;

Class K39_pencil 
    class K36_paraphenalia
    with plural "pencils"
    with description SC_4
;

Class K41_book 
    class K2_thing
    with plural "books"
    with description SC_5
;

Class K42_toy 
    class K2_thing
    with plural "toys"
    with description text_routine_1
;

Class K44_food 
    class K2_thing
    with plural "foods"
    has edible
    with p78_foodlevel I209_uneaten
;

Class K46_piece_of_toast 
    class K44_food
    with plural "pieces of toast"
    with description text_routine_2
;

Class K52_small_roll 
    class K44_food
    with plural "small rolls"
;

Class K45_cup 
    class K2_thing
    with plural "cups"
    with p79_drinklevel I218_overflowing
;

Class K50_writeable 
    class K2_thing
    with plural "writeables"
;

Class K51_penquill 
    class K2_thing
    with plural "penquills"
;

Class K53_pound_coin 
    class K2_thing
    with plural "pound coins"
    with parse_name Parse_Name_GV194
;

Class K54_photo 
    class K2_thing
    with plural "photos"
    with description SC_6
;

Class K9_region 
    class K0_kind
    with plural "regions"
    has ~privately_named
;

Class K3_direction 
    class K0_kind

    	has scenery, ! class CompassDirection,

    with plural "directions"
    has ~privately_named
    has ~workflag
    with p9_opposite I46_north
;

Object I46_north "" Compass
    class K3_direction
    with short_name "north"
    with article SC_7
    with p9_opposite I49_south
    with vector 0
    with list_together 0
    with IK3_Count 0
    with IK3_Link I47_northeast
    with KD_Count 3
    with name 'north' 'n//' 
    with parse_name Parse_Name_GV1
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I47_northeast "" Compass
    class K3_direction
    with short_name "northeast"
    with article SC_7
    with p9_opposite I51_southwest
    with vector 0
    with list_together 0
    with IK3_Count 1
    with IK3_Link I48_northwest
    with KD_Count 3
    with name 'northeast' 'ne' 
    with parse_name Parse_Name_GV2
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I48_northwest "" Compass
    class K3_direction
    with short_name "northwest"
    with article SC_7
    with p9_opposite I50_southeast
    with vector 0
    with list_together 0
    with IK3_Count 2
    with IK3_Link I49_south
    with KD_Count 3
    with name 'northwest' 'nw' 
    with parse_name Parse_Name_GV3
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I49_south "" Compass
    class K3_direction
    with short_name "south"
    with article SC_7
    with p9_opposite I46_north
    with vector 0
    with list_together 0
    with IK3_Count 3
    with IK3_Link I50_southeast
    with KD_Count 3
    with name 'south' 's//' 
    with parse_name Parse_Name_GV4
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I50_southeast "" Compass
    class K3_direction
    with short_name "southeast"
    with article SC_7
    with p9_opposite I48_northwest
    with vector 0
    with list_together 0
    with IK3_Count 4
    with IK3_Link I51_southwest
    with KD_Count 3
    with name 'southeast' 'se' 
    with parse_name Parse_Name_GV5
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I51_southwest "" Compass
    class K3_direction
    with short_name "southwest"
    with article SC_7
    with p9_opposite I47_northeast
    with vector 0
    with list_together 0
    with IK3_Count 5
    with IK3_Link I52_east
    with KD_Count 3
    with name 'southwest' 'sw' 
    with parse_name Parse_Name_GV6
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I52_east "" Compass
    class K3_direction
    with short_name "east"
    with article SC_7
    with p9_opposite I53_west
    with vector 0
    with list_together 0
    with IK3_Count 6
    with IK3_Link I53_west
    with KD_Count 3
    with name 'east' 'e//' 
    with parse_name Parse_Name_GV7
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I53_west "" Compass
    class K3_direction
    with short_name "west"
    with article SC_7
    with p9_opposite I52_east
    with vector 0
    with list_together 0
    with IK3_Count 7
    with IK3_Link I54_up
    with KD_Count 3
    with name 'west' 'w//' 
    with parse_name Parse_Name_GV8
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I54_up "" Compass
    class K3_direction
    with short_name "up"
    with article SC_7
    with p9_opposite I55_down
    with vector 0
    with list_together 0
    with IK3_Count 8
    with IK3_Link I55_down
    with KD_Count 3
    with name 'up' 'u//' 
    with parse_name Parse_Name_GV9
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I55_down "" Compass
    class K3_direction
    with short_name "down"
    with article SC_7
    with p9_opposite I54_up
    with vector 0
    with list_together 0
    with IK3_Count 9
    with IK3_Link in_obj
    with KD_Count 3
    with name 'down' 'd//' 
    with parse_name Parse_Name_GV10
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object in_obj "" Compass
    class K3_direction
    with short_name "inside"
    with article SC_7
    with p9_opposite out_obj
    with vector 0
    with list_together 0
    with IK3_Count 10
    with IK3_Link out_obj
    with KD_Count 3
    with name 'inside' 'in' 
    with parse_name Parse_Name_GV11
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object out_obj "" Compass
    class K3_direction
    with short_name "outside"
    with article SC_7
    with p9_opposite in_obj
    with vector 0
    with list_together 0
    with IK3_Count 11
    with IK3_Link nothing
    with KD_Count 3
    with name 'outside' 'out' 
    with parse_name Parse_Name_GV12
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object selfobj ""
    class K8_person

    	with saved_short_name "yourself",
     
    with short_name "yourself"
    with description SC_8
    has proper
    has concealed
    with vector 0
    with list_together 0
    with cap_short_name "Yourself"
    has mark_as_thing
    with IK2_Count 0
    with IK2_Link I119_bedroomwindow
    with IK8_Count 0
    with IK8_Link I97_dursley
    with KD_Count 8
    with name 'yourself' 'bye' 'bros' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I99_dursley_s_house ""
    class K9_region
    with short_name "Dursley's house"
    with vector 0
    with list_together 0
    with regional_found_in [; if (TestRegionalContainment(location, I99_dursley_s_house)) rtrue; rfalse; ],
    with IK9_Count 0
    with IK9_Link I239_grunnings
    with KD_Count 9
    with name 'dursley^s' 'house' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I102_darknesss ""
    class K1_room
    with short_name SC_9
    with description SC_10
    has proper
    has ~light
    with vector 0
    with room_index -1
    with list_together 0
    has mark_as_room
    with IK1_Count 0
    with IK1_Link I118_dursley_s_bedroom
    with KD_Count 1
    with name 'darknesss' 
;

Object I118_dursley_s_bedroom ""
    class K1_room
    with short_name "Dursley's bedroom"
    with description SC_11
    with map_region I99_dursley_s_house
    has proper
    has ~light
    with vector 0
    with room_index -1
    with list_together 0
    with cap_short_name "Dursley's bedroom"
    has mark_as_room
    with IK1_Count 1
    with IK1_Link I138_landing
    with KD_Count 1
    with name 'dursley^s' 'bedroom' 
;

Object -> I119_bedroomwindow ""
    class K2_thing
    with short_name SC_12
    with description SC_13
    has proper
    has light
    has static
    has ~concealed
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 2
    with IK2_Link I120_bed
    with KD_Count 2
    with name 'bedroomwindow' 'window' 
    with parse_name Parse_Name_GV126
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I120_bed ""
    class K5_container
    with short_name "bed"
    has proper
    has static
    has enterable
    has open
    has p60_large
    with vector 0
    with list_together 0
    with cap_short_name "Bed"
    has mark_as_thing
    with IK2_Count 3
    with IK2_Link I97_dursley
    with IK5_Count 0
    with IK5_Link I123_wardrobe
    with KD_Count 5
    with name 'bed' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> I97_dursley ""
    class K8_person
    with short_name "dursley"
    with description SC_14
    has proper
    has p63_huge
    with vector 0
    with list_together 0
    with cap_short_name "Dursley"
    has mark_as_thing
    with IK2_Count 1
    with IK2_Link I130_pyjamas
    with IK8_Count 1
    with IK8_Link I202_petunia
    with KD_Count 8
    with name 'dursley' 'vernon' 'bye' 'bros' 
    with parse_name Parse_Name_GV129
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> -> I130_pyjamas ""
    class K30_clothing
    with short_name "Pyjamas"
    has proper
    has clothing
    has worn
    with vector 0
    with list_together 0
    with cap_short_name "Pyjamas"
    has mark_as_thing
    with IK2_Count 8
    with IK2_Link I122_clock
    with IK30_Count 1
    with IK30_Link I127_wizards_robes
    with KD_Count 30
    with name 'pyjamas' 'pj^s' 
    with parse_name Parse_Name_GV127
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I122_clock ""
    class K2_thing
    with short_name "clock"
    with description text_routine_3
    has static
    has p61_small
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 5
    with IK2_Link I123_wardrobe
    with KD_Count 2
    with name 'clock' 'time' 
    with parse_name Parse_Name_GV130
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I123_wardrobe ""
    class K5_container
    with short_name "Wardrobe"
    with description SC_15
    has proper
    has static
    has ~open
    has openable
    has p60_large
    with vector 0
    with list_together 0
    with cap_short_name "Wardrobe"
    has mark_as_thing
    with IK2_Count 6
    with IK2_Link I121_mirror
    with IK5_Count 1
    with IK5_Link I132_bedside_drawer
    with KD_Count 5
    with name 'wardrobe' 'cupboard' 
    with parse_name Parse_Name_GV132
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> I121_mirror ""
    class K2_thing
    with short_name "mirror"
    with description text_routine_4
    has static
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 4
    with IK2_Link I127_wizards_robes
    with KD_Count 2
    with name 'mirror' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> I127_wizards_robes ""
    class K30_clothing
    with short_name "wizards robes"
    has proper
    with vector 0
    with list_together 0
    with cap_short_name "Wizards robes"
    has mark_as_thing
    with IK2_Count 7
    with IK2_Link X134
    with IK30_Count 0
    with IK30_Link X134
    with KD_Count 30
    with name 'wizards' 'robes' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> X134 ""
    class K31_suit
    with short_name "suit"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 12
    with IK2_Link X135
    with IK30_Count 2
    with IK30_Link X135
    with IK31_Count 0
    with IK31_Link nothing
    with KD_Count 31
    with name 'suit' 'suits//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> X135 ""
    class K32_muumuu
    with short_name "muumuu"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 13
    with IK2_Link X136
    with IK30_Count 3
    with IK30_Link X136
    with IK32_Count 0
    with IK32_Link nothing
    with KD_Count 32
    with name 'muumuu' 'muumuus//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> X136 ""
    class K33_tutu
    with short_name "tutu"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 14
    with IK2_Link I131_bedside_table
    with IK30_Count 4
    with IK30_Link nothing
    with IK33_Count 0
    with IK33_Link nothing
    with KD_Count 33
    with name 'tutu' 'tutus//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I131_bedside_table ""
    class K6_supporter
    with short_name "bedside table"
    with description SC_16
    has proper
    has p62_medium
    with vector 0
    with list_together 0
    with cap_short_name "Bedside table"
    has mark_as_thing
    with component_child I132_bedside_drawer
    with IK2_Count 9
    with IK2_Link I132_bedside_drawer
    with IK6_Count 0
    with IK6_Link I183_lily_sbroom
    with KD_Count 6
    with name 'bedside' 'table' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I132_bedside_drawer ""
    class K5_container
    with short_name "bedside drawer"
    has proper
    has ~open
    has openable
    has p61_small
    with vector 0
    with list_together 0
    with cap_short_name "Bedside drawer"
    has mark_as_thing
    with component_parent I131_bedside_table
    with IK2_Count 10
    with IK2_Link I133_scrap_of_paper
    with IK5_Count 2
    with IK5_Link I184_dusty_box
    with KD_Count 5
    with name 'bedside' 'drawer' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I133_scrap_of_paper ""
    class K2_thing
    with short_name "scrap of paper"
    with description text_routine_5
    has p61_small
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 11
    with IK2_Link I137_bedroomdoor
    with KD_Count 2
    with name 'scrap' 'of' 'paper' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I137_bedroomdoor ""
    class K4_door
    with short_name SC_17
    has proper
    has ~open
    has openable
    with vector 0
    with door_dir [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I138_landing) return I50_southeast; return I48_northwest; ],
    with door_to [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I138_landing) return I118_dursley_s_bedroom; return I138_landing; ],
    with found_in I138_landing I118_dursley_s_bedroom
    with list_together 0
    has mark_as_thing
    with IK2_Count 15
    with IK2_Link I139_staircase
    with IK4_Count 0
    with IK4_Link I139_staircase
    with KD_Count 4
    with name 'bedroomdoor' 'bedroom' 'door' 
    with parse_name Parse_Name_GV134
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I138_landing ""
    class K1_room
    with short_name "Landing"
    with description SC_18
    with map_region I99_dursley_s_house
    has proper
    with vector 0
    with room_index -1
    with list_together 0
    with cap_short_name "Landing"
    has mark_as_room
    with IK1_Count 2
    with IK1_Link I140_hall
    with KD_Count 1
    with name 'landing' 
;

Object I139_staircase ""
    class K4_door
    with short_name SC_19
    has proper
    has open
    has ~openable
    with vector 0
    with door_dir [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I138_landing) return I55_down; return I54_up; ],
    with door_to [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I138_landing) return I140_hall; return I138_landing; ],
    with found_in I138_landing I140_hall
    with list_together 0
    has mark_as_thing
    with IK2_Count 16
    with IK2_Link I142_toilet1
    with IK4_Count 1
    with IK4_Link I146_atticstairs
    with KD_Count 4
    with name 'staircase' 'door' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I140_hall ""
    class K1_room
    with short_name "Hall"
    with description SC_20
    with map_region I99_dursley_s_house
    has proper
    with vector 0
    with room_index -1
    with list_together 0
    with cap_short_name "Hall"
    has mark_as_room
    with IK1_Count 3
    with IK1_Link I141_toilets
    with KD_Count 1
    with name 'hall' 
;

Object I141_toilets ""
    class K1_room
    with short_name SC_21
    with description SC_22
    with map_region I99_dursley_s_house
    has proper
    with vector 0
    with room_index -1
    with list_together 0
    has mark_as_room
    with IK1_Count 4
    with IK1_Link I147_attic
    with KD_Count 1
    with name 'toilets' 
;

Object -> I142_toilet1 ""
    class K2_thing
    with short_name SC_21
    with description SC_23
    has proper
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 17
    with IK2_Link I143_sink1
    with KD_Count 2
    with name 'toilet1' 'toilet' 
    with parse_name Parse_Name_GV136
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I143_sink1 ""
    class K2_thing
    with short_name SC_24
    with description SC_25
    has proper
    with vector 0
    with list_together 0
    has mark_as_thing
    with component_child I144_tap1
    with IK2_Count 18
    with IK2_Link I144_tap1
    with KD_Count 2
    with name 'sink1' 'sink' 
    with parse_name Parse_Name_GV137
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I144_tap1 ""
    class K13_device
    with short_name SC_26
    has proper
    with vector 0
    with list_together 0
    has mark_as_thing
    with component_parent I143_sink1
    with IK2_Count 19
    with IK2_Link I146_atticstairs
    with IK13_Count 0
    with IK13_Link I236_light_switch
    with KD_Count 13
    with name 'tap1' 'tap' 'faucet' 
    with parse_name Parse_Name_GV138
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I146_atticstairs ""
    class K35_stairs
    with short_name text_routine_6
    has proper
    has ~open
    has openable
    with vector 0
    with door_dir [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I147_attic) return I55_down; return I54_up; ],
    with door_to [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I147_attic) return I138_landing; return I147_attic; ],
    with found_in I147_attic I138_landing
    with list_together 0
    has mark_as_thing
    with IK2_Count 20
    with IK2_Link I184_dusty_box
    with IK4_Count 2
    with IK4_Link I149_broomcupboard_door
    with IK35_Count 0
    with IK35_Link I251_officestairs
    with KD_Count 35
    with name 'atticstairs' 'panel' 'stairs' 'door' 
    with parse_name Parse_Name_GV139
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I147_attic ""
    class K1_room
    with short_name "attic"
    with description text_routine_7
    with map_region I99_dursley_s_house
    with vector 0
    with room_index -1
    with list_together 0
    has mark_as_room
    with IK1_Count 5
    with IK1_Link I148_broomcupboard
    with KD_Count 1
    with name 'attic' 
;

Object -> I184_dusty_box ""
    class K5_container
    with short_name "dusty box"
    has proper
    has static
    has ~open
    has openable
    has p62_medium
    with vector 0
    with list_together 0
    with cap_short_name "Dusty box"
    has mark_as_thing
    with IK2_Count 51
    with IK2_Link X187
    with IK5_Count 3
    with IK5_Link I222_fridge
    with KD_Count 5
    with name 'dusty' 'box' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> X187 ""
    class K42_toy
    with short_name "toy"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 52
    with IK2_Link X188
    with IK42_Count 0
    with IK42_Link X188
    with KD_Count 42
    with name 'toy' 'toys//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> X188 ""
    class K42_toy
    with short_name "toy"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 53
    with IK2_Link X189
    with IK42_Count 1
    with IK42_Link X189
    with KD_Count 42
    with name 'toy' 'toys//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> X189 ""
    class K42_toy
    with short_name "toy"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 54
    with IK2_Link I190_howto_spoil_your_childr
    with IK42_Count 2
    with IK42_Link X334
    with KD_Count 42
    with name 'toy' 'toys//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> I190_howto_spoil_your_childr ""
    class K41_book
    with short_name SC_27
    with description SC_28
    has proper
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 55
    with IK2_Link I191_drills__an_unabridged_h
    with IK41_Count 0
    with IK41_Link I191_drills__an_unabridged_h
    with KD_Count 41
    with name 'howto' 'spoil' 'your' 'children' 'handbook' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> I191_drills__an_unabridged_h ""
    class K41_book
    with short_name "drills- an unabridged history"
    with description SC_29
    has proper
    with vector 0
    with list_together 0
    with cap_short_name "Drills- an unabridged history"
    has mark_as_thing
    with IK2_Count 56
    with IK2_Link I192_101_pompous_complaints
    with IK41_Count 1
    with IK41_Link I192_101_pompous_complaints
    with KD_Count 41
    with name 'drills-' 'an' 'unabridged' 'history' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> I192_101_pompous_complaints ""
    class K41_book
    with short_name "101 Pompous Complaints"
    with description SC_30
    has proper
    with vector 0
    with list_together 0
    with cap_short_name "101 Pompous Complaints"
    has mark_as_thing
    with IK2_Count 57
    with IK2_Link I193_high_calorie_cookbook
    with IK41_Count 2
    with IK41_Link I193_high_calorie_cookbook
    with KD_Count 41
    with name '101' 'pompous' 'complaints' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> I193_high_calorie_cookbook ""
    class K41_book
    with short_name "High calorie cookbook"
    with description SC_31
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 58
    with IK2_Link I194_smeltings_schoolbook
    with IK41_Count 3
    with IK41_Link I194_smeltings_schoolbook
    with KD_Count 41
    with name 'high' 'calorie' 'cookbook' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> I194_smeltings_schoolbook ""
    class K41_book
    with short_name "smeltings schoolbook"
    with description text_routine_8
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 59
    with IK2_Link I195_petunia_s_diary
    with IK41_Count 4
    with IK41_Link I195_petunia_s_diary
    with KD_Count 41
    with name 'smeltings' 'schoolbook' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I195_petunia_s_diary ""
    class K41_book
    with short_name "Petunia's diary"
    with description text_routine_9
    has proper
    with vector 0
    with list_together 0
    with cap_short_name "Petunia's diary"
    has mark_as_thing
    with IK2_Count 60
    with IK2_Link I154_few_bits_of_rubbish
    with IK41_Count 5
    with IK41_Link X346
    with KD_Count 41
    with name 'petunia^s' 'diary' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I148_broomcupboard ""
    class K1_room
    with short_name SC_32
    with description text_routine_10
    with map_region I99_dursley_s_house
    has proper
    with vector 0
    with room_index -1
    with list_together 0
    has mark_as_room
    with IK1_Count 6
    with IK1_Link I198_kitchen
    with KD_Count 1
    with name 'broomcupboard' 'cupboard' 
    with parse_name Parse_Name_GV144
;

Object -> I154_few_bits_of_rubbish ""
    class K36_paraphenalia
    with short_name "few bits of rubbish"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 22
    with IK2_Link X155
    with IK36_Count 0
    with IK36_Link X155
    with KD_Count 36
    with name 'few' 'bits' 'of' 'rubbish' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X155 ""
    class K37_bag
    with short_name "Bag"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 23
    with IK2_Link X156
    with IK36_Count 1
    with IK36_Link X156
    with IK37_Count 0
    with IK37_Link X156
    with KD_Count 37
    with name 'bag' 'bags//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X156 ""
    class K37_bag
    with short_name "Bag"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 24
    with IK2_Link X157
    with IK36_Count 2
    with IK36_Link X157
    with IK37_Count 1
    with IK37_Link X157
    with KD_Count 37
    with name 'bag' 'bags//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X157 ""
    class K37_bag
    with short_name "Bag"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 25
    with IK2_Link X158
    with IK36_Count 3
    with IK36_Link X158
    with IK37_Count 2
    with IK37_Link nothing
    with KD_Count 37
    with name 'bag' 'bags//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X158 ""
    class K38_sock
    with short_name "sock"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 26
    with IK2_Link X159
    with IK36_Count 4
    with IK36_Link X159
    with IK38_Count 0
    with IK38_Link X159
    with KD_Count 38
    with name 'sock' 'socks//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X159 ""
    class K38_sock
    with short_name "sock"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 27
    with IK2_Link X160
    with IK36_Count 5
    with IK36_Link X160
    with IK38_Count 1
    with IK38_Link X160
    with KD_Count 38
    with name 'sock' 'socks//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X160 ""
    class K38_sock
    with short_name "sock"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 28
    with IK2_Link X161
    with IK36_Count 6
    with IK36_Link X161
    with IK38_Count 2
    with IK38_Link X161
    with KD_Count 38
    with name 'sock' 'socks//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X161 ""
    class K38_sock
    with short_name "sock"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 29
    with IK2_Link X162
    with IK36_Count 7
    with IK36_Link X162
    with IK38_Count 3
    with IK38_Link nothing
    with KD_Count 38
    with name 'sock' 'socks//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X162 ""
    class K39_pencil
    with short_name "pencil"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 30
    with IK2_Link X163
    with IK36_Count 8
    with IK36_Link X163
    with IK39_Count 0
    with IK39_Link X163
    with KD_Count 39
    with name 'pencil' 'pencils//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X163 ""
    class K39_pencil
    with short_name "pencil"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 31
    with IK2_Link X164
    with IK36_Count 9
    with IK36_Link X164
    with IK39_Count 1
    with IK39_Link X164
    with KD_Count 39
    with name 'pencil' 'pencils//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X164 ""
    class K39_pencil
    with short_name "pencil"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 32
    with IK2_Link X165
    with IK36_Count 10
    with IK36_Link X165
    with IK39_Count 2
    with IK39_Link X165
    with KD_Count 39
    with name 'pencil' 'pencils//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X165 ""
    class K39_pencil
    with short_name "pencil"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 33
    with IK2_Link X166
    with IK36_Count 11
    with IK36_Link X166
    with IK39_Count 3
    with IK39_Link X166
    with KD_Count 39
    with name 'pencil' 'pencils//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X166 ""
    class K39_pencil
    with short_name "pencil"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 34
    with IK2_Link X167
    with IK36_Count 12
    with IK36_Link X167
    with IK39_Count 4
    with IK39_Link X167
    with KD_Count 39
    with name 'pencil' 'pencils//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X167 ""
    class K39_pencil
    with short_name "pencil"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 35
    with IK2_Link X168
    with IK36_Count 13
    with IK36_Link X168
    with IK39_Count 5
    with IK39_Link X168
    with KD_Count 39
    with name 'pencil' 'pencils//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X168 ""
    class K39_pencil
    with short_name "pencil"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 36
    with IK2_Link X169
    with IK36_Count 14
    with IK36_Link X169
    with IK39_Count 6
    with IK39_Link X169
    with KD_Count 39
    with name 'pencil' 'pencils//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X169 ""
    class K39_pencil
    with short_name "pencil"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 37
    with IK2_Link X170
    with IK36_Count 15
    with IK36_Link X170
    with IK39_Count 7
    with IK39_Link X170
    with KD_Count 39
    with name 'pencil' 'pencils//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X170 ""
    class K39_pencil
    with short_name "pencil"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 38
    with IK2_Link X171
    with IK36_Count 16
    with IK36_Link X171
    with IK39_Count 8
    with IK39_Link X171
    with KD_Count 39
    with name 'pencil' 'pencils//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X171 ""
    class K39_pencil
    with short_name "pencil"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 39
    with IK2_Link X172
    with IK36_Count 17
    with IK36_Link X172
    with IK39_Count 9
    with IK39_Link X172
    with KD_Count 39
    with name 'pencil' 'pencils//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X172 ""
    class K39_pencil
    with short_name "pencil"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 40
    with IK2_Link X173
    with IK36_Count 18
    with IK36_Link X173
    with IK39_Count 10
    with IK39_Link X173
    with KD_Count 39
    with name 'pencil' 'pencils//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X173 ""
    class K39_pencil
    with short_name "pencil"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 41
    with IK2_Link X174
    with IK36_Count 19
    with IK36_Link X174
    with IK39_Count 11
    with IK39_Link X174
    with KD_Count 39
    with name 'pencil' 'pencils//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X174 ""
    class K39_pencil
    with short_name "pencil"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 42
    with IK2_Link X175
    with IK36_Count 20
    with IK36_Link X175
    with IK39_Count 12
    with IK39_Link X175
    with KD_Count 39
    with name 'pencil' 'pencils//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X175 ""
    class K39_pencil
    with short_name "pencil"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 43
    with IK2_Link X176
    with IK36_Count 21
    with IK36_Link X176
    with IK39_Count 13
    with IK39_Link X176
    with KD_Count 39
    with name 'pencil' 'pencils//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X176 ""
    class K39_pencil
    with short_name "pencil"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 44
    with IK2_Link X177
    with IK36_Count 22
    with IK36_Link X177
    with IK39_Count 14
    with IK39_Link X177
    with KD_Count 39
    with name 'pencil' 'pencils//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X177 ""
    class K39_pencil
    with short_name "pencil"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 45
    with IK2_Link X178
    with IK36_Count 23
    with IK36_Link X178
    with IK39_Count 15
    with IK39_Link X178
    with KD_Count 39
    with name 'pencil' 'pencils//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X178 ""
    class K39_pencil
    with short_name "pencil"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 46
    with IK2_Link X179
    with IK36_Count 24
    with IK36_Link X179
    with IK39_Count 16
    with IK39_Link X179
    with KD_Count 39
    with name 'pencil' 'pencils//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X179 ""
    class K39_pencil
    with short_name "pencil"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 47
    with IK2_Link X180
    with IK36_Count 25
    with IK36_Link X180
    with IK39_Count 17
    with IK39_Link X180
    with KD_Count 39
    with name 'pencil' 'pencils//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X180 ""
    class K39_pencil
    with short_name "pencil"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 48
    with IK2_Link X181
    with IK36_Count 26
    with IK36_Link X181
    with IK39_Count 18
    with IK39_Link X181
    with KD_Count 39
    with name 'pencil' 'pencils//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X181 ""
    class K39_pencil
    with short_name "pencil"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 49
    with IK2_Link I183_lily_sbroom
    with IK36_Count 27
    with IK36_Link nothing
    with IK39_Count 19
    with IK39_Link nothing
    with KD_Count 39
    with name 'pencil' 'pencils//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I183_lily_sbroom ""
    class K40_broom
    with short_name SC_33
    with description text_routine_11
    has proper
    has p60_large
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 50
    with IK2_Link I149_broomcupboard_door
    with IK6_Count 1
    with IK6_Link I205_highchair
    with IK22_Count 0
    with IK22_Link nothing
    with IK40_Count 0
    with IK40_Link nothing
    with KD_Count 40
    with name 'lily^sbroom' 'broomstick' 'broom' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I149_broomcupboard_door ""
    class K4_door
    with short_name SC_34
    has proper
    with vector 0
    with door_dir [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I148_broomcupboard) return I49_south; return I46_north; ],
    with door_to [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I148_broomcupboard) return I140_hall; return I148_broomcupboard; ],
    with found_in I148_broomcupboard I140_hall
    with list_together 0
    has mark_as_thing
    with IK2_Count 21
    with IK2_Link I196_letter
    with IK4_Count 3
    with IK4_Link I197_kitchendoor
    with KD_Count 4
    with name 'broomcupboard' 'door' 'door' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I196_letter ""
    class K2_thing
    with short_name "letter"
    with description text_routine_12
    has proper
    has p61_small
    with vector 0
    with list_together 0
    with cap_short_name "Letter"
    has mark_as_thing
    with IK2_Count 61
    with IK2_Link I197_kitchendoor
    with KD_Count 2
    with name 'letter' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I197_kitchendoor ""
    class K4_door
    with short_name text_routine_13
    has proper
    has open
    has openable
    with vector 0
    with door_dir [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I140_hall) return I53_west; return I52_east; ],
    with door_to [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I140_hall) return I198_kitchen; return I140_hall; ],
    with found_in I140_hall I198_kitchen
    with list_together 0
    has mark_as_thing
    with IK2_Count 62
    with IK2_Link I202_petunia
    with IK4_Count 4
    with IK4_Link I232_front_door
    with KD_Count 4
    with name 'kitchendoor' 'door' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I198_kitchen ""
    class K1_room
    with short_name "kitchen"
    with description text_routine_14
    with map_region I99_dursley_s_house
    with vector 0
    with room_index -1
    with list_together 0
    has mark_as_room
    with IK1_Count 7
    with IK1_Link I200_garden
    with KD_Count 1
    with name 'kitchen' 
;

Object -> I202_petunia ""
    class K17_npcf
    with short_name "Petunia"
    with description SC_35
    has proper
    has edible
    has p62_medium
    with vector 0
    with list_together 0
    with cap_short_name "Petunia"
    has mark_as_thing
    with IK2_Count 64
    with IK2_Link X203
    with IK8_Count 2
    with IK8_Link I221_dudley
    with IK11_Count 0
    with IK11_Link I259_customer
    with IK17_Count 0
    with IK17_Link I259_customer
    with KD_Count 17
    with name 'petunia' 'bye' 'bros' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> X203 ""
    class K19_pants
    with short_name "pants"
    has clothing
    has worn
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 65
    with IK2_Link X204
    with IK19_Count 0
    with IK19_Link X226
    with KD_Count 19
    with name 'pants' 'pantss//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> X204 ""
    class K18_shirt
    with short_name "shirt"
    has clothing
    has worn
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 66
    with IK2_Link I205_highchair
    with IK18_Count 0
    with IK18_Link X227
    with KD_Count 18
    with name 'shirt' 'shirts//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I205_highchair ""
    class K6_supporter
    with short_name "highchair"
    has proper
    has static
    has p60_large
    with vector 0
    with list_together 0
    with cap_short_name "Highchair"
    has mark_as_thing
    with IK2_Count 67
    with IK2_Link I221_dudley
    with IK6_Count 2
    with IK6_Link I206_kitchentable
    with KD_Count 6
    with name 'highchair' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> I221_dudley ""
    class K16_npcm
    with short_name "Dudley"
    has proper
    has edible
    has p60_large
    with p73_posture I115_seated
    with vector 0
    with list_together 0
    with cap_short_name "Dudley"
    has mark_as_thing
    with IK2_Count 72
    with IK2_Link X226
    with IK8_Count 3
    with IK8_Link I259_customer
    with IK16_Count 0
    with IK16_Link I277_mr_mason
    with KD_Count 16
    with name 'dudley' 'dudders' 'bye' 'bros' 
    with parse_name Parse_Name_GV153
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> -> X226 ""
    class K19_pants
    with short_name "pants"
    has clothing
    has worn
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 77
    with IK2_Link X227
    with IK19_Count 1
    with IK19_Link X260
    with KD_Count 19
    with name 'pants' 'pantss//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> -> X227 ""
    class K18_shirt
    with short_name "shirt"
    has clothing
    has worn
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 78
    with IK2_Link I206_kitchentable
    with IK18_Count 1
    with IK18_Link X261
    with KD_Count 18
    with name 'shirt' 'shirts//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I206_kitchentable ""
    class K6_supporter
    with short_name SC_36
    has proper
    has p60_large
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 68
    with IK2_Link X214
    with IK6_Count 3
    with IK6_Link I224_walls
    with KD_Count 6
    with name 'kitchentable' 'table' 
    with parse_name Parse_Name_GV154
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> X214 ""
    class K46_piece_of_toast
    with short_name "piece of toast"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 69
    with IK2_Link X215
    with IK44_Count 0
    with IK44_Link X215
    with IK46_Count 0
    with IK46_Link X215
    with KD_Count 46
    with name 'piece' 'of' 'toast' 'pieces//p'   
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> X215 ""
    class K46_piece_of_toast
    with short_name "piece of toast"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 70
    with IK2_Link I216_coffee_cup
    with IK44_Count 1
    with IK44_Link I223_steak
    with IK46_Count 1
    with IK46_Link nothing
    with KD_Count 46
    with name 'piece' 'of' 'toast' 'pieces//p'   
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> I216_coffee_cup ""
    class K45_cup
    with short_name SC_37
    has proper
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 71
    with IK2_Link I222_fridge
    with IK45_Count 0
    with IK45_Link I326_vernon_s_cup
    with KD_Count 45
    with name 'coffee' 'cup' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I222_fridge ""
    class K5_container
    with short_name SC_38
    has proper
    has static
    has ~open
    has openable
    has p60_large
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 73
    with IK2_Link I223_steak
    with IK5_Count 5
    with IK5_Link I228_suitcase
    with KD_Count 5
    with name 'fridge' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> I223_steak ""
    class K44_food
    with short_name SC_39
    with description SC_40
    has proper
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 74
    with IK2_Link I224_walls
    with IK44_Count 2
    with IK44_Link I292_doughnut
    with KD_Count 44
    with name 'steak' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I224_walls ""
    class K6_supporter
    with short_name "Walls"
    with description SC_41
    has static
    has scenery
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 75
    with IK2_Link I225_cereal
    with IK6_Count 4
    with IK6_Link I256_desk
    with KD_Count 6
    with name 'walls' 'wall' 
    with parse_name Parse_Name_GV156
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> I225_cereal ""
    class K2_thing
    with short_name "Cereal"
    has proper
    has static
    has concealed
    with vector 0
    with list_together 0
    with cap_short_name "Cereal"
    has mark_as_thing
    with IK2_Count 76
    with IK2_Link I228_suitcase
    with KD_Count 2
    with name 'cereal' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I228_suitcase ""
    class K27_number_unlockable
    with short_name "suitcase"
    with capacity 10
    has proper
    has ~open
    has openable
    has lockable
    has locked
    has p62_medium
    with vector 0
    with list_together 0
    with cap_short_name "Suitcase"
    has mark_as_thing
    with IK2_Count 79
    with IK2_Link I230_three_papers
    with IK5_Count 6
    with IK5_Link I201_garage
    with IK27_Count 0
    with IK27_Link nothing
    with KD_Count 27
    with name 'suitcase' 'case' 
    with parse_name Parse_Name_GV131
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> I230_three_papers ""
    class K2_thing
    with short_name "three papers"
    with description text_routine_15
    has proper
    has ~static
    has p61_small
    with vector 0
    with list_together 0
    with cap_short_name "Three papers"
    has mark_as_thing
    with IK2_Count 81
    with IK2_Link I231_keys
    with KD_Count 2
    with name 'three' 'papers' 'paper' 
    with parse_name Parse_Name_GV158
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> I231_keys ""
    class K2_thing
    with short_name "keys"
    has proper
    has p61_small
    with vector 0
    with list_together 0
    with cap_short_name "Keys"
    has mark_as_thing
    with IK2_Count 82
    with IK2_Link I229_window
    with KD_Count 2
    with name 'keys' 'key' 
    with parse_name Parse_Name_GV157
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I229_window ""
    class K2_thing
    with short_name "window"
    with description text_routine_16
    has proper
    has static
    has p62_medium
    with vector 0
    with list_together 0
    with cap_short_name "Window"
    has mark_as_thing
    with IK2_Count 80
    with IK2_Link I201_garage
    with KD_Count 2
    with name 'window' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I200_garden ""
    class K20_multiroad
    with short_name "Garden"
    with description SC_42
    with map_region I99_dursley_s_house
    has proper
    with vector 0
    with room_index -1
    with list_together 0
    with cap_short_name "Garden"
    has mark_as_room
    with IK1_Count 8
    with IK1_Link I240_highway
    with IK20_Count 0
    with IK20_Link I244_grunnings_carpark
    with KD_Count 20
    with name 'garden' 
;

Object -> I201_garage ""
    class K5_container
    with short_name "garage"
    has proper
    has static
    has enterable
    has ~transparent
    has ~open
    has openable
    has p63_huge
    with vector 0
    with list_together 0
    with cap_short_name "Garage"
    has mark_as_thing
    with IK2_Count 63
    with IK2_Link I236_light_switch
    with IK5_Count 4
    with IK5_Link I233_car
    with KD_Count 5
    with name 'garage' 'shed' 'garage' 
    with parse_name Parse_Name_GV159
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> I236_light_switch ""
    class K13_device
    with short_name "light switch"
    has proper
    has static
    with vector 0
    with list_together 0
    with cap_short_name "Light switch"
    has mark_as_thing
    with IK2_Count 87
    with IK2_Link I233_car
    with IK13_Count 2
    with IK13_Link I235_start_button
    with KD_Count 13
    with name 'light' 'switch' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I233_car ""
    class K14_vehicle
    with short_name "car"
    with description text_routine_17
    with with_key I231_keys
    has light
    has transparent
    has ~open
    has openable
    has lockable
    has locked
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 84
    with IK2_Link I232_front_door
    with IK5_Count 7
    with IK5_Link I234_ferrari_enzo
    with IK14_Count 0
    with IK14_Link I234_ferrari_enzo
    with KD_Count 14
    with name 'car' 
    with parse_name Parse_Name_GV161
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I232_front_door ""
    class K4_door
    with short_name SC_43
    with description text_routine_18
    has proper
    has ~open
    has openable
    with vector 0
    with door_dir [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I200_garden) return I53_west; return I52_east; ],
    with door_to [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I200_garden) return I140_hall; return I200_garden; ],
    with found_in I200_garden I140_hall
    with list_together 0
    has mark_as_thing
    with IK2_Count 83
    with IK2_Link I234_ferrari_enzo
    with IK4_Count 5
    with IK4_Link I251_officestairs
    with KD_Count 4
    with name 'front' 'door' 'door' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I234_ferrari_enzo ""
    class K14_vehicle
    with short_name "Ferrari Enzo"
    has proper
    with vector 0
    with list_together 0
    with cap_short_name "Ferrari Enzo"
    has mark_as_thing
    with IK2_Count 85
    with IK2_Link I235_start_button
    with IK5_Count 8
    with IK5_Link I245_red_car
    with IK14_Count 1
    with IK14_Link I245_red_car
    with KD_Count 14
    with name 'ferrari' 'enzo' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I235_start_button ""
    class K13_device
    with short_name "start button"
    has proper
    has static
    with vector 0
    with list_together 0
    with cap_short_name "Start button"
    has mark_as_thing
    with IK2_Count 86
    with IK2_Link I242_cars
    with IK13_Count 1
    with IK13_Link I250_elevatorbutton
    with KD_Count 13
    with name 'start' 'button' 'switch' 
    with parse_name Parse_Name_GV160
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I239_grunnings ""
    class K9_region
    with short_name "Grunnings"
    has proper
    with vector 0
    with list_together 0
    with cap_short_name "Grunnings"
    with regional_found_in [; if (TestRegionalContainment(location, I239_grunnings)) rtrue; rfalse; ],
    with IK9_Count 1
    with IK9_Link I253_level_1
    with KD_Count 9
    with name 'grunnings' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I253_level_1 ""
    class K9_region
    with short_name "level 1"
    has proper
    with vector 0
    with list_together 0
    with cap_short_name "Level 1"
    with regional_found_in [; if (TestRegionalContainment(location, I253_level_1)) rtrue; rfalse; ],
    with IK9_Count 3
    with IK9_Link I241_privet_sstreets
    with KD_Count 9
    with name 'level' '1//' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I240_highway ""
    class K43_road
    with short_name "highway"
    with description text_routine_19
    with map_region I241_privet_sstreets
    with vector 0
    with room_index -1
    with list_together 0
    has mark_as_room
    with IK1_Count 9
    with IK1_Link I244_grunnings_carpark
    with IK43_Count 0
    with IK43_Link nothing
    with KD_Count 43
    with name 'highway' 
;

Object -> I242_cars ""
    class K2_thing
    with short_name "cars"
    with description text_routine_20
    has proper
    has static
    has scenery
    with vector 0
    with list_together 0
    with cap_short_name "Cars"
    has mark_as_thing
    with IK2_Count 88
    with IK2_Link I245_red_car
    with KD_Count 2
    with name 'cars' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I241_privet_sstreets ""
    class K9_region
    with short_name SC_44
    has proper
    with vector 0
    with list_together 0
    with regional_found_in [; if (TestRegionalContainment(location, I241_privet_sstreets)) rtrue; rfalse; ],
    with IK9_Count 2
    with IK9_Link nothing
    with KD_Count 9
    with name 'privet^sstreets' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I244_grunnings_carpark ""
    class K20_multiroad
    with short_name "Grunnings Carpark"
    with description SC_45
    with map_region I239_grunnings
    has proper
    with vector 0
    with room_index -1
    with list_together 0
    with cap_short_name "Grunnings Carpark"
    has mark_as_room
    with IK1_Count 10
    with IK1_Link I252_corridor
    with IK20_Count 1
    with IK20_Link nothing
    with KD_Count 20
    with name 'grunnings' 'carpark' 
;

Object -> I245_red_car ""
    class K14_vehicle
    with short_name "red car"
    with description SC_46
    has proper
    has ~open
    has openable
    has lockable
    has locked
    with vector 0
    with list_together 0
    with cap_short_name "Red car"
    has mark_as_thing
    with IK2_Count 89
    with IK2_Link I246_blue_car
    with IK5_Count 9
    with IK5_Link I246_blue_car
    with IK14_Count 2
    with IK14_Link I246_blue_car
    with KD_Count 14
    with name 'red' 'car' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I246_blue_car ""
    class K14_vehicle
    with short_name "blue car"
    with description SC_47
    has proper
    has ~open
    has openable
    has lockable
    has locked
    with vector 0
    with list_together 0
    with cap_short_name "Blue car"
    has mark_as_thing
    with IK2_Count 90
    with IK2_Link I247_rainbow_car
    with IK5_Count 10
    with IK5_Link I247_rainbow_car
    with IK14_Count 3
    with IK14_Link I247_rainbow_car
    with KD_Count 14
    with name 'blue' 'car' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I247_rainbow_car ""
    class K14_vehicle
    with short_name "rainbow car"
    with description SC_48
    has proper
    has ~open
    has openable
    has lockable
    has locked
    with vector 0
    with list_together 0
    with cap_short_name "Rainbow car"
    has mark_as_thing
    with IK2_Count 91
    with IK2_Link I248_green_car
    with IK5_Count 11
    with IK5_Link I248_green_car
    with IK14_Count 4
    with IK14_Link I248_green_car
    with KD_Count 14
    with name 'rainbow' 'car' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I248_green_car ""
    class K14_vehicle
    with short_name "green car"
    with description SC_49
    has proper
    has ~open
    has openable
    has lockable
    has locked
    with vector 0
    with list_together 0
    with cap_short_name "Green car"
    has mark_as_thing
    with IK2_Count 92
    with IK2_Link I249_elevator
    with IK5_Count 12
    with IK5_Link I249_elevator
    with IK14_Count 5
    with IK14_Link nothing
    with KD_Count 14
    with name 'green' 'car' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I249_elevator ""
    class K5_container
    with short_name "elevator"
    has proper
    has static
    has enterable
    has ~transparent
    has open
    has p63_huge
    with vector 0
    with list_together 0
    with cap_short_name "Elevator"
    has mark_as_thing
    with IK2_Count 93
    with IK2_Link I250_elevatorbutton
    with IK5_Count 13
    with IK5_Link I275_fcdrawer
    with KD_Count 5
    with name 'elevator' 'lift' 
    with parse_name Parse_Name_GV128
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> I250_elevatorbutton ""
    class K13_device
    with short_name SC_50
    has proper
    has static
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 94
    with IK2_Link I251_officestairs
    with IK13_Count 3
    with IK13_Link I324_television
    with KD_Count 13
    with name 'elevatorbutton' 'button' 
    with parse_name Parse_Name_GV164
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I251_officestairs ""
    class K35_stairs
    with short_name SC_51
    has proper
    has open
    has ~openable
    with vector 0
    with door_dir [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I252_corridor) return I55_down; return I54_up; ],
    with door_to [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I252_corridor) return I244_grunnings_carpark; return I252_corridor; ],
    with found_in I252_corridor I244_grunnings_carpark
    with list_together 0
    has mark_as_thing
    with IK2_Count 95
    with IK2_Link I256_desk
    with IK4_Count 6
    with IK4_Link I255_office_door
    with IK35_Count 1
    with IK35_Link nothing
    with KD_Count 35
    with name 'officestairs' 'stairs' 'stairs' 'door' 
    with parse_name Parse_Name_GV167
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I252_corridor ""
    class K1_room
    with short_name "corridor"
    with map_region I253_level_1
    has proper
    with vector 0
    with room_index -1
    with list_together 0
    with cap_short_name "Corridor"
    has mark_as_room
    with IK1_Count 11
    with IK1_Link I254_work_office
    with KD_Count 1
    with name 'corridor' 
;

Object I254_work_office ""
    class K1_room
    with short_name "Work office"
    with description text_routine_21
    with map_region I253_level_1
    has proper
    with vector 0
    with room_index -1
    with list_together 0
    with cap_short_name "Work office"
    has mark_as_room
    with IK1_Count 12
    with IK1_Link I285_street
    with KD_Count 1
    with name 'work' 'office' 
;

Object -> I256_desk ""
    class K6_supporter
    with short_name "desk"
    with description SC_52
    has proper
    has p63_huge
    with vector 0
    with list_together 0
    with cap_short_name "Desk"
    has mark_as_thing
    with IK2_Count 97
    with IK2_Link I258_office_phone
    with IK6_Count 5
    with IK6_Link I272_office_chair
    with KD_Count 6
    with name 'desk' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> I258_office_phone ""
    class K29_telephone
    with short_name "office phone"
    with description SC_53
    with p14_calling_number 55527586
    has static
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 99
    with IK2_Link I263_ics_document
    with IK29_Count 0
    with IK29_Link I262_mobilel
    with KD_Count 29
    with name 'office' 'phone' 'phone' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> I263_ics_document ""
    class K2_thing
    with short_name SC_54
    with description text_routine_22
    has proper
    has p61_small
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 104
    with IK2_Link I273_rollerdex
    with KD_Count 2
    with name 'ics' 'document' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> I273_rollerdex ""
    class K2_thing
    with short_name SC_55
    with description text_routine_23
    has proper
    has p61_small
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 106
    with IK2_Link I282_notepad
    with KD_Count 2
    with name 'rollerdex' 'rolodex' 'roller' 'dex' 
    with parse_name Parse_Name_GV180
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> I282_notepad ""
    class K50_writeable
    with short_name "notepad"
    with description text_routine_24
    has proper
    with vector 0
    with list_together 0
    with cap_short_name "Notepad"
    has mark_as_thing
    with IK2_Count 113
    with IK2_Link I284_pen
    with IK50_Count 0
    with IK50_Link nothing
    with KD_Count 50
    with name 'notepad' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> I284_pen ""
    class K51_penquill
    with short_name "pen"
    has proper
    with vector 0
    with list_together 0
    with cap_short_name "Pen"
    has mark_as_thing
    with IK2_Count 114
    with IK2_Link X299
    with IK51_Count 0
    with IK51_Link nothing
    with KD_Count 51
    with name 'pen' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> X299 ""
    class K53_pound_coin
    with short_name "pound coin"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 125
    with IK2_Link X300
    with IK53_Count 0
    with IK53_Link X300
    with KD_Count 53
    with name 'pound' 'coin'  'coins//p' 'pounds' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> X300 ""
    class K53_pound_coin
    with short_name "pound coin"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 126
    with IK2_Link I257_workwindow
    with IK53_Count 1
    with IK53_Link nothing
    with KD_Count 53
    with name 'pound' 'coin'  'coins//p' 'pounds' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I257_workwindow ""
    class K2_thing
    with short_name SC_56
    with description text_routine_25
    has proper
    has static
    has p62_medium
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 98
    with IK2_Link I272_office_chair
    with KD_Count 2
    with name 'workwindow' 'window' 
    with parse_name Parse_Name_GV169
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I272_office_chair ""
    class K49_chair
    with short_name "office chair"
    has proper
    with vector 0
    with list_together 0
    with cap_short_name "Office chair"
    has mark_as_thing
    with IK2_Count 105
    with IK2_Link I274_filing_cabinet
    with IK6_Count 6
    with IK6_Link I305_dining_room_table
    with IK49_Count 0
    with IK49_Link X306
    with KD_Count 49
    with name 'office' 'chair' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I274_filing_cabinet ""
    class K2_thing
    with short_name SC_57
    with description SC_58
    has proper
    has static
    has p60_large
    with vector 0
    with list_together 0
    has mark_as_thing
    with component_child I275_fcdrawer
    with IK2_Count 107
    with IK2_Link I255_office_door
    with KD_Count 2
    with name 'filing' 'cabinet' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I255_office_door ""
    class K4_door
    with short_name "office door"
    with description text_routine_26
    with vector 0
    with door_dir [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I254_work_office) return I49_south; return I46_north; ],
    with door_to [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I254_work_office) return I252_corridor; return I254_work_office; ],
    with found_in I254_work_office I252_corridor
    with list_together 0
    has mark_as_thing
    with IK2_Count 96
    with IK2_Link I259_customer
    with IK4_Count 7
    with IK4_Link I286_bakery_door
    with KD_Count 4
    with name 'office' 'door' 'door' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I259_customer ""
    class K17_npcf
    with short_name "Customer"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 100
    with IK2_Link X260
    with IK8_Count 4
    with IK8_Link I277_mr_mason
    with IK11_Count 1
    with IK11_Link nothing
    with IK17_Count 1
    with IK17_Link nothing
    with KD_Count 17
    with name 'customer' 'bye' 'bros' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X260 ""
    class K19_pants
    with short_name "pants"
    has clothing
    has worn
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 101
    with IK2_Link X261
    with IK19_Count 2
    with IK19_Link X278
    with KD_Count 19
    with name 'pants' 'pantss//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X261 ""
    class K18_shirt
    with short_name "shirt"
    has clothing
    has worn
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 102
    with IK2_Link I262_mobilel
    with IK18_Count 2
    with IK18_Link X279
    with KD_Count 18
    with name 'shirt' 'shirts//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I262_mobilel ""
    class K29_telephone
    with short_name "mobilel"
    with p14_calling_number 893
    with p15_owner I259_customer
    has proper
    with vector 0
    with list_together 0
    with cap_short_name "Mobilel"
    has mark_as_thing
    with IK2_Count 103
    with IK2_Link I275_fcdrawer
    with IK29_Count 1
    with IK29_Link I280_mason_s_phone
    with KD_Count 29
    with name 'mobilel' 'phone' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I275_fcdrawer ""
    class K5_container
    with short_name SC_59
    has proper
    has ~open
    has openable
    has p62_medium
    with vector 0
    with list_together 0
    has mark_as_thing
    with component_parent I274_filing_cabinet
    with IK2_Count 108
    with IK2_Link I277_mr_mason
    with IK5_Count 14
    with IK5_Link I291_foods_display_case
    with KD_Count 5
    with name 'fcdrawer' 'drawer' 'drawers' 
    with parse_name Parse_Name_GV182
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I277_mr_mason ""
    class K16_npcm
    with short_name SC_60
    has proper
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 109
    with IK2_Link X278
    with IK8_Count 5
    with IK8_Link I288_shop_attendant
    with IK16_Count 1
    with IK16_Link I288_shop_attendant
    with KD_Count 16
    with name 'mr' 'mason' 'bye' 'bros' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X278 ""
    class K19_pants
    with short_name "pants"
    has clothing
    has worn
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 110
    with IK2_Link X279
    with IK19_Count 3
    with IK19_Link X289
    with KD_Count 19
    with name 'pants' 'pantss//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X279 ""
    class K18_shirt
    with short_name "shirt"
    has clothing
    has worn
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 111
    with IK2_Link I280_mason_s_phone
    with IK18_Count 3
    with IK18_Link X290
    with KD_Count 18
    with name 'shirt' 'shirts//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I280_mason_s_phone ""
    class K29_telephone
    with short_name "Mason's phone"
    with p14_calling_number 12856
    with p15_owner I277_mr_mason
    has proper
    with vector 0
    with list_together 0
    with cap_short_name "Mason's phone"
    has mark_as_thing
    with IK2_Count 112
    with IK2_Link I286_bakery_door
    with IK29_Count 2
    with IK29_Link nothing
    with KD_Count 29
    with name 'mason^s' 'phone' 'phone' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I285_street ""
    class K1_room
    with short_name "street"
    with description SC_61
    with map_region I241_privet_sstreets
    has proper
    with vector 0
    with room_index -1
    with list_together 0
    with cap_short_name "Street"
    has mark_as_room
    with IK1_Count 13
    with IK1_Link I287_bakers
    with KD_Count 1
    with name 'street' 
;

Object I286_bakery_door ""
    class K4_door
    with short_name SC_62
    has proper
    with vector 0
    with door_dir [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I287_bakers) return I53_west; return I52_east; ],
    with door_to [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I287_bakers) return I285_street; return I287_bakers; ],
    with found_in I287_bakers I285_street
    with list_together 0
    has mark_as_thing
    with IK2_Count 115
    with IK2_Link I288_shop_attendant
    with IK4_Count 8
    with IK4_Link I302_dining_room_door
    with KD_Count 4
    with name 'bakery' 'door' 'door' 
    with parse_name Parse_Name_GV191
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I287_bakers ""
    class K1_room
    with short_name SC_63
    with map_region I241_privet_sstreets
    has proper
    with vector 0
    with room_index -1
    with list_together 0
    has mark_as_room
    with IK1_Count 14
    with IK1_Link I301_dining_room
    with KD_Count 1
    with name 'bakers' 
;

Object -> I288_shop_attendant ""
    class K16_npcm
    with short_name "Shop attendant"
    with description text_routine_27
    has ~proper
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 116
    with IK2_Link X289
    with IK8_Count 6
    with IK8_Link nothing
    with IK16_Count 2
    with IK16_Link nothing
    with KD_Count 16
    with name 'shop' 'attendant' 'bye' 'bros' 
    with parse_name Parse_Name_GV192
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> X289 ""
    class K19_pants
    with short_name "pants"
    has clothing
    has worn
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 117
    with IK2_Link X290
    with IK19_Count 4
    with IK19_Link nothing
    with KD_Count 19
    with name 'pants' 'pantss//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> X290 ""
    class K18_shirt
    with short_name "shirt"
    has clothing
    has worn
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 118
    with IK2_Link I291_foods_display_case
    with IK18_Count 4
    with IK18_Link nothing
    with KD_Count 18
    with name 'shirt' 'shirts//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I291_foods_display_case ""
    class K5_container
    with short_name "foods display case"
    has static
    has transparent
    has ~open
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 119
    with IK2_Link I292_doughnut
    with IK5_Count 15
    with IK5_Link I331_cot
    with KD_Count 5
    with name 'foods' 'display' 'case' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> I292_doughnut ""
    class K44_food
    with short_name text_routine_28
    has proper
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 120
    with IK2_Link I293_bun
    with IK44_Count 3
    with IK44_Link I293_bun
    with KD_Count 44
    with name 'doughnut' 'donut' 
    with parse_name Parse_Name_GV193
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> I293_bun ""
    class K44_food
    with short_name text_routine_29
    has proper
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 121
    with IK2_Link I294_breadstick
    with IK44_Count 4
    with IK44_Link I294_breadstick
    with KD_Count 44
    with name 'bun' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> I294_breadstick ""
    class K44_food
    with short_name text_routine_30
    has proper
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 122
    with IK2_Link X296
    with IK44_Count 5
    with IK44_Link X296
    with KD_Count 44
    with name 'breadstick' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> X296 ""
    class K52_small_roll
    with short_name "small roll"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 123
    with IK2_Link X297
    with IK44_Count 6
    with IK44_Link X297
    with IK52_Count 0
    with IK52_Link X297
    with KD_Count 52
    with name 'small' 'roll'  'rolls//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> X297 ""
    class K52_small_roll
    with short_name "small roll"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 124
    with IK2_Link I305_dining_room_table
    with IK44_Count 7
    with IK44_Link nothing
    with IK52_Count 1
    with IK52_Link nothing
    with KD_Count 52
    with name 'small' 'roll'  'rolls//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I301_dining_room ""
    class K1_room
    with short_name "Dining room"
    with map_region I99_dursley_s_house
    has proper
    with vector 0
    with room_index -1
    with list_together 0
    with cap_short_name "Dining room"
    has mark_as_room
    with IK1_Count 15
    with IK1_Link I304_living_room
    with KD_Count 1
    with name 'dining' 'room' 
;

Object -> I305_dining_room_table ""
    class K6_supporter
    with short_name "Dining room table"
    with description SC_64
    has proper
    has static
    with vector 0
    with list_together 0
    with cap_short_name "Dining room table"
    has mark_as_thing
    with IK2_Count 129
    with IK2_Link X306
    with IK6_Count 7
    with IK6_Link X306
    with KD_Count 6
    with name 'dining' 'room' 'table' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X306 ""
    class K49_chair
    with short_name "chair"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 130
    with IK2_Link X307
    with IK6_Count 8
    with IK6_Link X307
    with IK49_Count 1
    with IK49_Link X307
    with KD_Count 49
    with name 'chair' 'chairs//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X307 ""
    class K49_chair
    with short_name "chair"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 131
    with IK2_Link X308
    with IK6_Count 9
    with IK6_Link X308
    with IK49_Count 2
    with IK49_Link X308
    with KD_Count 49
    with name 'chair' 'chairs//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X308 ""
    class K49_chair
    with short_name "chair"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 132
    with IK2_Link X309
    with IK6_Count 10
    with IK6_Link X309
    with IK49_Count 3
    with IK49_Link X309
    with KD_Count 49
    with name 'chair' 'chairs//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X309 ""
    class K49_chair
    with short_name "chair"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 133
    with IK2_Link X310
    with IK6_Count 11
    with IK6_Link X310
    with IK49_Count 4
    with IK49_Link X310
    with KD_Count 49
    with name 'chair' 'chairs//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X310 ""
    class K49_chair
    with short_name "chair"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 134
    with IK2_Link I302_dining_room_door
    with IK6_Count 12
    with IK6_Link I311_mantlepiece
    with IK49_Count 5
    with IK49_Link I321_stool
    with KD_Count 49
    with name 'chair' 'chairs//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I302_dining_room_door ""
    class K4_door
    with short_name SC_65
    has proper
    with vector 0
    with door_dir [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I140_hall) return I51_southwest; return I47_northeast; ],
    with door_to [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I140_hall) return I301_dining_room; return I140_hall; ],
    with found_in I140_hall I301_dining_room
    with list_together 0
    has mark_as_thing
    with IK2_Count 127
    with IK2_Link I303_door_from_dining_room_t
    with IK4_Count 9
    with IK4_Link I303_door_from_dining_room_t
    with KD_Count 4
    with name 'dining' 'room' 'door' 'door' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I303_door_from_dining_room_t ""
    class K4_door
    with short_name text_routine_31
    has proper
    with vector 0
    with door_dir [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I304_living_room) return I53_west; return I52_east; ],
    with door_to [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I304_living_room) return I301_dining_room; return I304_living_room; ],
    with found_in I304_living_room I301_dining_room
    with list_together 0
    has mark_as_thing
    with IK2_Count 128
    with IK2_Link I311_mantlepiece
    with IK4_Count 10
    with IK4_Link I318_living_room_door
    with KD_Count 4
    with name 'door' 'from' 'dining' 'room' 'to' 'living' 'room' 'door' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I304_living_room ""
    class K1_room
    with short_name "living-room"
    with map_region I99_dursley_s_house
    has proper
    with vector 0
    with room_index -1
    with list_together 0
    with cap_short_name "Living-room"
    has mark_as_room
    with IK1_Count 16
    with IK1_Link I329_dudley_s_bedroom
    with KD_Count 1
    with name 'living-room' 
;

Object -> I311_mantlepiece ""
    class K6_supporter
    with short_name "mantlepiece"
    has static
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 135
    with IK2_Link X313
    with IK6_Count 13
    with IK6_Link I319_piano
    with KD_Count 6
    with name 'mantlepiece' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> X313 ""
    class K54_photo
    with short_name "photo"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 136
    with IK2_Link X314
    with IK54_Count 0
    with IK54_Link X314
    with KD_Count 54
    with name 'photo' 'photos//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> X314 ""
    class K54_photo
    with short_name "photo"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 137
    with IK2_Link X315
    with IK54_Count 1
    with IK54_Link X315
    with KD_Count 54
    with name 'photo' 'photos//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> X315 ""
    class K54_photo
    with short_name "photo"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 138
    with IK2_Link X316
    with IK54_Count 2
    with IK54_Link X316
    with KD_Count 54
    with name 'photo' 'photos//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> X316 ""
    class K54_photo
    with short_name "photo"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 139
    with IK2_Link X317
    with IK54_Count 3
    with IK54_Link X317
    with KD_Count 54
    with name 'photo' 'photos//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> X317 ""
    class K54_photo
    with short_name "photo"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 140
    with IK2_Link I319_piano
    with IK54_Count 4
    with IK54_Link nothing
    with KD_Count 54
    with name 'photo' 'photos//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I319_piano ""
    class K6_supporter
    with short_name "Piano"
    has proper
    with vector 0
    with list_together 0
    with cap_short_name "Piano"
    has mark_as_thing
    with IK2_Count 142
    with IK2_Link I320_sheet_music
    with IK6_Count 14
    with IK6_Link I321_stool
    with KD_Count 6
    with name 'piano' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> I320_sheet_music ""
    class K2_thing
    with short_name "sheet music"
    has proper
    with vector 0
    with list_together 0
    with cap_short_name "Sheet music"
    has mark_as_thing
    with IK2_Count 143
    with IK2_Link I321_stool
    with KD_Count 2
    with name 'sheet' 'music' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I321_stool ""
    class K49_chair
    with short_name "Stool"
    has proper
    with vector 0
    with list_together 0
    with cap_short_name "Stool"
    has mark_as_thing
    with IK2_Count 144
    with IK2_Link I322_armchair
    with IK6_Count 15
    with IK6_Link I322_armchair
    with IK49_Count 6
    with IK49_Link I322_armchair
    with KD_Count 49
    with name 'stool' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I322_armchair ""
    class K49_chair
    with short_name "Armchair"
    has proper
    with vector 0
    with list_together 0
    with cap_short_name "Armchair"
    has mark_as_thing
    with IK2_Count 145
    with IK2_Link I323_couch
    with IK6_Count 16
    with IK6_Link I323_couch
    with IK49_Count 7
    with IK49_Link I323_couch
    with KD_Count 49
    with name 'armchair' 'chair' 
    with parse_name Parse_Name_GV197
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I323_couch ""
    class K49_chair
    with short_name "Couch"
    has proper
    with vector 0
    with list_together 0
    with cap_short_name "Couch"
    has mark_as_thing
    with IK2_Count 146
    with IK2_Link I324_television
    with IK6_Count 17
    with IK6_Link I325_tray
    with IK49_Count 8
    with IK49_Link nothing
    with KD_Count 49
    with name 'couch' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I324_television ""
    class K13_device
    with short_name "Television"
    has proper
    with vector 0
    with list_together 0
    with cap_short_name "Television"
    has mark_as_thing
    with IK2_Count 147
    with IK2_Link I318_living_room_door
    with IK13_Count 4
    with IK13_Link I354_tap2
    with KD_Count 13
    with name 'television' 'tv' 
    with parse_name Parse_Name_GV198
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I318_living_room_door ""
    class K4_door
    with short_name SC_66
    has proper
    with vector 0
    with door_dir [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I140_hall) return I49_south; return I46_north; ],
    with door_to [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I140_hall) return I304_living_room; return I140_hall; ],
    with found_in I140_hall I304_living_room
    with list_together 0
    has mark_as_thing
    with IK2_Count 141
    with IK2_Link I325_tray
    with IK4_Count 11
    with IK4_Link I330_dudley_s_bedroom_door
    with KD_Count 4
    with name 'living-room' 'door' 'door' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I325_tray ""
    class K6_supporter
    with short_name "tray"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 148
    with IK2_Link I326_vernon_s_cup
    with IK6_Count 18
    with IK6_Link nothing
    with KD_Count 6
    with name 'tray' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I326_vernon_s_cup ""
    class K45_cup
    with short_name SC_67
    has proper
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 149
    with IK2_Link I327_petunia_s_cup
    with IK45_Count 1
    with IK45_Link I327_petunia_s_cup
    with KD_Count 45
    with name 'vernon^s' 'cup' 'tea' 
    with parse_name Parse_Name_GV206
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I327_petunia_s_cup ""
    class K45_cup
    with short_name SC_67
    has proper
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 150
    with IK2_Link I331_cot
    with IK45_Count 2
    with IK45_Link nothing
    with KD_Count 45
    with name 'petunia^s' 'cup' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I329_dudley_s_bedroom ""
    class K1_room
    with short_name "Dudley's bedroom"
    with map_region I99_dursley_s_house
    has proper
    with vector 0
    with room_index -1
    with list_together 0
    with cap_short_name "Dudley's bedroom"
    has mark_as_room
    with IK1_Count 17
    with IK1_Link I343_dudley_s_second_room
    with KD_Count 1
    with name 'dudley^s' 'bedroom' 
;

Object -> I331_cot ""
    class K5_container
    with short_name "Cot"
    with description SC_68
    has proper
    has static
    has p60_large
    with vector 0
    with list_together 0
    with cap_short_name "Cot"
    has mark_as_thing
    with IK2_Count 152
    with IK2_Link I332_set_of_drawers
    with IK5_Count 16
    with IK5_Link I333_dudley_s_drawers
    with KD_Count 5
    with name 'cot' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I332_set_of_drawers ""
    class K2_thing
    with short_name "set of drawers"
    with description SC_69
    has static
    has p60_large
    with vector 0
    with list_together 0
    has mark_as_thing
    with component_child I333_dudley_s_drawers
    with IK2_Count 153
    with IK2_Link I342_magic_wand
    with KD_Count 2
    with name 'set' 'of' 'drawers' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I342_magic_wand ""
    class K2_thing
    with short_name "magic wand"
    has concealed
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 163
    with IK2_Link I330_dudley_s_bedroom_door
    with KD_Count 2
    with name 'magic' 'wand' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I330_dudley_s_bedroom_door ""
    class K4_door
    with short_name "Dudley's bedroom door"
    has proper
    with vector 0
    with door_dir [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I329_dudley_s_bedroom) return I50_southeast; return I48_northwest; ],
    with door_to [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I329_dudley_s_bedroom) return I138_landing; return I329_dudley_s_bedroom; ],
    with found_in I329_dudley_s_bedroom I138_landing
    with list_together 0
    with cap_short_name "Dudley's bedroom door"
    has mark_as_thing
    with IK2_Count 151
    with IK2_Link I333_dudley_s_drawers
    with IK4_Count 12
    with IK4_Link I344_dudley_s_second_room_s_
    with KD_Count 4
    with name 'dudley^s' 'bedroom' 'door' 'door' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I333_dudley_s_drawers ""
    class K5_container
    with short_name "Dudley's drawers"
    has proper
    has ~open
    has openable
    with vector 0
    with list_together 0
    with cap_short_name "Dudley's drawers"
    has mark_as_thing
    with component_parent I332_set_of_drawers
    with IK2_Count 154
    with IK2_Link X334
    with IK5_Count 17
    with IK5_Link I345_dudley_s_wardrobe
    with KD_Count 5
    with name 'dudley^s' 'drawers' 'drawer' 
    with parse_name Parse_Name_GV212
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X334 ""
    class K42_toy
    with short_name "toy"
    has p61_small
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 155
    with IK2_Link X335
    with IK42_Count 3
    with IK42_Link X335
    with KD_Count 42
    with name 'toy' 'toys//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X335 ""
    class K42_toy
    with short_name "toy"
    has p61_small
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 156
    with IK2_Link X336
    with IK42_Count 4
    with IK42_Link X336
    with KD_Count 42
    with name 'toy' 'toys//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X336 ""
    class K42_toy
    with short_name "toy"
    has p61_small
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 157
    with IK2_Link X337
    with IK42_Count 5
    with IK42_Link X337
    with KD_Count 42
    with name 'toy' 'toys//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X337 ""
    class K42_toy
    with short_name "toy"
    has p61_small
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 158
    with IK2_Link X338
    with IK42_Count 6
    with IK42_Link X338
    with KD_Count 42
    with name 'toy' 'toys//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X338 ""
    class K42_toy
    with short_name "toy"
    has p61_small
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 159
    with IK2_Link X339
    with IK42_Count 7
    with IK42_Link X339
    with KD_Count 42
    with name 'toy' 'toys//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X339 ""
    class K42_toy
    with short_name "toy"
    has p61_small
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 160
    with IK2_Link X340
    with IK42_Count 8
    with IK42_Link X340
    with KD_Count 42
    with name 'toy' 'toys//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> X340 ""
    class K42_toy
    with short_name "toy"
    has p61_small
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 161
    with IK2_Link I341_pair_of_glasses
    with IK42_Count 9
    with IK42_Link nothing
    with KD_Count 42
    with name 'toy' 'toys//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I341_pair_of_glasses ""
    class K2_thing
    with short_name "pair of glasses"
    has clothing
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 162
    with IK2_Link I345_dudley_s_wardrobe
    with KD_Count 2
    with name 'pair' 'of' 'glasses' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I343_dudley_s_second_room ""
    class K1_room
    with short_name "Dudley's second room"
    with description SC_70
    with map_region I99_dursley_s_house
    has proper
    with vector 0
    with room_index -1
    with list_together 0
    with cap_short_name "Dudley's second room"
    has mark_as_room
    with IK1_Count 18
    with IK1_Link I350_bathroom
    with KD_Count 1
    with name 'dudley^s' 'second' 'room' 
;

Object -> I345_dudley_s_wardrobe ""
    class K5_container
    with short_name "Dudley's wardrobe"
    has proper
    has static
    has ~open
    has openable
    with vector 0
    with list_together 0
    with cap_short_name "Dudley's wardrobe"
    has mark_as_thing
    with IK2_Count 165
    with IK2_Link X346
    with IK5_Count 18
    with IK5_Link I351_bath
    with KD_Count 5
    with name 'dudley^s' 'wardrobe' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> X346 ""
    class K41_book
    with short_name "book"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 166
    with IK2_Link X347
    with IK41_Count 6
    with IK41_Link X347
    with KD_Count 41
    with name 'book' 'books//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> X347 ""
    class K41_book
    with short_name "book"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 167
    with IK2_Link X348
    with IK41_Count 7
    with IK41_Link X348
    with KD_Count 41
    with name 'book' 'books//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> X348 ""
    class K41_book
    with short_name "book"
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 168
    with IK2_Link I349_spellbook
    with IK41_Count 8
    with IK41_Link I349_spellbook
    with KD_Count 41
    with name 'book' 'books//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> -> I349_spellbook ""
    class K41_book
    with short_name "Spellbook"
    with description SC_71
    has proper
    with vector 0
    with list_together 0
    with cap_short_name "Spellbook"
    has mark_as_thing
    with IK2_Count 169
    with IK2_Link I344_dudley_s_second_room_s_
    with IK41_Count 9
    with IK41_Link nothing
    with KD_Count 41
    with name 'spellbook' 'spell' 
    with parse_name Parse_Name_GV224
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I344_dudley_s_second_room_s_ ""
    class K4_door
    with short_name "Dudley's second room's door"
    has proper
    with vector 0
    with door_dir [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I343_dudley_s_second_room) return I51_southwest; return I47_northeast; ],
    with door_to [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I343_dudley_s_second_room) return I138_landing; return I343_dudley_s_second_room; ],
    with found_in I343_dudley_s_second_room I138_landing
    with list_together 0
    with cap_short_name "Dudley's second room's door"
    has mark_as_thing
    with IK2_Count 164
    with IK2_Link I351_bath
    with IK4_Count 13
    with IK4_Link nothing
    with KD_Count 4
    with name 'dudley^s' 'second' 'room^s' 'door' 'door' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I350_bathroom ""
    class K1_room
    with short_name "Bathroom"
    with map_region I99_dursley_s_house
    has proper
    with vector 0
    with room_index -1
    with list_together 0
    with cap_short_name "Bathroom"
    has mark_as_room
    with IK1_Count 19
    with IK1_Link I355_privet_drive
    with KD_Count 1
    with name 'bathroom' 
;

Object -> I351_bath ""
    class K5_container
    with short_name "Bath"
    has proper
    has static
    has enterable
    has open
    has ~openable
    with vector 0
    with list_together 0
    with cap_short_name "Bath"
    has mark_as_thing
    with IK2_Count 170
    with IK2_Link I352_toilet2
    with IK5_Count 19
    with IK5_Link nothing
    with KD_Count 5
    with name 'bath' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I352_toilet2 ""
    class K2_thing
    with short_name SC_21
    with description SC_23
    has proper
    with vector 0
    with list_together 0
    has mark_as_thing
    with IK2_Count 171
    with IK2_Link I353_sink2
    with KD_Count 2
    with name 'toilet2' 'toilet' 
    with parse_name Parse_Name_GV225
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object -> I353_sink2 ""
    class K2_thing
    with short_name SC_24
    with description SC_72
    has proper
    with vector 0
    with list_together 0
    has mark_as_thing
    with component_child I354_tap2
    with IK2_Count 172
    with IK2_Link I354_tap2
    with KD_Count 2
    with name 'sink2' 'sink' 
    with parse_name Parse_Name_GV226
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I354_tap2 ""
    class K13_device
    with short_name SC_26
    has proper
    with vector 0
    with list_together 0
    has mark_as_thing
    with component_parent I353_sink2
    with IK2_Count 173
    with IK2_Link nothing
    with IK13_Count 5
    with IK13_Link nothing
    with KD_Count 13
    with name 'tap2' 'tap' 'faucet' 
    with parse_name Parse_Name_GV227
    with action_bitmap 0 0 0 0 0 0 0 0 0 
;

Object I355_privet_drive ""
    class K1_room
    with short_name "Privet Drive"
    with description SC_73
    with map_region I241_privet_sstreets
    has proper
    with vector 0
    with room_index -1
    with list_together 0
    with cap_short_name "Privet Drive"
    has mark_as_room
    with IK1_Count 20
    with IK1_Link nothing
    with KD_Count 1
    with name 'privet' 'drive' 
;

Constant I65_figure_of_cover = 1;
Constant I66_entire_game = 1;
Constant I68_didn_t_understand_error = 1;
Constant I69_only_understood_as_far_a = 2;
Constant I70_didn_t_understand_that_n = 3;
Constant I71_can_only_do_that_to_some = 4;
Constant I72_can_t_see_any_such_thing = 5;
Constant I73_said_too_little_error = 6;
Constant I74_aren_t_holding_that_erro = 7;
Constant I75_can_t_use_multiple_objec = 8;
Constant I76_can_only_use_multiple_ob = 9;
Constant I77_not_sure_what_it_refers_ = 10;
Constant I78_excepted_something_not_i = 11;
Constant I79_not_a_verb_i_recognise_e = 12;
Constant I80_not_something_you_need_t = 13;
Constant I81_can_t_see_it_at_the_mome = 14;
Constant I82_didn_t_understand_the_wa = 15;
Constant I83_not_enough_of_those_avai = 16;
Constant I84_nothing_to_do_error = 17;
Constant I85_noun_did_not_make_sense_ = 18;
Constant I86_referred_to_a_determinat = 19;
Constant I87_i_beg_your_pardon_error = 20;
Constant I88_sound_of_intro_one = 1;
Constant I89_sound_of_intro_two = 2;
Constant I90_sound_of_intro_three = 3;
Constant I91_sound_of_intro_four = 4;
Constant I92_uncle_vernon_s_scene = 2;
Constant I111_implicit = 1;
Constant I112_explicit = 2;
Constant I115_seated = 1;
Constant I116_standing = 2;
Constant I117_reclining = 3;
Constant I209_uneaten = 1;
Constant I210_half_eaten = 2;
Constant I211_eaten = 3;
Constant I218_overflowing = 1;
Constant I219_half_empty = 2;
Constant I220_droplets = 3;
Constant I238_work = 3;
Constant I264_customercall = 4;
Constant I266_success = 1;
Constant I267_failure = 2;
Constant I268_incomplete = 3;
Constant I269_pending = 4;
Constant I270_half_complete = 5;
Constant I276_mrmason_call = 5;
Constant I328_living_room_cut_scene = 6;
Array Global_Vars -->
  (false) ! 7
  (SC_74) ! 24
  (SC_3) ! 29
  (SC_2) ! 30
  (EMPTY_TEXT_VALUE) ! 31
  (EMPTY_TEXT_VALUE) ! 32
  (0) ! 33
  (0) ! 34
  (0) ! 43
  (1) ! 51
  (400) ! 52
  (40) ! 53
  (400) ! 54
  (0) ! 55
  (0) ! 56
  (selfobj) ! 57
  (0) ! 58
  (selfobj) ! 59
  (0) ! 60
  (0) ! 61
  (SC_75) ! 62
  (T2_sample_options) ! 63
  (1) ! 64
  (0) ! 65
  (0) ! 66
  (0) ! 67
  (0) ! 68
  (1) ! 69
  (0) ! 70
  (0) ! 71
  (0) ! 72
  (0) ! 73
  (0) ! 74
  (0) ! 75
  (SC_76) ! 76
  (SC_77) ! 77
  (nothing) ! 78
  (I112_explicit) ! 79
  (I112_explicit) ! 80
  (0) ! 81
  (0) ! 82
  (0) ! 83
  (0) ! 85
  (T12_ordinary_status) ! 86
  (14) ! 87
  (text_routine_32) ! 88
  (text_routine_33) ! 89
  (text_routine_34) ! 90
  (text_routine_35) ! 91
  (text_routine_36) ! 92
  (text_routine_37) ! 93
  (text_routine_38) ! 94
  (text_routine_39) ! 95
  (text_routine_40) ! 96
  (text_routine_41) ! 97
  (text_routine_42) ! 98
  (text_routine_43) ! 99
  (text_routine_44) ! 100
  (text_routine_45) ! 101
  (text_routine_46) ! 102
  (text_routine_47) ! 103
  (text_routine_48) ! 104
  (text_routine_49) ! 105
  (text_routine_50) ! 106
  (text_routine_51) ! 107
  (text_routine_52) ! 108
  (text_routine_53) ! 109
  (text_routine_54) ! 110
  (text_routine_55) ! 111
  (EMPTY_TEXT_VALUE) ! 112
  (0) ! 113
  (0) ! 114
  (T14_customer_responses) ! 115
  (0) ! 116
  (SC_78) ! 117
  (0) ! 118
  (0) ! 119
  (nothing) ! 120
  (0) ! 121
  (0) ! 122
  (0) ! 123
;
Array V2V_Bitmap_71 --> IK2_Count 0 
  174 ! Number of left instances
  3 ! Number of right instances
    PrintShortName ! To print left instances
  T74 ! To print right instances
  true ! Cache broken flag
  V2V_Route_Cache_71 ! Cache array (if any)
$0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0800 $0000 $0000 $0000 $0000 $9240 $0004 $0000 $0049 $0000 $0000 $0000 $0000 $0000 ;
Constant V2V_Route_Cache_71 = 0;



Array T0_final_question_options table  tab_0_0 tab_0_1 tab_0_2 tab_0_3 tab_0_4;
Array tab_0_0 table $0064 0  (SC_79)  (SC_80)  (SC_81)  (SC_82)  (SC_83) ;
Array tab_0_1 table $0465 1  (0)  (0)  (1)  (0)  (0) ;
Array tab_0_2 table $2066 2  (Consult_Grammar_232)  (Consult_Grammar_233)  (Consult_Grammar_234)  (Consult_Grammar_235)  (Consult_Grammar_236) ;
Array tab_0_3 table $0067 3  (IMMEDIATELY_RESTART_VM_R)  (IMMEDIATELY_RESTORE_SAVED_R)  TABLE_NOVALUE (IMMEDIATELY_QUIT_R)  (IMMEDIATELY_UNDO_R) ;
Array tab_0_4 table $0068 4  TABLE_NOVALUE TABLE_NOVALUE (V26_amusing_a_victorious_pla)  TABLE_NOVALUE TABLE_NOVALUE;
Array T1_locale_priorities table  tab_1_0 tab_1_1;
Array tab_1_0 table $0869 NULL  TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE;
Array tab_1_1 table $446a 5  TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE;
Array T2_sample_options table  tab_2_0 tab_2_1 tab_2_2 tab_2_3;
Array tab_2_0 table $006b 27  (SC_84) ;
Array tab_2_1 table $006c 28  TABLE_NOVALUE;
Array tab_2_2 table $006d 29  (SC_85) ;
Array tab_2_3 table $006e 30  TABLE_NOVALUE;
Array T3_menu_commands table  tab_3_0 tab_3_1;
Array tab_3_0 table $446f 31  (78)  (110)  (80)  (112)  (81)  (113)  (13)  (32)  (130)  (129)  (27)  (-8)  (-6)  (-5)  (-4) ;
Array tab_3_1 table $0070 33  (R_863)  (R_863)  (R_864)  (R_864)  (R_862)  (R_862)  (R_865)  (R_865)  (R_863)  (R_864)  (R_862)  (R_862)  (R_865)  (R_863)  (R_864) ;
Array T4_shallow_menu_status table  tab_4_0 tab_4_1 tab_4_2;
Array tab_4_0 table $0071 35  (EMPTY_TEXT_VALUE) ;
Array tab_4_1 table $0072 36  (text_routine_56) ;
Array tab_4_2 table $0073 37  (EMPTY_TEXT_VALUE) ;
Array T5_deep_menu_status table  tab_5_0 tab_5_1 tab_5_2;
Array tab_5_0 table $0071 38  (EMPTY_TEXT_VALUE)  (EMPTY_TEXT_VALUE)  (SC_86)  (SC_87) ;
Array tab_5_1 table $0072 39  (text_routine_57)  (EMPTY_TEXT_VALUE)  (EMPTY_TEXT_VALUE)  (EMPTY_TEXT_VALUE) ;
Array tab_5_2 table $0073 40  (EMPTY_TEXT_VALUE)  (SC_88)  (text_routine_58)  (SC_89) ;
Array T6_sample_hints table  tab_6_0 tab_6_1;
Array tab_6_0 table $0074 41  (SC_90) ;
Array tab_6_1 table $4475 42  TABLE_NOVALUE;
Array T8_options table  tab_8_0 tab_8_1 tab_8_2 tab_8_3;
Array tab_8_0 table $006b 43  (SC_91)  (SC_92)  (SC_93)  (SC_94)  (SC_95)  (text_routine_59) ;
Array tab_8_1 table $006c 44  (T10_command_hints)  (T9_setting_options)  TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE;
Array tab_8_2 table $006d 45  (EMPTY_TEXT_VALUE)  TABLE_NOVALUE (SC_96)  (SC_97)  (text_routine_60)  (text_routine_61) ;
Array tab_8_3 table $006e 46  (R_873)  TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE;
Array T9_setting_options table  tab_9_0 tab_9_1 tab_9_2 tab_9_3;
Array tab_9_0 table $006b 47  (text_routine_62) ;
Array tab_9_1 table $006c 48  TABLE_NOVALUE;
Array tab_9_2 table $006d 49  TABLE_NOVALUE;
Array tab_9_3 table $006e 50  (R_891) ;
Array T10_command_hints table  tab_10_0 tab_10_1;
Array tab_10_0 table $0074 51  (SC_98)  (SC_99)  (SC_100)  (SC_101)  (SC_102)  (SC_103)  (SC_104)  (SC_105)  (SC_106)  (SC_107)  (SC_108)  (SC_109)  (SC_110)  (SC_111)  (SC_112)  (SC_113)  (SC_114)  (SC_115)  (SC_116)  (text_routine_63)  (text_routine_64)  (text_routine_65)  (text_routine_66)  (text_routine_67)  (text_routine_68)  (SC_117)  (text_routine_69)  (SC_118)  (SC_119)  (SC_120)  (SC_121) ;
Array tab_10_1 table $4475 55  TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE;
Array T11_misdialled_numbers table  tab_11_0 tab_11_1;
Array tab_11_0 table $446f 59  (911)  (5554385)  (0)  (999)  (911)  (5558707)  (5552368)  (5553223)  (5553226)  (5550101)  (5550123)  (5550168)  (5550193)  (8953) ;
Array tab_11_1 table $0076 61  (SC_122)  (SC_123)  (SC_124)  (SC_124)  (SC_124)  (SC_125)  (SC_126)  (SC_125)  (SC_127)  (SC_128)  (SC_129)  (SC_130)  (SC_131)  (SC_132) ;
Array T12_ordinary_status table  tab_12_0 tab_12_1 tab_12_2;
Array tab_12_0 table $0071 63  (text_routine_70) ;
Array tab_12_1 table $0072 64  (EMPTY_TEXT_VALUE) ;
Array tab_12_2 table $0073 65  (text_routine_71) ;
Array T14_customer_responses table  tab_14_0 tab_14_1;
Array tab_14_0 table $2066 66  (Consult_Grammar_237)  (Consult_Grammar_238)  (Consult_Grammar_239)  (Consult_Grammar_240)  (Consult_Grammar_241)  (Consult_Grammar_242)  (Consult_Grammar_243)  (Consult_Grammar_244)  (Consult_Grammar_245)  (Consult_Grammar_246)  (Consult_Grammar_247)  (Consult_Grammar_248)  (Consult_Grammar_249)  (Consult_Grammar_250)  (Consult_Grammar_251)  (Consult_Grammar_252) ;
Array tab_14_1 table $0077 68  (text_routine_72)  (text_routine_73)  (text_routine_74)  (text_routine_75)  (text_routine_76)  (text_routine_77)  (text_routine_78)  (text_routine_79)  (text_routine_80)  (text_routine_81)  (text_routine_82)  (text_routine_83)  (text_routine_84)  (text_routine_85)  (text_routine_86)  (text_routine_87) ;
Array T15_customer_responses_2 table  tab_15_0 tab_15_1;
Array tab_15_0 table $2066 70  (Consult_Grammar_253)  (Consult_Grammar_254)  (Consult_Grammar_255)  (Consult_Grammar_256) ;
Array tab_15_1 table $0077 71  (SC_133)  (SC_133)  (SC_133)  (SC_133) ;
Array T16_first_half_customer_resp table  tab_16_0 tab_16_1;
Array tab_16_0 table $2066 72  (Consult_Grammar_257)  (Consult_Grammar_258)  (Consult_Grammar_259)  (Consult_Grammar_260) ;
Array tab_16_1 table $0077 73  (SC_133)  (SC_133)  (SC_133)  (SC_133) ;
Array T17_second_half_customer_res table  tab_17_0 tab_17_1;
Array tab_17_0 table $2066 74  (Consult_Grammar_261)  (Consult_Grammar_262)  (Consult_Grammar_263)  (Consult_Grammar_264) ;
Array tab_17_1 table $0077 75  (SC_134)  (SC_134)  (SC_134)  (SC_134) ;
Array T18_rollerdex_entries_day --> 1 tab_18_0;
Array tab_18_0 table $0078 76  (SC_135)  (SC_136)  (SC_137)  (SC_138)  (SC_139)  (SC_140)  (SC_141) ;
Array T19_rollerdex_entries_month --> 1 tab_19_0;
Array tab_19_0 table $0079 77  (SC_142)  (SC_143)  (SC_144)  (SC_145)  (SC_146)  (SC_147)  (SC_148)  (SC_149)  (SC_150)  (SC_151)  (SC_152)  (SC_153) ;
Array T20_rollerdex_entries_days_o --> 1 tab_20_0;
Array tab_20_0 table $007a 79  (SC_154)  (SC_155)  (SC_156)  (SC_157)  (SC_158)  (SC_159)  (SC_160)  (SC_161)  (SC_162)  (SC_163)  (SC_164)  (SC_165)  (SC_166)  (SC_167)  (SC_168)  (SC_169)  (SC_170)  (SC_171)  (SC_172)  (SC_173)  (SC_174)  (SC_175)  (SC_176)  (SC_177)  (SC_178)  (SC_179)  (SC_180) ;
Array T21_drill_order_part_of_mrma table  tab_21_0 tab_21_1;
Array tab_21_0 table $2066 83  (Consult_Grammar_265)  (Consult_Grammar_266) ;
Array tab_21_1 table $007b 84  (SC_181)  (SC_182) ;
Array T22_chatting_part_of_mrmason table  tab_22_0 tab_22_1;
Array tab_22_0 table $2066 85  (Consult_Grammar_267) ;
Array tab_22_1 table $007b 86  (SC_183) ;
Array TB_Blanks -> 
  ! For table T0_final_question_options
  $00  ! Column 0
  $00  ! Column 1
  $00  ! Column 2
  $04  ! Column 3
  $1b  ! Column 4
  
  ! For table T1_locale_priorities
  $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $7f  ! Column 1
  
  ! For table T2_sample_options
  $00  ! Column 0
  $01  ! Column 1
  $00  ! Column 2
  $01  ! Column 3
  
  ! For table T3_menu_commands
  $00 $00  ! Column 0
  $00 $00  ! Column 1
  
  ! For table T4_shallow_menu_status
  $00  ! Column 0
  $00  ! Column 1
  $00  ! Column 2
  
  ! For table T5_deep_menu_status
  $00  ! Column 0
  $00  ! Column 1
  $00  ! Column 2
  
  ! For table T6_sample_hints
  $00  ! Column 0
  $01  ! Column 1
  
  ! For table T8_options
  $00  ! Column 0
  $3c  ! Column 1
  $02  ! Column 2
  $3e  ! Column 3
  
  ! For table T9_setting_options
  $00  ! Column 0
  $01  ! Column 1
  $01  ! Column 2
  $00  ! Column 3
  
  ! For table T10_command_hints
  $00 $00 $00 $00  ! Column 0
  $ff $ff $ff $7f  ! Column 1
  
  ! For table T11_misdialled_numbers
  $00 $00  ! Column 0
  $00 $00  ! Column 1
  
  ! For table T12_ordinary_status
  $00  ! Column 0
  $00  ! Column 1
  $00  ! Column 2
  
  ! For table T14_customer_responses
  $00 $00  ! Column 0
  $00 $00  ! Column 1
  
  ! For table T15_customer_responses_2
  $00  ! Column 0
  $00  ! Column 1
  
  ! For table T16_first_half_customer_resp
  $00  ! Column 0
  $00  ! Column 1
  
  ! For table T17_second_half_customer_res
  $00  ! Column 0
  $00  ! Column 1
  
  ! For table T18_rollerdex_entries_day
  $00  ! Column 0
  
  ! For table T19_rollerdex_entries_month
  $00 $00  ! Column 0
  
  ! For table T20_rollerdex_entries_days_o
  $00 $00 $00 $00  ! Column 0
  
  ! For table T21_drill_order_part_of_mrma
  $00  ! Column 0
  $00  ! Column 1
  
  ! For table T22_chatting_part_of_mrmason
  $00  ! Column 0
  $00  ! Column 1
  
  ! End of table
  NULL NULL;
[ TC_KOV tc;
    switch (tc) {
        100: return TEXT_TY; ! final question wording: text
        101: return TRUTH_STATE_TY; ! only if victorious: truth state
        102: return UNDERSTANDING_TY; ! topic: topic
        103: return KD1_values_based_rule_producin; ! final response rule: values based rule producing values
        104: return KD2_activity; ! final response activity: activity
        105: return OBJECT_TY; ! notable-object: object
        106: return NUMBER_TY; ! locale description priority: number
        107: return TEXT_TY; ! title: text
        108: return TABLE_TY; ! subtable: table name
        109: return TEXT_TY; ! description: text
        110: return KD1_values_based_rule_producin; ! toggle: values based rule producing values
        111: return NUMBER_TY; ! number: number
        112: return KD1_values_based_rule_producin; ! effect: values based rule producing values
        113: return TEXT_TY; ! left: text
        114: return TEXT_TY; ! central: text
        115: return TEXT_TY; ! right: text
        116: return TEXT_TY; ! hint: text
        117: return NUMBER_TY; ! used: number
        118: return TEXT_TY; ! retort: text
        119: return TEXT_TY; ! customer: text
        120: return TEXT_TY; ! day: text
        121: return TEXT_TY; ! month: text
        122: return TEXT_TY; ! dom: text
        123: return TEXT_TY; ! mason: text
    }
    return UNKNOWN_TY;
];

Array TableOfTables --> TheEmptyTable T0_final_question_options  T1_locale_priorities  T2_sample_options  T3_menu_commands  T4_shallow_menu_status  T5_deep_menu_status  T6_sample_hints  T8_options  T9_setting_options  T10_command_hints  T11_misdialled_numbers  T12_ordinary_status  T14_customer_responses  T15_customer_responses_2  T16_first_half_customer_resp  T17_second_half_customer_res  T18_rollerdex_entries_day  T19_rollerdex_entries_month  T20_rollerdex_entries_days_o  T21_drill_order_part_of_mrma  T22_chatting_part_of_mrmason  0 0;






[ NAP_0;
    if ((action ==##A103_implicit_asking)) rtrue;
    if ((action ==##A104_implicit_telling)) rtrue;
    if ((action ==##A105_implicit_quizzing)) rtrue;
    if ((action ==##A106_implicit_informing)) rtrue;
    if ((action ==##A107_implicit_requesting)) rtrue;
    if ((action ==##A108_implicit_imploring)) rtrue;
    if ((action ==##Yes)) rtrue;
    if ((action ==##No)) rtrue;
    if ((action ==##Sorry)) rtrue;
    rfalse;
];
[ NAP_1;
    if ((action ==##Ask) && ((noun ofclass K8_person)) && (true)) rtrue;
    if ((action ==##Tell) && ((noun ofclass K8_person)) && (true)) rtrue;
    if ((action ==##A101_quizzing_it_about) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))) rtrue;
    if ((action ==##A102_informing_it_about) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))) rtrue;
    if ((action ==##Answer) && ((noun ofclass K8_person)) && (true)) rtrue;
    if ((action ==##AskFor) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))) rtrue;
    if ((action ==##A99_requesting_it_for) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))) rtrue;
    if ((action ==##A100_imploring_it_for) && ((noun ofclass K8_person)) && (true)) rtrue;
    rfalse;
];
[ NAP_2;
    if ((action ==##Ask) && ((noun ofclass K8_person)) && (true)) rtrue;
    if ((action ==##Tell) && ((noun ofclass K8_person)) && (true)) rtrue;
    if ((action ==##A101_quizzing_it_about) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))) rtrue;
    if ((action ==##A102_informing_it_about) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))) rtrue;
    if ((action ==##Answer) && ((noun ofclass K8_person)) && (true)) rtrue;
    if ((action ==##AskFor) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))) rtrue;
    if ((action ==##A99_requesting_it_for) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))) rtrue;
    if ((action ==##A100_imploring_it_for) && ((noun ofclass K8_person)) && (true)) rtrue;
    if ((action ==##Yes)) rtrue;
    if ((action ==##No)) rtrue;
    if ((action ==##Sorry)) rtrue;
    rfalse;
];


Array ActionData table
  ##Inv  $$00000000  OBJECT_TY OBJECT_TY  0 20000
  ##Take  $$00001001  OBJECT_TY OBJECT_TY  ANSTVC_1 20001
  ##Remove  $$00011011  OBJECT_TY OBJECT_TY  0 20002
  ##Drop  $$00001001  OBJECT_TY OBJECT_TY  0 20003
  ##PutOn  $$00011011  OBJECT_TY OBJECT_TY  0 20004
  ##Insert  $$00011011  OBJECT_TY OBJECT_TY  0 20005
  ##Eat  $$01001001  OBJECT_TY OBJECT_TY  0 20006
  ##Go  $$00001000  OBJECT_TY OBJECT_TY  ANSTVC_7 20007
  ##Enter  $$00001001  OBJECT_TY OBJECT_TY  0 20008
  ##Exit  $$00000000  OBJECT_TY OBJECT_TY  ANSTVC_9 20009
  ##GetOff  $$00001001  OBJECT_TY OBJECT_TY  0 20010
  ##Look  $$00000000  OBJECT_TY OBJECT_TY  ANSTVC_11 20011
  ##Examine  $$00001100  OBJECT_TY OBJECT_TY  ANSTVC_12 20012
  ##LookUnder  $$00001100  OBJECT_TY OBJECT_TY  0 20013
  ##Search  $$00001101  OBJECT_TY OBJECT_TY  0 20014
  ##Consult  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20015
  ##Lock  $$10011011  OBJECT_TY OBJECT_TY  0 20016
  ##Unlock  $$10011011  OBJECT_TY OBJECT_TY  0 20017
  ##SwitchOn  $$00001001  OBJECT_TY OBJECT_TY  0 20018
  ##SwitchOff  $$00001001  OBJECT_TY OBJECT_TY  0 20019
  ##Open  $$00001001  OBJECT_TY OBJECT_TY  0 20020
  ##Close  $$00001001  OBJECT_TY OBJECT_TY  0 20021
  ##Wear  $$01001001  OBJECT_TY OBJECT_TY  0 20022
  ##Disrobe  $$01001001  OBJECT_TY OBJECT_TY  0 20023
  ##Give  $$01011011  OBJECT_TY OBJECT_TY  0 20024
  ##Show  $$01011001  OBJECT_TY OBJECT_TY  0 20025
  ##WakeOther  $$00001001  OBJECT_TY OBJECT_TY  0 20026
  ##ThrowAt  $$01011001  OBJECT_TY OBJECT_TY  0 20027
  ##Attack  $$00001001  OBJECT_TY OBJECT_TY  0 20028
  ##Kiss  $$00001001  OBJECT_TY OBJECT_TY  0 20029
  ##Answer  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20030
  ##Tell  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20031
  ##Ask  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20032
  ##AskFor  $$00011011  OBJECT_TY OBJECT_TY  0 20033
  ##Wait  $$00000000  OBJECT_TY OBJECT_TY  0 20034
  ##Touch  $$00001001  OBJECT_TY OBJECT_TY  0 20035
  ##Wave  $$00001001  OBJECT_TY OBJECT_TY  0 20036
  ##Pull  $$00001001  OBJECT_TY OBJECT_TY  0 20037
  ##Push  $$00001001  OBJECT_TY OBJECT_TY  0 20038
  ##Turn  $$00001001  OBJECT_TY OBJECT_TY  0 20039
  ##PushDir  $$00011001  OBJECT_TY OBJECT_TY  0 20040
  ##Squeeze  $$00001001  OBJECT_TY OBJECT_TY  0 20041
  ##Yes  $$00000000  OBJECT_TY OBJECT_TY  0 20042
  ##No  $$00000000  OBJECT_TY OBJECT_TY  0 20043
  ##Burn  $$00001001  OBJECT_TY OBJECT_TY  0 20044
  ##Wake  $$00000000  OBJECT_TY OBJECT_TY  0 20045
  ##Think  $$00000000  OBJECT_TY OBJECT_TY  0 20046
  ##Smell  $$00001001  OBJECT_TY OBJECT_TY  0 20047
  ##Listen  $$00001001  OBJECT_TY OBJECT_TY  0 20048
  ##Taste  $$00001001  OBJECT_TY OBJECT_TY  0 20049
  ##Cut  $$00001001  OBJECT_TY OBJECT_TY  0 20050
  ##Jump  $$00000000  OBJECT_TY OBJECT_TY  0 20051
  ##Tie  $$00011011  OBJECT_TY OBJECT_TY  0 20052
  ##Drink  $$00001001  OBJECT_TY OBJECT_TY  0 20053
  ##Sorry  $$00000000  OBJECT_TY OBJECT_TY  0 20054
  ##Strong  $$00000000  OBJECT_TY OBJECT_TY  0 20055
  ##Mild  $$00000000  OBJECT_TY OBJECT_TY  0 20056
  ##Swing  $$00001001  OBJECT_TY OBJECT_TY  0 20057
  ##Rub  $$00001001  OBJECT_TY OBJECT_TY  0 20058
  ##SetTo  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20059
  ##WaveHands  $$00000000  OBJECT_TY OBJECT_TY  0 20060
  ##Buy  $$00001001  OBJECT_TY OBJECT_TY  0 20061
  ##Sing  $$00000000  OBJECT_TY OBJECT_TY  0 20062
  ##Climb  $$00001001  OBJECT_TY OBJECT_TY  0 20063
  ##Sleep  $$00000000  OBJECT_TY OBJECT_TY  0 20064
  ##Quit  $$00100000  OBJECT_TY OBJECT_TY  0 20065
  ##Save  $$00100000  OBJECT_TY OBJECT_TY  0 20066
  ##Restore  $$00100000  OBJECT_TY OBJECT_TY  0 20067
  ##Restart  $$00100000  OBJECT_TY OBJECT_TY  0 20068
  ##Verify  $$00100000  OBJECT_TY OBJECT_TY  0 20069
  ##ScriptOn  $$00100000  OBJECT_TY OBJECT_TY  0 20070
  ##ScriptOff  $$00100000  OBJECT_TY OBJECT_TY  0 20071
  ##Version  $$00100000  OBJECT_TY OBJECT_TY  0 20072
  ##Score  $$00100000  OBJECT_TY OBJECT_TY  0 20073
  ##LMode3  $$00100000  OBJECT_TY OBJECT_TY  0 20074
  ##LMode2  $$00100000  OBJECT_TY OBJECT_TY  0 20075
  ##LMode1  $$00100000  OBJECT_TY OBJECT_TY  0 20076
  ##NotifyOn  $$00100000  OBJECT_TY OBJECT_TY  0 20077
  ##NotifyOff  $$00100000  OBJECT_TY OBJECT_TY  0 20078
  ##Pronouns  $$00100000  OBJECT_TY OBJECT_TY  0 20079
  ##A80_putting_it_under  $$00011011  OBJECT_TY OBJECT_TY  0 20080
  ##A81_getting_under  $$00001001  OBJECT_TY OBJECT_TY  0 20081
  ##A82_going_under  $$00001001  OBJECT_TY OBJECT_TY  0 20082
  ##A83_getting_out_from_under  $$00001001  OBJECT_TY OBJECT_TY  0 20083
  ##A84_mounting  $$00001001  OBJECT_TY OBJECT_TY  0 20084
  ##A85_dismounting  $$00000000  OBJECT_TY OBJECT_TY  0 20085
  ##A86_asking_for_help  $$00000000  OBJECT_TY OBJECT_TY  0 20086
  ##A87_switching_cheats_on  $$00000000  OBJECT_TY OBJECT_TY  0 20087
  ##A88_switching_cheats_off  $$00000000  OBJECT_TY OBJECT_TY  0 20088
  ##A89_teleporting_to  $$00001001  OBJECT_TY OBJECT_TY  0 20089
  ##A90_moving_to  $$00011000  OBJECT_TY OBJECT_TY  0 20090
  ##A91_putting_back  $$00011000  OBJECT_TY OBJECT_TY  0 20091
  ##A92_universal_opening  $$00000000  OBJECT_TY OBJECT_TY  0 20092
  ##A93_changing_player  $$00001000  OBJECT_TY OBJECT_TY  0 20093
  ##A94_point_increasing  $$00001000  NUMBER_TY OBJECT_TY  0 20094
  ##A95_restoring_score  $$00000000  OBJECT_TY OBJECT_TY  0 20095
  ##A96_removing  $$00001000  OBJECT_TY OBJECT_TY  0 20096
  ##A97_paying_wizard_money  $$00011011  OBJECT_TY OBJECT_TY  0 20097
  ##A98_inputting  $$00001000  VALUE_TY OBJECT_TY  0 20098
  ##A99_requesting_it_for  $$00011000  OBJECT_TY OBJECT_TY  0 20099
  ##A100_imploring_it_for  $$00011000  OBJECT_TY UNDERSTANDING_TY  0 20100
  ##A101_quizzing_it_about  $$00011000  OBJECT_TY OBJECT_TY  0 20101
  ##A102_informing_it_about  $$00011000  OBJECT_TY OBJECT_TY  0 20102
  ##A103_implicit_asking  $$00001000  UNDERSTANDING_TY OBJECT_TY  0 20103
  ##A104_implicit_telling  $$00001000  UNDERSTANDING_TY OBJECT_TY  0 20104
  ##A105_implicit_quizzing  $$00001000  OBJECT_TY OBJECT_TY  0 20105
  ##A106_implicit_informing  $$00001000  OBJECT_TY OBJECT_TY  0 20106
  ##A107_implicit_requesting  $$00001000  OBJECT_TY OBJECT_TY  0 20107
  ##A108_implicit_imploring  $$00001000  UNDERSTANDING_TY OBJECT_TY  0 20108
  ##A109_saying_hello_to  $$00001000  OBJECT_TY OBJECT_TY  0 20109
  ##A110_hailing  $$00000000  OBJECT_TY OBJECT_TY  0 20110
  ##A111_leavetaking  $$00000000  OBJECT_TY OBJECT_TY  0 20111
  ##A112_saying_goodbye_to  $$00001000  OBJECT_TY OBJECT_TY  0 20112
  ##A113_dialling_it_on  $$00011000  NUMBER_TY OBJECT_TY  ANSTVC_113 20113
  ##A114_hanging_up  $$00000000  OBJECT_TY OBJECT_TY  ANSTVC_114 20114
  ##A115_sitting_on  $$00001001  OBJECT_TY OBJECT_TY  0 20115
  ##A116_lying_on  $$00001001  OBJECT_TY OBJECT_TY  0 20116
  ##A117_standing_up_on  $$00001001  OBJECT_TY OBJECT_TY  0 20117
  ##A118_lying_down  $$00000000  OBJECT_TY OBJECT_TY  0 20118
  ##A119_sitting_down  $$00000000  OBJECT_TY OBJECT_TY  0 20119
  ##A120_standing_up  $$00000000  OBJECT_TY OBJECT_TY  0 20120
  ##A121_taking_position  $$00001000  46 OBJECT_TY  0 20121
  ##A122_asking_for_hints  $$00000000  OBJECT_TY OBJECT_TY  0 20122
  ##A123_getting_out  $$00000000  OBJECT_TY OBJECT_TY  0 20123
  ##A124_carjacking  $$00001000  OBJECT_TY OBJECT_TY  0 20124
  ##A125_using  $$00001001  OBJECT_TY OBJECT_TY  0 20125
  ##A126_responding_to_customer  $$00001000  UNDERSTANDING_TY OBJECT_TY  0 20126
  ##A127_saying  $$00001000  UNDERSTANDING_TY OBJECT_TY  0 20127
  ##A128_flipping  $$00001001  OBJECT_TY OBJECT_TY  0 20128
  ##A129_writing_intro  $$00001001  OBJECT_TY OBJECT_TY  0 20129
  ##A130_writing_on  $$00001000  UNDERSTANDING_TY OBJECT_TY  0 20130
  ##A131_clearing_the_screen  $$00100000  OBJECT_TY OBJECT_TY  0 20131
  ##A132_wanting  $$00001001  OBJECT_TY OBJECT_TY  0 20132
  ##A133_playing  $$00001001  OBJECT_TY OBJECT_TY  0 20133
  ##A134_thanking  $$00001001  OBJECT_TY OBJECT_TY  0 20134
  ##A135_thanking_with_no_noun  $$00000000  OBJECT_TY OBJECT_TY  0 20135
  ##A136_dursley_s_spellcasting  $$00000000  OBJECT_TY OBJECT_TY  0 20136
  ##A137_jumping_out_of  $$00001001  OBJECT_TY OBJECT_TY  0 20137
  ##A138_timing  $$00000000  OBJECT_TY OBJECT_TY  0 20138
;
Constant AD_RECORDS = 139;
[ ANSTVC_1 pos state;
    if (state == 1) {
        MStack-->pos = nothing; pos++;
    } else {
        pos++;
    }
    return 1;
];
[ ANSTVC_7 pos state;
    if (state == 1) {
        MStack-->pos = I102_darknesss; pos++;
        MStack-->pos = nothing; pos++;
        MStack-->pos = nothing; pos++;
        MStack-->pos = nothing; pos++;
        MStack-->pos = nothing; pos++;
    } else {
        pos++;
        pos++;
        pos++;
        pos++;
        pos++;
    }
    return 5;
];
[ ANSTVC_9 pos state;
    if (state == 1) {
        MStack-->pos = nothing; pos++;
    } else {
        pos++;
    }
    return 1;
];
[ ANSTVC_11 pos state;
    if (state == 1) {
        MStack-->pos = ##Wait; pos++;
        MStack-->pos = false; pos++;
        MStack-->pos = 0; pos++;
        MStack-->pos = nothing; pos++;
    } else {
        pos++;
        pos++;
        pos++;
        pos++;
    }
    return 4;
];
[ ANSTVC_12 pos state;
    if (state == 1) {
        MStack-->pos = false; pos++;
    } else {
        pos++;
    }
    return 1;
];
[ ANSTVC_113 pos state;
    if (state == 1) {
        MStack-->pos = nothing; pos++;
    } else {
        pos++;
    }
    return 1;
];
[ ANSTVC_114 pos state;
    if (state == 1) {
        MStack-->pos = nothing; pos++;
    } else {
        pos++;
    }
    return 1;
];
[ DB_Action_Details act n s for_say;
    switch (act) {
        ##Inv: print "taking inventory"; 
        ##Take: print "taking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Remove: print "removing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "from"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Drop: print "dropping"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##PutOn: print "putting"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "on"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Insert: print "inserting"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "into"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Eat: print "eating"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Go: print "going"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Enter: print "entering"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Exit: print "exiting"; 
        ##GetOff: print "getting off"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Look: print "looking"; 
        ##Examine: print "examining"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##LookUnder: print "looking under"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Search: print "searching"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Consult: print "consulting"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "about"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##Lock: print "locking"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "with"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Unlock: print "unlocking"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "with"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##SwitchOn: print "switching on"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##SwitchOff: print "switching off"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Open: print "opening"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Close: print "closing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Wear: print "wearing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Disrobe: print "taking off"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Give: print "giving"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Show: print "showing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##WakeOther: print "waking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##ThrowAt: print "throwing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "at"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Attack: print "attacking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Kiss: print "kissing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Answer: print "answering"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "that"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##Tell: print "telling"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "about"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##Ask: print "asking"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "about"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##AskFor: print "asking"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "for"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Wait: print "waiting"; 
        ##Touch: print "touching"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Wave: print "waving"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Pull: print "pulling"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Push: print "pushing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Turn: print "turning"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##PushDir: print "pushing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Squeeze: print "squeezing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Yes: print "saying yes"; 
        ##No: print "saying no"; 
        ##Burn: print "burning"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Wake: print "waking up"; 
        ##Think: print "thinking"; 
        ##Smell: print "smelling"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Listen: print "listening to"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Taste: print "tasting"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Cut: print "cutting"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Jump: print "jumping"; 
        ##Tie: print "tying"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Drink: print "drinking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Sorry: print "saying sorry"; 
        ##Strong: print "swearing obscenely"; 
        ##Mild: print "swearing mildly"; 
        ##Swing: print "swinging"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Rub: print "rubbing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##SetTo: print "setting"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##WaveHands: print "waving hands"; 
        ##Buy: print "buying"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Sing: print "singing"; 
        ##Climb: print "climbing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Sleep: print "sleeping"; 
        ##Quit: print "quitting the game"; 
        ##Save: print "saving the game"; 
        ##Restore: print "restoring the game"; 
        ##Restart: print "restarting the game"; 
        ##Verify: print "verifying the story file"; 
        ##ScriptOn: print "switching the story transcript on"; 
        ##ScriptOff: print "switching the story transcript off"; 
        ##Version: print "requesting the story file version"; 
        ##Score: print "requesting the score"; 
        ##LMode3: print "preferring abbreviated room descriptions"; 
        ##LMode2: print "preferring unabbreviated room descriptions"; 
        ##LMode1: print "preferring sometimes abbreviated room descriptions"; 
        ##NotifyOn: print "switching score notification on"; 
        ##NotifyOff: print "switching score notification off"; 
        ##Pronouns: print "requesting the pronoun meanings"; 
        ##A80_putting_it_under: print "putting"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "under"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##A81_getting_under: print "getting under"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A82_going_under: print "going under"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A83_getting_out_from_under: print "getting out from under"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A84_mounting: print "mounting"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A85_dismounting: print "dismounting"; 
        ##A86_asking_for_help: print "asking for help"; 
        ##A87_switching_cheats_on: print "switching cheats on"; 
        ##A88_switching_cheats_off: print "switching cheats off"; 
        ##A89_teleporting_to: print "teleporting to"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A90_moving_to: print "moving to"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A91_putting_back: print "putting back"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A92_universal_opening: print "universal opening"; 
        ##A93_changing_player: print "changing player"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A94_point_increasing: print "point increasing"; if (for_say ~= 2) { print " "; DA_Number(parsed_number); }
        ##A95_restoring_score: print "restoring score"; 
        ##A96_removing: print "removing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A97_paying_wizard_money: print "paying wizard money"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A98_inputting: print "inputting"; if (for_say ~= 2) { print " "; DA_Number(parsed_number); }
        ##A99_requesting_it_for: print "requesting"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "for"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##A100_imploring_it_for: print "imploring"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "for"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##A101_quizzing_it_about: print "quizzing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "about"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##A102_informing_it_about: print "informing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "about"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##A103_implicit_asking: print "implicit-asking"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##A104_implicit_telling: print "implicit-telling"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##A105_implicit_quizzing: print "implicit-quizzing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A106_implicit_informing: print "implicit-informing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A107_implicit_requesting: print "implicit-requesting"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A108_implicit_imploring: print "implicit-imploring"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##A109_saying_hello_to: print "saying hello to"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A110_hailing: print "hailing"; 
        ##A111_leavetaking: print "leavetaking"; 
        ##A112_saying_goodbye_to: print "saying goodbye to"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A113_dialling_it_on: print "dialling"; print " "; if (for_say == 2) print "it"; else DA_Number(parsed_number); print " "; print "on"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##A114_hanging_up: print "hanging up"; 
        ##A115_sitting_on: print "sitting on"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A116_lying_on: print "lying on"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A117_standing_up_on: print "standing up on"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A118_lying_down: print "lying down"; 
        ##A119_sitting_down: print "sitting down"; 
        ##A120_standing_up: print "standing up"; 
        ##A121_taking_position: print "taking position"; if (for_say ~= 2) { print " "; T74(parsed_number); }
        ##A122_asking_for_hints: print "asking for hints"; 
        ##A123_getting_out: print "getting out"; 
        ##A124_carjacking: print "carjacking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A125_using: print "using"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A126_responding_to_customer: print "responding to customer"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##A127_saying: print "saying"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##A128_flipping: print "flipping"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A129_writing_intro: print "writing intro"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A130_writing_on: print "writing on"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##A131_clearing_the_screen: print "clearing the screen"; 
        ##A132_wanting: print "wanting"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A133_playing: print "playing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A134_thanking: print "thanking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A135_thanking_with_no_noun: print "thanking with no noun"; 
        ##A136_dursley_s_spellcasting: print "dursley's spellcasting"; 
        ##A137_jumping_out_of: print "jumping out of"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A138_timing: print "timing"; 
    }
];

Array ActionCoding -->
    ##Inv ##Take ##Remove ##Drop ##PutOn ##Insert ##Eat ##Go
    ##Enter ##Exit ##GetOff ##Look ##Examine ##LookUnder ##Search ##Consult
    ##Lock ##Unlock ##SwitchOn ##SwitchOff ##Open ##Close ##Wear ##Disrobe
    ##Give ##Show ##WakeOther ##ThrowAt ##Attack ##Kiss ##Answer ##Tell
    ##Ask ##AskFor ##Wait ##Touch ##Wave ##Pull ##Push ##Turn
    ##PushDir ##Squeeze ##Yes ##No ##Burn ##Wake ##Think ##Smell
    ##Listen ##Taste ##Cut ##Jump ##Tie ##Drink ##Sorry ##Strong
    ##Mild ##Swing ##Rub ##SetTo ##WaveHands ##Buy ##Sing ##Climb
    ##Sleep ##Quit ##Save ##Restore ##Restart ##Verify ##ScriptOn ##ScriptOff
    ##Version ##Score ##LMode3 ##LMode2 ##LMode1 ##NotifyOn ##NotifyOff ##Pronouns
    ##A80_putting_it_under ##A81_getting_under ##A82_going_under ##A83_getting_out_from_under ##A84_mounting ##A85_dismounting ##A86_asking_for_help ##A87_switching_cheats_on
    ##A88_switching_cheats_off ##A89_teleporting_to ##A90_moving_to ##A91_putting_back ##A92_universal_opening ##A93_changing_player ##A94_point_increasing ##A95_restoring_score
    ##A96_removing ##A97_paying_wizard_money ##A98_inputting ##A99_requesting_it_for ##A100_imploring_it_for ##A101_quizzing_it_about ##A102_informing_it_about ##A103_implicit_asking
    ##A104_implicit_telling ##A105_implicit_quizzing ##A106_implicit_informing ##A107_implicit_requesting ##A108_implicit_imploring ##A109_saying_hello_to ##A110_hailing ##A111_leavetaking
    ##A112_saying_goodbye_to ##A113_dialling_it_on ##A114_hanging_up ##A115_sitting_on ##A116_lying_on ##A117_standing_up_on ##A118_lying_down ##A119_sitting_down
    ##A120_standing_up ##A121_taking_position ##A122_asking_for_hints ##A123_getting_out ##A124_carjacking ##A125_using ##A126_responding_to_customer ##A127_saying
    ##A128_flipping ##A129_writing_intro ##A130_writing_on ##A131_clearing_the_screen ##A132_wanting ##A133_playing ##A134_thanking ##A135_thanking_with_no_noun
    ##A136_dursley_s_spellcasting ##A137_jumping_out_of ##A138_timing;


Array ActionHappened --> 0 0 0 0 0 0 0 0 0;


[ InvSub; return GenericVerbSub(125,126,127); ];
[ TakeSub; return GenericVerbSub(128,129,130); ];
[ RemoveSub; return GenericVerbSub(131,132,133); ];
[ DropSub; return GenericVerbSub(134,135,136); ];
[ PutOnSub; return GenericVerbSub(137,138,139); ];
[ InsertSub; return GenericVerbSub(140,141,142); ];
[ EatSub; return GenericVerbSub(143,144,145); ];
[ GoSub; return GenericVerbSub(146,147,148); ];
[ EnterSub; return GenericVerbSub(149,150,151); ];
[ ExitSub; return GenericVerbSub(152,153,154); ];
[ GetOffSub; return GenericVerbSub(155,156,157); ];
[ LookSub; return GenericVerbSub(158,159,160); ];
[ ExamineSub; return GenericVerbSub(161,162,163); ];
[ LookUnderSub; return GenericVerbSub(164,165,166); ];
[ SearchSub; return GenericVerbSub(167,168,169); ];
[ ConsultSub; return GenericVerbSub(170,171,172); ];
[ LockSub; return GenericVerbSub(173,174,175); ];
[ UnlockSub; return GenericVerbSub(176,177,178); ];
[ SwitchOnSub; return GenericVerbSub(179,180,181); ];
[ SwitchOffSub; return GenericVerbSub(182,183,184); ];
[ OpenSub; return GenericVerbSub(185,186,187); ];
[ CloseSub; return GenericVerbSub(188,189,190); ];
[ WearSub; return GenericVerbSub(191,192,193); ];
[ DisrobeSub; return GenericVerbSub(194,195,196); ];
[ GiveSub; return GenericVerbSub(197,198,199); ];
[ ShowSub; return GenericVerbSub(200,201,202); ];
[ WakeOtherSub; return GenericVerbSub(203,204,205); ];
[ ThrowAtSub; return GenericVerbSub(206,207,208); ];
[ AttackSub; return GenericVerbSub(209,210,211); ];
[ KissSub; return GenericVerbSub(212,213,214); ];
[ AnswerSub; return GenericVerbSub(215,216,217); ];
[ TellSub; return GenericVerbSub(218,219,220); ];
[ AskSub; return GenericVerbSub(221,222,223); ];
[ AskForSub; return GenericVerbSub(224,225,226); ];
[ WaitSub; return GenericVerbSub(227,228,229); ];
[ TouchSub; return GenericVerbSub(230,231,232); ];
[ WaveSub; return GenericVerbSub(233,234,235); ];
[ PullSub; return GenericVerbSub(236,237,238); ];
[ PushSub; return GenericVerbSub(239,240,241); ];
[ TurnSub; return GenericVerbSub(242,243,244); ];
[ PushDirSub; return GenericVerbSub(245,246,247); ];
[ SqueezeSub; return GenericVerbSub(248,249,250); ];
[ YesSub; return GenericVerbSub(251,252,253); ];
[ NoSub; return GenericVerbSub(254,255,256); ];
[ BurnSub; return GenericVerbSub(257,258,259); ];
[ WakeSub; return GenericVerbSub(260,261,262); ];
[ ThinkSub; return GenericVerbSub(263,264,265); ];
[ SmellSub; return GenericVerbSub(266,267,268); ];
[ ListenSub; return GenericVerbSub(269,270,271); ];
[ TasteSub; return GenericVerbSub(272,273,274); ];
[ CutSub; return GenericVerbSub(275,276,277); ];
[ JumpSub; return GenericVerbSub(278,279,280); ];
[ TieSub; return GenericVerbSub(281,282,283); ];
[ DrinkSub; return GenericVerbSub(284,285,286); ];
[ SorrySub; return GenericVerbSub(287,288,289); ];
[ StrongSub; return GenericVerbSub(290,291,292); ];
[ MildSub; return GenericVerbSub(293,294,295); ];
[ SwingSub; return GenericVerbSub(296,297,298); ];
[ RubSub; return GenericVerbSub(299,300,301); ];
[ SetToSub; return GenericVerbSub(302,303,304); ];
[ WaveHandsSub; return GenericVerbSub(305,306,307); ];
[ BuySub; return GenericVerbSub(308,309,310); ];
[ SingSub; return GenericVerbSub(311,312,313); ];
[ ClimbSub; return GenericVerbSub(314,315,316); ];
[ SleepSub; return GenericVerbSub(317,318,319); ];
[ QuitSub; return GenericVerbSub(320,321,322); ];
[ SaveSub; return GenericVerbSub(323,324,325); ];
[ RestoreSub; return GenericVerbSub(326,327,328); ];
[ RestartSub; return GenericVerbSub(329,330,331); ];
[ VerifySub; return GenericVerbSub(332,333,334); ];
[ ScriptOnSub; return GenericVerbSub(335,336,337); ];
[ ScriptOffSub; return GenericVerbSub(338,339,340); ];
[ VersionSub; return GenericVerbSub(341,342,343); ];
[ ScoreSub; return GenericVerbSub(344,345,346); ];
[ LMode3Sub; return GenericVerbSub(347,348,349); ];
[ LMode2Sub; return GenericVerbSub(350,351,352); ];
[ LMode1Sub; return GenericVerbSub(353,354,355); ];
[ NotifyOnSub; return GenericVerbSub(356,357,358); ];
[ NotifyOffSub; return GenericVerbSub(359,360,361); ];
[ PronounsSub; return GenericVerbSub(362,363,364); ];
[ A80_putting_it_underSub; return GenericVerbSub(367,368,369); ];
[ A81_getting_underSub; return GenericVerbSub(370,371,372); ];
[ A82_going_underSub; return GenericVerbSub(373,374,375); ];
[ A83_getting_out_from_underSub; return GenericVerbSub(376,377,378); ];
[ A84_mountingSub; return GenericVerbSub(379,380,381); ];
[ A85_dismountingSub; return GenericVerbSub(382,383,384); ];
[ A86_asking_for_helpSub; return GenericVerbSub(388,389,390); ];
[ A87_switching_cheats_onSub; return GenericVerbSub(391,392,393); ];
[ A88_switching_cheats_offSub; return GenericVerbSub(394,395,396); ];
[ A89_teleporting_toSub; return GenericVerbSub(397,398,399); ];
[ A90_moving_toSub; return GenericVerbSub(400,401,402); ];
[ A91_putting_backSub; return GenericVerbSub(403,404,405); ];
[ A92_universal_openingSub; return GenericVerbSub(406,407,408); ];
[ A93_changing_playerSub; return GenericVerbSub(409,410,411); ];
[ A94_point_increasingSub; return GenericVerbSub(412,413,414); ];
[ A95_restoring_scoreSub; return GenericVerbSub(415,416,417); ];
[ A96_removingSub; return GenericVerbSub(418,419,420); ];
[ A97_paying_wizard_moneySub; return GenericVerbSub(421,422,423); ];
[ A98_inputtingSub; return GenericVerbSub(424,425,426); ];
[ A99_requesting_it_forSub; return GenericVerbSub(427,428,429); ];
[ A100_imploring_it_forSub; return GenericVerbSub(430,431,432); ];
[ A101_quizzing_it_aboutSub; return GenericVerbSub(433,434,435); ];
[ A102_informing_it_aboutSub; return GenericVerbSub(436,437,438); ];
[ A103_implicit_askingSub; return GenericVerbSub(439,440,441); ];
[ A104_implicit_tellingSub; return GenericVerbSub(442,443,444); ];
[ A105_implicit_quizzingSub; return GenericVerbSub(445,446,447); ];
[ A106_implicit_informingSub; return GenericVerbSub(448,449,450); ];
[ A107_implicit_requestingSub; return GenericVerbSub(451,452,453); ];
[ A108_implicit_imploringSub; return GenericVerbSub(454,455,456); ];
[ A109_saying_hello_toSub; return GenericVerbSub(457,458,459); ];
[ A110_hailingSub; return GenericVerbSub(460,461,462); ];
[ A111_leavetakingSub; return GenericVerbSub(463,464,465); ];
[ A112_saying_goodbye_toSub; return GenericVerbSub(466,467,468); ];
[ A113_dialling_it_onSub; return GenericVerbSub(486,487,488); ];
[ A114_hanging_upSub; return GenericVerbSub(489,490,491); ];
[ A115_sitting_onSub; return GenericVerbSub(492,493,494); ];
[ A116_lying_onSub; return GenericVerbSub(495,496,497); ];
[ A117_standing_up_onSub; return GenericVerbSub(498,499,500); ];
[ A118_lying_downSub; return GenericVerbSub(501,502,503); ];
[ A119_sitting_downSub; return GenericVerbSub(504,505,506); ];
[ A120_standing_upSub; return GenericVerbSub(507,508,509); ];
[ A121_taking_positionSub; return GenericVerbSub(510,511,512); ];
[ A122_asking_for_hintsSub; return GenericVerbSub(514,515,516); ];
[ A123_getting_outSub; return GenericVerbSub(517,518,519); ];
[ A124_carjackingSub; return GenericVerbSub(522,523,524); ];
[ A125_usingSub; return GenericVerbSub(525,526,527); ];
[ A126_responding_to_customerSub; return GenericVerbSub(530,531,532); ];
[ A127_sayingSub; return GenericVerbSub(533,534,535); ];
[ A128_flippingSub; return GenericVerbSub(536,537,538); ];
[ A129_writing_introSub; return GenericVerbSub(541,542,543); ];
[ A130_writing_onSub; return GenericVerbSub(544,545,546); ];
[ A131_clearing_the_screenSub; return GenericVerbSub(547,548,549); ];
[ A132_wantingSub; return GenericVerbSub(550,551,552); ];
[ A133_playingSub; return GenericVerbSub(553,554,555); ];
[ A134_thankingSub; return GenericVerbSub(556,557,558); ];
[ A135_thanking_with_no_nounSub; return GenericVerbSub(559,560,561); ];
[ A136_dursley_s_spellcastingSub; return GenericVerbSub(564,565,566); ];
[ A137_jumping_out_ofSub; return GenericVerbSub(567,568,569); ];
[ A138_timingSub; return GenericVerbSub(570,571,572); ];

[ MistakeActionSub;
    switch(understand_as_mistake_number) {
        493: ParserError(text_routine_88);
        494: ParserError(text_routine_89);
        495: ParserError(text_routine_90);
        496: ParserError(text_routine_91);
        default: "I didn't understand that sentence.";
    }
    say__p = 1;
];



! Definitions of rule phrases


! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Procedural (B0_procedural)
! ----------------------------------------------------------------------------------------------------
! Rule 1/16 ! Procedural rule while eating something:
!   >>> I - Number of aspects constrained >>>
! Rule 2/16 ! a procedural rule:
!   === which is equally specific with ===
! Rule 3/16 ! A procedural rule:
!   === which is equally specific with ===
! Rule 4/16 ! A procedural rule:
!   === which is equally specific with ===
! Rule 5/16 ! A procedural rule:
!   === which is equally specific with ===
! Rule 6/16 ! A procedural rule:
!   === which is equally specific with ===
! Rule 7/16 ! A procedural rule:
!   === which is equally specific with ===
! Rule 8/16 ! A procedural rule:
!   === which is equally specific with ===
! Rule 9/16 ! A procedural rule:
!   === which is equally specific with ===
! Rule 10/16 ! A procedural rule:
!   === which is equally specific with ===
! Rule 11/16 ! a procedural rule:
!   === which is equally specific with ===
! Rule 12/16 ! A procedural rule:
!   === which is equally specific with ===
! Rule 13/16 ! a procedural rule:
!   === which is equally specific with ===
! Rule 14/16 ! a procedural rule:
!   === which is equally specific with ===
! Rule 15/16 ! a procedural rule:
!   === which is equally specific with ===
! Rule 16/16 ! a procedural rule:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Procedural rule while eating something:
[ R_1135 ;
   if (((((action ==##Eat) &&  (actor==player) && ((noun ofclass K2_thing)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1135, 1135);
      ! phrase 1
      ! [1: ignore the carrying requirements rule]
       SuppressRule(CARRYING_REQUIREMENTS_R); 
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1135, 1135, true);
   rfalse;
];
! No specific request
! From "Cheats" by Orion Zymaris
! a procedural rule:
[ R_899 ;
      ! phrase 1
      ! [1: if cheats_bin is 1 begin]
       if ((((Global_Vars-->25) == 1)))  {
         ! phrase 2
         ! [2: ignore block attacking rule]
          SuppressRule(R_243); 
         ! phrase 3
         ! [3: end if]
         }

      ! phrase 4
      ! [4: if cheats_bin is 0 begin]
       if ((((Global_Vars-->25) == 0)))  {
         ! phrase 5
         ! [5: reinstate block attacking rule]
          ReinstateRule(R_243); 
         ! phrase 6
         ! [6: end if]
         }

   rfalse;
];
! No specific request
! From "Cheats" by Orion Zymaris
! A procedural rule:
[ R_913 ;
      ! phrase 1
      ! [1: if cheats_bin is 1 begin]
       if ((((Global_Vars-->25) == 1)))  {
         ! phrase 2
         ! [2: ignore can't take what's fixed in place rule]
          SuppressRule(R_98); 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: reinstate can't take what's fixed in place rule]
          ReinstateRule(R_98); 
         ! phrase 5
         ! [5: end if]
         }

   rfalse;
];
! No specific request
! From "Cheats" by Orion Zymaris
! A procedural rule:
[ R_914 ;
      ! phrase 1
      ! [1: if cheats_bin is 1 begin]
       if ((((Global_Vars-->25) == 1)))  {
         ! phrase 2
         ! [2: ignore can't take other people rule]
          SuppressRule(R_90); 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: reinstate can't take other people rule]
          ReinstateRule(R_90); 
         ! phrase 5
         ! [5: end if]
         }

   rfalse;
];
! No specific request
! From "Cheats" by Orion Zymaris
! A procedural rule:
[ R_915 ;
      ! phrase 1
      ! [1: if cheats_bin is 1 begin]
       if ((((Global_Vars-->25) == 1)))  {
         ! phrase 2
         ! [2: ignore can only take things rule]
          SuppressRule(R_97); 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: reinstate can only take things rule]
          ReinstateRule(R_97); 
         ! phrase 5
         ! [5: end if]
         }

   rfalse;
];
! No specific request
! From "Cheats" by Orion Zymaris
! A procedural rule:
[ R_916 ;
      ! phrase 1
      ! [1: if cheats_bin is 1 begin]
       if ((((Global_Vars-->25) == 1)))  {
         ! phrase 2
         ! [2: ignore can't take people's possessions rule]
          SuppressRule(R_92); 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: reinstate can't take people's possessions rule]
          ReinstateRule(R_92); 
         ! phrase 5
         ! [5: end if]
         }

   rfalse;
];
! No specific request
! From "Cheats" by Orion Zymaris
! A procedural rule:
[ R_917 ;
      ! phrase 1
      ! [1: if cheats_bin is 1 begin]
       if ((((Global_Vars-->25) == 1)))  {
         ! phrase 2
         ! [2: ignore can't reach inside closed containers rule]
          SuppressRule(CANT_REACH_INSIDE_CLOSED_R); 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: reinstate can't reach inside closed containers rule]
          ReinstateRule(CANT_REACH_INSIDE_CLOSED_R); 
         ! phrase 5
         ! [5: end if]
         }

   rfalse;
];
! No specific request
! From "Cheats" by Orion Zymaris
! A procedural rule:
[ R_918 ;
      ! phrase 1
      ! [1: if cheats_bin is 1 begin]
       if ((((Global_Vars-->25) == 1)))  {
         ! phrase 2
         ! [2: ignore can't reach inside rooms rule]
          SuppressRule(CANT_REACH_INSIDE_ROOMS_R); 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: reinstate can't reach inside rooms rule]
          ReinstateRule(CANT_REACH_INSIDE_ROOMS_R); 
         ! phrase 5
         ! [5: end if]
         }

   rfalse;
];
! No specific request
! A procedural rule:
[ R_1094 ;
      ! phrase 1
      ! [1: ignore block drinking rule]
       SuppressRule(R_288); 
   rfalse;
];
! No specific request
! A procedural rule:
[ R_1107 ;
      ! phrase 1
      ! [1: ignore block climbing rule]
       SuppressRule(R_298); 
   rfalse;
];
! No specific request
! a procedural rule:
[ R_1120 ;
      ! phrase 1
      ! [1: ignore block giving rule]
       SuppressRule(R_233); 
   rfalse;
];
! No specific request
! A procedural rule:
[ R_1127 ;
      ! phrase 1
      ! [1: ignore standard report eating rule]
       SuppressRule(R_136); 
   rfalse;
];
! No specific request
! a procedural rule:
[ R_1270 ;
      ! phrase 1
      ! [1: if the player is in street , ignore the block listening rule]
       if (((I285_street == ContainerOf(player)))) {  SuppressRule(R_283);   }
   rfalse;
];
! No specific request
! a procedural rule:
[ R_1293 ;
      ! phrase 1
      ! [1: ignore block thinking rule]
       SuppressRule(R_281); 
   rfalse;
];
! No specific request
! a procedural rule:
[ R_1294 ;
      ! phrase 1
      ! [1: ignore block answering rule]
       SuppressRule(R_246); 
   rfalse;
];
! No specific request
! a procedural rule:
[ R_1307 ;
      ! phrase 1
      ! [1: ignore block telling rule]
       SuppressRule(R_248); 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Startup (B1_startup)
! ----------------------------------------------------------------------------------------------------
! Rule 1/10: INITIALISE_MEMORY_R
!   === which is equally specific with ===
! Rule 2/10: VIRTUAL_MACHINE_STARTUP_R
!   === which is equally specific with ===
! Rule 3/10: SEED_RANDOM_NUMBER_GENERATOR_R
!   === which is equally specific with ===
! Rule 4/10: UPDATE_CHRONOLOGICAL_RECORDS_R
!   === which is equally specific with ===
! Rule 5/10: POSITION_PLAYER_IN_MODEL_R
!   === which is equally specific with ===
! Rule 6/10 ! This is the start in the correct scenes rule:
! --- now the mid-placed rules ---
! Rule 7/10 ! This is the when play begins stage rule:
!   === which is equally specific with ===
! Rule 8/10 ! This is the fix baseline scoring rule:
!   === which is equally specific with ===
! Rule 9/10 ! This is the display banner rule:
!   === which is equally specific with ===
! Rule 10/10 ! This is the initial room description rule:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! This is the start in the correct scenes rule:
[ R_8 ;
      ! phrase 1
      ! [1: consider the scene changing rules]
       ProcessRulebook(4); 
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the when play begins stage rule:
[ R_9 ;
      ! phrase 1
      ! [1: follow the when play begins rulebook]
       FollowRulebook(5); 
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the fix baseline scoring rule:
[ R_10 ;
      ! phrase 1
      ! [1: now the last notified score is the score]
       last_score = score; 
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the display banner rule:
[ R_11 ;
      ! phrase 1
      ! [1: say ~[banner text]~]
      say__p=1;ParaContent();  Banner();  .L_Say0; .L_SayX0;
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the initial room description rule:
[ R_12 ;
      ! phrase 1
      ! [1: try looking]
       TryAction(0, player, ##Look, 0, 0);; 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Turn sequence (B2_turn_sequence)
! ----------------------------------------------------------------------------------------------------
! Rule 1/11: PARSE_COMMAND_R
!   === which is equally specific with ===
! Rule 2/11: GENERATE_ACTION_R
!   === which is equally specific with ===
! Rule 3/11 ! A first turn sequence rule:
!   === which is equally specific with ===
! Rule 4/11 ! A first turn sequence rule ( this is the every turn stage rule ):
! --- now the mid-placed rules ---
! Rule 5/11: TIMED_EVENTS_R
!   === which is equally specific with ===
! Rule 6/11: ADVANCE_TIME_R
!   === which is equally specific with ===
! Rule 7/11: UPDATE_CHRONOLOGICAL_RECORDS_R
! --- now the last-placed rules ---
! Rule 8/11 ! A last turn sequence rule:
!   === which is equally specific with ===
! Rule 9/11: ADJUST_LIGHT_R
!   === which is equally specific with ===
! Rule 10/11: NOTE_OBJECT_ACQUISITIONS_R
!   === which is equally specific with ===
! Rule 11/11 ! This is the notify score changes rule:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! A first turn sequence rule:
[ R_14 ;
      ! phrase 1
      ! [1: consider the scene changing rules]
       ProcessRulebook(4); 
   rfalse;
];
! No specific request
! From the Standard Rules
! A first turn sequence rule ( this is the every turn stage rule ):
[ R_13 ;
      ! phrase 1
      ! [1: follow the every turn rules]
       FollowRulebook(9); 
   rfalse;
];
! No specific request
! From the Standard Rules
! A last turn sequence rule:
[ R_15 ;
      ! phrase 1
      ! [1: consider the scene changing rules]
       ProcessRulebook(4); 
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the notify score changes rule:
[ R_16 ;
      ! phrase 1
      ! [1: if the score is not the last notified score begin]
       if (((~~((score == last_score)))))  {
         ! phrase 2
         ! [2: issue score notification message]
          NotifyTheScore(); 
         ! phrase 3
         ! [3: now the last notified score is the score]
          last_score = score; 
         ! phrase 4
         ! [4: end if]
         }

   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Shutdown (B3_shutdown)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! This is the when play ends stage rule:
! --- now the last-placed rules ---
! Rule 2/4: RESURRECT_PLAYER_IF_ASKED_R
!   === which is equally specific with ===
! Rule 3/4 ! This is the print player's obituary rule:
!   === which is equally specific with ===
! Rule 4/4: ASK_FINAL_QUESTION_R
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! This is the when play ends stage rule:
[ R_17 ;
      ! phrase 1
      ! [1: follow the when play ends rulebook]
       FollowRulebook(6); 
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the print player's obituary rule:
[ R_18 ;
      ! phrase 1
      ! [1: carry out the printing the player's obituary activity]
       CarryOutActivity(V27_printing_the_player_s_ob); 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: When play begins (B5_when_play_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/8 ! when play begins:
!   === which is equally specific with ===
! Rule 2/8 ! When play begins:
!   === which is equally specific with ===
! Rule 3/8 ! When play begins:
!   === which is equally specific with ===
! Rule 4/8 ! When play begins:
!   === which is equally specific with ===
! Rule 5/8 ! When play begins:
!   === which is equally specific with ===
! Rule 6/8 ! When play begins:
!   === which is equally specific with ===
! Rule 7/8 ! when play begins:
!   === which is equally specific with ===
! Rule 8/8 ! when play begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! when play begins:
[ R_754 ;
      ! phrase 1
      ! [1: now the time of day is 7:30 am]
       the_time = 450; 
   rfalse;
];
! No specific request
! When play begins:
[ R_755 ;
      ! phrase 1
      ! [1: now the left hand status line is ~[score]/[turn count] [time of day]  [the player's surroundings]~]
       left_hand_status_line = text_routine_92; 
      ! phrase 2
      ! [2: now the right hand status line is ~[map region of the location]~]
       right_hand_status_line = text_routine_93; 
   rfalse;
];
! No specific request
! From "3 Digit Number Lock" by Orion Zymaris
! When play begins:
[ R_935 ;
      ! phrase 1
      ! [1: if a random chance of 1 in 10 succeeds begin]
       if (( (GenerateRandomNumber(1, 10) <= 1) ))  {
         ! phrase 2
         ! [2: now first digit is 0]
          (Global_Vars-->28) = 0; 
         ! phrase 3
         ! [3: otherwise if a random chance of 1 in 10 succeeds]
          } else if (( (GenerateRandomNumber(1, 10) <= 1) )) { 
         ! phrase 4
         ! [4: now first digit is 1]
          (Global_Vars-->28) = 1; 
         ! phrase 5
         ! [5: otherwise if a random chance of 1 in 10 succeeds]
          } else if (( (GenerateRandomNumber(1, 10) <= 1) )) { 
         ! phrase 6
         ! [6: now first digit is 2]
          (Global_Vars-->28) = 2; 
         ! phrase 7
         ! [7: otherwise if a random chance of 1 in 10 succeeds]
          } else if (( (GenerateRandomNumber(1, 10) <= 1) )) { 
         ! phrase 8
         ! [8: now first digit is 3]
          (Global_Vars-->28) = 3; 
         ! phrase 9
         ! [9: otherwise if a random chance of 1 in 10 succeeds]
          } else if (( (GenerateRandomNumber(1, 10) <= 1) )) { 
         ! phrase 10
         ! [10: now first digit is 4]
          (Global_Vars-->28) = 4; 
         ! phrase 11
         ! [11: otherwise if a random chance of 1 in 10 succeeds]
          } else if (( (GenerateRandomNumber(1, 10) <= 1) )) { 
         ! phrase 12
         ! [12: now first digit is 5]
          (Global_Vars-->28) = 5; 
         ! phrase 13
         ! [13: otherwise if a random chance of 1 in 10 succeeds]
          } else if (( (GenerateRandomNumber(1, 10) <= 1) )) { 
         ! phrase 14
         ! [14: now first digit is 6]
          (Global_Vars-->28) = 6; 
         ! phrase 15
         ! [15: otherwise if a random chance of 1 in 10 succeeds]
          } else if (( (GenerateRandomNumber(1, 10) <= 1) )) { 
         ! phrase 16
         ! [16: now first digit is 9]
          (Global_Vars-->28) = 9; 
         ! phrase 17
         ! [17: otherwise if a random chance of 1 in 10 succeeds]
          } else if (( (GenerateRandomNumber(1, 10) <= 1) )) { 
         ! phrase 18
         ! [18: now first digit is 8]
          (Global_Vars-->28) = 8; 
         ! phrase 19
         ! [19: otherwise]
         } else {

         ! phrase 20
         ! [20: now first digit is 7]
          (Global_Vars-->28) = 7; 
         ! phrase 21
         ! [21: end if]
         }

   rfalse;
];
! No specific request
! From "3 Digit Number Lock" by Orion Zymaris
! When play begins:
[ R_936 ;
      ! phrase 1
      ! [1: if a random chance of 1 in 10 succeeds begin]
       if (( (GenerateRandomNumber(1, 10) <= 1) ))  {
         ! phrase 2
         ! [2: now second digit is 0]
          (Global_Vars-->29) = 0; 
         ! phrase 3
         ! [3: otherwise if a random chance of 1 in 10 succeeds]
          } else if (( (GenerateRandomNumber(1, 10) <= 1) )) { 
         ! phrase 4
         ! [4: now second digit is 1]
          (Global_Vars-->29) = 1; 
         ! phrase 5
         ! [5: otherwise if a random chance of 1 in 10 succeeds]
          } else if (( (GenerateRandomNumber(1, 10) <= 1) )) { 
         ! phrase 6
         ! [6: now second digit is 2]
          (Global_Vars-->29) = 2; 
         ! phrase 7
         ! [7: otherwise if a random chance of 1 in 10 succeeds]
          } else if (( (GenerateRandomNumber(1, 10) <= 1) )) { 
         ! phrase 8
         ! [8: now second digit is 3]
          (Global_Vars-->29) = 3; 
         ! phrase 9
         ! [9: otherwise if a random chance of 1 in 10 succeeds]
          } else if (( (GenerateRandomNumber(1, 10) <= 1) )) { 
         ! phrase 10
         ! [10: now second digit is 4]
          (Global_Vars-->29) = 4; 
         ! phrase 11
         ! [11: otherwise if a random chance of 1 in 10 succeeds]
          } else if (( (GenerateRandomNumber(1, 10) <= 1) )) { 
         ! phrase 12
         ! [12: now second digit is 5]
          (Global_Vars-->29) = 5; 
         ! phrase 13
         ! [13: otherwise if a random chance of 1 in 10 succeeds]
          } else if (( (GenerateRandomNumber(1, 10) <= 1) )) { 
         ! phrase 14
         ! [14: now second digit is 6]
          (Global_Vars-->29) = 6; 
         ! phrase 15
         ! [15: otherwise if a random chance of 1 in 10 succeeds]
          } else if (( (GenerateRandomNumber(1, 10) <= 1) )) { 
         ! phrase 16
         ! [16: now second digit is 7]
          (Global_Vars-->29) = 7; 
         ! phrase 17
         ! [17: otherwise if a random chance of 1 in 10 succeeds]
          } else if (( (GenerateRandomNumber(1, 10) <= 1) )) { 
         ! phrase 18
         ! [18: now second digit is 8]
          (Global_Vars-->29) = 8; 
         ! phrase 19
         ! [19: otherwise]
         } else {

         ! phrase 20
         ! [20: now second digit is 9]
          (Global_Vars-->29) = 9; 
         ! phrase 21
         ! [21: end if]
         }

   rfalse;
];
! No specific request
! From "3 Digit Number Lock" by Orion Zymaris
! When play begins:
[ R_937 ;
      ! phrase 1
      ! [1: if a random chance of 1 in 10 succeeds begin]
       if (( (GenerateRandomNumber(1, 10) <= 1) ))  {
         ! phrase 2
         ! [2: now third digit is 9]
          (Global_Vars-->30) = 9; 
         ! phrase 3
         ! [3: otherwise if a random chance of 1 in 10 succeeds]
          } else if (( (GenerateRandomNumber(1, 10) <= 1) )) { 
         ! phrase 4
         ! [4: now third digit is 1]
          (Global_Vars-->30) = 1; 
         ! phrase 5
         ! [5: otherwise if a random chance of 1 in 10 succeeds]
          } else if (( (GenerateRandomNumber(1, 10) <= 1) )) { 
         ! phrase 6
         ! [6: now third digit is 2]
          (Global_Vars-->30) = 2; 
         ! phrase 7
         ! [7: otherwise if a random chance of 1 in 10 succeeds]
          } else if (( (GenerateRandomNumber(1, 10) <= 1) )) { 
         ! phrase 8
         ! [8: now third digit is 3]
          (Global_Vars-->30) = 3; 
         ! phrase 9
         ! [9: otherwise if a random chance of 1 in 10 succeeds]
          } else if (( (GenerateRandomNumber(1, 10) <= 1) )) { 
         ! phrase 10
         ! [10: now third digit is 4]
          (Global_Vars-->30) = 4; 
         ! phrase 11
         ! [11: otherwise if a random chance of 1 in 10 succeeds]
          } else if (( (GenerateRandomNumber(1, 10) <= 1) )) { 
         ! phrase 12
         ! [12: now third digit is 5]
          (Global_Vars-->30) = 5; 
         ! phrase 13
         ! [13: otherwise if a random chance of 1 in 10 succeeds]
          } else if (( (GenerateRandomNumber(1, 10) <= 1) )) { 
         ! phrase 14
         ! [14: now third digit is 6]
          (Global_Vars-->30) = 6; 
         ! phrase 15
         ! [15: otherwise if a random chance of 1 in 10 succeeds]
          } else if (( (GenerateRandomNumber(1, 10) <= 1) )) { 
         ! phrase 16
         ! [16: now third digit is 7]
          (Global_Vars-->30) = 7; 
         ! phrase 17
         ! [17: otherwise if a random chance of 1 in 10 succeeds]
          } else if (( (GenerateRandomNumber(1, 10) <= 1) )) { 
         ! phrase 18
         ! [18: now third digit is 8]
          (Global_Vars-->30) = 8; 
         ! phrase 19
         ! [19: otherwise]
         } else {

         ! phrase 20
         ! [20: now third digit is 0]
          (Global_Vars-->30) = 0; 
         ! phrase 21
         ! [21: end if]
         }

   rfalse;
];
! No specific request
! From "Conversation Framework" by Eric Eve
! When play begins:
[ R_975 ;
      ! phrase 1
      ! [1: reset the interlocutor]
      (PHR_976_r3 ());
   rfalse;
];
! No specific request
! when play begins:
[ R_1218 ;
      ! phrase 1
      ! [1: now rollentrypermanent is ~[rollerdexentry]~]
       BlkValueCast((Global_Vars-->73), INDEXED_TEXT_TY, TEXT_TY, (text_routine_94)); 
   rfalse;
];
! No specific request
! when play begins:
[ R_1262 ;
      ! phrase 1
      ! [1: now remembered product is dursley]
       (Global_Vars-->77) = I97_dursley; 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: When scene begins (B7_when_scene_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When a scene ( called the event ) begins ( this is the scene description text rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! When a scene ( called the event ) begins ( this is the scene description text rule ):
[ R_57 
    t_0 ! Local variable e.g. 'event' = scene
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (true))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_57, 57);
      ! phrase 1
      ! [1: if the description of the event is not ~~ , say ~[the description of the event][paragraph break]~]
       if (((~~((GProperty(SCENE_TY, t_0,description) == EMPTY_TEXT_VALUE))))) { say__p=1;ParaContent(); @push self;  print (PrintText) GProperty(SCENE_TY, self=t_0,description); @pull self; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say1; .L_SayX1;  }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_57, 57, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Every turn (B9_every_turn)
! ----------------------------------------------------------------------------------------------------
! Rule 1/23 ! every turn when in Garden or garage:
!   >>> II - When/while requirement >>>
! Rule 2/23 ! every turn when the location is not work office:
!   === which is equally specific with ===
! Rule 3/23 ! every turn when the player is not in work office:
!   === which is equally specific with ===
! Rule 4/23 ! every turn when petunia's cup is not on tray:
!   >>> II - When/while requirement >>>
! Rule 5/23 ! every turn when already reported taking is 1:
!   === which is equally specific with ===
! Rule 6/23 ! every turn when in garage:
!   === which is equally specific with ===
! Rule 7/23 ! every turn when in garage:
!   === which is equally specific with ===
! Rule 8/23 ! every turn when in ferrari enzo:
!   === which is equally specific with ===
! Rule 9/23 ! every turn when in ferrari enzo:
!   === which is equally specific with ===
! Rule 10/23 ! every turn when in_trouble is ~in trouble~:
!   === which is equally specific with ===
! Rule 11/23 ! every turn when in Grunnings Carpark:
!   === which is equally specific with ===
! Rule 12/23 ! every turn when tvonafterwork is 1:
!   >>> II - When/while requirement >>>
! Rule 13/23 ! every turn during uncle vernon's scene:
!   === which is equally specific with ===
! Rule 14/23 ! every turn during uncle vernon's scene:
!   === which is equally specific with ===
! Rule 15/23 ! every turn during uncle vernon's scene:
!   === which is equally specific with ===
! Rule 16/23 ! every turn during uncle vernon's scene:
!   === which is equally specific with ===
! Rule 17/23 ! every turn during uncle vernon's scene:
!   === which is equally specific with ===
! Rule 18/23 ! every turn during customercall:
!   === which is equally specific with ===
! Rule 19/23 ! every turn during mrmason call:
!   === which is equally specific with ===
! Rule 20/23 ! every turn during uncle vernon's scene:
!   === which is equally specific with ===
! Rule 21/23 ! every turn during work:
!   === which is equally specific with ===
! Rule 22/23 ! every turn during living-room cut scene:
!   >>> I - Number of aspects constrained >>>
! Rule 23/23 ! Every turn ( this is the reset protocol rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! every turn when in Garden or garage:
[ R_1155 ;
   if ((((( (WhetherIn(I200_garden)) ))) || ((((self == I201_garage)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1155, 1155);
      ! phrase 1
      ! [1: if light switch is switched on begin]
       if ((((Adj_75_t1_v9(I236_light_switch)))))  {
         ! phrase 2
         ! [2: now garage is lit]
          (Adj_46_t2_v9(I201_garage)); 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: now garage is not lit]
          (Adj_46_t3_v9(I201_garage)); 
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1155, 1155, true);
   rfalse;
];
! No specific request
! every turn when the location is not work office:
[ R_1186 ;
   if ((((((~~((real_location == I254_work_office)))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1186, 1186);
      ! phrase 1
      ! [1: now bored is 0]
       (Global_Vars-->70) = 0; 
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1186, 1186, true);
   rfalse;
];
! No specific request
! every turn when the player is not in work office:
[ R_1196 ;
   if ((((((~~((I254_work_office == ContainerOf(player))))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1196, 1196);
      ! phrase 1
      ! [1: now office phone is not inuse]
       (Adj_89_t3_v9(I258_office_phone)); 
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1196, 1196, true);
   rfalse;
];
! No specific request
! every turn when petunia's cup is not on tray:
[ R_1299 ;
   if ((((((~~((I325_tray == SupporterOf(I327_petunia_s_cup))))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1299, 1299);
      ! phrase 1
      ! [1: now the printed name is ~a tea cup~]
       WriteGProperty(OBJECT_TY, self,short_name,SC_67); 
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1299, 1299, true);
   rfalse;
];
! No specific request
! every turn when already reported taking is 1:
[ R_768 ;
   if (((((((Global_Vars-->16) == 1)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_768, 768);
      ! phrase 1
      ! [1: now already reported taking is 0]
       (Global_Vars-->16) = 0; 
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_768, 768, true);
   rfalse;
];
! No specific request
! every turn when in garage:
[ R_1156 ;
   if ((((( (WhetherIn(I201_garage)) ))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1156, 1156);
      ! phrase 1
      ! [1: if light switch is switched on begin]
       if ((((Adj_75_t1_v9(I236_light_switch)))))  {
         ! phrase 2
         ! [2: if garage is closed begin]
          if ((((Adj_66_t1_v9(I201_garage)))))  {
            ! phrase 3
            ! [3: now ferrari enzo is in garage]
             MoveObject(I234_ferrari_enzo,I201_garage); 
            ! phrase 4
            ! [4: end if]
            }

         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1156, 1156, true);
   rfalse;
];
! No specific request
! every turn when in garage:
[ R_1157 ;
   if ((((( (WhetherIn(I201_garage)) ))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1157, 1157);
      ! phrase 1
      ! [1: if ferrari enzo is in garage begin]
       if (((I201_garage == ContainerOf(I234_ferrari_enzo))))  {
         ! phrase 2
         ! [2: if player has not been in ferrari enzo begin]
          if (~~(TestSinglePastState(0, 0, false, 5)))  {
            ! phrase 3
            ! [3: if ferrari enzo has not been in garage for at least one turn begin]
             if (~~(TestSinglePastState(0, 1, false, 6) >= 1 ))  {
               ! phrase 4
               ! [4: say ~as you close the garage, a secret hole opens in the floor, revealing a Ferrari, which is slowly brought out to ground level~]
               say__p=1;ParaContent();  print (PrintText) SC_184;  .L_Say2; .L_SayX2;
               ! phrase 5
               ! [5: otherwise]
               } else {

               ! phrase 6
               ! [6: if the ferrari enzo is in garage begin]
                if (((I201_garage == ContainerOf(I234_ferrari_enzo))))  {
                  ! phrase 7
                  ! [7: say ~you can see your ferrari taking pride of place in your garage.~]
                  say__p=1;ParaContent();  print (PrintText) SC_185;  new_line; .L_Say3; .L_SayX3;
                  ! phrase 8
                  ! [8: otherwise]
                  } else {

                  ! phrase 9
                  ! [9: say ~big, grey, spacious, it's like any other garage you know~]
                  say__p=1;ParaContent();  print (PrintText) SC_186;  .L_Say4; .L_SayX4;
                  ! phrase 10
                  ! [10: end if]
                  }

               ! phrase 11
               ! [11: end if]
               }

            ! phrase 12
            ! [12: end if]
            }

         ! phrase 13
         ! [13: end if]
         }

   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1157, 1157, true);
   rfalse;
];
! No specific request
! every turn when in ferrari enzo:
[ R_1163 ;
   if ((((( (WhetherIn(I234_ferrari_enzo)) ))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1163, 1163);
      ! phrase 1
      ! [1: if ferrari enzo is in garage begin]
       if (((I201_garage == ContainerOf(I234_ferrari_enzo))))  {
         ! phrase 2
         ! [2: if player is in ferrari enzo begin]
          if (((I234_ferrari_enzo == ContainerOf(player))))  {
            ! phrase 3
            ! [3: if garage is open begin]
             if ((((Adj_65_t1_v9(I201_garage)))))  {
               ! phrase 4
               ! [4: if start button is switched on begin]
                if ((((Adj_75_t1_v9(I235_start_button)))))  {
                  ! phrase 5
                  ! [5: now ferrari enzo is in garden]
                   MoveObject(I234_ferrari_enzo,I200_garden); 
                  ! phrase 6
                  ! [6: now player is in ferrari enzo]
                   MoveObject(player,I234_ferrari_enzo); 
                  ! phrase 7
                  ! [7: end if]
                  }

               ! phrase 8
               ! [8: end if]
               }

            ! phrase 9
            ! [9: end if]
            }

         ! phrase 10
         ! [10: end if]
         }

   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1163, 1163, true);
   rfalse;
];
! No specific request
! every turn when in ferrari enzo:
[ R_1165 ;
   if ((((( (WhetherIn(I234_ferrari_enzo)) ))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1165, 1165);
      ! phrase 1
      ! [1: if ferrari enzo is in garage begin]
       if (((I201_garage == ContainerOf(I234_ferrari_enzo))))  {
         ! phrase 2
         ! [2: if garage is closed begin]
          if ((((Adj_66_t1_v9(I201_garage)))))  {
            ! phrase 3
            ! [3: if start button is switched on begin]
             if ((((Adj_75_t1_v9(I235_start_button)))))  {
               ! phrase 4
               ! [4: if start button has not been switched on for at least one turn begin]
                if (~~(TestSinglePastState(0, 2, false, 6) >= 1 ))  {
                  ! phrase 5
                  ! [5: say ~You need to open the garage before you can leave.~]
                  say__p=1;ParaContent();  print (PrintText) SC_187;  new_line; .L_Say5; .L_SayX5;
                  ! phrase 6
                  ! [6: end if]
                  }

               ! phrase 7
               ! [7: end if]
               }

            ! phrase 8
            ! [8: end if]
            }

         ! phrase 9
         ! [9: end if]
         }

   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1165, 1165, true);
   rfalse;
];
! No specific request
! every turn when in_trouble is ~in trouble~:
[ R_1172 ;
   if (((((((Global_Vars-->69) == SC_188)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1172, 1172);
      ! phrase 1
      ! [1: if a random chance of 1 in 3 succeeds begin]
       if (( (GenerateRandomNumber(1, 3) <= 1) ))  {
         ! phrase 2
         ! [2: if the location is grunnings carpark begin]
          if (((real_location == I244_grunnings_carpark)))  {
            ! phrase 3
            ! [3: say ~The police car comes into the carpark. You run.~]
            say__p=1;ParaContent();  print (PrintText) SC_189;  new_line; .L_Say6; .L_SayX6;
            ! phrase 4
            ! [4: now the location is corridor]
             real_location = I252_corridor; 
            ! phrase 5
            ! [5: now the player is in corridor]
             MoveObject(player,I252_corridor); 
            ! phrase 6
            ! [6: now in_trouble is ~safe~]
             (Global_Vars-->69) = SC_190; 
            ! phrase 7
            ! [7: otherwise]
            } else {

            ! phrase 8
            ! [8: now in_trouble is ~safe~]
             (Global_Vars-->69) = SC_190; 
            ! phrase 9
            ! [9: end if]
            }

         ! phrase 10
         ! [10: end if]
         }

   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1172, 1172, true);
   rfalse;
];
! No specific request
! every turn when in Grunnings Carpark:
[ R_1173 ;
   if ((((( (WhetherIn(I244_grunnings_carpark)) ))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1173, 1173);
      ! phrase 1
      ! [1: if the description of green car is ~a smashed and battered car.~ begin]
       if (((GProperty(9, I248_green_car,description) == SC_191)))  {
         ! phrase 2
         ! [2: now green car is unlocked]
          (Adj_71_t2_v9(I248_green_car)); 
         ! phrase 3
         ! [3: otherwise if the description of red car is ~a smashed and battered car.~]
          } else if (((GProperty(9, I245_red_car,description) == SC_191))) { 
         ! phrase 4
         ! [4: now red car is unlocked]
          (Adj_71_t2_v9(I245_red_car)); 
         ! phrase 5
         ! [5: otherwise if the description of blue car is ~a smashed and battered car.~]
          } else if (((GProperty(9, I246_blue_car,description) == SC_191))) { 
         ! phrase 6
         ! [6: now blue car is unlocked]
          (Adj_71_t2_v9(I246_blue_car)); 
         ! phrase 7
         ! [7: otherwise if the description of rainbow car is ~a smashed and battered car.~]
          } else if (((GProperty(9, I247_rainbow_car,description) == SC_191))) { 
         ! phrase 8
         ! [8: now rainbow car is unlocked]
          (Adj_71_t2_v9(I247_rainbow_car)); 
         ! phrase 9
         ! [9: end if]
         }

   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1173, 1173, true);
   rfalse;
];
! No specific request
! every turn when tvonafterwork is 1:
[ R_1306 ;
   if (((((((Global_Vars-->80) == 1)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1306, 1306);
      ! phrase 1
      ! [1: if the location is living-room begin]
       if (((real_location == I304_living_room)))  {
         ! phrase 2
         ! [2: if a random chance of 1 in 2 succeeds begin]
          if (( (GenerateRandomNumber(1, 2) <= 1) ))  {
            ! phrase 3
            ! [3: now petunia is in living-room]
             MoveObject(I202_petunia,I304_living_room); 
            ! phrase 4
            ! [4: now petunia is carrying a tray]
             MoveObject(I325_tray,I202_petunia); 
            ! phrase 5
            ! [5: now dursley is carrying vernon's cup]
             MoveObject(I326_vernon_s_cup,I97_dursley); 
            ! phrase 6
            ! [6: try silently saying hello to petunia]
             @push keep_silent; keep_silent=1; TryAction(0, player, ##A109_saying_hello_to, I202_petunia, 0);; @pull keep_silent; 
            ! phrase 7
            ! [7: now tvonafterwork is 2]
             (Global_Vars-->80) = 2; 
            ! phrase 8
            ! [8: say ~As you sit there thinking about your day, Petunia comes into the room, carrying a tray with 2 cups of tea.'Here's your tea, Vernon'.~]
            say__p=1;ParaContent();  print (PrintText) SC_192;  new_line; .L_Say7; .L_SayX7;
            ! phrase 9
            ! [9: end if]
            }

         ! phrase 10
         ! [10: end if]
         }

   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1306, 1306, true);
   rfalse;
];
! No specific request
! every turn during uncle vernon's scene:
[ R_1112 ;
   if (scene_status-->1 == 1) { ! Runs only during scene
   if (debug_rules) DB_Rule(R_1112, 1112);
      ! phrase 1
      ! [1: if lily'sbroom is undescribed begin]
       if ((((Adj_57_t1_v9(I183_lily_sbroom)))))  {
         ! phrase 2
         ! [2: now lily'sbroom is carried by player]
          MoveObject(I183_lily_sbroom,player); 
         ! phrase 3
         ! [3: now lily'sbroom is described]
          (Adj_56_t2_v9(I183_lily_sbroom)); 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only during scene
   else if (debug_rules > 1) DB_Rule(R_1112, 1112, true);
   rfalse;
];
! No specific request
! every turn during uncle vernon's scene:
[ R_1117 ;
   if (scene_status-->1 == 1) { ! Runs only during scene
   if (debug_rules) DB_Rule(R_1117, 1117);
      ! phrase 1
      ! [1: unless howto spoil your children handbook is in dusty box begin]
       if (~~(((I184_dusty_box == ContainerOf(I190_howto_spoil_your_childr)))))  {
         ! phrase 2
         ! [2: now the printed name of howto spoil your children handbook is ~How to Spoil your Children Handbook~]
          WriteGProperty(9, I190_howto_spoil_your_childr,short_name,SC_193); 
         ! phrase 3
         ! [3: end unless]
         }

   } ! Runs only during scene
   else if (debug_rules > 1) DB_Rule(R_1117, 1117, true);
   rfalse;
];
! No specific request
! every turn during uncle vernon's scene:
[ R_1158 ;
   if (scene_status-->1 == 1) { ! Runs only during scene
   if (debug_rules) DB_Rule(R_1158, 1158);
      ! phrase 1
      ! [1: if player is not in ferrari enzo begin]
       if (((~~((I234_ferrari_enzo == ContainerOf(player))))))  {
         ! phrase 2
         ! [2: if player has been in ferrari enzo for at least one turn begin]
          if (TestSinglePastState(0, 3, false, 6) >= 1 )  {
            ! phrase 3
            ! [3: now start button is switched off]
             (Adj_76_t2_v9(I235_start_button)); 
            ! phrase 4
            ! [4: end if]
            }

         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only during scene
   else if (debug_rules > 1) DB_Rule(R_1158, 1158, true);
   rfalse;
];
! No specific request
! every turn during uncle vernon's scene:
[ R_1178 ;
   if (scene_status-->1 == 1) { ! Runs only during scene
   if (debug_rules) DB_Rule(R_1178, 1178);
      ! phrase 1
      ! [1: if elevatorbutton is switched on begin]
       if ((((Adj_75_t1_v9(I250_elevatorbutton)))))  {
         ! phrase 2
         ! [2: now the elevatorbutton is switched off]
          (Adj_76_t2_v9(I250_elevatorbutton)); 
         ! phrase 3
         ! [3: end if]
         }

   } ! Runs only during scene
   else if (debug_rules > 1) DB_Rule(R_1178, 1178, true);
   rfalse;
];
! No specific request
! every turn during uncle vernon's scene:
[ R_1179 ;
   if (scene_status-->1 == 1) { ! Runs only during scene
   if (debug_rules) DB_Rule(R_1179, 1179);
      ! phrase 1
      ! [1: if player is in car begin]
       if (((I233_car == ContainerOf(player))))  {
         ! phrase 2
         ! [2: if car is in grunnings carpark begin]
          if (((I244_grunnings_carpark == ContainerOf(I233_car))))  {
            ! phrase 3
            ! [3: if car has not been in grunnings carpark for at least one turn begin]
             if (~~(TestSinglePastState(0, 4, false, 6) >= 1 ))  {
               ! phrase 4
               ! [4: say ~you see few cars in the Carpark today. Must be lots of people skipping work today. Slackers. It's people like them that keep our profits down... ~]
               say__p=1;ParaContent();  print (PrintText) SC_194;  .L_Say8; .L_SayX8;
               ! phrase 5
               ! [5: end if]
               }

            ! phrase 6
            ! [6: end if]
            }

         ! phrase 7
         ! [7: end if]
         }

   } ! Runs only during scene
   else if (debug_rules > 1) DB_Rule(R_1179, 1179, true);
   rfalse;
];
! No specific request
! every turn during customercall:
[ R_1187 ;
   if (scene_status-->3 == 1) { ! Runs only during scene
   if (debug_rules) DB_Rule(R_1187, 1187);
      ! phrase 1
      ! [1: if bored is 5 begin]
       if ((((Global_Vars-->70) == 5)))  {
         ! phrase 2
         ! [2: say ~The customer gets bored and hangs up. 'If you remember, call me at 893.'~]
         say__p=1;ParaContent();  print (PrintText) SC_195;  new_line; .L_Say9; .L_SayX9;
         ! phrase 3
         ! [3: try silently hanging up]
          @push keep_silent; keep_silent=1; TryAction(0, player, ##A114_hanging_up, 0, 0);; @pull keep_silent; 
         ! phrase 4
         ! [4: now bored is 0]
          (Global_Vars-->70) = 0; 
         ! phrase 5
         ! [5: now lexicon is table 1]
          (Global_Vars-->72) = T14_customer_responses; 
         ! phrase 6
         ! [6: end if]
         }

   } ! Runs only during scene
   else if (debug_rules > 1) DB_Rule(R_1187, 1187, true);
   rfalse;
];
! No specific request
! every turn during mrmason call:
[ R_1188 ;
   if (scene_status-->4 == 1) { ! Runs only during scene
   if (debug_rules) DB_Rule(R_1188, 1188);
      ! phrase 1
      ! [1: if rollerdex is familiar begin]
       if ((((Adj_87_t1_v9(I273_rollerdex)))))  {
         ! phrase 2
         ! [2: unless dialyes/no is 1 begin]
          if (~~((((Global_Vars-->71) == 1))))  {
            ! phrase 3
            ! [3: if bored is at least 5 begin]
             if ((((Global_Vars-->70) >= 5)))  {
               ! phrase 4
               ! [4: if office phone is inuse begin]
                if ((((Adj_89_t1_v9(I258_office_phone)))))  {
                  ! phrase 5
                  ! [5: say ~Mr. Mason gets bored and hangs up. 'If you remember, call me at 12856.'~]
                  say__p=1;ParaContent();  print (PrintText) SC_196;  new_line; .L_Say10; .L_SayX10;
                  ! phrase 6
                  ! [6: now the current interlocutor is nothing]
                   (Global_Vars-->36) = nothing; 
                  ! phrase 7
                  ! [7: try silently hanging up]
                   @push keep_silent; keep_silent=1; TryAction(0, player, ##A114_hanging_up, 0, 0);; @pull keep_silent; 
                  ! phrase 8
                  ! [8: now bored is 0]
                   (Global_Vars-->70) = 0; 
                  ! phrase 9
                  ! [9: now lexicon is table 1]
                   (Global_Vars-->72) = T14_customer_responses; 
                  ! phrase 10
                  ! [10: end if]
                  }

               ! phrase 11
               ! [11: end if]
               }

            ! phrase 12
            ! [12: end unless]
            }

         ! phrase 13
         ! [13: end if]
         }

   } ! Runs only during scene
   else if (debug_rules > 1) DB_Rule(R_1188, 1188, true);
   rfalse;
];
! No specific request
! every turn during uncle vernon's scene:
[ R_1189 ;
   if (scene_status-->1 == 1) { ! Runs only during scene
   if (debug_rules) DB_Rule(R_1189, 1189);
      ! phrase 1
      ! [1: increment bored]
       (Global_Vars-->70) = (Global_Vars-->70) + 1; 
   } ! Runs only during scene
   else if (debug_rules > 1) DB_Rule(R_1189, 1189, true);
   rfalse;
];
! No specific request
! every turn during work:
[ R_1244 ;
   if (scene_status-->2 == 1) { ! Runs only during scene
   if (debug_rules) DB_Rule(R_1244, 1244);
      ! phrase 1
      ! [1: if the venture of customercall is success begin]
       if (((GProperty(SCENE_TY, I264_customercall,p80_venture) == I266_success)))  {
         ! phrase 2
         ! [2: if the venture of mrmason call is success begin]
          if (((GProperty(SCENE_TY, I276_mrmason_call,p80_venture) == I266_success)))  {
            ! phrase 3
            ! [3: unless the venture of work is half-complete begin]
             if (~~(((GProperty(SCENE_TY, I238_work,p80_venture) == I270_half_complete))))  {
               ! phrase 4
               ! [4: now the time of day is 12:30 am]
                the_time = 30; 
               ! phrase 5
               ! [5: say ~Your boss walks into the office. 'Good Job', he says. 'I see you've made a few good sales. go, take a break; have some lunch.'.~]
               say__p=1;ParaContent();  print (PrintText) SC_197;  new_line; .L_Say11; .L_SayX11;
               ! phrase 6
               ! [6: now the venture of work is half-complete]
                WriteGProperty(SCENE_TY, I238_work,p80_venture,I270_half_complete); 
               ! phrase 7
               ! [7: end unless]
               }

            ! phrase 8
            ! [8: end if]
            }

         ! phrase 9
         ! [9: end if]
         }

   } ! Runs only during scene
   else if (debug_rules > 1) DB_Rule(R_1244, 1244, true);
   rfalse;
];
! No specific request
! every turn during living-room cut scene:
[ R_1298 ;
   if (scene_status-->5 == 1) { ! Runs only during scene
   if (debug_rules) DB_Rule(R_1298, 1298);
      ! phrase 1
      ! [1: if a random chance of 1 in 2 succeeds begin]
       if (( (GenerateRandomNumber(1, 2) <= 1) ))  {
         ! phrase 2
         ! [2: say ~Today's been a bit tiring. You should get to bed.~]
         say__p=1;ParaContent();  print (PrintText) SC_198;  new_line; .L_Say12; .L_SayX12;
         ! phrase 3
         ! [3: end if]
         }

   } ! Runs only during scene
   else if (debug_rules > 1) DB_Rule(R_1298, 1298, true);
   rfalse;
];
! No specific request
! From "Conversation Framework" by Eric Eve
! Every turn ( this is the reset protocol rule ):
[ R_985 ;
      ! phrase 1
      ! [1: now the farewell type is explicit]
       (Global_Vars-->38) = I112_explicit; 
      ! phrase 2
      ! [2: now the greeting type is explicit]
       (Global_Vars-->37) = I112_explicit; 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Action-processing (B10_action_processing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/12 ! This is the announce items from multiple object lists rule:
!   === which is equally specific with ===
! Rule 2/12 ! This is the set pronouns from items from multiple object lists rule:
!   === which is equally specific with ===
! Rule 3/12 ! This is the before stage rule:
! --- now the mid-placed rules ---
! Rule 4/12 ! This is the update ambiguous pronouns for actions rule:
!   >>> III - Action requirement >>>
! Rule 5/12: BASIC_VISIBILITY_R
!   === which is equally specific with ===
! Rule 6/12: BASIC_ACCESSIBILITY_R
!   === which is equally specific with ===
! Rule 7/12: CARRYING_REQUIREMENTS_R
! --- now the last-placed rules ---
! Rule 8/12 ! This is the instead stage rule:
!   === which is equally specific with ===
! Rule 9/12: REQUESTED_ACTIONS_REQUIRE_R
!   === which is equally specific with ===
! Rule 10/12: CARRY_OUT_REQUESTED_ACTIONS_R
!   === which is equally specific with ===
! Rule 11/12: DESCEND_TO_SPECIFIC_ACTION_R
!   === which is equally specific with ===
! Rule 12/12 ! This is the end action-processing in success rule:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! This is the announce items from multiple object lists rule:
[ R_20 ;
      ! phrase 1
      ! [1: if the current item from the multiple object list is not nothing , say ~[current item from the multiple object list]: [run paragraph on]~]
       if (((~~((multiple_object_item == nothing))))) { say__p=1;ParaContent();  print (PrintShortName) multiple_object_item; ParaContent();  print (PrintText) SC_199; ParaContent();  RunParagraphOn();  .L_Say13; .L_SayX13;  }
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the set pronouns from items from multiple object lists rule:
[ R_19 ;
      ! phrase 1
      ! [1: if the current item from the multiple object list is not nothing , set pronouns from the current item from the multiple object list]
       if (((~~((multiple_object_item == nothing))))) {  PronounNotice(multiple_object_item);   }
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the before stage rule:
[ R_21 ;
      ! phrase 1
      ! [1: abide by the before rules]
       if (ProcessRulebook(20)) rtrue; 
   rfalse;
];
! No specific request
! From "Plurality" by Emily Short
! This is the update ambiguous pronouns for actions rule:
[ R_837 ;
      ! phrase 1
      ! [1: if the noun is a thing and the noun is ambiguously plural begin]
       if ((((noun ofclass K2_thing))) && ((((Adj_83_t1_v9(noun))))))  {
         ! phrase 2
         ! [2: notice the plurality of the noun]
          PlugPlural(noun); 
         ! phrase 3
         ! [3: end if]
         }

      ! phrase 4
      ! [4: if the second noun is a thing and the second noun is ambiguously plural begin]
       if ((((second ofclass K2_thing))) && ((((Adj_83_t1_v9(second))))))  {
         ! phrase 5
         ! [5: notice the plurality of the second noun]
          PlugPlural(second); 
         ! phrase 6
         ! [6: end if]
         }

   rfalse;
];
! No specific request
! From the Standard Rules
! This is the instead stage rule:
[ R_22 ;
      ! phrase 1
      ! [1: abide by the instead rules]
       if (ProcessRulebook(21)) rtrue; 
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the end action-processing in success rule:
[ R_23 ;
      ! phrase 1
      ! [1: rule succeeds]
       RulebookSucceeds(); rtrue; 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Setting action variables (B11_setting_action_variables)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! Rule for setting action variables for going ( this is the standard set going variables rule ):
!   === which is equally specific with ===
! Rule 2/7 ! Setting action variables for looking ( this is the determine visibility ceiling rule ):
!   === which is equally specific with ===
! Rule 3/7 ! Rule for setting action variables for going ( this is the allow rideables to be going vehicles rule ):
!   === which is equally specific with ===
! Rule 4/7 ! Setting action variables for dialling ( this is the set up dialling rule ):
!   === which is equally specific with ===
! Rule 5/7 ! Setting action variables for hanging up ( this is the set up hanging up rule ):
!   === which is equally specific with ===
! Rule 6/7 ! Setting action variables for exiting:
!   === which is equally specific with ===
! Rule 7/7 ! Setting action variables for taking:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Rule for setting action variables for going ( this is the standard set going variables rule ):
[ R_137 
    t_0 ! Local variable e.g. 'carriage' = vehicle
    t_1 ! Local variable e.g. 'target' = object
    t_2 ! Local variable e.g. '?-1,-1?' = object
    ;
   if ((action ==##Go)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_137, 137);
      ! phrase 1
      ! [1: now the thing gone with is the item-pushed-between-rooms]
       (MStack-->MstVO(20007,4)) = move_pushing; 
      ! phrase 2
      ! [2: now the room gone from is the location of the actor]
       (MStack-->MstVO(20007,0)) =  LocationOf(actor) ; 
      ! phrase 3
      ! [3: if the actor is in an enterable vehicle ( called the carriage ) , now the vehicle gone by is the carriage]
       if (((ContainerOf(actor) ofclass K14_vehicle) && (t_0=(ContainerOf(actor)), true) && ((Adj_62_t1_v9(ContainerOf(actor)))))) {  (MStack-->MstVO(20007,3)) = t_0;   }
      ! phrase 4
      ! [4: let the target be nothing]
       t_1 = nothing; 
      ! phrase 5
      ! [5: if the noun is a direction begin]
       if (((noun ofclass K3_direction)))  {
         ! phrase 6
         ! [6: let direction d be the noun]
          t_2 = noun; 
         ! phrase 7
         ! [7: let the target be the room-or-door direction d from the room gone from]
          t_1 = (Resolver_0(t_2,(MStack-->MstVO(20007,0)),"source", 1948)); 
         ! phrase 8
         ! [8: otherwise]
         } else {

         ! phrase 9
         ! [9: if the noun is a door , let the target be the noun]
          if (((noun ofclass K4_door))) {  t_1 = noun;   }
         ! phrase 10
         ! [10: end if]
         }

      ! phrase 11
      ! [11: if the target is a door begin]
       if (((t_1 ofclass K4_door)))  {
         ! phrase 12
         ! [12: now the door gone through is the target]
          (MStack-->MstVO(20007,2)) = t_1; 
         ! phrase 13
         ! [13: now the target is the other side of the target from the room gone from]
          t_1 = (Resolver_1(t_1,(MStack-->MstVO(20007,0)),"source", 1953)); 
         ! phrase 14
         ! [14: end if]
         }

      ! phrase 15
      ! [15: now the room gone to is the target]
       (MStack-->MstVO(20007,1)) = t_1; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_137, 137, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Setting action variables for looking ( this is the determine visibility ceiling rule ):
[ R_171 ;
   if ((action ==##Look)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_171, 171);
      ! phrase 1
      ! [1: if the actor is the player , calculate visibility ceiling at low level]
       if (((actor == player))) {  FindVisibilityLevels();   }
      ! phrase 2
      ! [2: now the visibility level count is the visibility ceiling count calculated]
       (MStack-->MstVO(20011,2)) =  visibility_levels ; 
      ! phrase 3
      ! [3: now the visibility ceiling is the visibility ceiling calculated]
       (MStack-->MstVO(20011,3)) =  visibility_ceiling ; 
      ! phrase 4
      ! [4: now the room-describing action is the looking action]
       (MStack-->MstVO(20011,0)) = ##Look; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_171, 171, true);
   rfalse;
];
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Rule for setting action variables for going ( this is the allow rideables to be going vehicles rule ):
[ R_843 
    t_0 ! Local variable e.g. 'steed' = rideable animal
    t_1 ! Local variable e.g. 'conveyance' = rideable vehicle
    ;
   if ((action ==##Go)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_843, 843);
      ! phrase 1
      ! [1: if the actor is carried by a rideable animal ( called the steed ) , now the vehicle gone by is the steed]
       if (((CarrierOf(actor) ofclass K21_rideable_animal) && (t_0=(CarrierOf(actor)), true))) {  (MStack-->MstVO(20007,3)) = t_0;   }
      ! phrase 2
      ! [2: if the actor is on a rideable vehicle ( called the conveyance ) , now the vehicle gone by is the conveyance]
       if (((SupporterOf(actor) ofclass K22_rideable_vehicle) && (t_1=(SupporterOf(actor)), true))) {  (MStack-->MstVO(20007,3)) = t_1;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_843, 843, true);
   rfalse;
];
! No specific request
! From "Telephones" by George Tryfonas
! Setting action variables for dialling ( this is the set up dialling rule ):
[ R_1022 ;blockv_stack-->(blockv_sp+2) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_telephones);
    blockv_stack-->(blockv_sp+1) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_telephones);
    blockv_stack-->(blockv_sp+0) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_telephones);
    blockv_sp = blockv_sp + 3;
    blockv_stack-->(blockv_sp++) = R_SHELL_0(blockv_sp-3);
    blockv_sp = blockv_sp - 4;
    BlkFree(blockv_stack-->(blockv_sp+2));
    BlkFree(blockv_stack-->(blockv_sp+1));
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+3);
];
[ R_SHELL_0 I7BASPL 
    t_0 ! Local variable e.g. '?-1,-1?' = telephone
    t_1 ! Local variable e.g. '?-1,-1?' = number
    ;
   if ((action ==##A113_dialling_it_on)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1022, 1022);
      ! phrase 1
      ! [1: repeat with item running through the list of telephones begin]
       for (t_1=1, t_0=LIST_OF_TY_GetItem( LIST_OF_TY_Desc((blockv_stack-->(I7BASPL+0)), Prop_0, 9) , t_1, true): t_1<=LIST_OF_TY_GetLength( LIST_OF_TY_Desc((blockv_stack-->(I7BASPL+1)), Prop_1, 9) ): t_1++, t_0=LIST_OF_TY_GetItem( LIST_OF_TY_Desc((blockv_stack-->(I7BASPL+2)), Prop_2, 9) , t_1, true))  {
         ! phrase 2
         ! [2: if the calling number of the item is the number understood , now the line dialled is the item]
          if (((GProperty(9, t_0,p14_calling_number) == parsed_number))) {  (MStack-->MstVO(20113,0)) = t_0;   }
         ! phrase 3
         ! [3: end repeat]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1022, 1022, true);
   rfalse;
];
! No specific request
! From "Telephones" by George Tryfonas
! Setting action variables for hanging up ( this is the set up hanging up rule ):
[ R_1035 
    t_0 ! Local variable e.g. 'target' = object
    ;
   if ((action ==##A114_hanging_up)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1035, 1035);
      ! phrase 1
      ! [1: let the target be a random inuse telephone which can be touched by the player]
       t_0 =  (Prop_3()) ; 
      ! phrase 2
      ! [2: now the phone hanged up is the target]
       (MStack-->MstVO(20114,0)) = t_0; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1035, 1035, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Setting action variables for exiting:
[ R_159 ;
   if ((action ==##Exit)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_159, 159);
      ! phrase 1
      ! [1: now the container exited from is the holder of the actor]
       (MStack-->MstVO(20009,0)) =  (HolderOf(actor)) ; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_159, 159, true);
   rfalse;
];
! No specific request
! Setting action variables for taking:
[ R_756 ;
   if ((action ==##Take)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_756, 756);
      ! phrase 1
      ! [1: now previous locale is the holder of the noun]
       (MStack-->MstVO(20001,0)) =  (HolderOf(noun)) ; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_756, 756, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: specific action-processing (B12_specific_action_processi)
! ----------------------------------------------------------------------------------------------------
! Rule 1/8: WORK_OUT_DETAILS_OF_SPECIFIC_R
! --- now the mid-placed rules ---
! Rule 2/8 ! A specific action-processing rule ( this is the investigate player's awareness before action rule ):
!   === which is equally specific with ===
! Rule 3/8 ! A specific action-processing rule ( this is the check stage rule ):
!   === which is equally specific with ===
! Rule 4/8 ! A specific action-processing rule ( this is the carry out stage rule ):
!   === which is equally specific with ===
! Rule 5/8 ! A specific action-processing rule ( this is the after stage rule ):
!   === which is equally specific with ===
! Rule 6/8 ! A specific action-processing rule ( this is the investigate player's awareness after action rule ):
!   === which is equally specific with ===
! Rule 7/8 ! A specific action-processing rule ( this is the report stage rule ):
! --- now the last-placed rules ---
! Rule 8/8 ! The last specific action-processing rule:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! A specific action-processing rule ( this is the investigate player's awareness before action rule ):
[ R_24 ;
      ! phrase 1
      ! [1: consider the player's action awareness rules]
       ProcessRulebook(13); 
      ! phrase 2
      ! [2: if rule succeeded , now within the player's sight is true]
       if (( (RulebookSucceeded()) )) {  (MStack-->MstVO(12,5)) = 1;   }
      ! phrase 3
      ! [3: otherwise now within the player's sight is false]
       else {  (MStack-->MstVO(12,5)) = 0;   }
   rfalse;
];
! No specific request
! From the Standard Rules
! A specific action-processing rule ( this is the check stage rule ):
[ R_25 ;
      ! phrase 1
      ! [1: anonymously abide by the specific check rulebook]
       if (temporary_value = ProcessRulebook((MStack-->MstVO(12,2)))) {
		if (RulebookSucceeded()) ActRulebookSucceeds(temporary_value);
		else ActRulebookFails(temporary_value);
		return 2;
	} 
   rfalse;
];
! No specific request
! From the Standard Rules
! A specific action-processing rule ( this is the carry out stage rule ):
[ R_26 ;
      ! phrase 1
      ! [1: consider the specific carry out rulebook]
       ProcessRulebook((MStack-->MstVO(12,3))); 
   rfalse;
];
! No specific request
! From the Standard Rules
! A specific action-processing rule ( this is the after stage rule ):
[ R_27 ;
      ! phrase 1
      ! [1: if action in world is true , abide by the after rules]
       if (((((MStack-->MstVO(12,0)) && true) == (1 && true)))) {  if (ProcessRulebook(24)) rtrue;   }
   rfalse;
];
! No specific request
! From the Standard Rules
! A specific action-processing rule ( this is the investigate player's awareness after action rule ):
[ R_28 ;
      ! phrase 1
      ! [1: if within the player's sight is false begin]
       if (((((MStack-->MstVO(12,5)) && true) == (0 && true))))  {
         ! phrase 2
         ! [2: consider the player's action awareness rules]
          ProcessRulebook(13); 
         ! phrase 3
         ! [3: if rule succeeded , now within the player's sight is true]
          if (( (RulebookSucceeded()) )) {  (MStack-->MstVO(12,5)) = 1;   }
         ! phrase 4
         ! [4: end if]
         }

   rfalse;
];
! No specific request
! From the Standard Rules
! A specific action-processing rule ( this is the report stage rule ):
[ R_29 ;
      ! phrase 1
      ! [1: if within the player's sight is true and action keeping silent is false , consider the specific report rulebook]
       if ((((((MStack-->MstVO(12,5)) && true) == (1 && true)))) && (((((MStack-->MstVO(12,1)) && true) == (0 && true))))) {  ProcessRulebook((MStack-->MstVO(12,4)));   }
   rfalse;
];
! No specific request
! From the Standard Rules
! The last specific action-processing rule:
[ R_30 ;
      ! phrase 1
      ! [1: rule succeeds]
       RulebookSucceeds(); rtrue; 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: player's action awareness (B13_player_s_action_awarenes)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! A player's action awareness rule ( this is the player aware of his own actions rule ):
!   === which is equally specific with ===
! Rule 2/4 ! A player's action awareness rule ( this is the player aware of actions by visible actors rule ):
!   === which is equally specific with ===
! Rule 3/4 ! A player's action awareness rule ( this is the player aware of actions on visible nouns rule ):
!   === which is equally specific with ===
! Rule 4/4 ! A player's action awareness rule ( this is the player aware of actions on visible second nouns rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! A player's action awareness rule ( this is the player aware of his own actions rule ):
[ R_31 ;
      ! phrase 1
      ! [1: if the player is the actor , rule succeeds]
       if (((player == actor))) {  RulebookSucceeds(); rtrue;   }
   rfalse;
];
! No specific request
! From the Standard Rules
! A player's action awareness rule ( this is the player aware of actions by visible actors rule ):
[ R_32 ;
      ! phrase 1
      ! [1: if the player is not the actor and the player can see the actor , rule succeeds]
       if ((((~~((player == actor))))) && (((TestVisibility(player,actor))))) {  RulebookSucceeds(); rtrue;   }
   rfalse;
];
! No specific request
! From the Standard Rules
! A player's action awareness rule ( this is the player aware of actions on visible nouns rule ):
[ R_33 ;
      ! phrase 1
      ! [1: if the noun is a thing and the player can see the noun , rule succeeds]
       if ((((noun ofclass K2_thing))) && (((TestVisibility(player,noun))))) {  RulebookSucceeds(); rtrue;   }
   rfalse;
];
! No specific request
! From the Standard Rules
! A player's action awareness rule ( this is the player aware of actions on visible second nouns rule ):
[ R_34 ;
      ! phrase 1
      ! [1: if the second noun is a thing and the player can see the second noun , rule succeeds]
       if ((((second ofclass K2_thing))) && (((TestVisibility(player,second))))) {  RulebookSucceeds(); rtrue;   }
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Visibility (B17_visibility)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! The last visibility rule ( this is the can't act in the dark rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! The last visibility rule ( this is the can't act in the dark rule ):
[ R_35 ;
      ! phrase 1
      ! [1: if in darkness , rule succeeds]
       if (( (location==thedark) )) {  RulebookSucceeds(); rtrue;   }
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Persuasion (B18_persuasion)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! persuasion rule for asking shop attendant to try doing anything:
!   >>> III.3.3 - Action/What/Actor Performing Action >>>
! Rule 2/4 ! Persuasion rule for asking people to try hailing ( this is the allow hailing rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Persuasion rule for asking people to try leavetaking ( this is the alllow leavetaking rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Persuasion rule for asking people to try going:
! ----------------------------------------------------------------------------------------------------
! No specific request
! persuasion rule for asking shop attendant to try doing anything:
[ R_1267 ;
   if ( (actor~=player) && (act_requester) && ((actor == I288_shop_attendant) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1267, 1267);
      ! phrase 1
      ! [1: persuasion succeeds]
      RulebookSucceeds(19, RBNO_4); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1267, 1267, true);
   rfalse;
];
! No specific request
! From "Conversation Framework" by Eric Eve
! Persuasion rule for asking people to try hailing ( this is the allow hailing rule ):
[ R_974 ;
   if ((action ==##A110_hailing) &&  (actor~=player) && (act_requester) && ((actor ofclass K8_person))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_974, 974);
      ! phrase 1
      ! [1: persuasion succeeds]
      RulebookSucceeds(19, RBNO_4); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_974, 974, true);
   rfalse;
];
! No specific request
! From "Conversation Framework" by Eric Eve
! Persuasion rule for asking people to try leavetaking ( this is the alllow leavetaking rule ):
[ R_981 ;
   if ((action ==##A111_leavetaking) &&  (actor~=player) && (act_requester) && ((actor ofclass K8_person))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_981, 981);
      ! phrase 1
      ! [1: persuasion succeeds]
      RulebookSucceeds(19, RBNO_4); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_981, 981, true);
   rfalse;
];
! No specific request
! From "Cheats" by Orion Zymaris
! Persuasion rule for asking people to try going:
[ R_898 ;
   if ((action ==##Go) &&  (actor~=player) && (act_requester) && ((actor ofclass K8_person))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_898, 898);
      ! phrase 1
      ! [1: if cheats_bin is 1 begin]
       if ((((Global_Vars-->25) == 1)))  {
         ! phrase 2
         ! [2: persuasion succeeds]
         RulebookSucceeds(19, RBNO_4); rtrue;

         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: persuasion fails]
         RulebookFails(19, RBNO_5); rtrue;

         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_898, 898, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Unsuccessful attempt by (B19_unsuccessful_attempt_by)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Unsuccessful attempt by someone trying mounting ( this is the mounting excuses rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Unsuccessful attempt by someone trying dismounting ( this is the dismounting excuses rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Unsuccessful attempt by someone trying mounting ( this is the mounting excuses rule ):
[ R_856 ;
   if ((action ==##A84_mounting) &&  (actor~=player) && (act_requester==nothing) && ((actor ofclass K8_person))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_856, 856);
      ! phrase 1
      ! [1: if the reason the action failed is the can't mount when mounted on an animal rule , say ~[The person asked] [is-are] already riding [the random rideable animal which carries the person asked].~]
       if (((reason_the_action_failed == R_849))) { say__p=1;ParaContent();  print (The) actor; ParaContent();  print (PrintText) SC_88; ParaContent(); (PHR_777_r4 ());ParaContent();  print (PrintText) SC_200; ParaContent();  print (the)  (Prop_4()) ; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say14; .L_SayX14;  }
      ! phrase 2
      ! [2: if the reason the action failed is the can't mount when mounted on a vehicle rule , say ~[The person asked] [is-are] already riding [the random rideable vehicle which supports the person asked].~]
       if (((reason_the_action_failed == R_850))) { say__p=1;ParaContent();  print (The) actor; ParaContent();  print (PrintText) SC_88; ParaContent(); (PHR_777_r4 ());ParaContent();  print (PrintText) SC_200; ParaContent();  print (the)  (Prop_5()) ; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say15; .L_SayX15;  }
      ! phrase 3
      ! [3: if the reason the action failed is the can't mount something unrideable rule , say ~[The noun] cannot be ridden.~]
       if (((reason_the_action_failed == R_851))) { say__p=1;ParaContent();  print (The) noun; ParaContent();  print (PrintText) SC_202;  new_line; .L_Say16; .L_SayX16;  }
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_856, 856, true);
   rfalse;
];
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Unsuccessful attempt by someone trying dismounting ( this is the dismounting excuses rule ):
[ R_860 ;
   if ((action ==##A85_dismounting) &&  (actor~=player) && (act_requester==nothing) && ((actor ofclass K8_person))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_860, 860);
      ! phrase 1
      ! [1: if the reason the action failed is the can't dismount when not mounted rule , say ~[The person asked] [is-are] not riding anything.~]
       if (((reason_the_action_failed == R_857))) { say__p=1;ParaContent();  print (The) actor; ParaContent();  print (PrintText) SC_88; ParaContent(); (PHR_777_r4 ());ParaContent();  print (PrintText) SC_203;  new_line; .L_Say17; .L_SayX17;  }
      ! phrase 2
      ! [2: otherwise make no decision]
       else {  rfalse;   }
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_860, 860, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Before (B20_before)
! ----------------------------------------------------------------------------------------------------
! Rule 1/78 ! before going to highway when in car:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 2/78 ! before dialling 8953 on office phone when dialyes/no is 1:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 3/78 ! before asking the customer about a topic listed in the lexicon when lexicon is table 1:
!   === which is equally specific with ===
! Rule 4/78 ! before asking the customer about a topic listed in lexicon when lexicon is table 2:
!   === which is equally specific with ===
! Rule 5/78 ! before asking the customer about a topic listed in lexicon when lexicon is table 4:
!   === which is equally specific with ===
! Rule 6/78 ! before asking the customer about a topic listed in table 5 when lexicon is table 5:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 7/78 ! before giving something in foods display case to the player when in bakers:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 8/78 ! before asking the customer about a topic when dialyes/no is 1:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 9/78 ! Before showing something to someone when the second noun is not the current interlocutor ( this is the showing needs an interlocutor rule ):
!   === which is equally specific with ===
! Rule 10/78 ! Before giving something to someone when the second noun is not the current interlocutor ( this is the giving needs an interlocutor rule ):
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 11/78 ! before going north when in corridor for the first time:
!   >>> III.5.1 - Action/When/Duration >>>
! Rule 12/78 ! before going north when the location is corridor:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 13/78 ! before doing anything to rollerdex for the first time:
!   >>> III.5.1 - Action/When/Duration >>>
! Rule 14/78 ! before doing anything to rollerdex for at least the second time:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 15/78 ! before responding to customer a topic listed in the lexicon when the lexicon is table 9:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 16/78 ! before taking a noun when the noun is overlaying something ( called the under-contents ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 17/78 ! Before listening to someone when the player cannot touch the noun ( this is the listening to a connected party rule ):
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 18/78 ! before eating a food when the foodlevel of the noun is half-eaten:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 19/78 ! before buying anything when in bakers:
!   >>> I - Number of aspects constrained >>>
! Rule 20/78 ! Before asking someone to try hailing ( this is the change greeting command to greeting rule ):
!   <<< I - Number of aspects constrained <<<
! Rule 21/78 ! Before asking someone to try doing something when the person asked is not the current interlocutor ( this is the giving orders needs an interlocutor rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 22/78 ! Before going somewhere when the player reaches someone ( this is the go somewhere while on the line rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 23/78 ! before going through a door:
!   >>> III.2.1 - Action/Where/Going In Exotic Ways >>>
! Rule 24/78 ! before unlocking suitcase with dursley:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 25/78 ! before giving the pound coin to the shop attendant:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 26/78 ! Before answering someone that ~yes~ ( this is the change answering yes to saying yes rule ):
!   === which is equally specific with ===
! Rule 27/78 ! Before answering someone that ~no~ ( this is the change answering no to saying no rule ):
!   === which is equally specific with ===
! Rule 28/78 ! Before answering someone that ~sorry~ ( this is the change answering sorry to saying sorry rule ):
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 29/78 ! before opening the wardrobe:
!   === which is equally specific with ===
! Rule 30/78 ! before opening the bedroomdoor:
!   === which is equally specific with ===
! Rule 31/78 ! before taking howto spoil your children handbook:
!   === which is equally specific with ===
! Rule 32/78 ! before examining petunia's diary:
!   === which is equally specific with ===
! Rule 33/78 ! before drinking coffee cup:
!   === which is equally specific with ===
! Rule 34/78 ! before eating cereal:
!   === which is equally specific with ===
! Rule 35/78 ! before opening filing cabinet:
!   === which is equally specific with ===
! Rule 36/78 ! before examining filing cabinet:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 37/78 ! Before asking a rideable animal ( called the mount ) to try going a direction ( called the way ):
!   >>> III.3.3 - Action/What/Actor Performing Action >>>
! Rule 38/78 ! Before an actor entering a rideable animal ( called the steed ):
!   === which is equally specific with ===
! Rule 39/78 ! before mounting a broom:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 40/78 ! Before an actor entering a rideable vehicle ( called the conveyance ):
!   === which is equally specific with ===
! Rule 41/78 ! Before an actor getting off a rideable animal ( called the steed ):
!   === which is equally specific with ===
! Rule 42/78 ! Before an actor getting off a rideable vehicle ( called the conveyance ):
!   === which is equally specific with ===
! Rule 43/78 ! before wearing clothing:
!   === which is equally specific with ===
! Rule 44/78 ! before wearing clothing:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 45/78 ! before going under a thing:
!   === which is equally specific with ===
! Rule 46/78 ! before taking something:
!   === which is equally specific with ===
! Rule 47/78 ! before point increasing a number ( called Num ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 48/78 ! Before asking someone to try saying yes ( this is the greet before saying yes rule ):
!   === which is equally specific with ===
! Rule 49/78 ! Before asking someone to try saying no ( this is the greet before saying no rule ):
!   === which is equally specific with ===
! Rule 50/78 ! Before asking someone to try saying sorry ( this is the greet before saying sorry rule ):
!   >>> III.3.3 - Action/What/Actor Performing Action >>>
! Rule 51/78 ! Before dialling when the player reaches someone ( this is the dialling a telephone while on the line rule ):
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 52/78 ! before dismounting when player was on lily'sbroom:
!   === which is equally specific with ===
! Rule 53/78 ! before hanging up when dialyes/no is 1:
!   === which is equally specific with ===
! Rule 54/78 ! before responding to customer when lexicon is table 10:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 55/78 ! before saying yes during customercall:
!   === which is equally specific with ===
! Rule 56/78 ! before saying no during uncle vernon's scene:
!   === which is equally specific with ===
! Rule 57/78 ! before saying yes during mrmason call:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 58/78 ! before asking or implicit-imploring or implicit-asking when lexicon is table 5:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 59/78 ! before doing anything except hanging up or saying goodbye to when lexicon is table 10:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 60/78 ! Before implicit-conversing when the current interlocutor is not visible and the current interlocutor is not nothing ( this is the can't converse with absent interlocutor rule ):
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 61/78 ! Before conversing when the noun is not the current interlocutor ( this is the greet a new interlocutor rule ):
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 62/78 ! Before implicit-conversing when the current interlocutor is nothing ( this is the implicit-conversing needs current interlocutor rule ):
!   >>> III.6.1 - Action/Name/Is This Named >>>
! Rule 63/78 ! before doing anything when the command prompt is ~What do you want to write: ~:
!   >>> I - Number of aspects constrained >>>
! Rule 64/78 ! before moving to:
!   === which is equally specific with ===
! Rule 65/78 ! before putting under:
!   === which is equally specific with ===
! Rule 66/78 ! before teleporting to:
!   === which is equally specific with ===
! Rule 67/78 ! Before an actor exiting:
!   === which is equally specific with ===
! Rule 68/78 ! before teleporting to:
!   === which is equally specific with ===
! Rule 69/78 ! before putting back:
!   === which is equally specific with ===
! Rule 70/78 ! before paying wizard money:
!   === which is equally specific with ===
! Rule 71/78 ! before moving to:
!   === which is equally specific with ===
! Rule 72/78 ! before going:
!   === which is equally specific with ===
! Rule 73/78 ! before going:
!   === which is equally specific with ===
! Rule 74/78 ! before writing intro:
!   === which is equally specific with ===
! Rule 75/78 ! before wanting:
!   === which is equally specific with ===
! Rule 76/78 ! before thanking with no noun:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 77/78 ! before doing anything:
!   === which is equally specific with ===
! Rule 78/78 ! before doing anything:
! ----------------------------------------------------------------------------------------------------
! No specific request
! before going to highway when in car:
[ R_1166 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,1)) == I240_highway) && (true)) && (self=actor,true) && (( (WhetherIn(I233_car)) ))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1166, 1166);
      ! phrase 1
      ! [1: if player is in car begin]
       if (((I233_car == ContainerOf(player))))  {
         ! phrase 2
         ! [2: say ~[one of]As you back out of Privet Drive, you notice a tabby cat out of the corner of your eye. you also notice that the cat looks like it is reading a map. you look round again, but the map has gone. As you drive round the corner of the road, you notice the cat reading the sign - no, looking at the sign; cats can't read maps or signs.[or][stopping][line break][if the venture of work is incomplete]~]
         say__p=1;ParaContent();  I7_ST_say_one_of-->0 =
	i7_soo_stop(I7_ST_say_one_of-->0, 2);
	switch((I7_ST_say_one_of-->0)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_204;  new_line;ParaContent();  @nop; 1: ParaContent();  } ParaContent();  new_line; 
	if (~~((((GProperty(SCENE_TY, I238_work,p80_venture) == I268_incomplete))))) jump L_Say18;
		 .L_Say18; .L_SayX18;
         ! phrase 3
         ! [3: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1166, 1166, true);
   rfalse;
];
! No specific request
! before dialling 8953 on office phone when dialyes/no is 1:
[ R_1206 ;
   if ((action ==##A113_dialling_it_on) &&  (actor==player) && ((parsed_number == 8953) && (true)) && ((second == I258_office_phone) && (true)) && (self=actor,true) && ((((Global_Vars-->71) == 1)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1206, 1206);
      ! phrase 1
      ! [1: try asking the customer about ~call 8953~ instead]
       TryAction(32, player, ##Ask, I259_customer, SC_205);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1206, 1206, true);
   rfalse;
];
! No specific request
! before asking the customer about a topic listed in the lexicon when lexicon is table 1:
[ R_1199 
    ct_0 ct_1 ! Used for table searches
    ;
   if ((action ==##Ask) &&  (actor==player) && ((noun == I259_customer) && (true)) && (ct_1=ExistsTableRowCorr(ct_0=(Global_Vars-->72),102,parsed_number)) && (self=actor,true) && ((((Global_Vars-->72) == T14_customer_responses)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1199, 1199);
      ! phrase 1
      ! [1: now bored is 0]
       (Global_Vars-->70) = 0; 
      ! phrase 2
      ! [2: now the lexicon is table 2]
       (Global_Vars-->72) = T15_customer_responses_2; 
      ! phrase 3
      ! [3: say ~[customer entry][paragraph break]~ instead]
      say__p=1;ParaContent();  print (PrintText) TableLookUpEntry(ct_0,119,ct_1); ParaContent();  DivideParagraphPoint(); new_line;  rtrue; .L_Say19; .L_SayX19; rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1199, 1199, true);
   rfalse;
];
! No specific request
! before asking the customer about a topic listed in lexicon when lexicon is table 2:
[ R_1203 
    ct_0 ct_1 ! Used for table searches
    ;
   if ((action ==##Ask) &&  (actor==player) && ((noun == I259_customer) && (true)) && (ct_1=ExistsTableRowCorr(ct_0=(Global_Vars-->72),102,parsed_number)) && (self=actor,true) && ((((Global_Vars-->72) == T15_customer_responses_2)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1203, 1203);
      ! phrase 1
      ! [1: say ~[customer entry]~]
      say__p=1;ParaContent();  print (PrintText) TableLookUpEntry(ct_0,119,ct_1);  .L_Say20; .L_SayX20;
      ! phrase 2
      ! [2: now bored is 0]
       (Global_Vars-->70) = 0; 
      ! phrase 3
      ! [3: now lexicon is table 5 instead]
       (Global_Vars-->72) = T17_second_half_customer_res;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1203, 1203, true);
   rfalse;
];
! No specific request
! before asking the customer about a topic listed in lexicon when lexicon is table 4:
[ R_1204 
    ct_0 ct_1 ! Used for table searches
    ;
   if ((action ==##Ask) &&  (actor==player) && ((noun == I259_customer) && (true)) && (ct_1=ExistsTableRowCorr(ct_0=(Global_Vars-->72),102,parsed_number)) && (self=actor,true) && ((((Global_Vars-->72) == T16_first_half_customer_resp)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1204, 1204);
      ! phrase 1
      ! [1: say ~[Customer entry]~]
      say__p=1;ParaContent();  print (PrintText) TableLookUpEntry(ct_0,119,ct_1);  .L_Say21; .L_SayX21;
      ! phrase 2
      ! [2: now bored is 0]
       (Global_Vars-->70) = 0; 
      ! phrase 3
      ! [3: now lexicon is table 5 instead]
       (Global_Vars-->72) = T17_second_half_customer_res;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1204, 1204, true);
   rfalse;
];
! No specific request
! before asking the customer about a topic listed in table 5 when lexicon is table 5:
[ R_1205 
    ct_0 ct_1 ! Used for table searches
    ;
   if ((action ==##Ask) &&  (actor==player) && ((noun == I259_customer) && (true)) && (ct_1=ExistsTableRowCorr(ct_0=T17_second_half_customer_res,102,parsed_number)) && (self=actor,true) && ((((Global_Vars-->72) == T17_second_half_customer_res)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1205, 1205);
      ! phrase 1
      ! [1: say ~[customer entry]~]
      say__p=1;ParaContent();  print (PrintText) TableLookUpEntry(ct_0,119,ct_1);  .L_Say22; .L_SayX22;
      ! phrase 2
      ! [2: try silently hanging up]
       @push keep_silent; keep_silent=1; TryAction(0, player, ##A114_hanging_up, 0, 0);; @pull keep_silent; 
      ! phrase 3
      ! [3: say ~[line break]you put down the office phone, cutting the connection.~]
      say__p=1;ParaContent();  new_line; ParaContent();  print (PrintText) SC_206;  new_line; .L_Say23; .L_SayX23;
      ! phrase 4
      ! [4: now bored is 0]
       (Global_Vars-->70) = 0; 
      ! phrase 5
      ! [5: now lexicon is table 1]
       (Global_Vars-->72) = T14_customer_responses; 
      ! phrase 6
      ! [6: now the venture of customercall is a success instead]
       WriteGProperty(SCENE_TY, I264_customercall,p80_venture,I266_success);  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1205, 1205, true);
   rfalse;
];
! No specific request
! before giving something in foods display case to the player when in bakers:
[ R_1261 ;
   if ((action ==##Give) &&  (actor==player) && ((noun ofclass K2_thing) && (I291_foods_display_case == ContainerOf(noun))) && ((second == player) && (true)) && (self=actor,true) && (( (WhetherIn(I287_bakers)) ))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1261, 1261);
      ! phrase 1
      ! [1: if the credit is at least 1 begin]
       if ((((Global_Vars-->76) >= 1)))  {
         ! phrase 2
         ! [2: if the noun is in foods display case begin]
          if (((I291_foods_display_case == ContainerOf(noun))))  {
            ! phrase 3
            ! [3: move the noun to the player]
             MoveObject(noun, player, 0, false); 
            ! phrase 4
            ! [4: say ~'Ok. Here's your [noun].'~]
            say__p=1;ParaContent();  print (PrintText) SC_207; ParaContent();  print (PrintShortName) noun; ParaContent();  print (PrintText) SC_208;  new_line; .L_Say24; .L_SayX24;
            ! phrase 5
            ! [5: decrease credit by 1 instead]
             (Global_Vars-->76) = (Global_Vars-->76) - 1;  rtrue;
            ! phrase 6
            ! [6: otherwise if a noun is in foods display case]
             } else if (((I291_foods_display_case == ContainerOf(noun)))) { 
            ! phrase 7
            ! [7: move the noun to the player]
             MoveObject(noun, player, 0, false); 
            ! phrase 8
            ! [8: say ~'Ok. Here's your [noun].'~]
            say__p=1;ParaContent();  print (PrintText) SC_207; ParaContent();  print (PrintShortName) noun; ParaContent();  print (PrintText) SC_208;  new_line; .L_Say25; .L_SayX25;
            ! phrase 9
            ! [9: decrease credit by 1 instead]
             (Global_Vars-->76) = (Global_Vars-->76) - 1;  rtrue;
            ! phrase 10
            ! [10: otherwise if the noun is not in foods display case]
             } else if (((~~((I291_foods_display_case == ContainerOf(noun)))))) { 
            ! phrase 11
            ! [11: say ~'We're out of those, sorry.'~ instead]
            say__p=1;ParaContent();  print (PrintText) SC_209;  new_line; rtrue; .L_Say26; .L_SayX26; rtrue;
            ! phrase 12
            ! [12: end if]
            }

         ! phrase 13
         ! [13: otherwise]
         } else {

         ! phrase 14
         ! [14: say ~'You need to pay for that. That'll be a pound.'~]
         say__p=1;ParaContent();  print (PrintText) SC_210;  new_line; .L_Say27; .L_SayX27;
         ! phrase 15
         ! [15: now remembered product is the noun instead]
          (Global_Vars-->77) = noun;  rtrue;
         ! phrase 16
         ! [16: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1261, 1261, true);
   rfalse;
];
! No specific request
! before asking the customer about a topic when dialyes/no is 1:
[ R_1209 ;
   if ((action ==##Ask) &&  (actor==player) && ((noun == I259_customer) && (true)) && ((true)) && (self=actor,true) && ((((Global_Vars-->71) == 1)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1209, 1209);
      ! phrase 1
      ! [1: increment bored]
       (Global_Vars-->70) = (Global_Vars-->70) + 1; 
      ! phrase 2
      ! [2: say ~[one of]The customer doesn't understand you. Much like the rest of the world.[or]That seems like a rather pointless, if typical, thing for you to say. [as decreasingly likely outcomes][line break]~ instead]
      say__p=1;ParaContent();  I7_ST_say_one_of-->1 =
	i7_soo_tap(I7_ST_say_one_of-->1, 2);
	switch((I7_ST_say_one_of-->1)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_211;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_212; ParaContent();  } ParaContent();  new_line;  rtrue; .L_Say28; .L_SayX28; rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1209, 1209, true);
   rfalse;
];
! No specific request
! From "Conversation Framework" by Eric Eve
! Before showing something to someone when the second noun is not the current interlocutor ( this is the showing needs an interlocutor rule ):
[ R_963 ;
   if ((action ==##Show) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K8_person)) && (self=actor,true) && (((~~((second == (Global_Vars-->36))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_963, 963);
      ! phrase 1
      ! [1: implicitly greet the second noun]
      (Resolver_2(second,"source", 173));
      ! phrase 2
      ! [2: if the second noun is not the current interlocutor , stop the action]
       if (((~~((second == (Global_Vars-->36)))))) {  rtrue;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_963, 963, true);
   rfalse;
];
! No specific request
! From "Conversation Framework" by Eric Eve
! Before giving something to someone when the second noun is not the current interlocutor ( this is the giving needs an interlocutor rule ):
[ R_964 ;
   if ((action ==##Give) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K8_person)) && (self=actor,true) && (((~~((second == (Global_Vars-->36))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_964, 964);
      ! phrase 1
      ! [1: if the current interlocutor is not a person , abide by the implicit-conversing needs current interlocutor rule]
       if (((~~(((Global_Vars-->36) ofclass K8_person))))) {  if (ProcessRulebook(R_954)) rtrue;   }
      ! phrase 2
      ! [2: implicitly greet the second noun]
      (Resolver_2(second,"source", 178));
      ! phrase 3
      ! [3: if the second noun is not the current interlocutor , stop the action]
       if (((~~((second == (Global_Vars-->36)))))) {  rtrue;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_964, 964, true);
   rfalse;
];
! No specific request
! before going north when in corridor for the first time:
[ R_1180 ;
   if ((PAPR_0() && (((TimesActionHasHappened-->0) == 1) && (ActionCurrentlyHappeningFlag->0)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1180, 1180);
      ! phrase 1
      ! [1: if the time of day is at least 8:30 am begin]
       if (((the_time >= 510)))  {
         ! phrase 2
         ! [2: say ~As you [if lily'sbroom is occupied]fly[else]walk[end if] in, the Boss comes up to you. 'Late again, Dursley?' He says. 'Well, i hope this is the last time. Make sure you are here at 8:30 Tomorrow, On The Dot.'[paragraph break]~]
         say__p=1;ParaContent();  print (PrintText) SC_213; 
	if (~~(((((Adj_34_t1_v9(I183_lily_sbroom))))))) jump L_Say29;
		ParaContent();  print (PrintText) SC_214; 
	jump L_SayX29; .L_Say29;
		ParaContent();  print (PrintText) SC_215; 
	.L_Say30; .L_SayX29;
		ParaContent();  print (PrintText) SC_216; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say31; .L_SayX30;
         ! phrase 3
         ! [3: if glulx timekeeping is supported begin]
          if (( ( glk_gestalt(gestalt_Timer, 0) ) ))  {
            ! phrase 4
            ! [4: wait 2000 milliseconds before continuing]
            (PHR_1016_r6 (2000));
            ! phrase 5
            ! [5: end if]
            }

         ! phrase 6
         ! [6: say ~[no line break]~]
         say__p=1;ParaContent(); (PHR_335_r7 ()); .L_Say32; .L_SayX31;
         ! phrase 7
         ! [7: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1180, 1180, true);
   rfalse;
];
! No specific request
! before going north when the location is corridor:
[ R_1273 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I46_north) && (true)) && (self=actor,true) && (((real_location == I252_corridor)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1273, 1273);
      ! phrase 1
      ! [1: if bakers is visited begin]
       if ((((Adj_44_t1_v9(I287_bakers)))))  {
         ! phrase 2
         ! [2: if the venture of work is half-complete begin]
          if (((GProperty(SCENE_TY, I238_work,p80_venture) == I270_half_complete)))  {
            ! phrase 3
            ! [3: say ~You rush over to the phone and pick it up, but part-way through putting in your home phone number, you realise that you're overreacting, and put the phone down.[paragraph break]~]
            say__p=1;ParaContent();  print (PrintText) SC_217; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say33; .L_SayX32;
            ! phrase 4
            ! [4: if glulx timekeeping is supported begin]
             if (( ( glk_gestalt(gestalt_Timer, 0) ) ))  {
               ! phrase 5
               ! [5: wait 3000 ms before continuing]
               (PHR_1016_r6 (3000));
               ! phrase 6
               ! [6: end if]
               }

            ! phrase 7
            ! [7: say ~Still,you find it difficult to focus for the rest of the day. Why where the oddly dressed people talking about your sister's son?[paragraph break]~]
            say__p=1;ParaContent();  print (PrintText) SC_218; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say34; .L_SayX33;
            ! phrase 8
            ! [8: wait 2000 ms before continuing]
            (PHR_1016_r6 (2000));
            ! phrase 9
            ! [9: say ~Even though you have your chance to yell at a few people, your heart isn't in it.[line break]When the boss comes in to tell you that you can go home, you barely notice.[paragraph break][run paragraph on]~]
            say__p=1;ParaContent();  print (PrintText) SC_219; ParaContent();  new_line; ParaContent();  print (PrintText) SC_220; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  RunParagraphOn();  .L_Say35; .L_SayX34;
            ! phrase 10
            ! [10: now the time of day is 5:00 pm]
             the_time = 1020; 
            ! phrase 11
            ! [11: now the venture of work is success]
             WriteGProperty(SCENE_TY, I238_work,p80_venture,I266_success); 
            ! phrase 12
            ! [12: if glulx timekeeping is supported begin]
             if (( ( glk_gestalt(gestalt_Timer, 0) ) ))  {
               ! phrase 13
               ! [13: wait 2000 ms before continuing]
               (PHR_1016_r6 (2000));
               ! phrase 14
               ! [14: end if]
               }

            ! phrase 15
            ! [15: continue the action]
             rfalse; 
            ! phrase 16
            ! [16: end if]
            }

         ! phrase 17
         ! [17: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1273, 1273, true);
   rfalse;
];
! No specific request
! before doing anything to rollerdex for the first time:
[ R_1214 ;blockv_stack-->(blockv_sp+2) = BlkValueCreate(STORED_ACTION_TY,0,STORED_ACTION_TY);
    blockv_stack-->(blockv_sp+1) = BlkValueCreate(STORED_ACTION_TY,0,STORED_ACTION_TY);
    blockv_stack-->(blockv_sp+0) = BlkValueCreate(STORED_ACTION_TY,0,STORED_ACTION_TY);
    blockv_sp = blockv_sp + 3;
    blockv_stack-->(blockv_sp++) = R_SHELL_1(blockv_sp-3);
    blockv_sp = blockv_sp - 4;
    BlkFree(blockv_stack-->(blockv_sp+2));
    BlkFree(blockv_stack-->(blockv_sp+1));
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+3);
];
[ R_SHELL_1 I7BASPL ;
   if ((PAPR_1() && (((TimesActionHasHappened-->1) == 1) && (ActionCurrentlyHappeningFlag->1)))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1214, 1214);
      ! phrase 1
      ! [1: unless the current action is examining begin]
       if (~~(((((STORED_ACTION_TY_Adopt( STORED_ACTION_TY_Current((blockv_stack-->(I7BASPL+0))) ), SAT_Tmp-->0=((action ==##Examine) &&  (actor==player)), STORED_ACTION_TY_Unadopt()))))))  {
         ! phrase 2
         ! [2: unless the current action is flipping rollerdex begin]
          if (~~(((((STORED_ACTION_TY_Adopt( STORED_ACTION_TY_Current((blockv_stack-->(I7BASPL+1))) ), SAT_Tmp-->0=((action ==##A128_flipping) &&  (actor==player) && ((noun == I273_rollerdex) && (true))), STORED_ACTION_TY_Unadopt()))))))  {
            ! phrase 3
            ! [3: say ~while [current action], you inadvertantly flip the rollerdex to a random page.[line break]~]
            say__p=1;ParaContent();  print (PrintText) SC_221; ParaContent();  print (STORED_ACTION_TY_Say)  STORED_ACTION_TY_Current((blockv_stack-->(I7BASPL+2))) ; ParaContent();  print (PrintText) SC_222; ParaContent();  new_line;  .L_Say36; .L_SayX35;
            ! phrase 4
            ! [4: now the description of rollerdex is ~[rollentrypermanent]~]
             WriteGProperty(9, I273_rollerdex,description,text_routine_95); 
            ! phrase 5
            ! [5: now rollentrypermanent is ~[rollerdexentry]~ instead]
             BlkValueCast((Global_Vars-->73), INDEXED_TEXT_TY, TEXT_TY, (text_routine_96));  rtrue;
            ! phrase 6
            ! [6: end unless]
            }

         ! phrase 7
         ! [7: end unless]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1214, 1214, true);
   rfalse;
];
! No specific request
! before doing anything to rollerdex for at least the second time:
[ R_1215 ;blockv_stack-->(blockv_sp+5) = BlkValueCreate(STORED_ACTION_TY,0,STORED_ACTION_TY);
    blockv_stack-->(blockv_sp+4) = BlkValueCreate(STORED_ACTION_TY,0,STORED_ACTION_TY);
    blockv_stack-->(blockv_sp+3) = BlkValueCreate(STORED_ACTION_TY,0,STORED_ACTION_TY);
    blockv_stack-->(blockv_sp+2) = BlkValueCreate(STORED_ACTION_TY,0,STORED_ACTION_TY);
    blockv_stack-->(blockv_sp+1) = BlkValueCreate(STORED_ACTION_TY,0,STORED_ACTION_TY);
    blockv_stack-->(blockv_sp+0) = BlkValueCreate(STORED_ACTION_TY,0,STORED_ACTION_TY);
    blockv_sp = blockv_sp + 6;
    blockv_stack-->(blockv_sp++) = R_SHELL_2(blockv_sp-6);
    blockv_sp = blockv_sp - 7;
    BlkFree(blockv_stack-->(blockv_sp+5));
    BlkFree(blockv_stack-->(blockv_sp+4));
    BlkFree(blockv_stack-->(blockv_sp+3));
    BlkFree(blockv_stack-->(blockv_sp+2));
    BlkFree(blockv_stack-->(blockv_sp+1));
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+6);
];
[ R_SHELL_2 I7BASPL ;
   if ((PAPR_2() && (((TimesActionHasHappened-->2) >= 2) && (ActionCurrentlyHappeningFlag->2)))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1215, 1215);
      ! phrase 1
      ! [1: if a random chance of 3 in 4 succeeds begin]
       if (( (GenerateRandomNumber(1, 4) <= 3) ))  {
         ! phrase 2
         ! [2: unless the current action is examining begin]
          if (~~(((((STORED_ACTION_TY_Adopt( STORED_ACTION_TY_Current((blockv_stack-->(I7BASPL+0))) ), SAT_Tmp-->0=((action ==##Examine) &&  (actor==player)), STORED_ACTION_TY_Unadopt()))))))  {
            ! phrase 3
            ! [3: unless the current action is flipping rollerdex begin]
             if (~~(((((STORED_ACTION_TY_Adopt( STORED_ACTION_TY_Current((blockv_stack-->(I7BASPL+1))) ), SAT_Tmp-->0=((action ==##A128_flipping) &&  (actor==player) && ((noun == I273_rollerdex) && (true))), STORED_ACTION_TY_Unadopt()))))))  {
               ! phrase 4
               ! [4: say ~while [current action], you inadvertantly flip the rollerdex to a random page.[line break]~]
               say__p=1;ParaContent();  print (PrintText) SC_221; ParaContent();  print (STORED_ACTION_TY_Say)  STORED_ACTION_TY_Current((blockv_stack-->(I7BASPL+2))) ; ParaContent();  print (PrintText) SC_222; ParaContent();  new_line;  .L_Say37; .L_SayX36;
               ! phrase 5
               ! [5: now the description of rollerdex is ~[rollentrypermanent]~]
                WriteGProperty(9, I273_rollerdex,description,text_routine_97); 
               ! phrase 6
               ! [6: now rollentrypermanent is ~[rollerdexentry]~ instead]
                BlkValueCast((Global_Vars-->73), INDEXED_TEXT_TY, TEXT_TY, (text_routine_98));  rtrue;
               ! phrase 7
               ! [7: end unless]
               }

            ! phrase 8
            ! [8: end unless]
            }

         ! phrase 9
         ! [9: otherwise]
         } else {

         ! phrase 10
         ! [10: unless the current action is examining begin]
          if (~~(((((STORED_ACTION_TY_Adopt( STORED_ACTION_TY_Current((blockv_stack-->(I7BASPL+3))) ), SAT_Tmp-->0=((action ==##Examine) &&  (actor==player)), STORED_ACTION_TY_Unadopt()))))))  {
            ! phrase 11
            ! [11: unless the current action is flipping rollerdex begin]
             if (~~(((((STORED_ACTION_TY_Adopt( STORED_ACTION_TY_Current((blockv_stack-->(I7BASPL+4))) ), SAT_Tmp-->0=((action ==##A128_flipping) &&  (actor==player) && ((noun == I273_rollerdex) && (true))), STORED_ACTION_TY_Unadopt()))))))  {
               ! phrase 12
               ! [12: say ~while [current action], you flip the rollerdex back to today's page.[line break]~]
               say__p=1;ParaContent();  print (PrintText) SC_221; ParaContent();  print (STORED_ACTION_TY_Say)  STORED_ACTION_TY_Current((blockv_stack-->(I7BASPL+5))) ; ParaContent();  print (PrintText) SC_223; ParaContent();  new_line;  .L_Say38; .L_SayX37;
               ! phrase 13
               ! [13: now the description of rollerdex is ~Tuesday[paragraph break]Work for today:[paragraph break]Answer two customer phone calls:[line break]First call[if the venture of customercall is success]: [bold type]achieved[roman type][otherwise if the venture of customercall is failure]: [bold type]failed[roman type][otherwise].[end if][line break]Second call[if the venture of mrmason call is success]:[bold type]	achieved[roman type][otherwise if the venture of mrmason call is failure]:[bold type]	failed[roman type][otherwise if the venture of mrmason call is pending]:[bold type]	pending[roman type][otherwise].[end if]~ instead]
                WriteGProperty(9, I273_rollerdex,description,text_routine_99);  rtrue;
               ! phrase 14
               ! [14: end unless]
               }

            ! phrase 15
            ! [15: end unless]
            }

         ! phrase 16
         ! [16: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1215, 1215, true);
   rfalse;
];
! No specific request
! before responding to customer a topic listed in the lexicon when the lexicon is table 9:
[ R_1233 
    ct_0 ct_1 ! Used for table searches
    ;
   if ((action ==##A126_responding_to_customer) &&  (actor==player) && (ct_1=ExistsTableRowCorr(ct_0=(Global_Vars-->72),102,parsed_number)) && (self=actor,true) && ((((Global_Vars-->72) == T21_drill_order_part_of_mrma)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1233, 1233);
      ! phrase 1
      ! [1: say ~[mason entry][paragraph break]~]
      say__p=1;ParaContent();  print (PrintText) TableLookUpEntry(ct_0,123,ct_1); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say39; .L_SayX38;
      ! phrase 2
      ! [2: now bored is 0]
       (Global_Vars-->70) = 0; 
      ! phrase 3
      ! [3: say ~Mr. Mason continues. 'You know, we've been having a lot of strange events today. Our building site is continually being swooped by owls, even during the day. And there's also some other strange things happening. Shooting stars and the likes.'~]
      say__p=1;ParaContent();  print (PrintText) SC_224;  new_line; .L_Say40; .L_SayX39;
      ! phrase 4
      ! [4: now lexicon is table 10 instead]
       (Global_Vars-->72) = T22_chatting_part_of_mrmason;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1233, 1233, true);
   rfalse;
];
! No specific request
! before taking a noun when the noun is overlaying something ( called the under-contents ):
[ R_762 
    t_0 ! Local variable e.g. 'under-contents' = thing
    ;
   if ((action ==##Take) &&  (actor==player) && ((noun == noun) && (true)) && (self=actor,true) && ((Prop_6() && (t_0=deferred_calling_list-->0, true)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_762, 762);
      ! phrase 1
      ! [1: now the under-contents are in the location]
       MoveObject(t_0,real_location); 
      ! phrase 2
      ! [2: now the under-contents are described]
       (Adj_56_t2_v9(t_0)); 
      ! phrase 3
      ! [3: say ~As you pick up [the noun], you reveal [a list of things that are underlying the noun].[line break]~]
      say__p=1;ParaContent();  print (PrintText) SC_225; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_226; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && ((subst__v.p59_underlying) == noun)))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_201; ParaContent();  new_line;  .L_Say41; .L_SayX40;
      ! phrase 4
      ! [4: now the noun is not overlaying anything]
       Prop_7(); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_762, 762, true);
   rfalse;
];
! No specific request
! From "Telephones" by George Tryfonas
! Before listening to someone when the player cannot touch the noun ( this is the listening to a connected party rule ):
[ R_1031 ;
   if ((action ==##Listen) &&  (actor==player) && ((noun ofclass K8_person)) && (self=actor,true) && (((~~((TestTouchability(player,noun))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1031, 1031);
      ! phrase 1
      ! [1: say ~[The noun] is waiting for you to carry on the conversation.~ instead]
      say__p=1;ParaContent();  print (The) noun; ParaContent();  print (PrintText) SC_227;  new_line; rtrue; .L_Say42; .L_SayX41; rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1031, 1031, true);
   rfalse;
];
! No specific request
! before eating a food when the foodlevel of the noun is half-eaten:
[ R_1126 ;
   if ((action ==##Eat) &&  (actor==player) && ((noun ofclass K44_food)) && (self=actor,true) && (((GProperty(OBJECT_TY, noun,p78_foodlevel) == I210_half_eaten)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1126, 1126);
      ! phrase 1
      ! [1: say ~You finish the [noun].~]
      say__p=1;ParaContent();  print (PrintText) SC_228; ParaContent();  print (PrintShortName) noun; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say43; .L_SayX42;
      ! phrase 2
      ! [2: now the foodlevel of the noun is eaten]
       WriteGProperty(OBJECT_TY, noun,p78_foodlevel,I211_eaten); 
      ! phrase 3
      ! [3: now the noun is off-stage]
       (Adj_9_t3_v9(noun)); 
      ! phrase 4
      ! [4: rule succeeds]
       RulebookSucceeds(); rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1126, 1126, true);
   rfalse;
];
! No specific request
! before buying anything when in bakers:
[ R_1263 ;
   if ((action ==##Buy) &&  (actor==player) && ((noun ofclass K2_thing)) && (self=actor,true) && (( (WhetherIn(I287_bakers)) ))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1263, 1263);
      ! phrase 1
      ! [1: try giving the noun to the player instead]
       TryAction(0, player, ##Give, noun, player);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1263, 1263, true);
   rfalse;
];
! No specific request
! From "Conversation Framework" by Eric Eve
! Before asking someone to try hailing ( this is the change greeting command to greeting rule ):
[ R_971 ;
   if ((action ==##A110_hailing) &&  (actor~=player) && (act_requester) && ((actor ofclass K8_person))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_971, 971);
      ! phrase 1
      ! [1: now the greeting type is explicit]
       (Global_Vars-->37) = I112_explicit; 
      ! phrase 2
      ! [2: try saying hello to the person asked]
       TryAction(0, player, ##A109_saying_hello_to, actor, 0);; 
      ! phrase 3
      ! [3: rule succeeds]
       RulebookSucceeds(); rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_971, 971, true);
   rfalse;
];
! No specific request
! From "Conversation Framework" by Eric Eve
! Before asking someone to try doing something when the person asked is not the current interlocutor ( this is the giving orders needs an interlocutor rule ):
[ R_965 ;
   if ( (actor~=player) && (act_requester) && ((actor ofclass K8_person)) && (self=actor,true) && (((~~((actor == (Global_Vars-->36))))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_965, 965);
      ! phrase 1
      ! [1: implicitly greet the person asked]
      (Resolver_2(actor,"source", 182));
      ! phrase 2
      ! [2: if the person asked is not the current interlocutor , stop the action]
       if (((~~((actor == (Global_Vars-->36)))))) {  rtrue;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_965, 965, true);
   rfalse;
];
! No specific request
! From "Telephones" by George Tryfonas
! Before going somewhere when the player reaches someone ( this is the go somewhere while on the line rule ):
[ R_1039 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,1)) ofclass K1_room)) && (self=actor,true) && ((Prop_8()))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1039, 1039);
      ! phrase 1
      ! [1: if the number of inuse telephones held by the player is 0 begin]
       if ((( (Prop_9())  == 0)))  {
         ! phrase 2
         ! [2: say ~(first hanging up on [the other party of the player])[command clarification break]~]
         say__p=1;ParaContent();  print (PrintText) SC_229; ParaContent(); @push self;  print (the) GProperty(9, self=player,p72_other_party); @pull self; ParaContent();  print (PrintText) SC_230; ParaContent();  CommandClarificationBreak();  .L_Say44; .L_SayX43;
         ! phrase 3
         ! [3: end current conversation]
         (PHR_1041_r8 ());
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1039, 1039, true);
   rfalse;
];
! No specific request
! From "Cheats" by Orion Zymaris
! before going through a door:
[ R_920 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,2)) ofclass K4_door)) && ((MStack-->MstVON(20007,1)) ~= nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_920, 920);
      ! phrase 1
      ! [1: if the noun is carried begin]
       if ((((Adj_1_t1_v9(noun)))))  {
         ! phrase 2
         ! [2: say ~How could you go through it when you are carrying it?~]
         say__p=1;ParaContent();  print (PrintText) SC_231;  new_line; .L_Say45; .L_SayX44;
         ! phrase 3
         ! [3: stop the action]
          rtrue; 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_920, 920, true);
   rfalse;
];
! No specific request
! before unlocking suitcase with dursley:
[ R_1144 ;
   if ((action ==##Unlock) &&  (actor==player) && ((noun == I228_suitcase) && (true)) && ((second == I97_dursley) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1144, 1144);
      ! phrase 1
      ! [1: say ~Enter the combination lock code:~]
      say__p=1;ParaContent();  print (PrintText) SC_232;  .L_Say46; .L_SayX45;
      ! phrase 2
      ! [2: rule succeeds]
       RulebookSucceeds(); rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1144, 1144, true);
   rfalse;
];
! No specific request
! before giving the pound coin to the shop attendant:
[ R_1260 ;
   if ((action ==##Give) &&  (actor==player) && ((noun ofclass K53_pound_coin)) && ((second == I288_shop_attendant) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1260, 1260);
      ! phrase 1
      ! [1: if remembered product is not dursley begin]
       if (((~~(((Global_Vars-->77) == I97_dursley)))))  {
         ! phrase 2
         ! [2: if remembered product is in foods display case begin]
          if (((I291_foods_display_case == ContainerOf((Global_Vars-->77)))))  {
            ! phrase 3
            ! [3: increment credit]
             (Global_Vars-->76) = (Global_Vars-->76) + 1; 
            ! phrase 4
            ! [4: try giving remembered product to the player]
             TryAction(0, player, ##Give, (Global_Vars-->77), player);; 
            ! phrase 5
            ! [5: end if]
            }

         ! phrase 6
         ! [6: otherwise]
         } else {

         ! phrase 7
         ! [7: increment credit]
          (Global_Vars-->76) = (Global_Vars-->76) + 1; 
         ! phrase 8
         ! [8: say ~'Now, what do you want?'~]
         say__p=1;ParaContent();  print (PrintText) SC_233;  new_line; .L_Say47; .L_SayX46;
         ! phrase 9
         ! [9: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1260, 1260, true);
   rfalse;
];
! No specific request
! From "Conversation Framework" by Eric Eve
! Before answering someone that ~yes~ ( this is the change answering yes to saying yes rule ):
[ R_989 ;
   if ((action ==##Answer) &&  (actor==player) && ((noun ofclass K8_person)) && (Consult_Grammar_268(consult_from, consult_words)~=GPR_FAIL)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_989, 989);
      ! phrase 1
      ! [1: try saying yes instead]
       TryAction(0, player, ##Yes, 0, 0);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_989, 989, true);
   rfalse;
];
! No specific request
! From "Conversation Framework" by Eric Eve
! Before answering someone that ~no~ ( this is the change answering no to saying no rule ):
[ R_990 ;
   if ((action ==##Answer) &&  (actor==player) && ((noun ofclass K8_person)) && (Consult_Grammar_269(consult_from, consult_words)~=GPR_FAIL)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_990, 990);
      ! phrase 1
      ! [1: try saying no instead]
       TryAction(0, player, ##No, 0, 0);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_990, 990, true);
   rfalse;
];
! No specific request
! From "Conversation Framework" by Eric Eve
! Before answering someone that ~sorry~ ( this is the change answering sorry to saying sorry rule ):
[ R_991 ;
   if ((action ==##Answer) &&  (actor==player) && ((noun ofclass K8_person)) && (Consult_Grammar_270(consult_from, consult_words)~=GPR_FAIL)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_991, 991);
      ! phrase 1
      ! [1: try asking the noun to try saying sorry instead]
       TryAction(1, noun, ##Sorry, 0, 0);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_991, 991, true);
   rfalse;
];
! No specific request
! before opening the wardrobe:
[ R_1095 ;
   if ((action ==##Open) &&  (actor==player) && ((noun == I123_wardrobe) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1095, 1095);
      ! phrase 1
      ! [1: if player is in bed begin]
       if (((I120_bed == ContainerOf(player))))  {
         ! phrase 2
         ! [2: say ~You reach up to open the wardrobe, but you can't quite get there. You need to get up first.~]
         say__p=1;ParaContent();  print (PrintText) SC_234;  new_line; .L_Say48; .L_SayX47;
         ! phrase 3
         ! [3: stop the action]
          rtrue; 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1095, 1095, true);
   rfalse;
];
! No specific request
! before opening the bedroomdoor:
[ R_1096 ;
   if ((action ==##Open) &&  (actor==player) && ((noun == I137_bedroomdoor) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1096, 1096);
      ! phrase 1
      ! [1: if player is in bed begin]
       if (((I120_bed == ContainerOf(player))))  {
         ! phrase 2
         ! [2: say ~You should be out of bed before trying to reach the door.~]
         say__p=1;ParaContent();  print (PrintText) SC_235;  new_line; .L_Say49; .L_SayX48;
         ! phrase 3
         ! [3: stop the action]
          rtrue; 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1096, 1096, true);
   rfalse;
];
! No specific request
! before taking howto spoil your children handbook:
[ R_1115 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I190_howto_spoil_your_childr) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1115, 1115);
      ! phrase 1
      ! [1: now the printed name of howto spoil your children handbook is ~how to spoil your children handbook~]
       WriteGProperty(9, I190_howto_spoil_your_childr,short_name,SC_27); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1115, 1115, true);
   rfalse;
];
! No specific request
! before examining petunia's diary:
[ R_1119 ;
   if ((action ==##Examine) &&  (actor==player) && ((noun == I195_petunia_s_diary) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1119, 1119);
      ! phrase 1
      ! [1: now letter is in attic]
       MoveObject(I196_letter,I147_attic); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1119, 1119, true);
   rfalse;
];
! No specific request
! before drinking coffee cup:
[ R_1133 ;
   if ((action ==##Drink) &&  (actor==player) && ((noun == I216_coffee_cup) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1133, 1133);
      ! phrase 1
      ! [1: if player's command matches ~drink coffee cup~ begin]
       if (( (SnippetMatches(players_command, Consult_Grammar_271)) ))  {
         ! phrase 2
         ! [2: say ~How would you manage that?~ instead]
         say__p=1;ParaContent();  print (PrintText) SC_236;  new_line; rtrue; .L_Say50; .L_SayX49; rtrue;
         ! phrase 3
         ! [3: otherwise if player's command matches ~drink cup~]
          } else if (( (SnippetMatches(players_command, Consult_Grammar_272)) )) { 
         ! phrase 4
         ! [4: say ~How would you manage that?~ instead]
         say__p=1;ParaContent();  print (PrintText) SC_236;  new_line; rtrue; .L_Say51; .L_SayX50; rtrue;
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1133, 1133, true);
   rfalse;
];
! No specific request
! before eating cereal:
[ R_1141 ;
   if ((action ==##Eat) &&  (actor==player) && ((noun == I225_cereal) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1141, 1141);
      ! phrase 1
      ! [1: say ~that cereal's Dudleys. and it's also been in his mouth.~]
      say__p=1;ParaContent();  print (PrintText) SC_237;  new_line; .L_Say52; .L_SayX51;
      ! phrase 2
      ! [2: stop the action]
       rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1141, 1141, true);
   rfalse;
];
! No specific request
! before opening filing cabinet:
[ R_1222 ;
   if ((action ==##Open) &&  (actor==player) && ((noun == I274_filing_cabinet) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1222, 1222);
      ! phrase 1
      ! [1: try opening fcdrawer instead]
       TryAction(0, player, ##Open, I275_fcdrawer, 0);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1222, 1222, true);
   rfalse;
];
! No specific request
! before examining filing cabinet:
[ R_1223 ;
   if ((action ==##Examine) &&  (actor==player) && ((noun == I274_filing_cabinet) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1223, 1223);
      ! phrase 1
      ! [1: try opening fcdrawer instead]
       TryAction(0, player, ##Open, I275_fcdrawer, 0);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1223, 1223, true);
   rfalse;
];
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Before asking a rideable animal ( called the mount ) to try going a direction ( called the way ):
[ R_861 
    t_0 ! Local variable e.g. 'mount' = rideable animal
    t_1 ! Local variable e.g. 'way' = direction
    ;
   if ((action ==##Go) &&  (actor~=player) && (act_requester) && (t_0 = actor, (((t_0=(actor), true) && (actor ofclass K21_rideable_animal)))) && (t_1 = noun, (((t_1=(noun), true) && (noun ofclass K3_direction))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_861, 861);
      ! phrase 1
      ! [1: if the player is carried by the mount , try going the way instead]
       if (((t_0 == CarrierOf(player)))) {  TryAction(0, player, ##Go, t_1, 0);;   rtrue; }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_861, 861, true);
   rfalse;
];
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Before an actor entering a rideable animal ( called the steed ):
[ R_844 
    t_0 ! Local variable e.g. 'steed' = rideable animal
    ;
   if ((action ==##Enter) && (act_requester==nothing) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K21_rideable_animal))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_844, 844);
      ! phrase 1
      ! [1: try the actor mounting the steed instead]
       TryAction(0, actor, ##A84_mounting, t_0, 0);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_844, 844, true);
   rfalse;
];
! No specific request
! before mounting a broom:
[ R_1110 ;
   if ((action ==##A84_mounting) &&  (actor==player) && ((noun ofclass K40_broom))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1110, 1110);
      ! phrase 1
      ! [1: if the broom is carried by player begin]
       if ((Prop_10()))  {
         ! phrase 2
         ! [2: try silently dropping the noun]
          @push keep_silent; keep_silent=1; TryAction(0, player, ##Drop, noun, 0);; @pull keep_silent; 
         ! phrase 3
         ! [3: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1110, 1110, true);
   rfalse;
];
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Before an actor entering a rideable vehicle ( called the conveyance ):
[ R_845 
    t_0 ! Local variable e.g. 'conveyance' = rideable vehicle
    ;
   if ((action ==##Enter) && (act_requester==nothing) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K22_rideable_vehicle))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_845, 845);
      ! phrase 1
      ! [1: try the actor mounting the conveyance instead]
       TryAction(0, actor, ##A84_mounting, t_0, 0);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_845, 845, true);
   rfalse;
];
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Before an actor getting off a rideable animal ( called the steed ):
[ R_846 
    t_0 ! Local variable e.g. 'steed' = rideable animal
    ;
   if ((action ==##GetOff) && (act_requester==nothing) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K21_rideable_animal))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_846, 846);
      ! phrase 1
      ! [1: try the actor dismounting instead]
       TryAction(0, actor, ##A85_dismounting, 0, 0);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_846, 846, true);
   rfalse;
];
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Before an actor getting off a rideable vehicle ( called the conveyance ):
[ R_847 
    t_0 ! Local variable e.g. 'conveyance' = rideable vehicle
    ;
   if ((action ==##GetOff) && (act_requester==nothing) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K22_rideable_vehicle))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_847, 847);
      ! phrase 1
      ! [1: try the actor dismounting instead]
       TryAction(0, actor, ##A85_dismounting, 0, 0);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_847, 847, true);
   rfalse;
];
! No specific request
! before wearing clothing:
[ R_1098 ;
   if ((action ==##Wear) &&  (actor==player) && ((noun ofclass K30_clothing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1098, 1098);
      ! phrase 1
      ! [1: if player is wearing pyjamas begin]
       if (((player == WearerOf(I130_pyjamas))))  {
         ! phrase 2
         ! [2: unless the player's command includes ~pyjamas~ begin]
          if (~~(( (matched_text=SnippetIncludes(Consult_Grammar_273,players_command)) )))  {
            ! phrase 3
            ! [3: if the location is dursley's bedroom begin]
             if (((real_location == I118_dursley_s_bedroom)))  {
               ! phrase 4
               ! [4: now the pyjamas is in the wardrobe]
                MoveObject(I130_pyjamas,I123_wardrobe); 
               ! phrase 5
               ! [5: end if]
               }

            ! phrase 6
            ! [6: end unless]
            }

         ! phrase 7
         ! [7: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1098, 1098, true);
   rfalse;
];
! No specific request
! before wearing clothing:
[ R_1099 ;
   if ((action ==##Wear) &&  (actor==player) && ((noun ofclass K30_clothing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1099, 1099);
      ! phrase 1
      ! [1: if player is wearing clothing begin]
       if ((Prop_11()))  {
         ! phrase 2
         ! [2: say ~Even though you got the biggest clothing the store could sell you, you can barely wear one set of clothing, let alone two.~]
         say__p=1;ParaContent();  print (PrintText) SC_238;  new_line; .L_Say53; .L_SayX52;
         ! phrase 3
         ! [3: stop the action]
          rtrue; 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1099, 1099, true);
   rfalse;
];
! No specific request
! before going under a thing:
[ R_761 ;
   if ((action ==##A82_going_under) &&  (actor==player) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_761, 761);
      ! phrase 1
      ! [1: if the noun is carried by a person begin]
       if (((CarrierOf(noun) ofclass K8_person)))  {
         ! phrase 2
         ! [2: say ~That would be impossible.~]
         say__p=1;ParaContent();  print (PrintText) SC_239;  new_line; .L_Say54; .L_SayX53;
         ! phrase 3
         ! [3: stop the action]
          rtrue; 
         ! phrase 4
         ! [4: otherwise if the noun is worn by a person]
          } else if (((WearerOf(noun) ofclass K8_person))) { 
         ! phrase 5
         ! [5: say ~That would be impossible.~]
         say__p=1;ParaContent();  print (PrintText) SC_239;  new_line; .L_Say55; .L_SayX54;
         ! phrase 6
         ! [6: stop the action]
          rtrue; 
         ! phrase 7
         ! [7: otherwise if the noun is the player]
          } else if (((noun == player))) { 
         ! phrase 8
         ! [8: say ~That would be laughable.~]
         say__p=1;ParaContent();  print (PrintText) SC_240;  new_line; .L_Say56; .L_SayX55;
         ! phrase 9
         ! [9: stop the action]
          rtrue; 
         ! phrase 10
         ! [10: otherwise if the player is in the noun]
          } else if (((noun == ContainerOf(player)))) { 
         ! phrase 11
         ! [11: say ~That would be impossible.~]
         say__p=1;ParaContent();  print (PrintText) SC_239;  new_line; .L_Say57; .L_SayX56;
         ! phrase 12
         ! [12: stop the action]
          rtrue; 
         ! phrase 13
         ! [13: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_761, 761, true);
   rfalse;
];
! No specific request
! From "Cheats" by Orion Zymaris
! before taking something:
[ R_919 ;
   if ((action ==##Take) &&  (actor==player) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_919, 919);
      ! phrase 1
      ! [1: if the player is in the noun begin]
       if (((noun == ContainerOf(player))))  {
         ! phrase 2
         ! [2: try silently getting off the noun]
          @push keep_silent; keep_silent=1; TryAction(0, player, ##GetOff, noun, 0);; @pull keep_silent; 
         ! phrase 3
         ! [3: continue the action]
          rfalse; 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_919, 919, true);
   rfalse;
];
! No specific request
! From "Cheats" by Orion Zymaris
! before point increasing a number ( called Num ):
[ R_928 
    t_0 ! Local variable e.g. 'Num' = number
    ;
   if ((action ==##A94_point_increasing) &&  (actor==player) && (t_0 = parsed_number, (((t_0=(parsed_number), true) && (true))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_928, 928);
      ! phrase 1
      ! [1: increase added score by num]
       (Global_Vars-->26) = (Global_Vars-->26) + t_0; 
      ! phrase 2
      ! [2: now onactualscore is 0]
       (Global_Vars-->27) = 0; 
      ! phrase 3
      ! [3: continue the action]
       rfalse; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_928, 928, true);
   rfalse;
];
! No specific request
! From "Conversation Framework" by Eric Eve
! Before asking someone to try saying yes ( this is the greet before saying yes rule ):
[ R_986 ;
   if ((action ==##Yes) &&  (actor~=player) && (act_requester) && ((actor ofclass K8_person))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_986, 986);
      ! phrase 1
      ! [1: if the person asked is not the current interlocutor , implicitly greet the person asked]
       if (((~~((actor == (Global_Vars-->36)))))) { (Resolver_2(actor,"source", 307));  }
      ! phrase 2
      ! [2: try saying yes instead]
       TryAction(0, player, ##Yes, 0, 0);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_986, 986, true);
   rfalse;
];
! No specific request
! From "Conversation Framework" by Eric Eve
! Before asking someone to try saying no ( this is the greet before saying no rule ):
[ R_987 ;
   if ((action ==##No) &&  (actor~=player) && (act_requester) && ((actor ofclass K8_person))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_987, 987);
      ! phrase 1
      ! [1: if the person asked is not the current interlocutor , implicitly greet the person asked]
       if (((~~((actor == (Global_Vars-->36)))))) { (Resolver_2(actor,"source", 311));  }
      ! phrase 2
      ! [2: try saying no instead]
       TryAction(0, player, ##No, 0, 0);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_987, 987, true);
   rfalse;
];
! No specific request
! From "Conversation Framework" by Eric Eve
! Before asking someone to try saying sorry ( this is the greet before saying sorry rule ):
[ R_988 ;
   if ((action ==##Sorry) &&  (actor~=player) && (act_requester) && ((actor ofclass K8_person))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_988, 988);
      ! phrase 1
      ! [1: if the person asked is not the current interlocutor , implicitly greet the person asked]
       if (((~~((actor == (Global_Vars-->36)))))) { (Resolver_2(actor,"source", 315));  }
      ! phrase 2
      ! [2: try saying sorry instead]
       TryAction(0, player, ##Sorry, 0, 0);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_988, 988, true);
   rfalse;
];
! No specific request
! From "Telephones" by George Tryfonas
! Before dialling when the player reaches someone ( this is the dialling a telephone while on the line rule ):
[ R_1034 ;
   if ((action ==##A113_dialling_it_on) &&  (actor==player) && (self=actor,true) && ((Prop_12()))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1034, 1034);
      ! phrase 1
      ! [1: say ~(first ending your conversation with [the other party of the player])[command clarification break]~]
      say__p=1;ParaContent();  print (PrintText) SC_241; ParaContent(); @push self;  print (the) GProperty(9, self=player,p72_other_party); @pull self; ParaContent();  print (PrintText) SC_230; ParaContent();  CommandClarificationBreak();  .L_Say58; .L_SayX57;
      ! phrase 2
      ! [2: end current conversation]
      (PHR_1041_r8 ());
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1034, 1034, true);
   rfalse;
];
! No specific request
! before dismounting when player was on lily'sbroom:
[ R_1111 ;
   if ((action ==##A85_dismounting) &&  (actor==player) && (self=actor,true) && (TestSinglePastState(1, 5, false, 1))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1111, 1111);
      ! phrase 1
      ! [1: now lily'sbroom is undescribed]
       (Adj_57_t2_v9(I183_lily_sbroom)); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1111, 1111, true);
   rfalse;
];
! No specific request
! before hanging up when dialyes/no is 1:
[ R_1192 ;
   if ((action ==##A114_hanging_up) &&  (actor==player) && (self=actor,true) && ((((Global_Vars-->71) == 1)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1192, 1192);
      ! phrase 1
      ! [1: now dialyes/no is 0]
       (Global_Vars-->71) = 0; 
      ! phrase 2
      ! [2: now bored is 0]
       (Global_Vars-->70) = 0; 
      ! phrase 3
      ! [3: now lexicon is table 1]
       (Global_Vars-->72) = T14_customer_responses; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1192, 1192, true);
   rfalse;
];
! No specific request
! before responding to customer when lexicon is table 10:
[ R_1235 ;
   if ((action ==##A126_responding_to_customer) &&  (actor==player) && (self=actor,true) && ((((Global_Vars-->72) == T22_chatting_part_of_mrmason)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1235, 1235);
      ! phrase 1
      ! [1: say ~'Hmmm... Well, goodbye Dursley.'~]
      say__p=1;ParaContent();  print (PrintText) SC_242;  new_line; .L_Say59; .L_SayX58;
      ! phrase 2
      ! [2: now lexicon is table 1]
       (Global_Vars-->72) = T14_customer_responses; 
      ! phrase 3
      ! [3: now the venture of mrmason call is success]
       WriteGProperty(SCENE_TY, I276_mrmason_call,p80_venture,I266_success); 
      ! phrase 4
      ! [4: say ~You put down the office phone, cutting the connection.~]
      say__p=1;ParaContent();  print (PrintText) SC_243;  new_line; .L_Say60; .L_SayX59;
      ! phrase 5
      ! [5: try silently hanging up]
       @push keep_silent; keep_silent=1; TryAction(0, player, ##A114_hanging_up, 0, 0);; @pull keep_silent; 
      ! phrase 6
      ! [6: rule succeeds instead]
       RulebookSucceeds(); rtrue;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1235, 1235, true);
   rfalse;
];
! No specific request
! before saying yes during customercall:
[ R_1200 ;
   if (scene_status-->3 == 1) { ! Runs only during scene
   if ((action ==##Yes) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1200, 1200);
      ! phrase 1
      ! [1: if dialyes/no is 1 begin]
       if ((((Global_Vars-->71) == 1)))  {
         ! phrase 2
         ! [2: if lexicon is table 2 begin]
          if ((((Global_Vars-->72) == T15_customer_responses_2)))  {
            ! phrase 3
            ! [3: now bored is 0]
             (Global_Vars-->70) = 0; 
            ! phrase 4
            ! [4: now the lexicon is table 4]
             (Global_Vars-->72) = T16_first_half_customer_resp; 
            ! phrase 5
            ! [5: say ~'Great. Now, how do i get it?'~ instead]
            say__p=1;ParaContent();  print (PrintText) SC_244;  new_line; rtrue; .L_Say61; .L_SayX60; rtrue;
            ! phrase 6
            ! [6: end if]
            }

         ! phrase 7
         ! [7: otherwise]
         } else {

         ! phrase 8
         ! [8: do nothing]
          ; 
         ! phrase 9
         ! [9: end if]
         }

   } ! Runs only during scene
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1200, 1200, true);
   rfalse;
];
! No specific request
! before saying no during uncle vernon's scene:
[ R_1202 ;
   if (scene_status-->1 == 1) { ! Runs only during scene
   if ((action ==##No) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1202, 1202);
      ! phrase 1
      ! [1: if lexicon is table 2 begin]
       if ((((Global_Vars-->72) == T15_customer_responses_2)))  {
         ! phrase 2
         ! [2: if dialyes/no is 1 begin]
          if ((((Global_Vars-->71) == 1)))  {
            ! phrase 3
            ! [3: now bored is 0]
             (Global_Vars-->70) = 0; 
            ! phrase 4
            ! [4: now the lexicon is table 1]
             (Global_Vars-->72) = T14_customer_responses; 
            ! phrase 5
            ! [5: say ~'Oh... ok. Thanks. If you remember, call me at 893.'~]
            say__p=1;ParaContent();  print (PrintText) SC_245;  new_line; .L_Say62; .L_SayX61;
            ! phrase 6
            ! [6: try hanging up instead]
             TryAction(0, player, ##A114_hanging_up, 0, 0);;  rtrue;
            ! phrase 7
            ! [7: end if]
            }

         ! phrase 8
         ! [8: otherwise if lexicon is table 2]
          } else if ((((Global_Vars-->72) == T15_customer_responses_2))) { 
         ! phrase 9
         ! [9: if dialyes/no is 0 begin]
          if ((((Global_Vars-->71) == 0)))  {
            ! phrase 10
            ! [10: now bored is 0]
             (Global_Vars-->70) = 0; 
            ! phrase 11
            ! [11: now the lexicon is table 1]
             (Global_Vars-->72) = T14_customer_responses; 
            ! phrase 12
            ! [12: say ~'Oh... ok. Thanks. If you remember, call me at 12856.'~]
            say__p=1;ParaContent();  print (PrintText) SC_246;  new_line; .L_Say63; .L_SayX62;
            ! phrase 13
            ! [13: try hanging up instead]
             TryAction(0, player, ##A114_hanging_up, 0, 0);;  rtrue;
            ! phrase 14
            ! [14: end if]
            }

         ! phrase 15
         ! [15: otherwise]
         } else {

         ! phrase 16
         ! [16: do nothing]
          ; 
         ! phrase 17
         ! [17: end if]
         }

   } ! Runs only during scene
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1202, 1202, true);
   rfalse;
];
! No specific request
! before saying yes during mrmason call:
[ R_1230 ;
   if (scene_status-->4 == 1) { ! Runs only during scene
   if ((action ==##Yes) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1230, 1230);
      ! phrase 1
      ! [1: if lexicon is table 2 begin]
       if ((((Global_Vars-->72) == T15_customer_responses_2)))  {
         ! phrase 2
         ! [2: now bored is 0]
          (Global_Vars-->70) = 0; 
         ! phrase 3
         ! [3: now the lexicon is table 9]
          (Global_Vars-->72) = T21_drill_order_part_of_mrma; 
         ! phrase 4
         ! [4: say ~'That's great. Now, what drills would you reccomend for [mason drill specifics]~ instead]
         say__p=1;ParaContent();  print (PrintText) SC_247; ParaContent(); (PHR_1201_r9 ()); rtrue; .L_Say64; .L_SayX63; rtrue;
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: do nothing]
          ; 
         ! phrase 7
         ! [7: end if]
         }

   } ! Runs only during scene
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1230, 1230, true);
   rfalse;
];
! No specific request
! before asking or implicit-imploring or implicit-asking when lexicon is table 5:
[ R_1198 ;
   if ((action ==##A103_implicit_asking or ##A108_implicit_imploring or ##AskFor) &&  (actor==player) && (self=actor,true) && ((((Global_Vars-->72) == T17_second_half_customer_res)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1198, 1198);
      ! phrase 1
      ! [1: if the player's command includes ~HAL~ begin]
       if (( (matched_text=SnippetIncludes(Consult_Grammar_274,players_command)) ))  {
         ! phrase 2
         ! [2: if the player's command includes ~6502~ begin]
          if (( (matched_text=SnippetIncludes(Consult_Grammar_275,players_command)) ))  {
            ! phrase 3
            ! [3: try asking the customer about ~ask them for the HAL 6502~ instead]
             TryAction(32, player, ##Ask, I259_customer, SC_248);;  rtrue;
            ! phrase 4
            ! [4: end if]
            }

         ! phrase 5
         ! [5: otherwise if the player's command includes ~Bk~]
          } else if (( (matched_text=SnippetIncludes(Consult_Grammar_276,players_command)) )) { 
         ! phrase 6
         ! [6: if the player's command includes ~44~ begin]
          if (( (matched_text=SnippetIncludes(Consult_Grammar_277,players_command)) ))  {
            ! phrase 7
            ! [7: try asking the customer about ~ask them for the hal 6502~]
             TryAction(32, player, ##Ask, I259_customer, SC_249);; 
            ! phrase 8
            ! [8: end if]
            }

         ! phrase 9
         ! [9: otherwise if the player's command includes ~Qz~]
          } else if (( (matched_text=SnippetIncludes(Consult_Grammar_278,players_command)) )) { 
         ! phrase 10
         ! [10: if the player's command includes ~77~ begin]
          if (( (matched_text=SnippetIncludes(Consult_Grammar_279,players_command)) ))  {
            ! phrase 11
            ! [11: try asking the customer about ~ask them for the hal 6502~]
             TryAction(32, player, ##Ask, I259_customer, SC_249);; 
            ! phrase 12
            ! [12: end if]
            }

         ! phrase 13
         ! [13: otherwise if the player's command includes ~T1000~]
          } else if (( (matched_text=SnippetIncludes(Consult_Grammar_280,players_command)) )) { 
         ! phrase 14
         ! [14: try asking the customer about ~ask them for the hal 6502~]
          TryAction(32, player, ##Ask, I259_customer, SC_249);; 
         ! phrase 15
         ! [15: otherwise]
         } else {

         ! phrase 16
         ! [16: continue the action]
          rfalse; 
         ! phrase 17
         ! [17: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1198, 1198, true);
   rfalse;
];
! No specific request
! before doing anything except hanging up or saying goodbye to when lexicon is table 10:
[ R_1234 ;
   if ((action ~=##A112_saying_goodbye_to or ##A114_hanging_up) &&  (actor==player) && (self=actor,true) && ((((Global_Vars-->72) == T22_chatting_part_of_mrmason)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1234, 1234);
      ! phrase 1
      ! [1: say ~'Hmmm... Well, goodbye Dursley.'~]
      say__p=1;ParaContent();  print (PrintText) SC_242;  new_line; .L_Say65; .L_SayX64;
      ! phrase 2
      ! [2: now the venture of mrmason call is success]
       WriteGProperty(SCENE_TY, I276_mrmason_call,p80_venture,I266_success); 
      ! phrase 3
      ! [3: now lexicon is table 1]
       (Global_Vars-->72) = T14_customer_responses; 
      ! phrase 4
      ! [4: say ~You put down the office phone, cutting the connection.~]
      say__p=1;ParaContent();  print (PrintText) SC_243;  new_line; .L_Say66; .L_SayX65;
      ! phrase 5
      ! [5: try silently hanging up]
       @push keep_silent; keep_silent=1; TryAction(0, player, ##A114_hanging_up, 0, 0);; @pull keep_silent; 
      ! phrase 6
      ! [6: rule succeeds instead]
       RulebookSucceeds(); rtrue;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1234, 1234, true);
   rfalse;
];
! No specific request
! From "Conversation Framework" by Eric Eve
! Before implicit-conversing when the current interlocutor is not visible and the current interlocutor is not nothing ( this is the can't converse with absent interlocutor rule ):
[ R_955 ;
   if ((NAP_0()) &&  (actor==player) && (self=actor,true) && ((((~~(((Adj_3_t1_v9((Global_Vars-->36)))))))) && (((~~(((Global_Vars-->36) == nothing))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_955, 955);
      ! phrase 1
      ! [1: say ~[The current interlocutor] isn't here.~]
      say__p=1;ParaContent();  print (The) (Global_Vars-->36); ParaContent();  print (PrintText) SC_250;  new_line; .L_Say67; .L_SayX66;
      ! phrase 2
      ! [2: reset the interlocutor instead]
      (PHR_976_r3 ()); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_955, 955, true);
   rfalse;
];
! No specific request
! From "Conversation Framework" by Eric Eve
! Before conversing when the noun is not the current interlocutor ( this is the greet a new interlocutor rule ):
[ R_962 ;
   if ((NAP_1()) &&  (actor==player) && (self=actor,true) && (((~~((noun == (Global_Vars-->36))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_962, 962);
      ! phrase 1
      ! [1: implicitly greet the noun]
      (Resolver_2(noun,"source", 169));
      ! phrase 2
      ! [2: if the noun is not the current interlocutor , stop the action]
       if (((~~((noun == (Global_Vars-->36)))))) {  rtrue;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_962, 962, true);
   rfalse;
];
! No specific request
! From "Conversation Framework" by Eric Eve
! Before implicit-conversing when the current interlocutor is nothing ( this is the implicit-conversing needs current interlocutor rule ):
[ R_954 
    t_0 ! Local variable e.g. 'np' = number
    t_1 ! Local variable e.g. 'interlocutor' = object
    t_2 ! Local variable e.g. '?-1,-1?' = object
    ;
   if ((NAP_0()) &&  (actor==player) && (self=actor,true) && ((((Global_Vars-->36) == nothing)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_954, 954);
      ! phrase 1
      ! [1: let np be the number of visible people who are not the player]
       t_0 =  (Prop_13()) ; 
      ! phrase 2
      ! [2: if np is 0 , say ~There's no one here to talk to.~]
       if (((t_0 == 0))) { say__p=1;ParaContent();  print (PrintText) SC_251;  new_line; .L_Say68; .L_SayX67;  }
      ! phrase 3
      ! [3: if np > 1 , say ~You need to specify who you want to speak to.~]
       if (((t_0 > 1))) { say__p=1;ParaContent();  print (PrintText) SC_252;  new_line; .L_Say69; .L_SayX68;  }
      ! phrase 4
      ! [4: if np is not 1 , stop the action]
       if (((~~((t_0 == 1))))) {  rtrue;   }
      ! phrase 5
      ! [5: let the interlocutor be a random visible person who is not the player]
       t_1 =  (Prop_14()) ; 
      ! phrase 6
      ! [6: if the interlocutor is a person begin]
       if (((t_1 ofclass K8_person)))  {
         ! phrase 7
         ! [7: say ~(addressing [the interlocutor])~]
         say__p=1;ParaContent();  print (PrintText) SC_253; ParaContent();  print (the) t_1; ParaContent();  print (PrintText) SC_230;  .L_Say70; .L_SayX69;
         ! phrase 8
         ! [8: let sn be the second noun]
          t_2 = second; 
         ! phrase 9
         ! [9: implicitly greet the interlocutor]
         (Resolver_2(t_1,"source", 100));
         ! phrase 10
         ! [10: now the second noun is sn]
          second = t_2; 
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~You're not talking to anyone.~]
         say__p=1;ParaContent();  print (PrintText) SC_254;  new_line; .L_Say71; .L_SayX70;
         ! phrase 13
         ! [13: stop the action]
          rtrue; 
         ! phrase 14
         ! [14: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_954, 954, true);
   rfalse;
];
! No specific request
! before doing anything when the command prompt is ~What do you want to write: ~:
[ R_1240 ;
   if ( (actor==player) && (self=actor,true) && ((((Global_Vars-->1) == SC_255)))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1240, 1240);
      ! phrase 1
      ! [1: unless the player's command includes ~write on~ begin]
       if (~~(( (matched_text=SnippetIncludes(Consult_Grammar_281,players_command)) )))  {
         ! phrase 2
         ! [2: unless the player's command includes ~write in~ begin]
          if (~~(( (matched_text=SnippetIncludes(Consult_Grammar_282,players_command)) )))  {
            ! phrase 3
            ! [3: now the command prompt is ~>~]
             (Global_Vars-->1) = SC_74; 
            ! phrase 4
            ! [4: say ~You write '[the player's command]'.[line break]~]
            say__p=1;ParaContent();  print (PrintText) SC_256; ParaContent();  print (PrintSnippet) players_command; ParaContent();  print (PrintText) SC_257; ParaContent();  new_line;  .L_Say72; .L_SayX71;
            ! phrase 5
            ! [5: now notepad desc is the player's command instead]
             BlkValueCast((Global_Vars-->74), INDEXED_TEXT_TY, SNIPPET_TY, players_command);  rtrue;
            ! phrase 6
            ! [6: continue the action]
             rfalse; 
            ! phrase 7
            ! [7: end unless]
            }

         ! phrase 8
         ! [8: end unless]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1240, 1240, true);
   rfalse;
];
! No specific request
! before moving to:
[ R_759 ;
   if ((action ==##A90_moving_to) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_759, 759);
      ! phrase 1
      ! [1: if the noun is the player begin]
       if (((noun == player)))  {
         ! phrase 2
         ! [2: now underly is 0]
          (Global_Vars-->14) = 0; 
         ! phrase 3
         ! [3: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_759, 759, true);
   rfalse;
];
! No specific request
! before putting under:
[ R_760 ;
   if ((action ==##A80_putting_it_under) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_760, 760);
      ! phrase 1
      ! [1: if the second noun is carried by a person begin]
       if (((CarrierOf(second) ofclass K8_person)))  {
         ! phrase 2
         ! [2: say ~That would be impossible.~]
         say__p=1;ParaContent();  print (PrintText) SC_239;  new_line; .L_Say73; .L_SayX72;
         ! phrase 3
         ! [3: stop the action]
          rtrue; 
         ! phrase 4
         ! [4: otherwise if the second noun is a rideable vehicle]
          } else if (((second ofclass K22_rideable_vehicle))) { 
         ! phrase 5
         ! [5: say ~That would not fit under there.~]
         say__p=1;ParaContent();  print (PrintText) SC_258;  new_line; .L_Say74; .L_SayX73;
         ! phrase 6
         ! [6: stop the action]
          rtrue; 
         ! phrase 7
         ! [7: otherwise if the second noun is worn by a person]
          } else if (((WearerOf(second) ofclass K8_person))) { 
         ! phrase 8
         ! [8: say ~That would be impossible.~]
         say__p=1;ParaContent();  print (PrintText) SC_239;  new_line; .L_Say75; .L_SayX74;
         ! phrase 9
         ! [9: stop the action]
          rtrue; 
         ! phrase 10
         ! [10: otherwise if the second noun is a person]
          } else if (((second ofclass K8_person))) { 
         ! phrase 11
         ! [11: say ~That would be ridiculous.~]
         say__p=1;ParaContent();  print (PrintText) SC_259;  new_line; .L_Say76; .L_SayX75;
         ! phrase 12
         ! [12: stop the action]
          rtrue; 
         ! phrase 13
         ! [13: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_760, 760, true);
   rfalse;
];
! No specific request
! before teleporting to:
[ R_763 ;
   if ((action ==##A89_teleporting_to) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_763, 763);
      ! phrase 1
      ! [1: now the player is not underlying anything]
       Prop_15(); 
      ! phrase 2
      ! [2: continue the action]
       rfalse; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_763, 763, true);
   rfalse;
];
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Before an actor exiting:
[ R_848 ;
   if ((action ==##Exit) && (act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_848, 848);
      ! phrase 1
      ! [1: if the actor is carried by a rideable animal , try the actor dismounting instead]
       if (((CarrierOf(actor) ofclass K21_rideable_animal))) {  TryAction(0, actor, ##A85_dismounting, 0, 0);;   rtrue; }
      ! phrase 2
      ! [2: if the actor is carried by a rideable vehicle , try the actor dismounting instead]
       if (((CarrierOf(actor) ofclass K22_rideable_vehicle) && (CarrierOf(actor) ofclass K8_person))) {  TryAction(0, actor, ##A85_dismounting, 0, 0);;   rtrue; }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_848, 848, true);
   rfalse;
];
! No specific request
! From "Cheats" by Orion Zymaris
! before teleporting to:
[ R_902 ;
   if ((action ==##A89_teleporting_to) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_902, 902);
      ! phrase 1
      ! [1: ignore the basic accessibility rule]
       SuppressRule(BASIC_ACCESSIBILITY_R); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_902, 902, true);
   rfalse;
];
! No specific request
! From "Cheats" by Orion Zymaris
! before putting back:
[ R_923 ;
   if ((action ==##A91_putting_back) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_923, 923);
      ! phrase 1
      ! [1: if the noun is in the second noun begin]
       if (((second == ContainerOf(noun))))  {
         ! phrase 2
         ! [2: say ~You've already done that!~]
         say__p=1;ParaContent();  print (PrintText) SC_260;  new_line; .L_Say77; .L_SayX76;
         ! phrase 3
         ! [3: otherwise if the noun is on the second noun]
          } else if (((second == SupporterOf(noun)))) { 
         ! phrase 4
         ! [4: say ~You've already done that!~]
         say__p=1;ParaContent();  print (PrintText) SC_260;  new_line; .L_Say78; .L_SayX77;
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_923, 923, true);
   rfalse;
];
! No specific request
! From "Wizard Money" by Orion Zymaris
! before paying wizard money:
[ R_934 ;
   if ((action ==##A97_paying_wizard_money) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_934, 934);
      ! phrase 1
      ! [1: if the cost of the second noun is less than the cost of the noun begin]
       if (((GProperty(OBJECT_TY, second,p66_cost) < GProperty(OBJECT_TY, noun,p66_cost))))  {
         ! phrase 2
         ! [2: say ~That isn't enough![line break]~]
         say__p=1;ParaContent();  print (PrintText) SC_261; ParaContent();  new_line;  .L_Say79; .L_SayX78;
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: move the noun to the player]
          MoveObject(noun, player, 0, false); 
         ! phrase 5
         ! [5: say ~Ok. Here you go![line break]~]
         say__p=1;ParaContent();  print (PrintText) SC_262; ParaContent();  new_line;  .L_Say80; .L_SayX79;
         ! phrase 6
         ! [6: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_934, 934, true);
   rfalse;
];
! No specific request
! before moving to:
[ R_1118 ;
   if ((action ==##A90_moving_to) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1118, 1118);
      ! phrase 1
      ! [1: if player's command includes ~handbook~ begin]
       if (( (matched_text=SnippetIncludes(Consult_Grammar_283,players_command)) ))  {
         ! phrase 2
         ! [2: now the printed name of howto spoil your children handbook is ~How to Spoil your Children Handbook~]
          WriteGProperty(9, I190_howto_spoil_your_childr,short_name,SC_193); 
         ! phrase 3
         ! [3: move howto to the second noun]
          MoveObject(I190_howto_spoil_your_childr, second, 0, false); 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1118, 1118, true);
   rfalse;
];
! No specific request
! before going:
[ R_1161 ;
   if ((action ==##Go) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1161, 1161);
      ! phrase 1
      ! [1: if player's command includes ~drive~ begin]
       if (( (matched_text=SnippetIncludes(Consult_Grammar_284,players_command)) ))  {
         ! phrase 2
         ! [2: unless player is in a vehicle begin]
          if (~~(((ContainerOf(player) ofclass K14_vehicle))))  {
            ! phrase 3
            ! [3: say ~you need to be in a car to drive.~]
            say__p=1;ParaContent();  print (PrintText) SC_263;  new_line; .L_Say81; .L_SayX80;
            ! phrase 4
            ! [4: stop the action]
             rtrue; 
            ! phrase 5
            ! [5: end unless]
            }

         ! phrase 6
         ! [6: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1161, 1161, true);
   rfalse;
];
! No specific request
! before going:
[ R_1162 ;
   if ((action ==##Go) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1162, 1162);
      ! phrase 1
      ! [1: if player's command includes ~fly~ begin]
       if (( (matched_text=SnippetIncludes(Consult_Grammar_285,players_command)) ))  {
         ! phrase 2
         ! [2: unless player is on a broom begin]
          if (~~(((SupporterOf(player) ofclass K40_broom))))  {
            ! phrase 3
            ! [3: say ~How is that possible?~]
            say__p=1;ParaContent();  print (PrintText) SC_264;  new_line; .L_Say82; .L_SayX81;
            ! phrase 4
            ! [4: stop the action]
             rtrue; 
            ! phrase 5
            ! [5: end unless]
            }

         ! phrase 6
         ! [6: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1162, 1162, true);
   rfalse;
];
! No specific request
! before writing intro:
[ R_1241 ;
   if ((action ==##A129_writing_intro) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1241, 1241);
      ! phrase 1
      ! [1: if the player is carrying a penquill begin]
       if ((Prop_16()))  {
         ! phrase 2
         ! [2: continue the action]
          rfalse; 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~You can't write on something without a pen.~ instead]
         say__p=1;ParaContent();  print (PrintText) SC_265;  new_line; rtrue; .L_Say83; .L_SayX82; rtrue;
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1241, 1241, true);
   rfalse;
];
! No specific request
! before wanting:
[ R_1264 ;
   if ((action ==##A132_wanting) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1264, 1264);
      ! phrase 1
      ! [1: try giving the noun to the player instead]
       TryAction(0, player, ##Give, noun, player);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1264, 1264, true);
   rfalse;
];
! No specific request
! before thanking with no noun:
[ R_1314 ;
   if ((action ==##A135_thanking_with_no_noun) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1314, 1314);
      ! phrase 1
      ! [1: try thanking current interlocutor instead]
       TryAction(0, player, ##A134_thanking, (Global_Vars-->36), 0);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1314, 1314, true);
   rfalse;
];
! No specific request
! before doing anything:
[ R_764 ;
   if ( (actor==player)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_764, 764);
      ! phrase 1
      ! [1: unless the player is underlying something begin]
       if (~~((((player.p59_underlying) ofclass K2_thing))))  {
         ! phrase 2
         ! [2: now underly is 0]
          (Global_Vars-->14) = 0; 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: now the player is reclining]
          player.p73_posture = I117_reclining; 
         ! phrase 5
         ! [5: end unless]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_764, 764, true);
   rfalse;
];
! No specific request
! before doing anything:
[ R_771 ;
   if ( (actor==player)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_771, 771);
      ! phrase 1
      ! [1: now already reported taking is 0]
       (Global_Vars-->16) = 0; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_771, 771, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Instead (B21_instead)
! ----------------------------------------------------------------------------------------------------
! Rule 1/58 ! Instead of going by a vehicle ( called the auto ) to somewhere offroad:
!   >>> III.2.1 - Action/Where/Going In Exotic Ways >>>
! Rule 2/58 ! instead of going to a road when the player is not in a vehicle:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 3/58 ! instead of dialling 893 on office phone when the venture of customercall is success:
!   === which is equally specific with ===
! Rule 4/58 ! instead of dialling 12856 on office phone when the venture of mrmason call is success:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 5/58 ! instead of taking the office phone when player's command includes ~Pick up phone~ for the first time:
!   >>> III.5.1 - Action/When/Duration >>>
! Rule 6/58 ! instead of saying hello to the customer for at least the second time:
!   >>> III.5.1 - Action/When/Duration >>>
! Rule 7/58 ! instead of examining television when television is switched on:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 8/58 ! Instead of listening to a inuse telephone when the player reaches someone ( this is the listening to a connected telephone rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 9/58 ! instead of eating a food when the foodlevel of the noun is uneaten:
!   === which is equally specific with ===
! Rule 10/58 ! instead of examining chairs when in dining room:
!   >>> I - Number of aspects constrained >>>
! Rule 11/58 ! instead of exiting from a vehicle when the vehicle is in a road:
!   === which is equally specific with ===
! Rule 12/58 ! instead of exiting from a rideable vehicle when the rideable vehicle is in a road:
!   >>> III.2.4 - Action/Where/Other Optional Clauses >>>
! Rule 13/58 ! Instead of asking a female person about ~herself~ ( this is the asking a woman about herself rule ):
!   === which is equally specific with ===
! Rule 14/58 ! Instead of asking a male person about ~himself~ ( this is the asking a man about himself rule ):
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 15/58 ! instead of telling the customer about a topic:
!   === which is equally specific with ===
! Rule 16/58 ! instead of requesting the shop attendant for anything:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 17/58 ! instead of turning tap1:
!   === which is equally specific with ===
! Rule 18/58 ! instead of switching on tap1:
!   === which is equally specific with ===
! Rule 19/58 ! instead of using tap1:
!   === which is equally specific with ===
! Rule 20/58 ! instead of opening diary:
!   === which is equally specific with ===
! Rule 21/58 ! Instead of eating Petunia:
!   === which is equally specific with ===
! Rule 22/58 ! Instead of eating Dudley:
!   === which is equally specific with ===
! Rule 23/58 ! instead of carjacking ferrari enzo:
!   === which is equally specific with ===
! Rule 24/58 ! Instead of carjacking car:
!   === which is equally specific with ===
! Rule 25/58 ! instead of answering the customer that:
!   === which is equally specific with ===
! Rule 26/58 ! instead of opening fcdrawer:
!   === which is equally specific with ===
! Rule 27/58 ! instead of entering cot:
!   === which is equally specific with ===
! Rule 28/58 ! instead of opening set of drawers:
!   === which is equally specific with ===
! Rule 29/58 ! instead of searching the set of drawers:
!   === which is equally specific with ===
! Rule 30/58 ! instead of turning tap2:
!   === which is equally specific with ===
! Rule 31/58 ! instead of switching on tap2:
!   === which is equally specific with ===
! Rule 32/58 ! instead of using tap2:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 33/58 ! instead of drinking something that is not a cup:
!   === which is equally specific with ===
! Rule 34/58 ! instead of carjacking something that is not a vehicle:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 35/58 ! instead of examining a direction ( called direction ):
!   === which is equally specific with ===
! Rule 36/58 ! instead of point increasing a number ( called Num ):
!   === which is equally specific with ===
! Rule 37/58 ! instead of taking a toy:
!   === which is equally specific with ===
! Rule 38/58 ! Instead of taking a photo:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 39/58 ! instead of asking the shop attendant to try doing anything:
!   >>> III.3.3 - Action/What/Actor Performing Action >>>
! Rule 40/58 ! instead of hanging up when lexicon is not table 5:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 41/58 ! instead of putting under when player's command includes ~put me under [any thing]~:
!   === which is equally specific with ===
! Rule 42/58 ! instead of exiting when underly is 1:
!   === which is equally specific with ===
! Rule 43/58 ! instead of teleporting to when cheats_bin is 0:
!   === which is equally specific with ===
! Rule 44/58 ! Instead of moving to when cheats_bin is 0:
!   === which is equally specific with ===
! Rule 45/58 ! instead of looking when location is street:
!   === which is equally specific with ===
! Rule 46/58 ! instead of taking when the player's command includes ~steal~:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 47/58 ! instead of swearing obscenely or swearing mildly when dialyes/no is 1:
!   === which is equally specific with ===
! Rule 48/58 ! instead of swearing obscenely or swearing mildly when office phone is inuse:
!   >>> I - Number of aspects constrained >>>
! Rule 49/58 ! Instead of an actor lying down ( this is the convert lying down rule ):
!   === which is equally specific with ===
! Rule 50/58 ! Instead of an actor sitting down ( this is the convert sitting down rule ):
!   === which is equally specific with ===
! Rule 51/58 ! Instead of an actor standing up ( this is the convert standing up rule ):
!   === which is equally specific with ===
! Rule 52/58 ! Instead of implicit-asking:
!   === which is equally specific with ===
! Rule 53/58 ! Instead of implicit-telling:
!   === which is equally specific with ===
! Rule 54/58 ! Instead of implicit-quizzing:
!   === which is equally specific with ===
! Rule 55/58 ! Instead of implicit-informing:
!   === which is equally specific with ===
! Rule 56/58 ! Instead of implicit-requesting:
!   === which is equally specific with ===
! Rule 57/58 ! Instead of implicit-imploring:
!   === which is equally specific with ===
! Rule 58/58 ! instead of taking inventory:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Instead of going by a vehicle ( called the auto ) to somewhere offroad:
[ R_1151 
    t_0 ! Local variable e.g. 'auto' = vehicle
    ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,1)) ofclass K1_room) && ((Adj_35_t1_v9((MStack-->MstVON(20007,1)))))) && (t_0 = (MStack-->MstVON(20007,3)), (((t_0=((MStack-->MstVON(20007,3))), true) && ((MStack-->MstVON(20007,3)) ofclass K14_vehicle))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1151, 1151);
      ! phrase 1
      ! [1: unless going by a vehicle to a multiroad begin]
       if (~~((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,1)) ofclass K20_multiroad)) && (((MStack-->MstVON(20007,3)) ofclass K14_vehicle))))  {
         ! phrase 2
         ! [2: say ~You can't drive the [the auto] off-road.~]
         say__p=1;ParaContent();  print (PrintText) SC_266; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_267;  new_line; .L_Say84; .L_SayX83;
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: continue the action]
          rfalse; 
         ! phrase 5
         ! [5: end unless]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1151, 1151, true);
   rfalse;
];
! No specific request
! instead of going to a road when the player is not in a vehicle:
[ R_1150 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,1)) ofclass K43_road)) && (self=actor,true) && ((Prop_17()))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1150, 1150);
      ! phrase 1
      ! [1: unless road is highway begin]
       if (~~(((I240_highway ofclass K43_road))))  {
         ! phrase 2
         ! [2: unless lily'sbroom is occupied begin]
          if (~~((((Adj_34_t1_v9(I183_lily_sbroom))))))  {
            ! phrase 3
            ! [3: say ~You need a vehicle to do that.~]
            say__p=1;ParaContent();  print (PrintText) SC_268;  new_line; .L_Say85; .L_SayX84;
            ! phrase 4
            ! [4: end unless]
            }

         ! phrase 5
         ! [5: otherwise if lily'sbroom is occupied]
          } else if ((((Adj_34_t1_v9(I183_lily_sbroom))))) { 
         ! phrase 6
         ! [6: continue the action]
          rfalse; 
         ! phrase 7
         ! [7: otherwise if the player is in carpark]
          } else if (((I244_grunnings_carpark == ContainerOf(player)))) { 
         ! phrase 8
         ! [8: if road is highway begin]
          if (((I240_highway ofclass K43_road)))  {
            ! phrase 9
            ! [9: now the player is in street]
             MoveObject(player,I285_street); 
            ! phrase 10
            ! [10: end if]
            }

         ! phrase 11
         ! [11: otherwise if the player is in street]
          } else if (((I285_street == ContainerOf(player)))) { 
         ! phrase 12
         ! [12: if road is highway begin]
          if (((I240_highway ofclass K43_road)))  {
            ! phrase 13
            ! [13: if bakers is visited begin]
             if ((((Adj_44_t1_v9(I287_bakers)))))  {
               ! phrase 14
               ! [14: try listening]
                TryAction(0, player, ##Listen, 0, 0);; 
               ! phrase 15
               ! [15: end if]
               }

            ! phrase 16
            ! [16: now the player is in grunnings carpark]
             MoveObject(player,I244_grunnings_carpark); 
            ! phrase 17
            ! [17: end if]
            }

         ! phrase 18
         ! [18: otherwise]
         } else {

         ! phrase 19
         ! [19: say ~You need a vehicle to do that.~]
         say__p=1;ParaContent();  print (PrintText) SC_268;  new_line; .L_Say86; .L_SayX85;
         ! phrase 20
         ! [20: end unless]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1150, 1150, true);
   rfalse;
];
! No specific request
! instead of dialling 893 on office phone when the venture of customercall is success:
[ R_1225 ;
   if ((action ==##A113_dialling_it_on) &&  (actor==player) && ((parsed_number == 893) && (true)) && ((second == I258_office_phone) && (true)) && (self=actor,true) && (((GProperty(SCENE_TY, I264_customercall,p80_venture) == I266_success)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1225, 1225);
      ! phrase 1
      ! [1: say ~Unless there's something important to tell the customer, i wouldn't reccomend it.~]
      say__p=1;ParaContent();  print (PrintText) SC_269;  new_line; .L_Say87; .L_SayX86;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1225, 1225, true);
   rfalse;
];
! No specific request
! instead of dialling 12856 on office phone when the venture of mrmason call is success:
[ R_1226 ;
   if ((action ==##A113_dialling_it_on) &&  (actor==player) && ((parsed_number == 12856) && (true)) && ((second == I258_office_phone) && (true)) && (self=actor,true) && (((GProperty(SCENE_TY, I276_mrmason_call,p80_venture) == I266_success)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1226, 1226);
      ! phrase 1
      ! [1: say ~Unless there's something important to tell Mr Mason, i wouldn't reccomend it.~]
      say__p=1;ParaContent();  print (PrintText) SC_270;  new_line; .L_Say88; .L_SayX87;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1226, 1226, true);
   rfalse;
];
! No specific request
! instead of taking the office phone when player's command includes ~Pick up phone~ for the first time:
[ R_1182 ;
   if ((PAPR_3() && (((TimesActionHasHappened-->3) == 1) && (ActionCurrentlyHappeningFlag->3)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1182, 1182);
      ! phrase 1
      ! [1: say ~As you go to pick up the phone, it rings. You pick it up.~]
      say__p=1;ParaContent();  print (PrintText) SC_271;  new_line; .L_Say89; .L_SayX88;
      ! phrase 2
      ! [2: try dialling 893 on office phone]
       TryAction(0, player, ##A113_dialling_it_on, 893, I258_office_phone);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1182, 1182, true);
   rfalse;
];
! No specific request
! instead of saying hello to the customer for at least the second time:
[ R_1212 ;
   if ((PAPR_4() && (((TimesActionHasHappened-->4) >= 2) && (ActionCurrentlyHappeningFlag->4)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1212, 1212);
      ! phrase 1
      ! [1: if the player's command includes ~good~ begin]
       if (( (matched_text=SnippetIncludes(Consult_Grammar_286,players_command)) ))  {
         ! phrase 2
         ! [2: unless the player's command includes ~morning~ begin]
          if (~~(( (matched_text=SnippetIncludes(Consult_Grammar_287,players_command)) )))  {
            ! phrase 3
            ! [3: try asking the customer about ~good~]
             TryAction(32, player, ##Ask, I259_customer, SC_272);; 
            ! phrase 4
            ! [4: end unless]
            }

         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: say ~'Hello again. How are you?'~]
         say__p=1;ParaContent();  print (PrintText) SC_273;  new_line; .L_Say90; .L_SayX89;
         ! phrase 7
         ! [7: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1212, 1212, true);
   rfalse;
];
! No specific request
! instead of examining television when television is switched on:
[ R_1290 ;
   if ((action ==##Examine) &&  (actor==player) && ((noun == I324_television) && (true)) && (self=actor,true) && ((((Adj_75_t1_v9(I324_television)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1290, 1290);
      ! phrase 1
      ! [1: try silently switching off television]
       @push keep_silent; keep_silent=1; TryAction(0, player, ##SwitchOff, I324_television, 0);; @pull keep_silent; 
      ! phrase 2
      ! [2: try switching on television]
       TryAction(0, player, ##SwitchOn, I324_television, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1290, 1290, true);
   rfalse;
];
! No specific request
! From "Telephones" by George Tryfonas
! Instead of listening to a inuse telephone when the player reaches someone ( this is the listening to a connected telephone rule ):
[ R_1030 ;
   if ((action ==##Listen) &&  (actor==player) && ((noun ofclass K29_telephone) && ((Adj_89_t1_v9(noun)))) && (self=actor,true) && ((Prop_18()))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1030, 1030);
      ! phrase 1
      ! [1: say ~You can hear [the other party of the player] breathing.~]
      say__p=1;ParaContent();  print (PrintText) SC_274; ParaContent(); @push self;  print (the) GProperty(9, self=player,p72_other_party); @pull self; ParaContent();  print (PrintText) SC_275;  new_line; .L_Say91; .L_SayX90;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1030, 1030, true);
   rfalse;
];
! No specific request
! instead of eating a food when the foodlevel of the noun is uneaten:
[ R_1125 ;
   if ((action ==##Eat) &&  (actor==player) && ((noun ofclass K44_food)) && (self=actor,true) && (((GProperty(OBJECT_TY, noun,p78_foodlevel) == I209_uneaten)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1125, 1125);
      ! phrase 1
      ! [1: say ~You take a big bite from the [noun].~]
      say__p=1;ParaContent();  print (PrintText) SC_276; ParaContent();  print (PrintShortName) noun; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say92; .L_SayX91;
      ! phrase 2
      ! [2: now the foodlevel of the noun is half-eaten]
       WriteGProperty(OBJECT_TY, noun,p78_foodlevel,I210_half_eaten); 
      ! phrase 3
      ! [3: rule succeeds]
       RulebookSucceeds(); rtrue; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1125, 1125, true);
   rfalse;
];
! No specific request
! instead of examining chairs when in dining room:
[ R_1284 ;
   if ((action ==##Examine) &&  (actor==player) && ((noun ofclass K49_chair)) && (self=actor,true) && (( (WhetherIn(I301_dining_room)) ))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1284, 1284);
      ! phrase 1
      ! [1: say ~[if player is dursley]One for you, One for Petunia, and three for Dudley, when he grows up to a good, healthy size.[otherwise if player is Petunia]One for you, One for Vernon, and three for Dudley, when he grows up to a good, healthy size.[otherwise if player is Dudley]Those are called chairs.[otherwise]Some chairs.~]
      say__p=1;
	if (~~((((player == I97_dursley))))) jump L_Say93;
		ParaContent();  print (PrintText) SC_277;  new_line;ParaContent(); 
	jump L_SayX92; .L_Say93; if (~~((((player == I202_petunia))))) jump L_Say94;
		ParaContent();  print (PrintText) SC_278;  new_line;ParaContent(); 
	jump L_SayX92; .L_Say94; if (~~((((player == I221_dudley))))) jump L_Say95;
		ParaContent();  print (PrintText) SC_279;  new_line;
	jump L_SayX92; .L_Say95;
		ParaContent();  print (PrintText) SC_280;  new_line; .L_Say96; .L_SayX92;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1284, 1284, true);
   rfalse;
];
! No specific request
! instead of exiting from a vehicle when the vehicle is in a road:
[ R_1159 ;
   if ((action ==##Exit) &&  (actor==player) && (((MStack-->MstVON(20009,0)) ofclass K14_vehicle)) && (self=actor,true) && ((Prop_19()))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1159, 1159);
      ! phrase 1
      ! [1: say ~That seems rather suicidal.~]
      say__p=1;ParaContent();  print (PrintText) SC_281;  new_line; .L_Say97; .L_SayX93;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1159, 1159, true);
   rfalse;
];
! No specific request
! instead of exiting from a rideable vehicle when the rideable vehicle is in a road:
[ R_1160 ;
   if ((action ==##Exit) &&  (actor==player) && (((MStack-->MstVON(20009,0)) ofclass K22_rideable_vehicle)) && (self=actor,true) && ((Prop_20()))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1160, 1160);
      ! phrase 1
      ! [1: say ~That seems rather suicidal.~]
      say__p=1;ParaContent();  print (PrintText) SC_281;  new_line; .L_Say98; .L_SayX94;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1160, 1160, true);
   rfalse;
];
! No specific request
! From "Conversation Framework" by Eric Eve
! Instead of asking a female person about ~herself~ ( this is the asking a woman about herself rule ):
[ R_952 ;
   if ((action ==##Ask) &&  (actor==player) && ((noun ofclass K8_person) && ((Adj_72_t1_v9(noun)))) && (Consult_Grammar_288(consult_from, consult_words)~=GPR_FAIL)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_952, 952);
      ! phrase 1
      ! [1: try quizzing the noun about the noun]
       TryAction(0, player, ##A101_quizzing_it_about, noun, noun);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_952, 952, true);
   rfalse;
];
! No specific request
! From "Conversation Framework" by Eric Eve
! Instead of asking a male person about ~himself~ ( this is the asking a man about himself rule ):
[ R_953 ;
   if ((action ==##Ask) &&  (actor==player) && ((noun ofclass K8_person) && ((Adj_73_t1_v9(noun)))) && (Consult_Grammar_289(consult_from, consult_words)~=GPR_FAIL)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_953, 953);
      ! phrase 1
      ! [1: try quizzing the noun about the noun]
       TryAction(0, player, ##A101_quizzing_it_about, noun, noun);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_953, 953, true);
   rfalse;
];
! No specific request
! instead of telling the customer about a topic:
[ R_1211 ;
   if ((action ==##Tell) &&  (actor==player) && ((noun == I259_customer) && (true)) && ((true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1211, 1211);
      ! phrase 1
      ! [1: try asking the noun about it]
       TryAction(0, player, ##Ask, noun, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1211, 1211, true);
   rfalse;
];
! No specific request
! instead of requesting the shop attendant for anything:
[ R_1266 ;
   if ((action ==##A99_requesting_it_for) &&  (actor==player) && ((noun == I288_shop_attendant) && (true)) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1266, 1266);
      ! phrase 1
      ! [1: try giving the second noun to the player]
       TryAction(0, player, ##Give, second, player);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1266, 1266, true);
   rfalse;
];
! No specific request
! instead of turning tap1:
[ R_1102 ;
   if ((action ==##Turn) &&  (actor==player) && ((noun == I144_tap1) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1102, 1102);
      ! phrase 1
      ! [1: try using sink1 instead]
       TryAction(0, player, ##A125_using, I143_sink1, 0);;  rtrue;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1102, 1102, true);
   rfalse;
];
! No specific request
! instead of switching on tap1:
[ R_1103 ;
   if ((action ==##SwitchOn) &&  (actor==player) && ((noun == I144_tap1) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1103, 1103);
      ! phrase 1
      ! [1: try using sink1 instead]
       TryAction(0, player, ##A125_using, I143_sink1, 0);;  rtrue;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1103, 1103, true);
   rfalse;
];
! No specific request
! instead of using tap1:
[ R_1104 ;
   if ((action ==##A125_using) &&  (actor==player) && ((noun == I144_tap1) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1104, 1104);
      ! phrase 1
      ! [1: try using sink1 instead]
       TryAction(0, player, ##A125_using, I143_sink1, 0);;  rtrue;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1104, 1104, true);
   rfalse;
];
! No specific request
! instead of opening diary:
[ R_1114 ;
   if ((action ==##Open) &&  (actor==player) && ((noun == I195_petunia_s_diary) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1114, 1114);
      ! phrase 1
      ! [1: try examining diary]
       TryAction(0, player, ##Examine, I195_petunia_s_diary, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1114, 1114, true);
   rfalse;
];
! No specific request
! Instead of eating Petunia:
[ R_1121 ;
   if ((action ==##Eat) &&  (actor==player) && ((noun == I202_petunia) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1121, 1121);
      ! phrase 1
      ! [1: say ~Why would you want to do that?~]
      say__p=1;ParaContent();  print (PrintText) SC_282;  new_line; .L_Say99; .L_SayX95;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1121, 1121, true);
   rfalse;
];
! No specific request
! Instead of eating Dudley:
[ R_1134 ;
   if ((action ==##Eat) &&  (actor==player) && ((noun == I221_dudley) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1134, 1134);
      ! phrase 1
      ! [1: say ~Even though you are able to eat half a cow's worth of meat in one sitting, you don't think you could eat Dudley.~]
      say__p=1;ParaContent();  print (PrintText) SC_283;  new_line; .L_Say100; .L_SayX96;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1134, 1134, true);
   rfalse;
];
! No specific request
! instead of carjacking ferrari enzo:
[ R_1169 ;
   if ((action ==##A124_carjacking) &&  (actor==player) && ((noun == I234_ferrari_enzo) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1169, 1169);
      ! phrase 1
      ! [1: say ~You own this vehicle already. why damage it?~]
      say__p=1;ParaContent();  print (PrintText) SC_284;  new_line; .L_Say101; .L_SayX97;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1169, 1169, true);
   rfalse;
];
! No specific request
! Instead of carjacking car:
[ R_1170 ;
   if ((action ==##A124_carjacking) &&  (actor==player) && ((noun == I233_car) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1170, 1170);
      ! phrase 1
      ! [1: say ~Why would you want to carjack your own car?~]
      say__p=1;ParaContent();  print (PrintText) SC_285;  new_line; .L_Say102; .L_SayX98;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1170, 1170, true);
   rfalse;
];
! No specific request
! instead of answering the customer that:
[ R_1210 ;
   if ((action ==##Answer) &&  (actor==player) && ((noun == I259_customer) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1210, 1210);
      ! phrase 1
      ! [1: try asking the noun about it]
       TryAction(0, player, ##Ask, noun, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1210, 1210, true);
   rfalse;
];
! No specific request
! instead of opening fcdrawer:
[ R_1224 ;
   if ((action ==##Open) &&  (actor==player) && ((noun == I275_fcdrawer) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1224, 1224);
      ! phrase 1
      ! [1: say ~as you open the drawer, you see [one of]your Complaints section, which takes a whole drawer on it's own[or]some boring papers to send off[or]some work that you filed yesterday[or]your collection of the yearly editions of 101 Pompous Complaints[or]a paper on which is written:[line break]The latest drill models - The Bk 44 model T, The Qz  77, the T1000, and the HAL 6502.[line break]The Bk 44 model T is reccomended for hard work and long lasting life.[line break]The Qz 77 is reccomended for it's low, low price.[line break]The HAL 6502 is reccomended for use with smaller screws and where finesse is needed.[line break]The T1000 is reccomended for use with large bolts and large scale work[or]a paper on which is written:[line break]The latest drill models - The Bk 44 model T, The Qz  77, the T1000, and the HAL 6502.[line break]The Bk 44 model T is reccomended for hard work and long lasting life.[line break]The Qz 77 is reccomended for it's low, low price.[line break]The HAL 6502 is reccomended for use with smaller screws and where finesse is needed.[line break]The T1000 is reccomended for use with large bolts and large scale work[purely at random].~]
      say__p=1;ParaContent();  print (PrintText) SC_286; ParaContent();  I7_ST_say_one_of-->2 =
	i7_soo_par(I7_ST_say_one_of-->2, 6);
	switch((I7_ST_say_one_of-->2)%(6+1)-1) {
		0: ParaContent();  print (PrintText) SC_287; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_288; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_289; ParaContent();  @nop; 3: ParaContent();  print (PrintText) SC_290; ParaContent();  @nop; 4: ParaContent();  print (PrintText) SC_291; ParaContent();  new_line; ParaContent();  print (PrintText) SC_292; ParaContent();  new_line; ParaContent();  print (PrintText) SC_293; ParaContent();  new_line; ParaContent();  print (PrintText) SC_294; ParaContent();  new_line; ParaContent();  print (PrintText) SC_295; ParaContent();  new_line; ParaContent();  print (PrintText) SC_296; ParaContent();  @nop; 5: ParaContent();  print (PrintText) SC_291; ParaContent();  new_line; ParaContent();  print (PrintText) SC_292; ParaContent();  new_line; ParaContent();  print (PrintText) SC_293; ParaContent();  new_line; ParaContent();  print (PrintText) SC_294; ParaContent();  new_line; ParaContent();  print (PrintText) SC_295; ParaContent();  new_line; ParaContent();  print (PrintText) SC_296; ParaContent();  } ParaContent();  print (PrintText) SC_201;  new_line; .L_Say103; .L_SayX99;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1224, 1224, true);
   rfalse;
];
! No specific request
! instead of entering cot:
[ R_1318 ;
   if ((action ==##Enter) &&  (actor==player) && ((noun == I331_cot) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1318, 1318);
      ! phrase 1
      ! [1: say ~You wouldn't fit in there.~]
      say__p=1;ParaContent();  print (PrintText) SC_297;  new_line; .L_Say104; .L_SayX100;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1318, 1318, true);
   rfalse;
];
! No specific request
! instead of opening set of drawers:
[ R_1319 ;
   if ((action ==##Open) &&  (actor==player) && ((noun == I332_set_of_drawers) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1319, 1319);
      ! phrase 1
      ! [1: try opening dudley's drawers]
       TryAction(0, player, ##Open, I333_dudley_s_drawers, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1319, 1319, true);
   rfalse;
];
! No specific request
! instead of searching the set of drawers:
[ R_1320 ;
   if ((action ==##Search) &&  (actor==player) && ((noun == I332_set_of_drawers) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1320, 1320);
      ! phrase 1
      ! [1: try searching dudley's drawers]
       TryAction(0, player, ##Search, I333_dudley_s_drawers, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1320, 1320, true);
   rfalse;
];
! No specific request
! instead of turning tap2:
[ R_1331 ;
   if ((action ==##Turn) &&  (actor==player) && ((noun == I354_tap2) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1331, 1331);
      ! phrase 1
      ! [1: try using sink2 instead]
       TryAction(0, player, ##A125_using, I353_sink2, 0);;  rtrue;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1331, 1331, true);
   rfalse;
];
! No specific request
! instead of switching on tap2:
[ R_1332 ;
   if ((action ==##SwitchOn) &&  (actor==player) && ((noun == I354_tap2) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1332, 1332);
      ! phrase 1
      ! [1: try using sink2 instead]
       TryAction(0, player, ##A125_using, I353_sink2, 0);;  rtrue;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1332, 1332, true);
   rfalse;
];
! No specific request
! instead of using tap2:
[ R_1333 ;
   if ((action ==##A125_using) &&  (actor==player) && ((noun == I354_tap2) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1333, 1333);
      ! phrase 1
      ! [1: try using sink2 instead]
       TryAction(0, player, ##A125_using, I353_sink2, 0);;  rtrue;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1333, 1333, true);
   rfalse;
];
! No specific request
! instead of drinking something that is not a cup:
[ R_1128 ;
   if ((action ==##Drink) &&  (actor==player) && ((noun ofclass K2_thing) && (~~((noun ofclass K45_cup))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1128, 1128);
      ! phrase 1
      ! [1: say ~That doesn't seem the most sanitary thing to drink from, if it even contains liquid to drink.~]
      say__p=1;ParaContent();  print (PrintText) SC_298;  new_line; .L_Say105; .L_SayX101;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1128, 1128, true);
   rfalse;
];
! No specific request
! instead of carjacking something that is not a vehicle:
[ R_1168 ;
   if ((action ==##A124_carjacking) &&  (actor==player) && ((noun ofclass K2_thing) && (~~((noun ofclass K14_vehicle))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1168, 1168);
      ! phrase 1
      ! [1: say ~How can you carjack that? It isn't a vehicle.~]
      say__p=1;ParaContent();  print (PrintText) SC_299;  new_line; .L_Say106; .L_SayX102;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1168, 1168, true);
   rfalse;
];
! No specific request
! From "Door Directions" by Orion Zymaris
! instead of examining a direction ( called direction ):
[ R_895 
    t_0 ! Local variable e.g. 'direction' = direction
    t_1 ! Local variable e.g. 'x' = object
    ;
   if ((action ==##Examine) &&  (actor==player) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K3_direction))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_895, 895);
      ! phrase 1
      ! [1: let x be the door direction of the location]
       t_1 = (Resolver_3(t_0,real_location,"source", 13)); 
      ! phrase 2
      ! [2: if x is a door begin]
       if (((t_1 ofclass K4_door)))  {
         ! phrase 3
         ! [3: unless direction is up begin]
          if (~~(((t_0 == I54_up))))  {
            ! phrase 4
            ! [4: unless direction is down begin]
             if (~~(((t_0 == I55_down))))  {
               ! phrase 5
               ! [5: say ~to the [direction] is [x].~]
               say__p=1;ParaContent();  print (PrintText) SC_300; ParaContent();  print (PrintShortName) t_0; ParaContent();  print (PrintText) SC_301; ParaContent();  print (PrintShortName) t_1; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say107; .L_SayX103;
               ! phrase 6
               ! [6: otherwise if direction is down]
                } else if (((t_0 == I55_down))) { 
               ! phrase 7
               ! [7: say ~Below you is [x].~]
               say__p=1;ParaContent();  print (PrintText) SC_302; ParaContent();  print (PrintShortName) t_1; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say108; .L_SayX104;
               ! phrase 8
               ! [8: end unless]
               }

            ! phrase 9
            ! [9: otherwise if direction is up]
             } else if (((t_0 == I54_up))) { 
            ! phrase 10
            ! [10: say ~Above you is [x].~]
            say__p=1;ParaContent();  print (PrintText) SC_303; ParaContent();  print (PrintShortName) t_1; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say109; .L_SayX105;
            ! phrase 11
            ! [11: end unless]
            }

         ! phrase 12
         ! [12: otherwise]
         } else {

         ! phrase 13
         ! [13: let x be the room direction of the location]
          t_1 = (Resolver_4(t_0,real_location,"source", 23)); 
         ! phrase 14
         ! [14: if x is a room begin]
          if (((t_1 ofclass K1_room)))  {
            ! phrase 15
            ! [15: unless direction is up begin]
             if (~~(((t_0 == I54_up))))  {
               ! phrase 16
               ! [16: unless direction is down begin]
                if (~~(((t_0 == I55_down))))  {
                  ! phrase 17
                  ! [17: say ~to the [direction] is [x].~]
                  say__p=1;ParaContent();  print (PrintText) SC_300; ParaContent();  print (PrintShortName) t_0; ParaContent();  print (PrintText) SC_301; ParaContent();  print (PrintShortName) t_1; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say110; .L_SayX106;
                  ! phrase 18
                  ! [18: otherwise if direction is down]
                   } else if (((t_0 == I55_down))) { 
                  ! phrase 19
                  ! [19: say ~Below you is [x].~]
                  say__p=1;ParaContent();  print (PrintText) SC_302; ParaContent();  print (PrintShortName) t_1; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say111; .L_SayX107;
                  ! phrase 20
                  ! [20: end unless]
                  }

               ! phrase 21
               ! [21: otherwise if direction is up]
                } else if (((t_0 == I54_up))) { 
               ! phrase 22
               ! [22: say ~Above you is [x].~]
               say__p=1;ParaContent();  print (PrintText) SC_303; ParaContent();  print (PrintShortName) t_1; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say112; .L_SayX108;
               ! phrase 23
               ! [23: end unless]
               }

            ! phrase 24
            ! [24: otherwise]
            } else {

            ! phrase 25
            ! [25: say ~You see nothing unexpected in that direction.~]
            say__p=1;ParaContent();  print (PrintText) SC_304;  new_line; .L_Say113; .L_SayX109;
            ! phrase 26
            ! [26: end if]
            }

         ! phrase 27
         ! [27: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_895, 895, true);
   rfalse;
];
! No specific request
! From "Cheats" by Orion Zymaris
! instead of point increasing a number ( called Num ):
[ R_929 
    t_0 ! Local variable e.g. 'Num' = number
    ;
   if ((action ==##A94_point_increasing) &&  (actor==player) && (t_0 = parsed_number, (((t_0=(parsed_number), true) && (true))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_929, 929);
      ! phrase 1
      ! [1: increase the score by num instead]
       score = score + t_0;  rtrue;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_929, 929, true);
   rfalse;
];
! No specific request
! instead of taking a toy:
[ R_1113 ;
   if ((action ==##Take) &&  (actor==player) && ((noun ofclass K42_toy))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1113, 1113);
      ! phrase 1
      ! [1: say ~[first time]If you took one of Dudley's toys, he would notice.[line break]after he spent an hour counting them.[only]You can't take that.~]
      say__p=1;ParaContent();  
	if ((I7_ST_say_first_time-->0)++ == 0) {
		ParaContent();  print (PrintText) SC_305; ParaContent();  new_line; ParaContent();  print (PrintText) SC_306;  new_line;ParaContent();  } ParaContent();  print (PrintText) SC_307;  new_line; .L_Say114; .L_SayX110;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1113, 1113, true);
   rfalse;
];
! No specific request
! Instead of taking a photo:
[ R_1285 ;
   if ((action ==##Take) &&  (actor==player) && ((noun ofclass K54_photo))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1285, 1285);
      ! phrase 1
      ! [1: say ~You should leave these. They're family possessions.~]
      say__p=1;ParaContent();  print (PrintText) SC_308;  new_line; .L_Say115; .L_SayX111;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1285, 1285, true);
   rfalse;
];
! No specific request
! instead of asking the shop attendant to try doing anything:
[ R_1265 ;
   if ( (actor~=player) && (act_requester) && ((actor == I288_shop_attendant) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1265, 1265);
      ! phrase 1
      ! [1: try giving the second noun to the player]
       TryAction(0, player, ##Give, second, player);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1265, 1265, true);
   rfalse;
];
! No specific request
! instead of hanging up when lexicon is not table 5:
[ R_1184 ;
   if ((action ==##A114_hanging_up) &&  (actor==player) && (self=actor,true) && (((~~(((Global_Vars-->72) == T17_second_half_customer_res)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1184, 1184);
      ! phrase 1
      ! [1: if lexicon is table 10 begin]
       if ((((Global_Vars-->72) == T22_chatting_part_of_mrmason)))  {
         ! phrase 2
         ! [2: continue the action]
          rfalse; 
         ! phrase 3
         ! [3: otherwise if player's command includes ~hang up~]
          } else if (( (matched_text=SnippetIncludes(Consult_Grammar_290,players_command)) )) { 
         ! phrase 4
         ! [4: say ~That would be rude.~]
         say__p=1;ParaContent();  print (PrintText) SC_309;  new_line; .L_Say116; .L_SayX112;
         ! phrase 5
         ! [5: otherwise if the player's command includes ~call~]
          } else if (( (matched_text=SnippetIncludes(Consult_Grammar_291,players_command)) )) { 
         ! phrase 6
         ! [6: say ~That would be rude.~]
         say__p=1;ParaContent();  print (PrintText) SC_309;  new_line; .L_Say117; .L_SayX113;
         ! phrase 7
         ! [7: otherwise if the player's command includes ~dial~]
          } else if (( (matched_text=SnippetIncludes(Consult_Grammar_292,players_command)) )) { 
         ! phrase 8
         ! [8: say ~That would be rude.~]
         say__p=1;ParaContent();  print (PrintText) SC_309;  new_line; .L_Say118; .L_SayX114;
         ! phrase 9
         ! [9: otherwise if the player's command includes ~ring~]
          } else if (( (matched_text=SnippetIncludes(Consult_Grammar_293,players_command)) )) { 
         ! phrase 10
         ! [10: say ~That would be rude.~]
         say__p=1;ParaContent();  print (PrintText) SC_309;  new_line; .L_Say119; .L_SayX115;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: continue the action]
          rfalse; 
         ! phrase 13
         ! [13: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1184, 1184, true);
   rfalse;
];
! No specific request
! instead of putting under when player's command includes ~put me under [any thing]~:
[ R_757 ;
   if ((action ==##A80_putting_it_under) &&  (actor==player) && (self=actor,true) && (( (matched_text=SnippetIncludes(Consult_Grammar_294,players_command)) ))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_757, 757);
      ! phrase 1
      ! [1: now the player underlies the noun]
       player.p59_underlying = noun; 
      ! phrase 2
      ! [2: now underly is 1]
       (Global_Vars-->14) = 1; 
      ! phrase 3
      ! [3: say ~You put yourself under [the second noun].~]
      say__p=1;ParaContent();  print (PrintText) SC_310; ParaContent();  print (the) second; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say120; .L_SayX116;
      ! phrase 4
      ! [4: now overlay is the second noun]
       (Global_Vars-->15) = second; if (~~((Global_Vars-->15) ofclass K2_thing)) RunTimeProblem(RTP_WRONGASSIGNEDKIND, (Global_Vars-->15), "now overlay is the second noun", "thing");; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_757, 757, true);
   rfalse;
];
! No specific request
! instead of exiting when underly is 1:
[ R_766 ;
   if ((action ==##Exit) &&  (actor==player) && (self=actor,true) && ((((Global_Vars-->14) == 1)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_766, 766);
      ! phrase 1
      ! [1: try getting out from under overlay]
       TryAction(0, player, ##A83_getting_out_from_under, (Global_Vars-->15), 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_766, 766, true);
   rfalse;
];
! No specific request
! From "Cheats" by Orion Zymaris
! instead of teleporting to when cheats_bin is 0:
[ R_901 ;
   if ((action ==##A89_teleporting_to) &&  (actor==player) && (self=actor,true) && ((((Global_Vars-->25) == 0)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_901, 901);
      ! phrase 1
      ! [1: say ~I didn't understand that sentence.~]
      say__p=1;ParaContent();  print (PrintText) SC_311;  new_line; .L_Say121; .L_SayX117;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_901, 901, true);
   rfalse;
];
! No specific request
! From "Cheats" by Orion Zymaris
! Instead of moving to when cheats_bin is 0:
[ R_904 ;
   if ((action ==##A90_moving_to) &&  (actor==player) && (self=actor,true) && ((((Global_Vars-->25) == 0)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_904, 904);
      ! phrase 1
      ! [1: say ~I didn't understand that sentence.~]
      say__p=1;ParaContent();  print (PrintText) SC_311;  new_line; .L_Say122; .L_SayX118;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_904, 904, true);
   rfalse;
];
! No specific request
! instead of looking when location is street:
[ R_1268 ;
   if ((action ==##Look) &&  (actor==player) && (self=actor,true) && (((real_location == I285_street)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1268, 1268);
      ! phrase 1
      ! [1: if bakers is visited begin]
       if ((((Adj_44_t1_v9(I287_bakers)))))  {
         ! phrase 2
         ! [2: try listening instead]
          TryAction(0, player, ##Listen, 0, 0);;  rtrue;
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: continue the action]
          rfalse; 
         ! phrase 5
         ! [5: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1268, 1268, true);
   rfalse;
];
! No specific request
! instead of taking when the player's command includes ~steal~:
[ R_1336 ;
   if ((action ==##Take) &&  (actor==player) && (self=actor,true) && (( (matched_text=SnippetIncludes(Consult_Grammar_295,players_command)) ))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1336, 1336);
      ! phrase 1
      ! [1: say ~That would be immoral.~]
      say__p=1;ParaContent();  print (PrintText) SC_312;  new_line; .L_Say123; .L_SayX119;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1336, 1336, true);
   rfalse;
];
! No specific request
! instead of swearing obscenely or swearing mildly when dialyes/no is 1:
[ R_1190 ;
   if ((action ==##Mild or ##Strong) &&  (actor==player) && (self=actor,true) && ((((Global_Vars-->71) == 1)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1190, 1190);
      ! phrase 1
      ! [1: unless the venture of customercall is success begin]
       if (~~(((GProperty(SCENE_TY, I264_customercall,p80_venture) == I266_success))))  {
         ! phrase 2
         ! [2: say ~'Well, my number is 893. Call me back if you ever gain a civil tongue. '~]
         say__p=1;ParaContent();  print (PrintText) SC_313;  .L_Say124; .L_SayX120;
         ! phrase 3
         ! [3: try hanging up]
          TryAction(0, player, ##A114_hanging_up, 0, 0);; 
         ! phrase 4
         ! [4: now lexicon is table 1 instead]
          (Global_Vars-->72) = T14_customer_responses;  rtrue;
         ! phrase 5
         ! [5: end unless]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1190, 1190, true);
   rfalse;
];
! No specific request
! instead of swearing obscenely or swearing mildly when office phone is inuse:
[ R_1237 ;
   if ((action ==##Mild or ##Strong) &&  (actor==player) && (self=actor,true) && ((((Adj_89_t1_v9(I258_office_phone)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1237, 1237);
      ! phrase 1
      ! [1: if dialyes/no is 0 begin]
       if ((((Global_Vars-->71) == 0)))  {
         ! phrase 2
         ! [2: unless the venture of customercall is success begin]
          if (~~(((GProperty(SCENE_TY, I264_customercall,p80_venture) == I266_success))))  {
            ! phrase 3
            ! [3: say ~'My number is 12586. call me back if you ever gain a civil tongue.' Says Mr. Mason, rather coldly.~]
            say__p=1;ParaContent();  print (PrintText) SC_314;  new_line; .L_Say125; .L_SayX121;
            ! phrase 4
            ! [4: try hanging up]
             TryAction(0, player, ##A114_hanging_up, 0, 0);; 
            ! phrase 5
            ! [5: end unless]
            }

         ! phrase 6
         ! [6: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1237, 1237, true);
   rfalse;
];
! No specific request
! From "Postures" by Emily Short
! Instead of an actor lying down ( this is the convert lying down rule ):
[ R_1046 
    t_0 ! Local variable e.g. 'target' = thing
    t_1 ! Local variable e.g. 'better target' = thing
    ;
   if ((action ==##A118_lying_down) && (act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1046, 1046);
      ! phrase 1
      ! [1: if the actor can lie here begin]
       if (((PHR_1045_r10 (actor))))  {
         ! phrase 2
         ! [2: try the actor taking position reclining]
          TryAction(0, actor, ##A121_taking_position, I117_reclining, 0);; 
         ! phrase 3
         ! [3: if the posture of the actor is reclining begin]
          if (((GProperty(9, actor,p73_posture) == I117_reclining)))  {
            ! phrase 4
            ! [4: rule succeeds]
             RulebookSucceeds(); rtrue; 
            ! phrase 5
            ! [5: end if]
            }

         ! phrase 6
         ! [6: rule fails]
          RulebookFails(); rtrue; 
         ! phrase 7
         ! [7: otherwise if the holder of the actor contains something ( called target ) which allows reclining]
          } else if ((Prop_21(, (HolderOf(actor)) ) && (t_0=deferred_calling_list-->0, true))) { 
         ! phrase 8
         ! [8: if the holder of the actor contains an enterable reclining thing ( called the better target ) begin]
          if ((Prop_22(, (HolderOf(actor)) ) && (t_1=deferred_calling_list-->0, true)))  {
            ! phrase 9
            ! [9: now the target is the better target]
             t_0 = t_1; 
            ! phrase 10
            ! [10: end if]
            }

         ! phrase 11
         ! [11: try the actor lying on the target]
          TryAction(0, actor, ##A116_lying_on, t_0, 0);; 
         ! phrase 12
         ! [12: if the posture of the actor is reclining and the actor is on the target begin]
          if ((((GProperty(9, actor,p73_posture) == I117_reclining))) && (((t_0 == SupporterOf(actor)))))  {
            ! phrase 13
            ! [13: rule succeeds]
             RulebookSucceeds(); rtrue; 
            ! phrase 14
            ! [14: end if]
            }

         ! phrase 15
         ! [15: rule fails]
          RulebookFails(); rtrue; 
         ! phrase 16
         ! [16: otherwise]
         } else {

         ! phrase 17
         ! [17: if the player is the actor begin]
          if (((player == actor)))  {
            ! phrase 18
            ! [18: if the holder of the actor is a thing begin]
             if ((( (HolderOf(actor))  ofclass K2_thing)))  {
               ! phrase 19
               ! [19: say ~You can't lie down on [the holder of the actor].~]
               say__p=1;ParaContent();  print (PrintText) SC_315; ParaContent();  print (the)  (HolderOf(actor)) ; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say126; .L_SayX122;
               ! phrase 20
               ! [20: otherwise]
               } else {

               ! phrase 21
               ! [21: say ~There's nothing to lie on.~]
               say__p=1;ParaContent();  print (PrintText) SC_316;  new_line; .L_Say127; .L_SayX123;
               ! phrase 22
               ! [22: end if]
               }

            ! phrase 23
            ! [23: end if]
            }

         ! phrase 24
         ! [24: rule fails]
          RulebookFails(); rtrue; 
         ! phrase 25
         ! [25: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1046, 1046, true);
   rfalse;
];
! No specific request
! From "Postures" by Emily Short
! Instead of an actor sitting down ( this is the convert sitting down rule ):
[ R_1048 
    t_0 ! Local variable e.g. 'target' = thing
    t_1 ! Local variable e.g. 'better target' = thing
    ;
   if ((action ==##A119_sitting_down) && (act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1048, 1048);
      ! phrase 1
      ! [1: if the actor can sit here begin]
       if (((PHR_1047_r11 (actor))))  {
         ! phrase 2
         ! [2: try the actor taking position seated]
          TryAction(0, actor, ##A121_taking_position, I115_seated, 0);; 
         ! phrase 3
         ! [3: if the posture of the actor is seated begin]
          if (((GProperty(9, actor,p73_posture) == I115_seated)))  {
            ! phrase 4
            ! [4: rule succeeds]
             RulebookSucceeds(); rtrue; 
            ! phrase 5
            ! [5: end if]
            }

         ! phrase 6
         ! [6: rule fails]
          RulebookFails(); rtrue; 
         ! phrase 7
         ! [7: otherwise if the holder of the actor contains something ( called target ) which allows seated]
          } else if ((Prop_23(, (HolderOf(actor)) ) && (t_0=deferred_calling_list-->0, true))) { 
         ! phrase 8
         ! [8: if the holder of the actor contains an enterable seated thing ( called the better target ) begin]
          if ((Prop_24(, (HolderOf(actor)) ) && (t_1=deferred_calling_list-->0, true)))  {
            ! phrase 9
            ! [9: now the target is the better target]
             t_0 = t_1; 
            ! phrase 10
            ! [10: end if]
            }

         ! phrase 11
         ! [11: try the actor sitting on the target]
          TryAction(0, actor, ##A115_sitting_on, t_0, 0);; 
         ! phrase 12
         ! [12: if the posture of the actor is seated and the actor is on the target begin]
          if ((((GProperty(9, actor,p73_posture) == I115_seated))) && (((t_0 == SupporterOf(actor)))))  {
            ! phrase 13
            ! [13: rule succeeds]
             RulebookSucceeds(); rtrue; 
            ! phrase 14
            ! [14: end if]
            }

         ! phrase 15
         ! [15: rule fails]
          RulebookFails(); rtrue; 
         ! phrase 16
         ! [16: otherwise]
         } else {

         ! phrase 17
         ! [17: if the player is the actor begin]
          if (((player == actor)))  {
            ! phrase 18
            ! [18: if the holder of the actor is a thing begin]
             if ((( (HolderOf(actor))  ofclass K2_thing)))  {
               ! phrase 19
               ! [19: say ~You can't sit down on [the holder of the actor].~]
               say__p=1;ParaContent();  print (PrintText) SC_317; ParaContent();  print (the)  (HolderOf(actor)) ; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say128; .L_SayX124;
               ! phrase 20
               ! [20: otherwise]
               } else {

               ! phrase 21
               ! [21: say ~There's nothing to sit on.~]
               say__p=1;ParaContent();  print (PrintText) SC_318;  new_line; .L_Say129; .L_SayX125;
               ! phrase 22
               ! [22: end if]
               }

            ! phrase 23
            ! [23: end if]
            }

         ! phrase 24
         ! [24: rule fails]
          RulebookFails(); rtrue; 
         ! phrase 25
         ! [25: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1048, 1048, true);
   rfalse;
];
! No specific request
! From "Postures" by Emily Short
! Instead of an actor standing up ( this is the convert standing up rule ):
[ R_1049 
    t_0 ! Local variable e.g. '?-1,-1?' = object
    ;
   if ((action ==##A120_standing_up) && (act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1049, 1049);
      ! phrase 1
      ! [1: if the holder of the actor is a thing and the holder of the actor allows standing begin]
       if (((( (HolderOf(actor))  ofclass K2_thing))) && ((((Relation_TestVtoV( (HolderOf(actor)) ,Rel_Record_71,I116_standing,false))))))  {
         ! phrase 2
         ! [2: try the actor taking position standing]
          TryAction(0, actor, ##A121_taking_position, I116_standing, 0);; 
         ! phrase 3
         ! [3: if the posture of the actor is standing begin]
          if (((GProperty(9, actor,p73_posture) == I116_standing)))  {
            ! phrase 4
            ! [4: rule succeeds]
             RulebookSucceeds(); rtrue; 
            ! phrase 5
            ! [5: end if]
            }

         ! phrase 6
         ! [6: rule fails]
          RulebookFails(); rtrue; 
         ! phrase 7
         ! [7: otherwise if the holder of the actor is not the location]
          } else if (((~~(( (HolderOf(actor))  == real_location))))) { 
         ! phrase 8
         ! [8: let the source be the holder of the actor]
          t_0 =  (HolderOf(actor)) ; 
         ! phrase 9
         ! [9: try the actor exiting]
          TryAction(0, actor, ##Exit, 0, 0);; 
         ! phrase 10
         ! [10: if the holder of the actor is the source begin]
          if ((( (HolderOf(actor))  == t_0)))  {
            ! phrase 11
            ! [11: rule fails]
             RulebookFails(); rtrue; 
            ! phrase 12
            ! [12: end if]
            }

         ! phrase 13
         ! [13: rule succeeds]
          RulebookSucceeds(); rtrue; 
         ! phrase 14
         ! [14: otherwise]
         } else {

         ! phrase 15
         ! [15: if the player is the actor begin]
          if (((player == actor)))  {
            ! phrase 16
            ! [16: if the holder of the actor is a thing begin]
             if ((( (HolderOf(actor))  ofclass K2_thing)))  {
               ! phrase 17
               ! [17: say ~You can't lie down on [the holder of the actor].~]
               say__p=1;ParaContent();  print (PrintText) SC_315; ParaContent();  print (the)  (HolderOf(actor)) ; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say130; .L_SayX126;
               ! phrase 18
               ! [18: otherwise]
               } else {

               ! phrase 19
               ! [19: say ~There's nothing to stand on.~]
               say__p=1;ParaContent();  print (PrintText) SC_319;  new_line; .L_Say131; .L_SayX127;
               ! phrase 20
               ! [20: end if]
               }

            ! phrase 21
            ! [21: end if]
            }

         ! phrase 22
         ! [22: rule fails]
          RulebookFails(); rtrue; 
         ! phrase 23
         ! [23: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1049, 1049, true);
   rfalse;
];
! No specific request
! From "Conversation Framework" by Eric Eve
! Instead of implicit-asking:
[ R_956 ;
   if ((action ==##A103_implicit_asking) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_956, 956);
      ! phrase 1
      ! [1: try asking the current interlocutor about it]
       TryAction(0, player, ##Ask, (Global_Vars-->36), 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_956, 956, true);
   rfalse;
];
! No specific request
! From "Conversation Framework" by Eric Eve
! Instead of implicit-telling:
[ R_957 ;
   if ((action ==##A104_implicit_telling) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_957, 957);
      ! phrase 1
      ! [1: try telling the current interlocutor about it]
       TryAction(0, player, ##Tell, (Global_Vars-->36), 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_957, 957, true);
   rfalse;
];
! No specific request
! From "Conversation Framework" by Eric Eve
! Instead of implicit-quizzing:
[ R_958 ;
   if ((action ==##A105_implicit_quizzing) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_958, 958);
      ! phrase 1
      ! [1: try quizzing the current interlocutor about the noun]
       TryAction(0, player, ##A101_quizzing_it_about, (Global_Vars-->36), noun);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_958, 958, true);
   rfalse;
];
! No specific request
! From "Conversation Framework" by Eric Eve
! Instead of implicit-informing:
[ R_959 ;
   if ((action ==##A106_implicit_informing) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_959, 959);
      ! phrase 1
      ! [1: try informing the current interlocutor about the noun]
       TryAction(0, player, ##A102_informing_it_about, (Global_Vars-->36), noun);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_959, 959, true);
   rfalse;
];
! No specific request
! From "Conversation Framework" by Eric Eve
! Instead of implicit-requesting:
[ R_960 ;
   if ((action ==##A107_implicit_requesting) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_960, 960);
      ! phrase 1
      ! [1: try requesting the current interlocutor for the noun]
       TryAction(0, player, ##A99_requesting_it_for, (Global_Vars-->36), noun);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_960, 960, true);
   rfalse;
];
! No specific request
! From "Conversation Framework" by Eric Eve
! Instead of implicit-imploring:
[ R_961 ;
   if ((action ==##A108_implicit_imploring) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_961, 961);
      ! phrase 1
      ! [1: try imploring the current interlocutor for it]
       TryAction(0, player, ##A100_imploring_it_for, (Global_Vars-->36), 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_961, 961, true);
   rfalse;
];
! No specific request
! instead of taking inventory:
[ R_1097 ;
   if ((action ==##Inv) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1097, 1097);
      ! phrase 1
      ! [1: if the player is carrying at least 6 things begin]
       if ((Prop_25()))  {
         ! phrase 2
         ! [2: continue the action]
          rfalse; 
         ! phrase 3
         ! [3: otherwise if the player is wearing at least 6 things]
          } else if ((Prop_26())) { 
         ! phrase 4
         ! [4: continue the action]
          rfalse; 
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: say ~You are carrying [a list of things carried by the player][if the player wears something]. You are wearing [a list of things worn by the player][end if].~ instead]
         say__p=1;ParaContent();  print (PrintText) SC_320; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && (player == CarrierOf(subst__v))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT);
		@pull subst__v; 
	if (~~(((Prop_27())))) jump L_Say132;
		ParaContent();  print (PrintText) SC_321; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && (player == WearerOf(subst__v))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT);
		@pull subst__v; 
	.L_Say132; .L_SayX128;
		ParaContent();  print (PrintText) SC_201;  new_line; rtrue; .L_Say133; .L_SayX129; rtrue;
         ! phrase 7
         ! [7: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1097, 1097, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: After (B24_after)
! ----------------------------------------------------------------------------------------------------
! Rule 1/38 ! after going through bakery door when the location is bakers:
!   >>> III.2.1 - Action/Where/Going In Exotic Ways >>>
! Rule 2/38 ! after going to highway when lily'sbroom is occupied for the first time:
!   >>> III.5.1 - Action/When/Duration >>>
! Rule 3/38 ! after going to Grunnings carpark when the venture of work is success:
!   === which is equally specific with ===
! Rule 4/38 ! after going to Garden when the venture of work is success:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 5/38 ! after taking something from the location when cheats_bin is 0:
!   >>> III.2.4 - Action/Where/Other Optional Clauses >>>
! Rule 6/38 ! After saying hello to petunia when the venture of work is incomplete:
!   === which is equally specific with ===
! Rule 7/38 ! after switching on elevatorbutton when in elevator:
!   === which is equally specific with ===
! Rule 8/38 ! after switching on elevatorbutton when not in elevator:
!   === which is equally specific with ===
! Rule 9/38 ! after going west when bakers is visited:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 10/38 ! after entering bed during living-room cut scene:
!   >>> I - Number of aspects constrained >>>
! Rule 11/38 ! after going to living-room:
!   === which is equally specific with ===
! Rule 12/38 ! after going to Dudley's bedroom:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 13/38 ! after exiting from elevator when the location is Grunnings carpark:
!   >>> III.2.4 - Action/Where/Other Optional Clauses >>>
! Rule 14/38 ! after dialling 893 on the office phone:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 15/38 ! after saying hello to dudley:
!   === which is equally specific with ===
! Rule 16/38 ! after examining ics document:
!   === which is equally specific with ===
! Rule 17/38 ! after saying hello to the customer:
!   === which is equally specific with ===
! Rule 18/38 ! after examining rollerdex:
!   === which is equally specific with ===
! Rule 19/38 ! after saying hello to mr mason:
!   === which is equally specific with ===
! Rule 20/38 ! after examining shop attendant:
!   === which is equally specific with ===
! Rule 21/38 ! after examining foods display case:
!   === which is equally specific with ===
! Rule 22/38 ! after entering car:
!   === which is equally specific with ===
! Rule 23/38 ! after drinking vernon's cup:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 24/38 ! after taking a noun:
!   === which is equally specific with ===
! Rule 25/38 ! After teleporting to a noun:
!   === which is equally specific with ===
! Rule 26/38 ! after teleporting to a noun:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 27/38 ! after opening stairs:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 28/38 ! After opening a door:
!   === which is equally specific with ===
! Rule 29/38 ! after opening a door:
!   === which is equally specific with ===
! Rule 30/38 ! after taking a wizard coin ( called T ):
!   === which is equally specific with ===
! Rule 31/38 ! after mounting broom:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 32/38 ! after taking a thing:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 33/38 ! After looking when the player reaches someone ( this is the look while on the line rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 34/38 ! after exiting from work office:
!   >>> III.2.4 - Action/Where/Other Optional Clauses >>>
! Rule 35/38 ! after putting under:
!   === which is equally specific with ===
! Rule 36/38 ! after changing player:
!   === which is equally specific with ===
! Rule 37/38 ! after dismounting:
!   === which is equally specific with ===
! Rule 38/38 ! after moving to:
! ----------------------------------------------------------------------------------------------------
! No specific request
! after going through bakery door when the location is bakers:
[ R_1251 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,2)) == I286_bakery_door) && (true)) && ((MStack-->MstVON(20007,1)) ~= nothing) && (self=actor,true) && (((real_location == I287_bakers)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1251, 1251);
      ! phrase 1
      ! [1: say ~'Good morning! How may i help you, sir?' asks the shop attendant.[if the player is on a broom]Wait, How are you flying that?~]
      say__p=1;ParaContent();  print (PrintText) SC_322;  new_line;
	if (~~((((SupporterOf(player) ofclass K40_broom))))) jump L_Say134;
		ParaContent();  print (PrintText) SC_323;  new_line; .L_Say134; .L_SayX130;
      ! phrase 2
      ! [2: unless shop attendant is the current interlocutor begin]
       if (~~(((I288_shop_attendant == (Global_Vars-->36)))))  {
         ! phrase 3
         ! [3: try silently saying hello to shop attendant]
          @push keep_silent; keep_silent=1; TryAction(0, player, ##A109_saying_hello_to, I288_shop_attendant, 0);; @pull keep_silent; 
         ! phrase 4
         ! [4: end unless]
         }

      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1251, 1251, true);
   rfalse;
];
! No specific request
! after going to highway when lily'sbroom is occupied for the first time:
[ R_1167 ;
   if ((PAPR_5() && (((TimesActionHasHappened-->5) == 1) && (ActionCurrentlyHappeningFlag->5)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1167, 1167);
      ! phrase 1
      ! [1: say ~As you fly out to the highway, you notice a tabby cat out of the corner of your eye. you also notice that the cat looks like it is reading a map. you look round again, but the map has gone. as you drive round the corner of the road, you notice the cat reading the sign - no, looking at the sign; cats can't read maps or signs. The people on the street seem to be looking at you rather strangely.~]
      say__p=1;ParaContent();  print (PrintText) SC_324;  new_line; .L_Say135; .L_SayX131;
      ! phrase 2
      ! [2: continue the action]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1167, 1167, true);
   rfalse;
];
! No specific request
! after going to Grunnings carpark when the venture of work is success:
[ R_1274 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,1)) == I244_grunnings_carpark) && (true)) && (self=actor,true) && (((GProperty(SCENE_TY, I238_work,p80_venture) == I266_success)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1274, 1274);
      ! phrase 1
      ! [1: if bumpedinto is 0 begin]
       if ((((Global_Vars-->79) == 0)))  {
         ! phrase 2
         ! [2: say ~As you're a bit distracted, you don't see where you are going, and you bump into someone. [line break]'Sorry', you say gruffly, before realising that this small man is wearing a violet cloak.[paragraph break]~]
         say__p=1;ParaContent();  print (PrintText) SC_325; ParaContent();  new_line; ParaContent();  print (PrintText) SC_326; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say136; .L_SayX132;
         ! phrase 3
         ! [3: if glulx timekeeping is supported begin]
          if (( ( glk_gestalt(gestalt_Timer, 0) ) ))  {
            ! phrase 4
            ! [4: wait 4000 ms before continuing]
            (PHR_1016_r6 (4000));
            ! phrase 5
            ! [5: end if]
            }

         ! phrase 6
         ! [6: say ~'[no line break]Don't be sorry, my dear sir, for nothing could upset me today![line break]Rejoice, for You-Know-Who has gone at last![line break]Even Muggles such as yourself should be celebrating, this happy, happy day!'[paragraph break][no line break]~]
         say__p=1;ParaContent();  print (PrintText) SC_327; ParaContent(); (PHR_335_r7 ());ParaContent();  print (PrintText) SC_328; ParaContent();  new_line; ParaContent();  print (PrintText) SC_329; ParaContent();  new_line; ParaContent();  print (PrintText) SC_330; ParaContent();  DivideParagraphPoint(); new_line; ParaContent(); (PHR_335_r7 ()); .L_Say137; .L_SayX133;
         ! phrase 7
         ! [7: now bumpedinto is 1]
          (Global_Vars-->79) = 1; 
         ! phrase 8
         ! [8: end if]
         }

      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1274, 1274, true);
   rfalse;
];
! No specific request
! after going to Garden when the venture of work is success:
[ R_1279 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,1)) == I200_garden) && (true)) && (self=actor,true) && (((GProperty(SCENE_TY, I238_work,p80_venture) == I266_success)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1279, 1279);
      ! phrase 1
      ! [1: now the description of garden is ~You notice the cat from this morning sitting on the garden wall. Despite your attempts to shoo it away, it is still sitting there, looking sternly at you.~]
       WriteGProperty(9, I200_garden,description,SC_331); 
      ! phrase 2
      ! [2: continue the action]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1279, 1279, true);
   rfalse;
];
! No specific request
! after taking something from the location when cheats_bin is 0:
[ R_769 ;
   if ((action ==##Take) &&  (actor==player) && ((noun ofclass K2_thing)) && (((MStack-->MstVON(20001,0)) == real_location) && (true)) && (self=actor,true) && ((((Global_Vars-->25) == 0)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_769, 769);
      ! phrase 1
      ! [1: unless the thing is underlying something begin]
       if (~~((Prop_28())))  {
         ! phrase 2
         ! [2: say ~You pick up [the noun] from the ground.~]
         say__p=1;ParaContent();  print (PrintText) SC_332; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_333;  new_line; .L_Say138; .L_SayX134;
         ! phrase 3
         ! [3: now already reported taking is 1]
          (Global_Vars-->16) = 1; 
         ! phrase 4
         ! [4: continue the action]
          rfalse; 
         ! phrase 5
         ! [5: otherwise if the noun is underlying nothing]
          } else if ((Prop_29())) { 
         ! phrase 6
         ! [6: say ~You pick up [the noun] from the ground.~]
         say__p=1;ParaContent();  print (PrintText) SC_332; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_333;  new_line; .L_Say139; .L_SayX135;
         ! phrase 7
         ! [7: now already reported taking is 1]
          (Global_Vars-->16) = 1; 
         ! phrase 8
         ! [8: continue the action]
          rfalse; 
         ! phrase 9
         ! [9: otherwise if the noun is underlying something]
          } else if ((((noun.p59_underlying) ofclass K2_thing))) { 
         ! phrase 10
         ! [10: say ~You take [the noun] from under [list of things that are overlaying the noun].~]
         say__p=1;ParaContent();  print (PrintText) SC_334; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_335; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && ((noun.p59_underlying) == subst__v)))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT+NOARTICLE_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say140; .L_SayX136;
         ! phrase 11
         ! [11: now already reported taking is 1]
          (Global_Vars-->16) = 1; 
         ! phrase 12
         ! [12: continue the action]
          rfalse; 
         ! phrase 13
         ! [13: end unless]
         }

      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_769, 769, true);
   rfalse;
];
! No specific request
! After saying hello to petunia when the venture of work is incomplete:
[ R_1123 ;
   if ((action ==##A109_saying_hello_to) &&  (actor==player) && ((noun == I202_petunia) && (true)) && (self=actor,true) && (((GProperty(SCENE_TY, I238_work,p80_venture) == I268_incomplete)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1123, 1123);
      ! phrase 1
      ! [1: if the description of petunia is not ~Your lovely wife Petunia.~ begin]
       if (((~~((GProperty(9, I202_petunia,description) == SC_336)))))  {
         ! phrase 2
         ! [2: now the description of petunia is ~Your lovely wife Petunia.~]
          WriteGProperty(9, I202_petunia,description,SC_336); 
         ! phrase 3
         ! [3: say ~[if broom is occupied]'What on earth... How are you flying that?'[otherwise]'Good morning. How did you sleep?' Asks Petunia.[paragraph break]'Since there[']s Cereal all over the place, can you go get the broom and clean it up?'[no line break]~]
         say__p=1;
	if (~~(((Prop_30())))) jump L_Say141;
		ParaContent();  print (PrintText) SC_337;  new_line;
	jump L_SayX137; .L_Say141;
		ParaContent();  print (PrintText) SC_338; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_339; ParaContent();  print "'"; ParaContent();  print (PrintText) SC_340; ParaContent(); (PHR_335_r7 ()); .L_Say142; .L_SayX137;
         ! phrase 4
         ! [4: rule succeeds]
          RulebookSucceeds(); rtrue; 
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: say ~'Good morning' Says Petunia.[if broom is occupied] 'Why are you doing... (Petunia looks around nervously) Magic, in our house?'~]
         say__p=1;ParaContent();  print (PrintText) SC_341;  new_line;
	if (~~(((Prop_31())))) jump L_Say143;
		ParaContent();  print (PrintText) SC_342;  new_line; .L_Say143; .L_SayX138;
         ! phrase 7
         ! [7: rule succeeds]
          RulebookSucceeds(); rtrue; 
         ! phrase 8
         ! [8: end if]
         }

      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1123, 1123, true);
   rfalse;
];
! No specific request
! after switching on elevatorbutton when in elevator:
[ R_1176 ;
   if ((action ==##SwitchOn) &&  (actor==player) && ((noun == I250_elevatorbutton) && (true)) && (self=actor,true) && (( (WhetherIn(I249_elevator)) ))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1176, 1176);
      ! phrase 1
      ! [1: unless the location is corridor begin]
       if (~~(((real_location == I252_corridor))))  {
         ! phrase 2
         ! [2: say ~You go up the elevator. when you look out of the elevator, you see there are offices to either side of you.~]
         say__p=1;ParaContent();  print (PrintText) SC_343;  new_line; .L_Say144; .L_SayX139;
         ! phrase 3
         ! [3: now elevator is in corridor]
          MoveObject(I249_elevator,I252_corridor); 
         ! phrase 4
         ! [4: now player is in elevator]
          MoveObject(player,I249_elevator); 
         ! phrase 5
         ! [5: otherwise if player is in elevator]
          } else if (((I249_elevator == ContainerOf(player)))) { 
         ! phrase 6
         ! [6: say ~You go down the elevator, back to the carpark.~]
         say__p=1;ParaContent();  print (PrintText) SC_344;  new_line; .L_Say145; .L_SayX140;
         ! phrase 7
         ! [7: now elevator is in carpark]
          MoveObject(I249_elevator,I244_grunnings_carpark); 
         ! phrase 8
         ! [8: now player is in elevator]
          MoveObject(player,I249_elevator); 
         ! phrase 9
         ! [9: otherwise]
         } else {

         ! phrase 10
         ! [10: continue the action]
          rfalse; 
         ! phrase 11
         ! [11: end unless]
         }

      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1176, 1176, true);
   rfalse;
];
! No specific request
! after switching on elevatorbutton when not in elevator:
[ R_1177 ;
   if ((action ==##SwitchOn) &&  (actor==player) && ((noun == I250_elevatorbutton) && (true)) && (self=actor,true) && (~~(( (WhetherIn(I249_elevator)) )))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1177, 1177);
      ! phrase 1
      ! [1: say ~Since you pressed the button without getting in, you have to wait for the elevator to come back to the [location].~]
      say__p=1;ParaContent();  print (PrintText) SC_345; ParaContent();  print (PrintShortName) real_location; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say146; .L_SayX141;
      ! phrase 2
      ! [2: if glulx timekeeping is supported begin]
       if (( ( glk_gestalt(gestalt_Timer, 0) ) ))  {
         ! phrase 3
         ! [3: wait 5000 milliseconds before continuing , strictly]
         (PHR_1016_r6 (5000,1));
         ! phrase 4
         ! [4: end if]
         }

      ! phrase 5
      ! [5: say ~The elevator comes back to the [location] with a soft pinging noise.~]
      say__p=1;ParaContent();  print (PrintText) SC_346; ParaContent();  print (PrintShortName) real_location; ParaContent();  print (PrintText) SC_347;  new_line; .L_Say147; .L_SayX142;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1177, 1177, true);
   rfalse;
];
! No specific request
! after going west when bakers is visited:
[ R_1269 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I53_west) && (true)) && (self=actor,true) && ((((Adj_44_t1_v9(I287_bakers)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1269, 1269);
      ! phrase 1
      ! [1: say ~As you stroll out of the shop, you notice another group of robed people standing further down the road. I wonder what they could be talking about?~]
      say__p=1;ParaContent();  print (PrintText) SC_348;  new_line; .L_Say148; .L_SayX143;
      ! phrase 2
      ! [2: continue the action]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1269, 1269, true);
   rfalse;
];
! No specific request
! after entering bed during living-room cut scene:
[ R_1316 ;
   if (scene_status-->5 == 1) { ! Runs only during scene
   if ((action ==##Enter) &&  (actor==player) && ((noun == I120_bed) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1316, 1316);
      ! phrase 1
      ! [1: say ~As you climb into bed, you hear slight mutterings from outside, and the sound of a motorbike.[run paragraph on]~]
      say__p=1;ParaContent();  print (PrintText) SC_349; ParaContent();  RunParagraphOn();  .L_Say149; .L_SayX144;
      ! phrase 2
      ! [2: now the venture of living-room cut scene is success]
       WriteGProperty(SCENE_TY, I328_living_room_cut_scene,p80_venture,I266_success); 
      ! phrase 3
      ! [3: now the venture of uncle vernon's scene is success]
       WriteGProperty(SCENE_TY, I92_uncle_vernon_s_scene,p80_venture,I266_success); 
      ! phrase 4
      ! [4: if glulx timekeeping is supported begin]
       if (( ( glk_gestalt(gestalt_Timer, 0) ) ))  {
         ! phrase 5
         ! [5: wait 2000 ms before continuing]
         (PHR_1016_r6 (2000));
         ! phrase 6
         ! [6: end if]
         }

      ! phrase 7
      ! [7: end the story finally saying ~This is the end of chapter 1~]
       deadflag=SC_350; story_complete=true; 
      RulebookSucceeds(); rtrue;
   } ! Runs only during scene
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1316, 1316, true);
   rfalse;
];
! No specific request
! after going to living-room:
[ R_1289 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,1)) == I304_living_room) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1289, 1289);
      ! phrase 1
      ! [1: now television is switched off]
       (Adj_76_t2_v9(I324_television)); 
      ! phrase 2
      ! [2: continue the action]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1289, 1289, true);
   rfalse;
];
! No specific request
! after going to Dudley's bedroom:
[ R_1323 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,1)) == I329_dudley_s_bedroom) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1323, 1323);
      ! phrase 1
      ! [1: set pronouns from dudley's drawers]
       PronounNotice(I333_dudley_s_drawers); 
      ! phrase 2
      ! [2: try silently putting a magic wand under cot]
       @push keep_silent; keep_silent=1; TryAction(0, player, ##A80_putting_it_under, I342_magic_wand, I331_cot);; @pull keep_silent; 
      ! phrase 3
      ! [3: now overlay is cot]
       (Global_Vars-->15) = I331_cot; 
      ! phrase 4
      ! [4: continue the action]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1323, 1323, true);
   rfalse;
];
! No specific request
! after exiting from elevator when the location is Grunnings carpark:
[ R_1275 ;
   if ((action ==##Exit) &&  (actor==player) && (((MStack-->MstVON(20009,0)) == I249_elevator) && (true)) && (self=actor,true) && (((real_location == I244_grunnings_carpark)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1275, 1275);
      ! phrase 1
      ! [1: if bumpedinto is 0 begin]
       if ((((Global_Vars-->79) == 0)))  {
         ! phrase 2
         ! [2: if the venture of work is success begin]
          if (((GProperty(SCENE_TY, I238_work,p80_venture) == I266_success)))  {
            ! phrase 3
            ! [3: say ~As you're a bit distracted, you don't see where you are going, and you bump into someone. [line break]'Sorry', you say gruffly, before realising that this small man is wearing a violet cloak.[paragraph break]~]
            say__p=1;ParaContent();  print (PrintText) SC_325; ParaContent();  new_line; ParaContent();  print (PrintText) SC_326; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say150; .L_SayX145;
            ! phrase 4
            ! [4: if glulx timekeeping is supported begin]
             if (( ( glk_gestalt(gestalt_Timer, 0) ) ))  {
               ! phrase 5
               ! [5: wait 4000 ms before continuing]
               (PHR_1016_r6 (4000));
               ! phrase 6
               ! [6: end if]
               }

            ! phrase 7
            ! [7: say ~'[no line break]Don't be sorry, my dear sir, for nothing could upset me today![line break]Rejoice, for You-Know-Who has gone at last![line break]Even Muggles such as yourself should be celebrating, this happy, happy day!'[paragraph break][no line break]~]
            say__p=1;ParaContent();  print (PrintText) SC_327; ParaContent(); (PHR_335_r7 ());ParaContent();  print (PrintText) SC_328; ParaContent();  new_line; ParaContent();  print (PrintText) SC_329; ParaContent();  new_line; ParaContent();  print (PrintText) SC_330; ParaContent();  DivideParagraphPoint(); new_line; ParaContent(); (PHR_335_r7 ()); .L_Say151; .L_SayX146;
            ! phrase 8
            ! [8: now bumpedinto is 1]
             (Global_Vars-->79) = 1; 
            ! phrase 9
            ! [9: end if]
            }

         ! phrase 10
         ! [10: end if]
         }

      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1275, 1275, true);
   rfalse;
];
! No specific request
! after dialling 893 on the office phone:
[ R_1191 ;
   if ((action ==##A113_dialling_it_on) &&  (actor==player) && ((parsed_number == 893) && (true)) && ((second == I258_office_phone) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1191, 1191);
      ! phrase 1
      ! [1: now dialyes/no is 1]
       (Global_Vars-->71) = 1; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1191, 1191, true);
   rfalse;
];
! No specific request
! after saying hello to dudley:
[ R_1124 ;
   if ((action ==##A109_saying_hello_to) &&  (actor==player) && ((noun == I221_dudley) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1124, 1124);
      ! phrase 1
      ! [1: say ~You say hello to Dudley.[line break]'Shan't! Shan't!' Says Dudley.~ instead]
      say__p=1;ParaContent();  print (PrintText) SC_351; ParaContent();  new_line; ParaContent();  print (PrintText) SC_352;  new_line; rtrue; .L_Say152; .L_SayX147; rtrue;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1124, 1124, true);
   rfalse;
];
! No specific request
! after examining ics document:
[ R_1220 ;
   if ((action ==##Examine) &&  (actor==player) && ((noun == I263_ics_document) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1220, 1220);
      ! phrase 1
      ! [1: unless office phone is inuse begin]
       if (~~((((Adj_89_t1_v9(I258_office_phone))))))  {
         ! phrase 2
         ! [2: if the venture of customercall is incomplete begin]
          if (((GProperty(SCENE_TY, I264_customercall,p80_venture) == I268_incomplete)))  {
            ! phrase 3
            ! [3: if glulx timekeeping is supported begin]
             if (( ( glk_gestalt(gestalt_Timer, 0) ) ))  {
               ! phrase 4
               ! [4: wait 2000 ms before continuing]
               (PHR_1016_r6 (2000));
               ! phrase 5
               ! [5: end if]
               }

            ! phrase 6
            ! [6: say ~As you go about looking at the document, the phone rings. How convenient.[line break]You pick up the phone.[paragraph break]Hello? Says the voice on the other end of the line. ~]
            say__p=1;ParaContent();  print (PrintText) SC_353; ParaContent();  new_line; ParaContent();  print (PrintText) SC_354; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_355;  .L_Say153; .L_SayX148;
            ! phrase 7
            ! [7: now dialyes/no is 1]
             (Global_Vars-->71) = 1; 
            ! phrase 8
            ! [8: now bored is 0]
             (Global_Vars-->70) = 0; 
            ! phrase 9
            ! [9: now office phone is inuse]
             (Adj_89_t2_v9(I258_office_phone)); 
            ! phrase 10
            ! [10: try dialling 893 on the office phone]
             TryAction(0, player, ##A113_dialling_it_on, 893, I258_office_phone);; 
            ! phrase 11
            ! [11: end if]
            }

         ! phrase 12
         ! [12: end unless]
         }

      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1220, 1220, true);
   rfalse;
];
! No specific request
! after saying hello to the customer:
[ R_1221 ;
   if ((action ==##A109_saying_hello_to) &&  (actor==player) && ((noun == I259_customer) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1221, 1221);
      ! phrase 1
      ! [1: now bored is 0]
       (Global_Vars-->70) = 0; 
      ! phrase 2
      ! [2: say ~'Hello. How are you?'~]
      say__p=1;ParaContent();  print (PrintText) SC_356;  new_line; .L_Say154; .L_SayX149;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1221, 1221, true);
   rfalse;
];
! No specific request
! after examining rollerdex:
[ R_1228 ;
   if ((action ==##Examine) &&  (actor==player) && ((noun == I273_rollerdex) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1228, 1228);
      ! phrase 1
      ! [1: if the venture of mrmason call is incomplete begin]
       if (((GProperty(SCENE_TY, I276_mrmason_call,p80_venture) == I268_incomplete)))  {
         ! phrase 2
         ! [2: unless the phone is inuse begin]
          if (~~((((Adj_89_t1_v9(I258_office_phone))))))  {
            ! phrase 3
            ! [3: say ~After reading the rolodex, you look out the window to see an owl perched on the windowsill. How strange.[paragraph break]~]
            say__p=1;ParaContent();  print (PrintText) SC_357; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say155; .L_SayX150;
            ! phrase 4
            ! [4: if glulx timekeeping is supported begin]
             if (( ( glk_gestalt(gestalt_Timer, 0) ) ))  {
               ! phrase 5
               ! [5: wait 2000 ms before continuing]
               (PHR_1016_r6 (2000));
               ! phrase 6
               ! [6: end if]
               }

            ! phrase 7
            ! [7: now bored is 0]
             (Global_Vars-->70) = 0; 
            ! phrase 8
            ! [8: say ~The phone rings[if dialyes/no has been 1] again[end if].~]
            say__p=1;ParaContent();  print (PrintText) SC_358; 
	if (~~((TestSinglePastState(0, 6, false, 5)))) jump L_Say156;
		ParaContent();  print (PrintText) SC_359; 
	.L_Say156; .L_SayX151;
		ParaContent();  print (PrintText) SC_201;  new_line; .L_Say157; .L_SayX152;
            ! phrase 9
            ! [9: try dialling 12856 on office phone]
             TryAction(0, player, ##A113_dialling_it_on, 12856, I258_office_phone);; 
            ! phrase 10
            ! [10: end unless]
            }

         ! phrase 11
         ! [11: end if]
         }

      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1228, 1228, true);
   rfalse;
];
! No specific request
! after saying hello to mr mason:
[ R_1229 ;
   if ((action ==##A109_saying_hello_to) &&  (actor==player) && ((noun == I277_mr_mason) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1229, 1229);
      ! phrase 1
      ! [1: say ~'Hello Dursley. This is Mr. Mason.'[paragraph break]~]
      say__p=1;ParaContent();  print (PrintText) SC_360; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say158; .L_SayX153;
      ! phrase 2
      ! [2: if glulx timekeeping is supported begin]
       if (( ( glk_gestalt(gestalt_Timer, 0) ) ))  {
         ! phrase 3
         ! [3: wait 2000 milliseconds before continuing]
         (PHR_1016_r6 (2000));
         ! phrase 4
         ! [4: end if]
         }

      ! phrase 5
      ! [5: say ~'Can I order another 50 drills? the last ones where excellent.'~]
      say__p=1;ParaContent();  print (PrintText) SC_361;  new_line; .L_Say159; .L_SayX154;
      ! phrase 6
      ! [6: now bored is 0]
       (Global_Vars-->70) = 0; 
      ! phrase 7
      ! [7: now the lexicon is table 2]
       (Global_Vars-->72) = T15_customer_responses_2; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1229, 1229, true);
   rfalse;
];
! No specific request
! after examining shop attendant:
[ R_1252 ;
   if ((action ==##Examine) &&  (actor==player) && ((noun == I288_shop_attendant) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1252, 1252);
      ! phrase 1
      ! [1: now the printed name is ~Mr. Finnigan~]
       WriteGProperty(OBJECT_TY, self,short_name,SC_362); 
      ! phrase 2
      ! [2: now shop attendant is proper-named]
       (Adj_38_t2_v9(I288_shop_attendant)); 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1252, 1252, true);
   rfalse;
];
! No specific request
! after examining foods display case:
[ R_1253 ;
   if ((action ==##Examine) &&  (actor==player) && ((noun == I291_foods_display_case) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1253, 1253);
      ! phrase 1
      ! [1: stop the action]
       rtrue; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1253, 1253, true);
   rfalse;
];
! No specific request
! after entering car:
[ R_1278 ;
   if ((action ==##Enter) &&  (actor==player) && ((noun == I233_car) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1278, 1278);
      ! phrase 1
      ! [1: if the location is grunnings carpark begin]
       if (((real_location == I244_grunnings_carpark)))  {
         ! phrase 2
         ! [2: if the venture of work is success begin]
          if (((GProperty(SCENE_TY, I238_work,p80_venture) == I266_success)))  {
            ! phrase 3
            ! [3: say ~As you get into the car, you hope that the events of today were all in your imagination, even though imagination is something which you do not approve of.~]
            say__p=1;ParaContent();  print (PrintText) SC_363;  new_line; .L_Say160; .L_SayX155;
            ! phrase 4
            ! [4: otherwise]
            } else {

            ! phrase 5
            ! [5: continue the action]
             rfalse; 
            ! phrase 6
            ! [6: end if]
            }

         ! phrase 7
         ! [7: otherwise]
         } else {

         ! phrase 8
         ! [8: continue the action]
          rfalse; 
         ! phrase 9
         ! [9: end if]
         }

      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1278, 1278, true);
   rfalse;
];
! No specific request
! after drinking vernon's cup:
[ R_1313 ;
   if ((action ==##Drink) &&  (actor==player) && ((noun == I326_vernon_s_cup) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1313, 1313);
      ! phrase 1
      ! [1: say ~You gulp down some [noun].~]
      say__p=1;ParaContent();  print (PrintText) SC_364; ParaContent();  print (PrintShortName) noun; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say161; .L_SayX156;
      ! phrase 2
      ! [2: say ~[one of]'Er - Petunia, dear - you haven't heard from your sister lately, have you?'[paragraph break]'No. Why?' Says Petunia, rather sharply.[or]'Er - Petunia, dear - you haven't heard from your sister lately, have you?'[paragraph break]'No. Why?' Says Petunia, rather sharply.[or]'No, and will you please not mention her unless you have to?' says Petunia.[stopping][line break][run paragraph on]~]
      say__p=1;ParaContent();  I7_ST_say_one_of-->3 =
	i7_soo_stop(I7_ST_say_one_of-->3, 3);
	switch((I7_ST_say_one_of-->3)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_365; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_366;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_365; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_366;  new_line;ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_367;  new_line;ParaContent();  } ParaContent();  new_line; ParaContent();  RunParagraphOn();  .L_Say162; .L_SayX157;
      ! phrase 3
      ! [3: now the venture of living-room cut scene is half-complete]
       WriteGProperty(SCENE_TY, I328_living_room_cut_scene,p80_venture,I270_half_complete); 
      ! phrase 4
      ! [4: continue the action]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1313, 1313, true);
   rfalse;
];
! No specific request
! after taking a noun:
[ R_751 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == noun) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_751, 751);
      ! phrase 1
      ! [1: now the noun is not underlying anything]
       Prop_32(); 
      ! phrase 2
      ! [2: continue the action]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_751, 751, true);
   rfalse;
];
! No specific request
! From "Cheats" by Orion Zymaris
! After teleporting to a noun:
[ R_903 ;
   if ((action ==##A89_teleporting_to) &&  (actor==player) && ((noun == noun) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_903, 903);
      ! phrase 1
      ! [1: move the player to the noun , without printing a room description]
       MoveObject(player, noun, 1, false); 
      ! phrase 2
      ! [2: say ~You appear in [the player's surroundings][no line break].~]
      say__p=1;ParaContent();  print (PrintText) SC_368; ParaContent();  SL_Location(); ParaContent(); (PHR_335_r7 ());ParaContent();  print (PrintText) SC_201;  new_line; .L_Say163; .L_SayX158;
      ! phrase 3
      ! [3: continue the action]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_903, 903, true);
   rfalse;
];
! No specific request
! after teleporting to a noun:
[ R_1194 ;
   if ((action ==##A89_teleporting_to) &&  (actor==player) && ((noun == noun) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1194, 1194);
      ! phrase 1
      ! [1: unless the noun is work office begin]
       if (~~(((noun == I254_work_office))))  {
         ! phrase 2
         ! [2: unless dialyes/no is 0 begin]
          if (~~((((Global_Vars-->71) == 0))))  {
            ! phrase 3
            ! [3: now dialyes/no is 0]
             (Global_Vars-->71) = 0; 
            ! phrase 4
            ! [4: try silently hanging up]
             @push keep_silent; keep_silent=1; TryAction(0, player, ##A114_hanging_up, 0, 0);; @pull keep_silent; 
            ! phrase 5
            ! [5: end unless]
            }

         ! phrase 6
         ! [6: end unless]
         }

      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1194, 1194, true);
   rfalse;
];
! No specific request
! after opening stairs:
[ R_1105 ;
   if ((action ==##Open) &&  (actor==player) && ((noun ofclass K35_stairs))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1105, 1105);
      ! phrase 1
      ! [1: say ~You pull on the panel, lowering a set of stairs to the ground that lead to the roof.~]
      say__p=1;ParaContent();  print (PrintText) SC_369;  new_line; .L_Say164; .L_SayX159;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1105, 1105, true);
   rfalse;
];
! No specific request
! From "Door Directions" by Orion Zymaris
! After opening a door:
[ R_896 ;
   if ((action ==##Open) &&  (actor==player) && ((noun ofclass K4_door))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_896, 896);
      ! phrase 1
      ! [1: increment ixnay]
       (Global_Vars-->24) = (Global_Vars-->24) + 1; 
      ! phrase 2
      ! [2: continue the action]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_896, 896, true);
   rfalse;
];
! No specific request
! From "Door Directions" by Orion Zymaris
! after opening a door:
[ R_897 ;
   if ((action ==##Open) &&  (actor==player) && ((noun ofclass K4_door))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_897, 897);
      ! phrase 1
      ! [1: now the openyesno of the noun is 1]
       WriteGProperty(OBJECT_TY, noun,p13_openyesno,1); 
      ! phrase 2
      ! [2: continue the action]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_897, 897, true);
   rfalse;
];
! No specific request
! From "Wizard Money" by Orion Zymaris
! after taking a wizard coin ( called T ):
[ R_933 
    t_0 ! Local variable e.g. 'T' = wizard coin
    ;
   if ((action ==##Take) &&  (actor==player) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K23_wizard_coin))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_933, 933);
      ! phrase 1
      ! [1: increase the cost of the player by the cost of t]
       WriteGProperty(9, player,p66_cost,GProperty(9, player,p66_cost) + GProperty(9, t_0,p66_cost)); 
      ! phrase 2
      ! [2: continue the action]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_933, 933, true);
   rfalse;
];
! No specific request
! after mounting broom:
[ R_1108 ;
   if ((action ==##A84_mounting) &&  (actor==player) && ((noun ofclass K40_broom))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1108, 1108);
      ! phrase 1
      ! [1: now the noun is occupied]
       (Adj_34_t2_v9(noun)); 
      ! phrase 2
      ! [2: continue the action]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1108, 1108, true);
   rfalse;
];
! No specific request
! after taking a thing:
[ R_749 ;
   if ((action ==##Take) &&  (actor==player) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_749, 749);
      ! phrase 1
      ! [1: if the noun is undescribed begin]
       if ((((Adj_57_t1_v9(noun)))))  {
         ! phrase 2
         ! [2: now the noun is described]
          (Adj_56_t2_v9(noun)); 
         ! phrase 3
         ! [3: continue the action]
          rfalse; 
         ! phrase 4
         ! [4: otherwise]
         } else {

         ! phrase 5
         ! [5: continue the action]
          rfalse; 
         ! phrase 6
         ! [6: end if]
         }

      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_749, 749, true);
   rfalse;
];
! No specific request
! From "Telephones" by George Tryfonas
! After looking when the player reaches someone ( this is the look while on the line rule ):
[ R_1040 ;
   if ((action ==##Look) &&  (actor==player) && (self=actor,true) && ((Prop_33()))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1040, 1040);
      ! phrase 1
      ! [1: try listening to the other party of the player]
       TryAction(0, player, ##Listen, GProperty(9, player,p72_other_party), 0);; 
      ! phrase 2
      ! [2: continue the action]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1040, 1040, true);
   rfalse;
];
! No specific request
! after exiting from work office:
[ R_1193 ;
   if ((action ==##Exit) &&  (actor==player) && (((MStack-->MstVON(20009,0)) == I254_work_office) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1193, 1193);
      ! phrase 1
      ! [1: unless dialyes/no is 0 begin]
       if (~~((((Global_Vars-->71) == 0))))  {
         ! phrase 2
         ! [2: now dialyes/no is 0]
          (Global_Vars-->71) = 0; 
         ! phrase 3
         ! [3: try saying goodbye to]
          TryAction(0, player, ##A112_saying_goodbye_to, 0, 0);; 
         ! phrase 4
         ! [4: try hanging up]
          TryAction(0, player, ##A114_hanging_up, 0, 0);; 
         ! phrase 5
         ! [5: end unless]
         }

      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1193, 1193, true);
   rfalse;
];
! No specific request
! after putting under:
[ R_747 ;
   if ((action ==##A80_putting_it_under) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_747, 747);
      ! phrase 1
      ! [1: now the noun is in location]
       MoveObject(noun,real_location); 
      ! phrase 2
      ! [2: now the noun is undescribed]
       (Adj_57_t2_v9(noun)); 
      ! phrase 3
      ! [3: continue the action]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_747, 747, true);
   rfalse;
];
! No specific request
! From "Cheats" by Orion Zymaris
! after changing player:
[ R_927 ;
   if ((action ==##A93_changing_player) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_927, 927);
      ! phrase 1
      ! [1: say ~You are now [a noun].~]
      say__p=1;ParaContent();  print (PrintText) SC_370; ParaContent();  print (a) noun; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say165; .L_SayX160;
      ! phrase 2
      ! [2: continue the action]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_927, 927, true);
   rfalse;
];
! No specific request
! after dismounting:
[ R_1109 ;
   if ((action ==##A85_dismounting) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1109, 1109);
      ! phrase 1
      ! [1: now the noun is not occupied]
       (Adj_34_t3_v9(noun)); 
      ! phrase 2
      ! [2: continue the action]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1109, 1109, true);
   rfalse;
];
! No specific request
! after moving to:
[ R_1195 ;
   if ((action ==##A90_moving_to) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1195, 1195);
      ! phrase 1
      ! [1: unless the second noun is work office begin]
       if (~~(((second == I254_work_office))))  {
         ! phrase 2
         ! [2: unless the second noun is in work office begin]
          if (~~(((I254_work_office == ContainerOf(second)))))  {
            ! phrase 3
            ! [3: unless dialyes/no is 0 begin]
             if (~~((((Global_Vars-->71) == 0))))  {
               ! phrase 4
               ! [4: now dialyes/no is 0]
                (Global_Vars-->71) = 0; 
               ! phrase 5
               ! [5: try silently hanging up]
                @push keep_silent; keep_silent=1; TryAction(0, player, ##A114_hanging_up, 0, 0);; @pull keep_silent; 
               ! phrase 6
               ! [6: end unless]
               }

            ! phrase 7
            ! [7: end unless]
            }

         ! phrase 8
         ! [8: end unless]
         }

      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1195, 1195, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: does the player mean (B26_does_the_player_mean)
! ----------------------------------------------------------------------------------------------------
! Rule 1/13 ! Does the player mean asking someone to try sitting on something when the posture of the noun is seated ( this is the prefer request sitting on seating objects rule ):
!   === which is equally specific with ===
! Rule 2/13 ! Does the player mean asking someone to try standing up on something when the posture of the noun is standing ( this is the prefer request standing on standing objects rule ):
!   === which is equally specific with ===
! Rule 3/13 ! Does the player mean asking someone to try lying on something when the posture of the noun is reclining ( this is the prefer request lying on reclining objects rule ):
!   >>> III.3.3 - Action/What/Actor Performing Action >>>
! Rule 4/13 ! Does the player mean sitting on something when the posture of the noun is seated ( this is the prefer sitting on seating objects rule ):
!   === which is equally specific with ===
! Rule 5/13 ! Does the player mean standing up on something when the posture of the noun is standing ( this is the prefer standing on standing objects rule ):
!   === which is equally specific with ===
! Rule 6/13 ! Does the player mean lying on something when the posture of the noun is reclining ( this is the prefer lying on reclining objects rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 7/13 ! does the player mean switching on elevatorbutton:
!   === which is equally specific with ===
! Rule 8/13 ! does the player mean moving to car:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 9/13 ! does the player mean doing anything to living-room:
!   === which is equally specific with ===
! Rule 10/13 ! does the player mean doing anything to car:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 11/13 ! Does the player mean taking something which is carried by the player ( this is the very unlikely to mean taking what's already carried rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 12/13 ! does the player mean moving to something:
!   >>> I - Number of aspects constrained >>>
! Rule 13/13 ! does the player mean saying hello to:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Postures" by Emily Short
! Does the player mean asking someone to try sitting on something when the posture of the noun is seated ( this is the prefer request sitting on seating objects rule ):
[ R_1053 ;
   if ((action ==##A115_sitting_on) &&  (actor~=player) && (act_requester) && ((actor ofclass K8_person)) && ((noun ofclass K2_thing)) && (self=actor,true) && (((GProperty(OBJECT_TY, noun,p73_posture) == I115_seated)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1053, 1053);
      ! phrase 1
      ! [1: it is very likely]
      RulebookSucceeds(19, RBNO_6); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1053, 1053, true);
   rfalse;
];
! No specific request
! From "Postures" by Emily Short
! Does the player mean asking someone to try standing up on something when the posture of the noun is standing ( this is the prefer request standing on standing objects rule ):
[ R_1054 ;
   if ((action ==##A117_standing_up_on) &&  (actor~=player) && (act_requester) && ((actor ofclass K8_person)) && ((noun ofclass K2_thing)) && (self=actor,true) && (((GProperty(OBJECT_TY, noun,p73_posture) == I116_standing)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1054, 1054);
      ! phrase 1
      ! [1: it is very likely]
      RulebookSucceeds(19, RBNO_6); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1054, 1054, true);
   rfalse;
];
! No specific request
! From "Postures" by Emily Short
! Does the player mean asking someone to try lying on something when the posture of the noun is reclining ( this is the prefer request lying on reclining objects rule ):
[ R_1055 ;
   if ((action ==##A116_lying_on) &&  (actor~=player) && (act_requester) && ((actor ofclass K8_person)) && ((noun ofclass K2_thing)) && (self=actor,true) && (((GProperty(OBJECT_TY, noun,p73_posture) == I117_reclining)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1055, 1055);
      ! phrase 1
      ! [1: it is very likely]
      RulebookSucceeds(19, RBNO_6); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1055, 1055, true);
   rfalse;
];
! No specific request
! From "Postures" by Emily Short
! Does the player mean sitting on something when the posture of the noun is seated ( this is the prefer sitting on seating objects rule ):
[ R_1050 ;
   if ((action ==##A115_sitting_on) &&  (actor==player) && ((noun ofclass K2_thing)) && (self=actor,true) && (((GProperty(OBJECT_TY, noun,p73_posture) == I115_seated)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1050, 1050);
      ! phrase 1
      ! [1: it is very likely]
      RulebookSucceeds(19, RBNO_6); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1050, 1050, true);
   rfalse;
];
! No specific request
! From "Postures" by Emily Short
! Does the player mean standing up on something when the posture of the noun is standing ( this is the prefer standing on standing objects rule ):
[ R_1051 ;
   if ((action ==##A117_standing_up_on) &&  (actor==player) && ((noun ofclass K2_thing)) && (self=actor,true) && (((GProperty(OBJECT_TY, noun,p73_posture) == I116_standing)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1051, 1051);
      ! phrase 1
      ! [1: it is very likely]
      RulebookSucceeds(19, RBNO_6); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1051, 1051, true);
   rfalse;
];
! No specific request
! From "Postures" by Emily Short
! Does the player mean lying on something when the posture of the noun is reclining ( this is the prefer lying on reclining objects rule ):
[ R_1052 ;
   if ((action ==##A116_lying_on) &&  (actor==player) && ((noun ofclass K2_thing)) && (self=actor,true) && (((GProperty(OBJECT_TY, noun,p73_posture) == I117_reclining)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1052, 1052);
      ! phrase 1
      ! [1: it is very likely]
      RulebookSucceeds(19, RBNO_6); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1052, 1052, true);
   rfalse;
];
! No specific request
! does the player mean switching on elevatorbutton:
[ R_1175 ;
   if ((action ==##SwitchOn) &&  (actor==player) && ((noun == I250_elevatorbutton) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1175, 1175);
      ! phrase 1
      ! [1: it is very likely]
      RulebookSucceeds(19, RBNO_6); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1175, 1175, true);
   rfalse;
];
! No specific request
! does the player mean moving to car:
[ R_1277 ;
   if ((action ==##A90_moving_to) &&  (actor==player) && ((noun == I233_car) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1277, 1277);
      ! phrase 1
      ! [1: it is likely]
      RulebookSucceeds(19, RBNO_7); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1277, 1277, true);
   rfalse;
];
! No specific request
! does the player mean doing anything to living-room:
[ R_1243 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun == I304_living_room) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1243, 1243);
      ! phrase 1
      ! [1: it is likely]
      RulebookSucceeds(19, RBNO_7); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1243, 1243, true);
   rfalse;
];
! No specific request
! does the player mean doing anything to car:
[ R_1276 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun == I233_car) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1276, 1276);
      ! phrase 1
      ! [1: it is likely]
      RulebookSucceeds(19, RBNO_7); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1276, 1276, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Does the player mean taking something which is carried by the player ( this is the very unlikely to mean taking what's already carried rule ):
[ R_36 ;
   if ((action ==##Take) &&  (actor==player) && ((noun ofclass K2_thing) && (player == CarrierOf(noun)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_36, 36);
      ! phrase 1
      ! [1: it is very unlikely]
      RulebookSucceeds(19, RBNO_10); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_36, 36, true);
   rfalse;
];
! No specific request
! From "Cheats" by Orion Zymaris
! does the player mean moving to something:
[ R_910 ;
   if ((action ==##A90_moving_to) &&  (actor==player) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_910, 910);
      ! phrase 1
      ! [1: if the noun is in the location begin]
       if (((real_location == ContainerOf(noun))))  {
         ! phrase 2
         ! [2: decide yes]
          rtrue; 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: decide no]
          rfalse; 
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_910, 910, true);
   rfalse;
];
! No specific request
! does the player mean saying hello to:
[ R_1213 ;
   if ((action ==##A109_saying_hello_to) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1213, 1213);
      ! phrase 1
      ! [1: if the player's command includes ~good~ begin]
       if (( (matched_text=SnippetIncludes(Consult_Grammar_296,players_command)) ))  {
         ! phrase 2
         ! [2: unless the player's command includes ~morning~ begin]
          if (~~(( (matched_text=SnippetIncludes(Consult_Grammar_297,players_command)) )))  {
            ! phrase 3
            ! [3: it is very unlikely]
            RulebookSucceeds(19, RBNO_10); rtrue;

            ! phrase 4
            ! [4: end unless]
            }

         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1213, 1213, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Printing the name (B29_before_printing_the_name)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Before printing the name of a thing ( called the item being printed ) ( this is the make named things mentioned rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Before printing the name of a thing ( called the item being printed ) ( this is the make named things mentioned rule ):
[ R_58 
    t_0 ! Local variable e.g. 'item being printed' = thing
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_58, 58);
      ! phrase 1
      ! [1: now the item being printed is mentioned]
       (Adj_60_t2_v9(t_0)); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_58, 58, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the name (B30_for_printing_the_name)
! ----------------------------------------------------------------------------------------------------
! Rule 1/28 ! rule for printing the name of coffee cup when taking coffee cup:
!   === which is equally specific with ===
! Rule 2/28 ! rule for printing the name of coffee cup when drinking coffee cup:
!   === which is equally specific with ===
! Rule 3/28 ! rule for printing the name of fridge while opening fridge:
!   === which is equally specific with ===
! Rule 4/28 ! rule for printing the name of steak when eating steak:
!   === which is equally specific with ===
! Rule 5/28 ! Rule for printing the name of the suitcase while taking inventory:
!   === which is equally specific with ===
! Rule 6/28 ! rule for printing the name of ics document when taking ics document:
!   === which is equally specific with ===
! Rule 7/28 ! rule for printing the name of bakery door when opening bakery door:
!   === which is equally specific with ===
! Rule 8/28 ! rule for printing the name of bakery door when going through bakery door:
!   === which is equally specific with ===
! Rule 9/28 ! rule for printing the name of doughnut when taking doughnut:
!   === which is equally specific with ===
! Rule 10/28 ! rule for printing the name of doughnut when giving doughnut to yourself:
!   === which is equally specific with ===
! Rule 11/28 ! rule for printing the name of bun when taking bun:
!   === which is equally specific with ===
! Rule 12/28 ! rule for printing the name of bun when giving bun to yourself:
!   === which is equally specific with ===
! Rule 13/28 ! rule for printing the name of breadstick when taking breadstick:
!   === which is equally specific with ===
! Rule 14/28 ! rule for printing the name of breadstick when giving breadstick to yourself:
!   === which is equally specific with ===
! Rule 15/28 ! rule for printing the name of vernon's cup when taking vernon's cup:
!   === which is equally specific with ===
! Rule 16/28 ! rule for printing the name of vernon's cup when dropping vernon's cup:
!   === which is equally specific with ===
! Rule 17/28 ! rule for printing the name of petunia's cup when taking petunia's cup:
!   === which is equally specific with ===
! Rule 18/28 ! rule for printing the name of petunia's cup when dropping petunia's cup:
!   === which is equally specific with ===
! Rule 19/28 ! rule for printing the name of vernon's cup when drinking vernon's cup:
!   === which is equally specific with ===
! Rule 20/28 ! rule for printing the name of vernon's cup when drinking petunia's cup:
!   === which is equally specific with ===
! Rule 21/28 ! rule for printing the name of cot when looking:
!   === which is equally specific with ===
! Rule 22/28 ! rule for printing the name of a pair of glasses when doing anything to a pair of glasses:
!   === which is equally specific with ===
! Rule 23/28 ! rule for printing the name of magic wand when doing anything to magic wand:
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 24/28 ! rule for printing the name of a door when going through a door:
!   === which is equally specific with ===
! Rule 25/28 ! rule for printing the name of a door when opening a door:
!   >>> II - When/while requirement >>>
! Rule 26/28 ! rule for printing the name of howto spoil your children handbook when listing contents of dusty box:
!   === which is equally specific with ===
! Rule 27/28 ! rule for printing the name of fridge when listing contents:
! --- now the last-placed rules ---
! Rule 28/28: STANDARD_NAME_PRINTING_R
! ----------------------------------------------------------------------------------------------------
! No specific request
! rule for printing the name of coffee cup when taking coffee cup:
[ R_1131 ;
   if (((parameter_object == I216_coffee_cup) && (true))) { ! Runs only when pattern matches
   if (((((action ==##Take) &&  (actor==player) && ((noun == I216_coffee_cup) && (true)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1131, 1131);
      ! phrase 1
      ! [1: say ~the coffee cup~]
      say__p=1;ParaContent();  print (PrintText) SC_371;  .L_Say166; .L_SayX161;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1131, 1131, true);
   rfalse;
];
! No specific request
! rule for printing the name of coffee cup when drinking coffee cup:
[ R_1132 ;
   if (((parameter_object == I216_coffee_cup) && (true))) { ! Runs only when pattern matches
   if (((((action ==##Drink) &&  (actor==player) && ((noun == I216_coffee_cup) && (true)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1132, 1132);
      ! phrase 1
      ! [1: say ~coffee~]
      say__p=1;ParaContent();  print (PrintText) SC_372;  .L_Say167; .L_SayX162;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1132, 1132, true);
   rfalse;
];
! No specific request
! rule for printing the name of fridge while opening fridge:
[ R_1137 ;
   if (((parameter_object == I222_fridge) && (true))) { ! Runs only when pattern matches
   if (((((action ==##Open) &&  (actor==player) && ((noun == I222_fridge) && (true)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1137, 1137);
      ! phrase 1
      ! [1: say ~fridge~]
      say__p=1;ParaContent();  print (PrintText) SC_373;  .L_Say168; .L_SayX163;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1137, 1137, true);
   rfalse;
];
! No specific request
! rule for printing the name of steak when eating steak:
[ R_1138 ;
   if (((parameter_object == I223_steak) && (true))) { ! Runs only when pattern matches
   if (((((action ==##Eat) &&  (actor==player) && ((noun == I223_steak) && (true)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1138, 1138);
      ! phrase 1
      ! [1: say ~steak~]
      say__p=1;ParaContent();  print (PrintText) SC_374;  .L_Say169; .L_SayX164;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1138, 1138, true);
   rfalse;
];
! No specific request
! Rule for printing the name of the suitcase while taking inventory:
[ R_1142 ;
   if (((parameter_object == I228_suitcase) && (true))) { ! Runs only when pattern matches
   if (((((action ==##Inv) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1142, 1142);
      ! phrase 1
      ! [1: say ~a suitcase~]
      say__p=1;ParaContent();  print (PrintText) SC_375;  .L_Say170; .L_SayX165;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1142, 1142, true);
   rfalse;
];
! No specific request
! rule for printing the name of ics document when taking ics document:
[ R_1185 ;
   if (((parameter_object == I263_ics_document) && (true))) { ! Runs only when pattern matches
   if (((((action ==##Take) &&  (actor==player) && ((noun == I263_ics_document) && (true)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1185, 1185);
      ! phrase 1
      ! [1: say ~the important customer service document~]
      say__p=1;ParaContent();  print (PrintText) SC_376;  .L_Say171; .L_SayX166;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1185, 1185, true);
   rfalse;
];
! No specific request
! rule for printing the name of bakery door when opening bakery door:
[ R_1249 ;
   if (((parameter_object == I286_bakery_door) && (true))) { ! Runs only when pattern matches
   if (((((action ==##Open) &&  (actor==player) && ((noun == I286_bakery_door) && (true)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1249, 1249);
      ! phrase 1
      ! [1: say ~the door~]
      say__p=1;ParaContent();  print (PrintText) SC_377;  .L_Say172; .L_SayX167;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1249, 1249, true);
   rfalse;
];
! No specific request
! rule for printing the name of bakery door when going through bakery door:
[ R_1250 ;
   if (((parameter_object == I286_bakery_door) && (true))) { ! Runs only when pattern matches
   if (((((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,2)) == I286_bakery_door) && (true)) && ((MStack-->MstVON(20007,1)) ~= nothing))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1250, 1250);
      ! phrase 1
      ! [1: say ~the door~]
      say__p=1;ParaContent();  print (PrintText) SC_377;  .L_Say173; .L_SayX168;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1250, 1250, true);
   rfalse;
];
! No specific request
! rule for printing the name of doughnut when taking doughnut:
[ R_1254 ;
   if (((parameter_object == I292_doughnut) && (true))) { ! Runs only when pattern matches
   if (((((action ==##Take) &&  (actor==player) && ((noun == I292_doughnut) && (true)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1254, 1254);
      ! phrase 1
      ! [1: say ~doughnut~]
      say__p=1;ParaContent();  print (PrintText) SC_378;  .L_Say174; .L_SayX169;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1254, 1254, true);
   rfalse;
];
! No specific request
! rule for printing the name of doughnut when giving doughnut to yourself:
[ R_1255 ;
   if (((parameter_object == I292_doughnut) && (true))) { ! Runs only when pattern matches
   if (((((action ==##Give) &&  (actor==player) && ((noun == I292_doughnut) && (true)) && ((second == selfobj) && (true)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1255, 1255);
      ! phrase 1
      ! [1: say ~doughnut~]
      say__p=1;ParaContent();  print (PrintText) SC_378;  .L_Say175; .L_SayX170;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1255, 1255, true);
   rfalse;
];
! No specific request
! rule for printing the name of bun when taking bun:
[ R_1256 ;
   if (((parameter_object == I293_bun) && (true))) { ! Runs only when pattern matches
   if (((((action ==##Take) &&  (actor==player) && ((noun == I293_bun) && (true)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1256, 1256);
      ! phrase 1
      ! [1: say ~bun~]
      say__p=1;ParaContent();  print (PrintText) SC_379;  .L_Say176; .L_SayX171;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1256, 1256, true);
   rfalse;
];
! No specific request
! rule for printing the name of bun when giving bun to yourself:
[ R_1257 ;
   if (((parameter_object == I293_bun) && (true))) { ! Runs only when pattern matches
   if (((((action ==##Give) &&  (actor==player) && ((noun == I293_bun) && (true)) && ((second == selfobj) && (true)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1257, 1257);
      ! phrase 1
      ! [1: say ~bun~]
      say__p=1;ParaContent();  print (PrintText) SC_379;  .L_Say177; .L_SayX172;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1257, 1257, true);
   rfalse;
];
! No specific request
! rule for printing the name of breadstick when taking breadstick:
[ R_1258 ;
   if (((parameter_object == I294_breadstick) && (true))) { ! Runs only when pattern matches
   if (((((action ==##Take) &&  (actor==player) && ((noun == I294_breadstick) && (true)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1258, 1258);
      ! phrase 1
      ! [1: say ~breadstick~]
      say__p=1;ParaContent();  print (PrintText) SC_380;  .L_Say178; .L_SayX173;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1258, 1258, true);
   rfalse;
];
! No specific request
! rule for printing the name of breadstick when giving breadstick to yourself:
[ R_1259 ;
   if (((parameter_object == I294_breadstick) && (true))) { ! Runs only when pattern matches
   if (((((action ==##Give) &&  (actor==player) && ((noun == I294_breadstick) && (true)) && ((second == selfobj) && (true)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1259, 1259);
      ! phrase 1
      ! [1: say ~breadstick~]
      say__p=1;ParaContent();  print (PrintText) SC_380;  .L_Say179; .L_SayX174;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1259, 1259, true);
   rfalse;
];
! No specific request
! rule for printing the name of vernon's cup when taking vernon's cup:
[ R_1300 ;
   if (((parameter_object == I326_vernon_s_cup) && (true))) { ! Runs only when pattern matches
   if (((((action ==##Take) &&  (actor==player) && ((noun == I326_vernon_s_cup) && (true)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1300, 1300);
      ! phrase 1
      ! [1: say ~the tea cup~]
      say__p=1;ParaContent();  print (PrintText) SC_381;  .L_Say180; .L_SayX175;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1300, 1300, true);
   rfalse;
];
! No specific request
! rule for printing the name of vernon's cup when dropping vernon's cup:
[ R_1301 ;
   if (((parameter_object == I326_vernon_s_cup) && (true))) { ! Runs only when pattern matches
   if (((((action ==##Drop) &&  (actor==player) && ((noun == I326_vernon_s_cup) && (true)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1301, 1301);
      ! phrase 1
      ! [1: say ~the tea cup~]
      say__p=1;ParaContent();  print (PrintText) SC_381;  .L_Say181; .L_SayX176;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1301, 1301, true);
   rfalse;
];
! No specific request
! rule for printing the name of petunia's cup when taking petunia's cup:
[ R_1302 ;
   if (((parameter_object == I327_petunia_s_cup) && (true))) { ! Runs only when pattern matches
   if (((((action ==##Take) &&  (actor==player) && ((noun == I327_petunia_s_cup) && (true)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1302, 1302);
      ! phrase 1
      ! [1: say ~the tea cup~]
      say__p=1;ParaContent();  print (PrintText) SC_381;  .L_Say182; .L_SayX177;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1302, 1302, true);
   rfalse;
];
! No specific request
! rule for printing the name of petunia's cup when dropping petunia's cup:
[ R_1303 ;
   if (((parameter_object == I327_petunia_s_cup) && (true))) { ! Runs only when pattern matches
   if (((((action ==##Drop) &&  (actor==player) && ((noun == I327_petunia_s_cup) && (true)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1303, 1303);
      ! phrase 1
      ! [1: say ~the tea cup~]
      say__p=1;ParaContent();  print (PrintText) SC_381;  .L_Say183; .L_SayX178;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1303, 1303, true);
   rfalse;
];
! No specific request
! rule for printing the name of vernon's cup when drinking vernon's cup:
[ R_1304 ;
   if (((parameter_object == I326_vernon_s_cup) && (true))) { ! Runs only when pattern matches
   if (((((action ==##Drink) &&  (actor==player) && ((noun == I326_vernon_s_cup) && (true)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1304, 1304);
      ! phrase 1
      ! [1: say ~tea~]
      say__p=1;ParaContent();  print (PrintText) SC_382;  .L_Say184; .L_SayX179;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1304, 1304, true);
   rfalse;
];
! No specific request
! rule for printing the name of vernon's cup when drinking petunia's cup:
[ R_1305 ;
   if (((parameter_object == I326_vernon_s_cup) && (true))) { ! Runs only when pattern matches
   if (((((action ==##Drink) &&  (actor==player) && ((noun == I327_petunia_s_cup) && (true)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1305, 1305);
      ! phrase 1
      ! [1: say ~tea~]
      say__p=1;ParaContent();  print (PrintText) SC_382;  .L_Say185; .L_SayX180;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1305, 1305, true);
   rfalse;
];
! No specific request
! rule for printing the name of cot when looking:
[ R_1317 ;
   if (((parameter_object == I331_cot) && (true))) { ! Runs only when pattern matches
   if (((((action ==##Look) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1317, 1317);
      ! phrase 1
      ! [1: say ~a cot~]
      say__p=1;ParaContent();  print (PrintText) SC_383;  .L_Say186; .L_SayX181;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1317, 1317, true);
   rfalse;
];
! No specific request
! rule for printing the name of a pair of glasses when doing anything to a pair of glasses:
[ R_1321 ;
   if (((parameter_object == I341_pair_of_glasses) && (true))) { ! Runs only when pattern matches
   if (((( (actor==player) &&  (noun) && (noun == inp1) && ((noun == I341_pair_of_glasses) && (true)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1321, 1321);
      ! phrase 1
      ! [1: say ~the pair of glasses~]
      say__p=1;ParaContent();  print (PrintText) SC_384;  .L_Say187; .L_SayX182;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1321, 1321, true);
   rfalse;
];
! No specific request
! rule for printing the name of magic wand when doing anything to magic wand:
[ R_1322 ;
   if (((parameter_object == I342_magic_wand) && (true))) { ! Runs only when pattern matches
   if (((( (actor==player) &&  (noun) && (noun == inp1) && ((noun == I342_magic_wand) && (true)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1322, 1322);
      ! phrase 1
      ! [1: say ~the wand~]
      say__p=1;ParaContent();  print (PrintText) SC_385;  .L_Say188; .L_SayX183;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1322, 1322, true);
   rfalse;
];
! No specific request
! rule for printing the name of a door when going through a door:
[ R_1281 ;
   if (((parameter_object ofclass K4_door))) { ! Runs only when pattern matches
   if (((((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,2)) ofclass K4_door)) && ((MStack-->MstVON(20007,1)) ~= nothing))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1281, 1281);
      ! phrase 1
      ! [1: say ~the door~]
      say__p=1;ParaContent();  print (PrintText) SC_377;  .L_Say189; .L_SayX184;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1281, 1281, true);
   rfalse;
];
! No specific request
! rule for printing the name of a door when opening a door:
[ R_1282 ;
   if (((parameter_object ofclass K4_door))) { ! Runs only when pattern matches
   if (((((action ==##Open) &&  (actor==player) && ((noun ofclass K4_door)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1282, 1282);
      ! phrase 1
      ! [1: say ~the door~]
      say__p=1;ParaContent();  print (PrintText) SC_377;  .L_Say190; .L_SayX185;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1282, 1282, true);
   rfalse;
];
! No specific request
! rule for printing the name of howto spoil your children handbook when listing contents of dusty box:
[ R_1116 ;
   if (((parameter_object == I190_howto_spoil_your_childr) && (true))) { ! Runs only when pattern matches
   if (((TestActivity(V4_listing_contents_of_somet, 0, I184_dusty_box)))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1116, 1116);
      ! phrase 1
      ! [1: say ~[first time]and books with titles such as [only]the how to spoil your children handbook~]
      say__p=1;ParaContent();  
	if ((I7_ST_say_first_time-->1)++ == 0) {
		ParaContent();  print (PrintText) SC_386; ParaContent();  } ParaContent();  print (PrintText) SC_387;  .L_Say191; .L_SayX186;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1116, 1116, true);
   rfalse;
];
! No specific request
! rule for printing the name of fridge when listing contents:
[ R_1136 ;
   if (((parameter_object == I222_fridge) && (true))) { ! Runs only when pattern matches
   if (((TestActivity(V4_listing_contents_of_somet)))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1136, 1136);
      ! phrase 1
      ! [1: say ~the fridge~]
      say__p=1;ParaContent();  print (PrintText) SC_388;  .L_Say192; .L_SayX187;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1136, 1136, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: after Printing the name (B31_after_printing_the_name)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! After printing the name of an ambiguously plural thing ( called the suspect ) ( this is the notice plurality of printed ambiguous object rule ):
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 2/4 ! After printing the name of a door:
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 3/4 ! After printing the name of something ( called the target ) ( this is the notice plurality of printed object rule ):
!   === which is equally specific with ===
! Rule 4/4 ! after printing the name of a room:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Plurality" by Emily Short
! After printing the name of an ambiguously plural thing ( called the suspect ) ( this is the notice plurality of printed ambiguous object rule ):
[ R_838 
    t_0 ! Local variable e.g. 'suspect' = thing
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing) && ((Adj_83_t1_v9(parameter_object))))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_838, 838);
      ! phrase 1
      ! [1: if the manual pronouns option is active begin]
       if ((((Adj_22_t1_v15(22)))))  {
         ! phrase 2
         ! [2: do nothing]
          ; 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: notice the plurality of the suspect]
          PlugPlural(t_0); 
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_838, 838, true);
   rfalse;
];
! No specific request
! From "Door Directions" by Orion Zymaris
! After printing the name of a door:
[ R_894 ;
   if (((parameter_object ofclass K4_door))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_894, 894);
      ! phrase 1
      ! [1: unless going through door begin]
       if (~~((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,2)) ofclass K4_door)) && ((MStack-->MstVON(20007,1)) ~= nothing)))  {
         ! phrase 2
         ! [2: unless opening door begin]
          if (~~((action ==##Open) &&  (actor==player) && ((noun ofclass K4_door))))  {
            ! phrase 3
            ! [3: unless closing door begin]
             if (~~((action ==##Close) &&  (actor==player) && ((noun ofclass K4_door))))  {
               ! phrase 4
               ! [4: unless examining a direction begin]
                if (~~((action ==##Examine) &&  (actor==player) && ((noun ofclass K3_direction))))  {
                  ! phrase 5
                  ! [5: say ~ ([direction of the item described from the location])~]
                  say__p=1;ParaContent();  print (PrintText) SC_389; ParaContent();  print (PrintShortName) (Resolver_5(self,real_location,"source", 1)); ParaContent();  print (PrintText) SC_230;  .L_Say193; .L_SayX188;
                  ! phrase 6
                  ! [6: otherwise]
                  } else {

                  ! phrase 7
                  ! [7: say ~[if the openyesno of the item described is 1] leading towards [the other side]~]
                  say__p=1;
	if (~~((((GProperty(OBJECT_TY, self,p13_openyesno) == 1))))) jump L_Say194;
		ParaContent();  print (PrintText) SC_390; ParaContent(); @push self;  print (the) GProperty(OBJECT_TY, self=self,door_to); @pull self;  .L_Say194; .L_SayX189;
                  ! phrase 8
                  ! [8: end unless]
                  }

               ! phrase 9
               ! [9: end unless]
               }

            ! phrase 10
            ! [10: end unless]
            }

         ! phrase 11
         ! [11: end unless]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_894, 894, true);
   rfalse;
];
! No specific request
! From "Plurality" by Emily Short
! After printing the name of something ( called the target ) ( this is the notice plurality of printed object rule ):
[ R_772 
    t_0 ! Local variable e.g. 'target' = thing
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_772, 772);
      ! phrase 1
      ! [1: mark target in output]
      (PHR_773_r12 (t_0));
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_772, 772, true);
   rfalse;
];
! No specific request
! after printing the name of a room:
[ R_758 ;
   if (((parameter_object ofclass K1_room))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_758, 758);
      ! phrase 1
      ! [1: if underly is 1 begin]
       if ((((Global_Vars-->14) == 1)))  {
         ! phrase 2
         ! [2: say ~ [roman type](under [overlay])~]
         say__p=1;ParaContent();  print (PrintText) SC_88; ParaContent();  style roman; ParaContent();  print (PrintText) SC_391; ParaContent();  print (PrintShortName) (Global_Vars-->15); ParaContent();  print (PrintText) SC_230;  .L_Say195; .L_SayX190;
         ! phrase 3
         ! [3: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_758, 758, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the plural name (B33_for_printing_the_plural_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for printing the plural name of something ( called the item ) ( this is the standard printing the plural name rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Rule for printing the plural name of something ( called the item ) ( this is the standard printing the plural name rule ):
[ R_59 
    t_0 ! Local variable e.g. 'item' = thing
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_59, 59);
      ! phrase 1
      ! [1: say the printed plural name of the item]
      say__p=1;ParaContent(); @push self;  print (PrintText) GProperty(9, self=t_0,plural); @pull self;  .L_Say196; .L_SayX191;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_59, 59, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing a number (B36_for_printing_a_number)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for printing a number of something ( called the item ) ( this is the standard printing a number of something rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Rule for printing a number of something ( called the item ) ( this is the standard printing a number of something rule ):
[ R_60 
    t_0 ! Local variable e.g. 'item' = thing
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_60, 60);
      ! phrase 1
      ! [1: say ~[listing group size in words] ~]
      say__p=1;ParaContent();  print (number) say__n=(listing_size); ParaContent();  print (PrintText) SC_88;  .L_Say197; .L_SayX192;
      ! phrase 2
      ! [2: carry out the printing the plural name activity with the item]
       CarryOutActivity(V1_printing_the_plural_name_, t_0); 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_60, 60, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the announcement of light (B63_for_printing_the_announc)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! This is the look around once light available rule:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! This is the look around once light available rule:
[ R_61 ;
      ! phrase 1
      ! [1: try looking]
       TryAction(0, player, ##Look, 0, 0);; 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Constructing the status line (B69_for_constructing_the_sta)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for constructing the status line while displaying ( this is the constructing status line while displaying rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Menus" by Emily Short
! Rule for constructing the status line while displaying ( this is the constructing status line while displaying rule ):
[ R_870 ;
   if (((TestActivity(V32_displaying)))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_870, 870);
      ! phrase 1
      ! [1: if the endnode flag is 0 , fill status bar with table of deep menu status]
       if ((((Global_Vars-->19) == 0))) { (PHR_1082_r13 (T5_deep_menu_status));  }
      ! phrase 2
      ! [2: otherwise fill status bar with table of shallow menu status]
       else { (PHR_1082_r13 (T4_shallow_menu_status));  }
      ! phrase 3
      ! [3: rule succeeds]
       RulebookSucceeds(); rtrue; 
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_870, 870, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Printing the banner text (B71_before_printing_the_bann)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! before printing the banner text when bannerprinted is 0:
! ----------------------------------------------------------------------------------------------------
! No specific request
! before printing the banner text when bannerprinted is 0:
[ R_744 ;
   if (((((((Global_Vars-->13) == 0)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_744, 744);
      ! phrase 1
      ! [1: clear the screen]
       VM_ClearScreen(0); 
      ! phrase 2
      ! [2: play sound of intro one]
       PlaySound(ResourceIDsOfSounds-->I88_sound_of_intro_one, 0); 
      ! phrase 3
      ! [3: say ~[bold type]Welcome to An Interactive Fiction version of Harry Potter.[line break][italic type]                (If you ever need help, type help.)[roman type][paragraph break]Mr and Mrs Dursley, of number four, Privet Drive, were proud to say that they were perfectly normal, thank you very much.[line break]They were the last people you'd expect to be involved in anything strange or mysterious,  because they just didn't hold with such nonsense.[paragraph break][run paragraph on]~]
      say__p=1;ParaContent();  style bold; ParaContent();  print (PrintText) SC_392; ParaContent();  new_line; ParaContent();  style underline; ParaContent();  print (PrintText) SC_393; ParaContent();  style roman; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_394; ParaContent();  new_line; ParaContent();  print (PrintText) SC_395; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  RunParagraphOn();  .L_Say198; .L_SayX193;
      ! phrase 4
      ! [4: if glulx timekeeping is supported begin]
       if (( ( glk_gestalt(gestalt_Timer, 0) ) ))  {
         ! phrase 5
         ! [5: wait 17995 ms before continuing]
         (PHR_1016_r6 (17995));
         ! phrase 6
         ! [6: clear the screen]
          VM_ClearScreen(0); 
         ! phrase 7
         ! [7: end if]
         }

      ! phrase 8
      ! [8: play sound of intro two]
       PlaySound(ResourceIDsOfSounds-->I89_sound_of_intro_two, 0); 
      ! phrase 9
      ! [9: say ~[if glulx timekeeping is supported][bold type]Welcome to An Interactive Fiction version of Harry Potter.[line break][italic type]                (If you ever need help, type help.)[roman type][paragraph break][end if]Mr Dursley was the director of a firm called Grunnings, which made drills. He was a big, beefy man with hardly any neck, although he did have a very large moustache. Mrs Dursley was thin and blonde and had nearly twice the usual amount of neck, which came in very useful as she spent so much of her time craning over garden fences, spying on the neighbours. The Dursleys had a small son called Dudley and in their opinion there was no finer boy anywhere.[run paragraph on]~]
      say__p=1;
	if (~~((( ( glk_gestalt(gestalt_Timer, 0) ) )))) jump L_Say199;
		ParaContent();  style bold; ParaContent();  print (PrintText) SC_392; ParaContent();  new_line; ParaContent();  style underline; ParaContent();  print (PrintText) SC_393; ParaContent();  style roman; ParaContent();  DivideParagraphPoint(); new_line; 
	.L_Say199; .L_SayX194;
		ParaContent();  print (PrintText) SC_396; ParaContent();  RunParagraphOn();  .L_Say200; .L_SayX195;
      ! phrase 10
      ! [10: if glulx timekeeping is supported begin]
       if (( ( glk_gestalt(gestalt_Timer, 0) ) ))  {
         ! phrase 11
         ! [11: wait 33850 ms before continuing]
         (PHR_1016_r6 (33850));
         ! phrase 12
         ! [12: clear the screen]
          VM_ClearScreen(0); 
         ! phrase 13
         ! [13: end if]
         }

      ! phrase 14
      ! [14: play sound of intro three]
       PlaySound(ResourceIDsOfSounds-->I90_sound_of_intro_three, 0); 
      ! phrase 15
      ! [15: say ~[if glulx timekeeping is supported][bold type]Welcome to An Interactive Fiction version of Harry Potter.[line break][italic type]                (If you ever need help, type help.)[roman type][paragraph break][end if]The Dursleys had everything they wanted, but they also had a secret, and their greatest fear was that somebody would discover it. They didn't think they could bear it if anyone found out about the Potters. Mrs Potter was Mrs Dursley's sister, but they hadn't met for several years; in fact, Mrs Dursley pretended she didn't have a sister, because her sister and her good-for-nothing husband were as unDursleyish as it was possible to be. The Dursleys shuddered to think what the neighbours would say if the Potters arrived in the street. The Dursleys knew that the Potters had a small son too, but they had never seen him. This boy was another good reason for keeping the Potters away; they didn't want Dudley mixing with a child like that.[paragraph break][run paragraph on]~]
      say__p=1;
	if (~~((( ( glk_gestalt(gestalt_Timer, 0) ) )))) jump L_Say201;
		ParaContent();  style bold; ParaContent();  print (PrintText) SC_392; ParaContent();  new_line; ParaContent();  style underline; ParaContent();  print (PrintText) SC_393; ParaContent();  style roman; ParaContent();  DivideParagraphPoint(); new_line; 
	.L_Say201; .L_SayX196;
		ParaContent();  print (PrintText) SC_397; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  RunParagraphOn();  .L_Say202; .L_SayX197;
      ! phrase 16
      ! [16: if glulx timekeeping is supported begin]
       if (( ( glk_gestalt(gestalt_Timer, 0) ) ))  {
         ! phrase 17
         ! [17: wait 58095 ms before continuing]
         (PHR_1016_r6 (58095));
         ! phrase 18
         ! [18: clear the screen]
          VM_ClearScreen(0); 
         ! phrase 19
         ! [19: end if]
         }

      ! phrase 20
      ! [20: play sound of intro four]
       PlaySound(ResourceIDsOfSounds-->I91_sound_of_intro_four, 0); 
      ! phrase 21
      ! [21: say ~[now bannerprinted is 1][banner text][paragraph break][if glulx timekeeping is supported][bold type]Welcome to An Interactive Fiction version of Harry Potter.[line break][italic type]                (If you ever need help, type help.)[roman type][paragraph break][end if]When Mr and Mrs Dursley woke up on the dull, grey Tuesday our story starts, there was nothing about the cloudy sky outside to suggest that strange and mysterious things would soon be happening all over the country.[paragraph break]~]
      say__p=1;ParaContent(); (PHR_743_r14 ());ParaContent();  Banner(); ParaContent();  DivideParagraphPoint(); new_line; 
	if (~~((( ( glk_gestalt(gestalt_Timer, 0) ) )))) jump L_Say203;
		ParaContent();  style bold; ParaContent();  print (PrintText) SC_392; ParaContent();  new_line; ParaContent();  style underline; ParaContent();  print (PrintText) SC_393; ParaContent();  style roman; ParaContent();  DivideParagraphPoint(); new_line; 
	.L_Say203; .L_SayX198;
		ParaContent();  print (PrintText) SC_398; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say204; .L_SayX199;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_744, 744, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: after Reading a command (B76_after_reading_a_command)
! ----------------------------------------------------------------------------------------------------
! Rule 1/14 ! After reading a command when cheats_bin is 1:
!   === which is equally specific with ===
! Rule 2/14 ! after reading a command when the command prompt is ~Search:  ~:
!   === which is equally specific with ===
! Rule 3/14 ! after reading a command when the player is in corridor:
!   === which is equally specific with ===
! Rule 4/14 ! after reading a command when the lexicon is table 10:
!   === which is equally specific with ===
! Rule 5/14 ! After reading a command when the command prompt is ~What do you want to write: ~:
!   === which is equally specific with ===
! Rule 6/14 ! after reading a command when the location is dining room:
!   === which is equally specific with ===
! Rule 7/14 ! after reading a command when the player's command matches ~sit down~:
!   >>> II - When/while requirement >>>
! Rule 8/14 ! after reading a command during uncle vernon's scene:
!   === which is equally specific with ===
! Rule 9/14 ! after reading a command during work:
!   === which is equally specific with ===
! Rule 10/14 ! after reading a command during uncle vernon's scene:
!   === which is equally specific with ===
! Rule 11/14 ! after reading a command during uncle vernon's scene:
!   === which is equally specific with ===
! Rule 12/14 ! after reading a command during uncle vernon's scene:
!   === which is equally specific with ===
! Rule 13/14 ! after reading a command during uncle vernon's scene:
!   === which is equally specific with ===
! Rule 14/14 ! after reading a command during uncle vernon's scene:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Cheats" by Orion Zymaris
! After reading a command when cheats_bin is 1:
[ R_932 ;
   if (((((((Global_Vars-->25) == 1)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_932, 932);
      ! phrase 1
      ! [1: if the player's command includes ~eat me~ begin]
       if (( (matched_text=SnippetIncludes(Consult_Grammar_298,players_command)) ))  {
         ! phrase 2
         ! [2: say ~You manage to eat yourself. You are in darkness.~]
         say__p=1;ParaContent();  print (PrintText) SC_399;  new_line; .L_Say205; .L_SayX200;
         ! phrase 3
         ! [3: now the player is in darknesss]
          MoveObject(player,I102_darknesss); 
         ! phrase 4
         ! [4: reject the player's command]
          RulebookFails(); rtrue; 
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_932, 932, true);
   rfalse;
];
! No specific request
! From "Hpmenu for chapter 1" by Orion Zymaris
! after reading a command when the command prompt is ~Search:  ~:
[ R_1093 ;blockv_stack-->(blockv_sp+27) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+26) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+25) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+24) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+23) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+22) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+21) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+20) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+19) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+18) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+17) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+16) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+15) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+14) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+13) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+12) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+11) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+10) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+9) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+8) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+7) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+6) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+5) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+4) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+3) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+2) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+1) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+0) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_sp = blockv_sp + 28;
    blockv_stack-->(blockv_sp++) = R_SHELL_3(blockv_sp-28);
    blockv_sp = blockv_sp - 29;
    BlkFree(blockv_stack-->(blockv_sp+27));
    BlkFree(blockv_stack-->(blockv_sp+26));
    BlkFree(blockv_stack-->(blockv_sp+25));
    BlkFree(blockv_stack-->(blockv_sp+24));
    BlkFree(blockv_stack-->(blockv_sp+23));
    BlkFree(blockv_stack-->(blockv_sp+22));
    BlkFree(blockv_stack-->(blockv_sp+21));
    BlkFree(blockv_stack-->(blockv_sp+20));
    BlkFree(blockv_stack-->(blockv_sp+19));
    BlkFree(blockv_stack-->(blockv_sp+18));
    BlkFree(blockv_stack-->(blockv_sp+17));
    BlkFree(blockv_stack-->(blockv_sp+16));
    BlkFree(blockv_stack-->(blockv_sp+15));
    BlkFree(blockv_stack-->(blockv_sp+14));
    BlkFree(blockv_stack-->(blockv_sp+13));
    BlkFree(blockv_stack-->(blockv_sp+12));
    BlkFree(blockv_stack-->(blockv_sp+11));
    BlkFree(blockv_stack-->(blockv_sp+10));
    BlkFree(blockv_stack-->(blockv_sp+9));
    BlkFree(blockv_stack-->(blockv_sp+8));
    BlkFree(blockv_stack-->(blockv_sp+7));
    BlkFree(blockv_stack-->(blockv_sp+6));
    BlkFree(blockv_stack-->(blockv_sp+5));
    BlkFree(blockv_stack-->(blockv_sp+4));
    BlkFree(blockv_stack-->(blockv_sp+3));
    BlkFree(blockv_stack-->(blockv_sp+2));
    BlkFree(blockv_stack-->(blockv_sp+1));
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+28);
];
[ R_SHELL_3 I7BASPL 
    t_0 ! Local variable e.g. 'T' = indexed text
    ;
   if (((((((Global_Vars-->1) == SC_400)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1093, 1093);
      ! phrase 1
      ! [1: let t be indexed text]
       t_0 = (blockv_stack-->(I7BASPL+0)); 
      ! phrase 2
      ! [2: let t be the player's command in lower case]
       BlkValueCopy(t_0,  IT_CharactersToCase((blockv_stack-->(I7BASPL+1)), BlkValueCast((blockv_stack-->(I7BASPL+2)),INDEXED_TEXT_TY,SNIPPET_TY,players_command), 0) ); 
      ! phrase 3
      ! [3: if t exactly matches the text ~all~ begin]
       if (( IT_Replace_RE(CHR_BLOB,t_0,BlkValueCast((blockv_stack-->(I7BASPL+3)),INDEXED_TEXT_TY,TEXT_TY,SC_401),0,0,1) ))  {
         ! phrase 4
         ! [4: say ~1:[hint1][line break]2:[hint2][line break]3:[hint3][line break]4:[hint4][line break]5:[hint5][line break]6:[hint6][line break]7:[hint7][line break]8:[hint8][line break]9:[hint9][line break]10:[hint10][line break]11:[hint11][line break]12:[hint12][line break]13:[hint13][line break]14:[hint14][line break]15:[hint15][line break]16:[hint16][line break]17:[hint17][line break]18:[hint18][line break]19:[hint19][line break]20:[hint20][line break]21:[hint21][line break]22:[hint22][line break]23:[hint23][line break]24:[hint24][line break]~]
         say__p=1;ParaContent();  print (PrintText) SC_402; ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->45); ParaContent();  new_line; ParaContent();  print (PrintText) SC_403; ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->46); ParaContent();  new_line; ParaContent();  print (PrintText) SC_404; ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->47); ParaContent();  new_line; ParaContent();  print (PrintText) SC_405; ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->48); ParaContent();  new_line; ParaContent();  print (PrintText) SC_406; ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->49); ParaContent();  new_line; ParaContent();  print (PrintText) SC_407; ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->50); ParaContent();  new_line; ParaContent();  print (PrintText) SC_408; ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->51); ParaContent();  new_line; ParaContent();  print (PrintText) SC_409; ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->52); ParaContent();  new_line; ParaContent();  print (PrintText) SC_410; ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->53); ParaContent();  new_line; ParaContent();  print (PrintText) SC_411; ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->54); ParaContent();  new_line; ParaContent();  print (PrintText) SC_412; ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->55); ParaContent();  new_line; ParaContent();  print (PrintText) SC_413; ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->56); ParaContent();  new_line; ParaContent();  print (PrintText) SC_414; ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->57); ParaContent();  new_line; ParaContent();  print (PrintText) SC_415; ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->58); ParaContent();  new_line; ParaContent();  print (PrintText) SC_416; ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->59); ParaContent();  new_line; ParaContent();  print (PrintText) SC_417; ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->60); ParaContent();  new_line; ParaContent();  print (PrintText) SC_418; ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->61); ParaContent();  new_line; ParaContent();  print (PrintText) SC_419; ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->62); ParaContent();  new_line; ParaContent();  print (PrintText) SC_420; ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->63); ParaContent();  new_line; ParaContent();  print (PrintText) SC_421; ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->64); ParaContent();  new_line; ParaContent();  print (PrintText) SC_422; ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->65); ParaContent();  new_line; ParaContent();  print (PrintText) SC_423; ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->66); ParaContent();  new_line; ParaContent();  print (PrintText) SC_424; ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->67); ParaContent();  new_line; ParaContent();  print (PrintText) SC_425; ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->68); ParaContent();  new_line;  .L_Say206; .L_SayX201;
         ! phrase 5
         ! [5: now the command prompt is ~>~]
          (Global_Vars-->1) = SC_74; 
         ! phrase 6
         ! [6: rule succeeds]
          RulebookSucceeds(); rtrue; 
         ! phrase 7
         ! [7: end if]
         }

      ! phrase 8
      ! [8: if hint1 matches the text ~[T]~ begin]
       if (( IT_Replace_RE(CHR_BLOB,(Global_Vars-->45),BlkValueCast((blockv_stack-->(I7BASPL+4)),INDEXED_TEXT_TY,TEXT_TY,((LocalParking-->0=t_0)*0+text_routine_100)),0,0) ))  {
         ! phrase 9
         ! [9: say ~[hint1][paragraph break]~]
         say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->45); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say207; .L_SayX202;
         ! phrase 10
         ! [10: end if]
         }

      ! phrase 11
      ! [11: if hint2 matches the text ~[T]~ begin]
       if (( IT_Replace_RE(CHR_BLOB,(Global_Vars-->46),BlkValueCast((blockv_stack-->(I7BASPL+5)),INDEXED_TEXT_TY,TEXT_TY,((LocalParking-->0=t_0)*0+text_routine_101)),0,0) ))  {
         ! phrase 12
         ! [12: say ~[hint2][paragraph break]~]
         say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->46); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say208; .L_SayX203;
         ! phrase 13
         ! [13: end if]
         }

      ! phrase 14
      ! [14: if hint3 matches the text ~[T]~ begin]
       if (( IT_Replace_RE(CHR_BLOB,(Global_Vars-->47),BlkValueCast((blockv_stack-->(I7BASPL+6)),INDEXED_TEXT_TY,TEXT_TY,((LocalParking-->0=t_0)*0+text_routine_102)),0,0) ))  {
         ! phrase 15
         ! [15: say ~[hint3][paragraph break]~]
         say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->47); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say209; .L_SayX204;
         ! phrase 16
         ! [16: end if]
         }

      ! phrase 17
      ! [17: if hint4 matches the text ~[T]~ begin]
       if (( IT_Replace_RE(CHR_BLOB,(Global_Vars-->48),BlkValueCast((blockv_stack-->(I7BASPL+7)),INDEXED_TEXT_TY,TEXT_TY,((LocalParking-->0=t_0)*0+text_routine_103)),0,0) ))  {
         ! phrase 18
         ! [18: say ~[hint4][paragraph break]~]
         say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->48); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say210; .L_SayX205;
         ! phrase 19
         ! [19: end if]
         }

      ! phrase 20
      ! [20: if hint5 matches the text ~[T]~ begin]
       if (( IT_Replace_RE(CHR_BLOB,(Global_Vars-->49),BlkValueCast((blockv_stack-->(I7BASPL+8)),INDEXED_TEXT_TY,TEXT_TY,((LocalParking-->0=t_0)*0+text_routine_104)),0,0) ))  {
         ! phrase 21
         ! [21: say ~[hint5][paragraph break]~]
         say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->49); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say211; .L_SayX206;
         ! phrase 22
         ! [22: end if]
         }

      ! phrase 23
      ! [23: if hint6 matches the text ~[T]~ begin]
       if (( IT_Replace_RE(CHR_BLOB,(Global_Vars-->50),BlkValueCast((blockv_stack-->(I7BASPL+9)),INDEXED_TEXT_TY,TEXT_TY,((LocalParking-->0=t_0)*0+text_routine_105)),0,0) ))  {
         ! phrase 24
         ! [24: say ~[hint6][paragraph break]~]
         say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->50); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say212; .L_SayX207;
         ! phrase 25
         ! [25: end if]
         }

      ! phrase 26
      ! [26: if hint7 matches the text ~[T]~ begin]
       if (( IT_Replace_RE(CHR_BLOB,(Global_Vars-->51),BlkValueCast((blockv_stack-->(I7BASPL+10)),INDEXED_TEXT_TY,TEXT_TY,((LocalParking-->0=t_0)*0+text_routine_106)),0,0) ))  {
         ! phrase 27
         ! [27: say ~[hint7][paragraph break]~]
         say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->51); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say213; .L_SayX208;
         ! phrase 28
         ! [28: end if]
         }

      ! phrase 29
      ! [29: if hint8 matches the text ~[T]~ begin]
       if (( IT_Replace_RE(CHR_BLOB,(Global_Vars-->52),BlkValueCast((blockv_stack-->(I7BASPL+11)),INDEXED_TEXT_TY,TEXT_TY,((LocalParking-->0=t_0)*0+text_routine_107)),0,0) ))  {
         ! phrase 30
         ! [30: say ~[hint8][paragraph break]~]
         say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->52); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say214; .L_SayX209;
         ! phrase 31
         ! [31: end if]
         }

      ! phrase 32
      ! [32: if hint9 matches the text ~[T]~ begin]
       if (( IT_Replace_RE(CHR_BLOB,(Global_Vars-->53),BlkValueCast((blockv_stack-->(I7BASPL+12)),INDEXED_TEXT_TY,TEXT_TY,((LocalParking-->0=t_0)*0+text_routine_108)),0,0) ))  {
         ! phrase 33
         ! [33: say ~[hint9][paragraph break]~]
         say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->53); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say215; .L_SayX210;
         ! phrase 34
         ! [34: end if]
         }

      ! phrase 35
      ! [35: if hint10 matches the text ~[T]~ begin]
       if (( IT_Replace_RE(CHR_BLOB,(Global_Vars-->54),BlkValueCast((blockv_stack-->(I7BASPL+13)),INDEXED_TEXT_TY,TEXT_TY,((LocalParking-->0=t_0)*0+text_routine_109)),0,0) ))  {
         ! phrase 36
         ! [36: say ~[hint10][paragraph break]~]
         say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->54); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say216; .L_SayX211;
         ! phrase 37
         ! [37: end if]
         }

      ! phrase 38
      ! [38: if hint11 matches the text ~[T]~ begin]
       if (( IT_Replace_RE(CHR_BLOB,(Global_Vars-->55),BlkValueCast((blockv_stack-->(I7BASPL+14)),INDEXED_TEXT_TY,TEXT_TY,((LocalParking-->0=t_0)*0+text_routine_110)),0,0) ))  {
         ! phrase 39
         ! [39: say ~[hint11][paragraph break]~]
         say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->55); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say217; .L_SayX212;
         ! phrase 40
         ! [40: end if]
         }

      ! phrase 41
      ! [41: if hint12 matches the text ~[T]~ begin]
       if (( IT_Replace_RE(CHR_BLOB,(Global_Vars-->56),BlkValueCast((blockv_stack-->(I7BASPL+15)),INDEXED_TEXT_TY,TEXT_TY,((LocalParking-->0=t_0)*0+text_routine_111)),0,0) ))  {
         ! phrase 42
         ! [42: say ~[hint12][paragraph break]~]
         say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->56); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say218; .L_SayX213;
         ! phrase 43
         ! [43: end if]
         }

      ! phrase 44
      ! [44: if hint13 matches the text ~[T]~ begin]
       if (( IT_Replace_RE(CHR_BLOB,(Global_Vars-->57),BlkValueCast((blockv_stack-->(I7BASPL+16)),INDEXED_TEXT_TY,TEXT_TY,((LocalParking-->0=t_0)*0+text_routine_112)),0,0) ))  {
         ! phrase 45
         ! [45: say ~[hint13][paragraph break]~]
         say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->57); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say219; .L_SayX214;
         ! phrase 46
         ! [46: end if]
         }

      ! phrase 47
      ! [47: if hint14 matches the text ~[T]~ begin]
       if (( IT_Replace_RE(CHR_BLOB,(Global_Vars-->58),BlkValueCast((blockv_stack-->(I7BASPL+17)),INDEXED_TEXT_TY,TEXT_TY,((LocalParking-->0=t_0)*0+text_routine_113)),0,0) ))  {
         ! phrase 48
         ! [48: say ~[hint14][paragraph break]~]
         say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->58); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say220; .L_SayX215;
         ! phrase 49
         ! [49: end if]
         }

      ! phrase 50
      ! [50: if hint15 matches the text ~[T]~ begin]
       if (( IT_Replace_RE(CHR_BLOB,(Global_Vars-->59),BlkValueCast((blockv_stack-->(I7BASPL+18)),INDEXED_TEXT_TY,TEXT_TY,((LocalParking-->0=t_0)*0+text_routine_114)),0,0) ))  {
         ! phrase 51
         ! [51: say ~[hint15][paragraph break]~]
         say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->59); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say221; .L_SayX216;
         ! phrase 52
         ! [52: end if]
         }

      ! phrase 53
      ! [53: if hint16 matches the text ~[T]~ begin]
       if (( IT_Replace_RE(CHR_BLOB,(Global_Vars-->60),BlkValueCast((blockv_stack-->(I7BASPL+19)),INDEXED_TEXT_TY,TEXT_TY,((LocalParking-->0=t_0)*0+text_routine_115)),0,0) ))  {
         ! phrase 54
         ! [54: say ~[hint16][paragraph break]~]
         say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->60); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say222; .L_SayX217;
         ! phrase 55
         ! [55: end if]
         }

      ! phrase 56
      ! [56: if hint17 matches the text ~[T]~ begin]
       if (( IT_Replace_RE(CHR_BLOB,(Global_Vars-->61),BlkValueCast((blockv_stack-->(I7BASPL+20)),INDEXED_TEXT_TY,TEXT_TY,((LocalParking-->0=t_0)*0+text_routine_116)),0,0) ))  {
         ! phrase 57
         ! [57: say ~[hint17][paragraph break]~]
         say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->61); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say223; .L_SayX218;
         ! phrase 58
         ! [58: end if]
         }

      ! phrase 59
      ! [59: if hint18 matches the text ~[T]~ begin]
       if (( IT_Replace_RE(CHR_BLOB,(Global_Vars-->62),BlkValueCast((blockv_stack-->(I7BASPL+21)),INDEXED_TEXT_TY,TEXT_TY,((LocalParking-->0=t_0)*0+text_routine_117)),0,0) ))  {
         ! phrase 60
         ! [60: say ~[hint18][paragraph break]~]
         say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->62); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say224; .L_SayX219;
         ! phrase 61
         ! [61: end if]
         }

      ! phrase 62
      ! [62: if hint19 matches the text ~[T]~ begin]
       if (( IT_Replace_RE(CHR_BLOB,(Global_Vars-->63),BlkValueCast((blockv_stack-->(I7BASPL+22)),INDEXED_TEXT_TY,TEXT_TY,((LocalParking-->0=t_0)*0+text_routine_118)),0,0) ))  {
         ! phrase 63
         ! [63: say ~[hint19][paragraph break]~]
         say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->63); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say225; .L_SayX220;
         ! phrase 64
         ! [64: end if]
         }

      ! phrase 65
      ! [65: if hint20 matches the text ~[T]~ begin]
       if (( IT_Replace_RE(CHR_BLOB,(Global_Vars-->64),BlkValueCast((blockv_stack-->(I7BASPL+23)),INDEXED_TEXT_TY,TEXT_TY,((LocalParking-->0=t_0)*0+text_routine_119)),0,0) ))  {
         ! phrase 66
         ! [66: say ~[hint20][paragraph break]~]
         say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->64); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say226; .L_SayX221;
         ! phrase 67
         ! [67: end if]
         }

      ! phrase 68
      ! [68: if hint21 matches the text ~[T]~ begin]
       if (( IT_Replace_RE(CHR_BLOB,(Global_Vars-->65),BlkValueCast((blockv_stack-->(I7BASPL+24)),INDEXED_TEXT_TY,TEXT_TY,((LocalParking-->0=t_0)*0+text_routine_120)),0,0) ))  {
         ! phrase 69
         ! [69: say ~[hint21][paragraph break]~]
         say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->65); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say227; .L_SayX222;
         ! phrase 70
         ! [70: end if]
         }

      ! phrase 71
      ! [71: if hint22 matches the text ~[T]~ begin]
       if (( IT_Replace_RE(CHR_BLOB,(Global_Vars-->66),BlkValueCast((blockv_stack-->(I7BASPL+25)),INDEXED_TEXT_TY,TEXT_TY,((LocalParking-->0=t_0)*0+text_routine_121)),0,0) ))  {
         ! phrase 72
         ! [72: say ~[hint22][paragraph break]~]
         say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->66); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say228; .L_SayX223;
         ! phrase 73
         ! [73: end if]
         }

      ! phrase 74
      ! [74: if hint23 matches the text ~[T]~ begin]
       if (( IT_Replace_RE(CHR_BLOB,(Global_Vars-->67),BlkValueCast((blockv_stack-->(I7BASPL+26)),INDEXED_TEXT_TY,TEXT_TY,((LocalParking-->0=t_0)*0+text_routine_122)),0,0) ))  {
         ! phrase 75
         ! [75: say ~[hint23][paragraph break]~]
         say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->67); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say229; .L_SayX224;
         ! phrase 76
         ! [76: end if]
         }

      ! phrase 77
      ! [77: if hint24 matches the text ~[T]~ begin]
       if (( IT_Replace_RE(CHR_BLOB,(Global_Vars-->68),BlkValueCast((blockv_stack-->(I7BASPL+27)),INDEXED_TEXT_TY,TEXT_TY,((LocalParking-->0=t_0)*0+text_routine_123)),0,0) ))  {
         ! phrase 78
         ! [78: say ~[hint24][paragraph break]~]
         say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->68); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say230; .L_SayX225;
         ! phrase 79
         ! [79: end if]
         }

      ! phrase 80
      ! [80: now the command prompt is ~>~]
       (Global_Vars-->1) = SC_74; 
      ! phrase 81
      ! [81: rule succeeds]
       RulebookSucceeds(); rtrue; 
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1093, 1093, true);
   rfalse;
];
! No specific request
! after reading a command when the player is in corridor:
[ R_1174 ;
   if ((((((I252_corridor == ContainerOf(player))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1174, 1174);
      ! phrase 1
      ! [1: if the player's command includes ~get in~ begin]
       if (( (matched_text=SnippetIncludes(Consult_Grammar_299,players_command)) ))  {
         ! phrase 2
         ! [2: unless elevator is in corridor begin]
          if (~~(((I252_corridor == ContainerOf(I249_elevator)))))  {
            ! phrase 3
            ! [3: say ~The elevator seems to be being used at the moment. There are stairs, you know. do you know what they are?~ instead]
            say__p=1;ParaContent();  print (PrintText) SC_426;  new_line; rtrue; .L_Say231; .L_SayX226; rtrue;
            ! phrase 4
            ! [4: end unless]
            }

         ! phrase 5
         ! [5: otherwise if the player's command includes ~push~]
          } else if (( (matched_text=SnippetIncludes(Consult_Grammar_300,players_command)) )) { 
         ! phrase 6
         ! [6: unless elevator is in corridor begin]
          if (~~(((I252_corridor == ContainerOf(I249_elevator)))))  {
            ! phrase 7
            ! [7: say ~The elevator seems to be being used at the moment. There are stairs, you know. do you know what they are?~ instead]
            say__p=1;ParaContent();  print (PrintText) SC_426;  new_line; rtrue; .L_Say232; .L_SayX227; rtrue;
            ! phrase 8
            ! [8: end unless]
            }

         ! phrase 9
         ! [9: otherwise if the player's command includes ~elevator~]
          } else if (( (matched_text=SnippetIncludes(Consult_Grammar_301,players_command)) )) { 
         ! phrase 10
         ! [10: unless elevator is in corridor begin]
          if (~~(((I252_corridor == ContainerOf(I249_elevator)))))  {
            ! phrase 11
            ! [11: say ~The elevator seems to be being used at the moment. There are stairs, you know. do you know what they are?~ instead]
            say__p=1;ParaContent();  print (PrintText) SC_426;  new_line; rtrue; .L_Say233; .L_SayX228; rtrue;
            ! phrase 12
            ! [12: end unless]
            }

         ! phrase 13
         ! [13: otherwise if the player's command includes ~press~]
          } else if (( (matched_text=SnippetIncludes(Consult_Grammar_302,players_command)) )) { 
         ! phrase 14
         ! [14: unless elevator is in corridor begin]
          if (~~(((I252_corridor == ContainerOf(I249_elevator)))))  {
            ! phrase 15
            ! [15: say ~The elevator seems to be being used at the moment. There are stairs, you know. do you know what they are?~ instead]
            say__p=1;ParaContent();  print (PrintText) SC_426;  new_line; rtrue; .L_Say234; .L_SayX229; rtrue;
            ! phrase 16
            ! [16: end unless]
            }

         ! phrase 17
         ! [17: end if]
         }

   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1174, 1174, true);
   rfalse;
];
! No specific request
! after reading a command when the lexicon is table 10:
[ R_1236 ;blockv_stack-->(blockv_sp+2) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+1) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+0) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_sp = blockv_sp + 3;
    blockv_stack-->(blockv_sp++) = R_SHELL_4(blockv_sp-3);
    blockv_sp = blockv_sp - 4;
    BlkFree(blockv_stack-->(blockv_sp+2));
    BlkFree(blockv_stack-->(blockv_sp+1));
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+3);
];
[ R_SHELL_4 I7BASPL 
    t_0 ! Local variable e.g. 'T' = indexed text
    ;
   if (((((((Global_Vars-->72) == T22_chatting_part_of_mrmason)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1236, 1236);
      ! phrase 1
      ! [1: let t be indexed text]
       t_0 = (blockv_stack-->(I7BASPL+0)); 
      ! phrase 2
      ! [2: let t be the player's command]
       BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
      ! phrase 3
      ! [3: replace the regular expression ~@{5C}p~ in t with ~~]
       IT_Replace_RE(REGEXP_BLOB, t_0, BlkValueCast((blockv_stack-->(I7BASPL+1)),INDEXED_TEXT_TY,TEXT_TY,SC_427),
		BlkValueCast((blockv_stack-->(I7BASPL+2)),INDEXED_TEXT_TY,TEXT_TY,EMPTY_TEXT_VALUE), 0); 
      ! phrase 4
      ! [4: change the text of the player's command to t]
       SetPlayersCommand(t_0); 
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1236, 1236, true);
   rfalse;
];
! No specific request
! After reading a command when the command prompt is ~What do you want to write: ~:
[ R_1242 ;
   if (((((((Global_Vars-->1) == SC_255)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1242, 1242);
      ! phrase 1
      ! [1: if word at the start of the player's command includes ~write~ begin]
       if (( (matched_text=SnippetIncludes(Consult_Grammar_303,(PHR_874_r15 ( players_command/100 )))) ))  {
         ! phrase 2
         ! [2: cut the matched text]
          SpliceSnippet(matched_text, 0); 
         ! phrase 3
         ! [3: now notepad desc is the player's command]
          BlkValueCast((Global_Vars-->74), INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 4
         ! [4: say ~You write '[player's command]'~]
         say__p=1;ParaContent();  print (PrintText) SC_256; ParaContent();  print (PrintSnippet) players_command; ParaContent();  print (PrintText) SC_327;  .L_Say235; .L_SayX230;
         ! phrase 5
         ! [5: now the command prompt is ~>~ instead]
          (Global_Vars-->1) = SC_74;  rtrue;
         ! phrase 6
         ! [6: otherwise]
         } else {

         ! phrase 7
         ! [7: now notepad desc is the player's command]
          BlkValueCast((Global_Vars-->74), INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 8
         ! [8: now the command prompt is ~>~]
          (Global_Vars-->1) = SC_74; 
         ! phrase 9
         ! [9: say ~You write '[player's command]'~ instead]
         say__p=1;ParaContent();  print (PrintText) SC_256; ParaContent();  print (PrintSnippet) players_command; ParaContent();  print (PrintText) SC_327;  rtrue; .L_Say236; .L_SayX231; rtrue;
         ! phrase 10
         ! [10: end if]
         }

   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1242, 1242, true);
   rfalse;
];
! No specific request
! after reading a command when the location is dining room:
[ R_1283 ;blockv_stack-->(blockv_sp+0) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_sp = blockv_sp + 1;
    blockv_stack-->(blockv_sp++) = R_SHELL_5(blockv_sp-1);
    blockv_sp = blockv_sp - 2;
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+1);
];
[ R_SHELL_5 I7BASPL ;
   if ((((((real_location == I301_dining_room)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1283, 1283);
      ! phrase 1
      ! [1: if the player's command matches ~look chairs~ begin]
       if (( (SnippetMatches(players_command, Consult_Grammar_304)) ))  {
         ! phrase 2
         ! [2: change the text of the player's command to ~look chair~]
          SetPlayersCommand(BlkValueCast((blockv_stack-->(I7BASPL+0)),INDEXED_TEXT_TY,TEXT_TY,SC_428)); 
         ! phrase 3
         ! [3: continue the action]
          rfalse; 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1283, 1283, true);
   rfalse;
];
! No specific request
! after reading a command when the player's command matches ~sit down~:
[ R_1288 ;blockv_stack-->(blockv_sp+0) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_sp = blockv_sp + 1;
    blockv_stack-->(blockv_sp++) = R_SHELL_6(blockv_sp-1);
    blockv_sp = blockv_sp - 2;
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+1);
];
[ R_SHELL_6 I7BASPL ;
   if ((((( (SnippetMatches(players_command, Consult_Grammar_305)) ))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1288, 1288);
      ! phrase 1
      ! [1: if location is living-room begin]
       if (((real_location == I304_living_room)))  {
         ! phrase 2
         ! [2: set pronouns from armchair]
          PronounNotice(I322_armchair); 
         ! phrase 3
         ! [3: change the text of the player's command to ~Sit on it~]
          SetPlayersCommand(BlkValueCast((blockv_stack-->(I7BASPL+0)),INDEXED_TEXT_TY,TEXT_TY,SC_429)); 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1288, 1288, true);
   rfalse;
];
! No specific request
! after reading a command during uncle vernon's scene:
[ R_1143 ;blockv_stack-->(blockv_sp+1) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+0) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_sp = blockv_sp + 2;
    blockv_stack-->(blockv_sp++) = R_SHELL_7(blockv_sp-2);
    blockv_sp = blockv_sp - 3;
    BlkFree(blockv_stack-->(blockv_sp+1));
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+2);
];
[ R_SHELL_7 I7BASPL ;
   if (scene_status-->1 == 1) { ! Runs only during scene
   if (debug_rules) DB_Rule(R_1143, 1143);
      ! phrase 1
      ! [1: if the player's command includes ~unlock case~ begin]
       if (( (matched_text=SnippetIncludes(Consult_Grammar_306,players_command)) ))  {
         ! phrase 2
         ! [2: change the text of the player's command to ~unlock case with dursley~]
          SetPlayersCommand(BlkValueCast((blockv_stack-->(I7BASPL+0)),INDEXED_TEXT_TY,TEXT_TY,SC_430)); 
         ! phrase 3
         ! [3: continue the action]
          rfalse; 
         ! phrase 4
         ! [4: otherwise if the player's command includes ~unlock suitcase~]
          } else if (( (matched_text=SnippetIncludes(Consult_Grammar_307,players_command)) )) { 
         ! phrase 5
         ! [5: change the text of the player's command to ~unlock case with dursley~]
          SetPlayersCommand(BlkValueCast((blockv_stack-->(I7BASPL+1)),INDEXED_TEXT_TY,TEXT_TY,SC_430)); 
         ! phrase 6
         ! [6: continue the action]
          rfalse; 
         ! phrase 7
         ! [7: end if]
         }

   } ! Runs only during scene
   else if (debug_rules > 1) DB_Rule(R_1143, 1143, true);
   rfalse;
];
! No specific request
! after reading a command during work:
[ R_1227 ;blockv_stack-->(blockv_sp+2) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+1) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+0) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_sp = blockv_sp + 3;
    blockv_stack-->(blockv_sp++) = R_SHELL_8(blockv_sp-3);
    blockv_sp = blockv_sp - 4;
    BlkFree(blockv_stack-->(blockv_sp+2));
    BlkFree(blockv_stack-->(blockv_sp+1));
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+3);
];
[ R_SHELL_8 I7BASPL 
    t_0 ! Local variable e.g. '?-1,-1?' = indexed text
    ;
   if (scene_status-->2 == 1) { ! Runs only during scene
   if (debug_rules) DB_Rule(R_1227, 1227);
      ! phrase 1
      ! [1: unless the command prompt is ~What do you want to write: ~ begin]
       if (~~((((Global_Vars-->1) == SC_255))))  {
         ! phrase 2
         ! [2: if the venture of work is incomplete begin]
          if (((GProperty(SCENE_TY, I238_work,p80_venture) == I268_incomplete)))  {
            ! phrase 3
            ! [3: let t be indexed text]
             t_0 = (blockv_stack-->(I7BASPL+0)); 
            ! phrase 4
            ! [4: let t be the player's command]
             BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
            ! phrase 5
            ! [5: replace the regular expression ~@{5C}p~ in t with ~~]
             IT_Replace_RE(REGEXP_BLOB, t_0, BlkValueCast((blockv_stack-->(I7BASPL+1)),INDEXED_TEXT_TY,TEXT_TY,SC_427),
		BlkValueCast((blockv_stack-->(I7BASPL+2)),INDEXED_TEXT_TY,TEXT_TY,EMPTY_TEXT_VALUE), 0); 
            ! phrase 6
            ! [6: change the text of the player's command to t]
             SetPlayersCommand(t_0); 
            ! phrase 7
            ! [7: end if]
            }

         ! phrase 8
         ! [8: end unless]
         }

   } ! Runs only during scene
   else if (debug_rules > 1) DB_Rule(R_1227, 1227, true);
   rfalse;
];
! No specific request
! after reading a command during uncle vernon's scene:
[ R_1246 ;
   if (scene_status-->1 == 1) { ! Runs only during scene
   if (debug_rules) DB_Rule(R_1246, 1246);
      ! phrase 1
      ! [1: if the player's command includes ~cross road~ begin]
       if (( (matched_text=SnippetIncludes(Consult_Grammar_308,players_command)) ))  {
         ! phrase 2
         ! [2: if the location is grunnings carpark begin]
          if (((real_location == I244_grunnings_carpark)))  {
            ! phrase 3
            ! [3: now the player is in street]
             MoveObject(player,I285_street); 
            ! phrase 4
            ! [4: otherwise if the location is street]
             } else if (((real_location == I285_street))) { 
            ! phrase 5
            ! [5: now the player is in grunnings carpark]
             MoveObject(player,I244_grunnings_carpark); 
            ! phrase 6
            ! [6: end if]
            }

         ! phrase 7
         ! [7: rule succeeds]
          RulebookSucceeds(); rtrue; 
         ! phrase 8
         ! [8: end if]
         }

   } ! Runs only during scene
   else if (debug_rules > 1) DB_Rule(R_1246, 1246, true);
   rfalse;
];
! No specific request
! after reading a command during uncle vernon's scene:
[ R_1247 ;
   if (scene_status-->1 == 1) { ! Runs only during scene
   if (debug_rules) DB_Rule(R_1247, 1247);
      ! phrase 1
      ! [1: if the player's command includes ~cross highway~ begin]
       if (( (matched_text=SnippetIncludes(Consult_Grammar_309,players_command)) ))  {
         ! phrase 2
         ! [2: if the location is grunnings carpark begin]
          if (((real_location == I244_grunnings_carpark)))  {
            ! phrase 3
            ! [3: now the player is in street]
             MoveObject(player,I285_street); 
            ! phrase 4
            ! [4: otherwise if the location is street]
             } else if (((real_location == I285_street))) { 
            ! phrase 5
            ! [5: now the player is in grunnings carpark]
             MoveObject(player,I244_grunnings_carpark); 
            ! phrase 6
            ! [6: end if]
            }

         ! phrase 7
         ! [7: rule succeeds]
          RulebookSucceeds(); rtrue; 
         ! phrase 8
         ! [8: end if]
         }

   } ! Runs only during scene
   else if (debug_rules > 1) DB_Rule(R_1247, 1247, true);
   rfalse;
];
! No specific request
! after reading a command during uncle vernon's scene:
[ R_1248 ;
   if (scene_status-->1 == 1) { ! Runs only during scene
   if (debug_rules) DB_Rule(R_1248, 1248);
      ! phrase 1
      ! [1: if the player's command includes ~cross street~ begin]
       if (( (matched_text=SnippetIncludes(Consult_Grammar_310,players_command)) ))  {
         ! phrase 2
         ! [2: if the location is grunnings carpark begin]
          if (((real_location == I244_grunnings_carpark)))  {
            ! phrase 3
            ! [3: now the player is in street]
             MoveObject(player,I285_street); 
            ! phrase 4
            ! [4: otherwise if the location is street]
             } else if (((real_location == I285_street))) { 
            ! phrase 5
            ! [5: now the player is in grunnings carpark]
             MoveObject(player,I244_grunnings_carpark); 
            ! phrase 6
            ! [6: end if]
            }

         ! phrase 7
         ! [7: rule succeeds]
          RulebookSucceeds(); rtrue; 
         ! phrase 8
         ! [8: end if]
         }

   } ! Runs only during scene
   else if (debug_rules > 1) DB_Rule(R_1248, 1248, true);
   rfalse;
];
! No specific request
! after reading a command during uncle vernon's scene:
[ R_1271 ;
   if (scene_status-->1 == 1) { ! Runs only during scene
   if (debug_rules) DB_Rule(R_1271, 1271);
      ! phrase 1
      ! [1: if the player is in street begin]
       if (((I285_street == ContainerOf(player))))  {
         ! phrase 2
         ! [2: if bakers is visited begin]
          if ((((Adj_44_t1_v9(I287_bakers)))))  {
            ! phrase 3
            ! [3: if alreadylooked is 0 begin]
             if ((((Global_Vars-->78) == 0)))  {
               ! phrase 4
               ! [4: if the player's command includes ~look~ begin]
                if (( (matched_text=SnippetIncludes(Consult_Grammar_311,players_command)) ))  {
                  ! phrase 5
                  ! [5: now alreadylooked is 1]
                   (Global_Vars-->78) = 1; 
                  ! phrase 6
                  ! [6: try listening to instead]
                   TryAction(0, player, ##Listen, 0, 0);;  rtrue;
                  ! phrase 7
                  ! [7: end if]
                  }

               ! phrase 8
               ! [8: end if]
               }

            ! phrase 9
            ! [9: end if]
            }

         ! phrase 10
         ! [10: end if]
         }

   } ! Runs only during scene
   else if (debug_rules > 1) DB_Rule(R_1271, 1271, true);
   rfalse;
];
! No specific request
! after reading a command during uncle vernon's scene:
[ R_1324 ;blockv_stack-->(blockv_sp+0) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_sp = blockv_sp + 1;
    blockv_stack-->(blockv_sp++) = R_SHELL_9(blockv_sp-1);
    blockv_sp = blockv_sp - 2;
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+1);
];
[ R_SHELL_9 I7BASPL ;
   if (scene_status-->1 == 1) { ! Runs only during scene
   if (debug_rules) DB_Rule(R_1324, 1324);
      ! phrase 1
      ! [1: if the player carries a magic wand begin]
       if (((player == CarrierOf(I342_magic_wand))))  {
         ! phrase 2
         ! [2: if the player's command includes ~wave wand~ begin]
          if (( (matched_text=SnippetIncludes(Consult_Grammar_312,players_command)) ))  {
            ! phrase 3
            ! [3: change the text of the player's command to ~expelliarmus~]
             SetPlayersCommand(BlkValueCast((blockv_stack-->(I7BASPL+0)),INDEXED_TEXT_TY,TEXT_TY,SC_431)); 
            ! phrase 4
            ! [4: end if]
            }

         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only during scene
   else if (debug_rules > 1) DB_Rule(R_1324, 1324, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: after Deciding the scope (B79_after_deciding_the_scope)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! After deciding the scope of the player while the player reaches someone ( this is the establish connection rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Telephones" by George Tryfonas
! After deciding the scope of the player while the player reaches someone ( this is the establish connection rule ):
[ R_1029 ;
   if (((parameter_object == player) && (true))) { ! Runs only when pattern matches
   if (((((Prop_34()))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1029, 1029);
      ! phrase 1
      ! [1: place the other party of the player in scope]
       PlaceInScope(GProperty(9, player,p72_other_party), 0); 
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1029, 1029, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Deciding whether all includes (B84_for_deciding_whether_all)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Rule for deciding whether all includes scenery while taking ( this is the exclude scenery from take all rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Rule for deciding whether all includes fixed in place things while taking ( this is the exclude fixed in place things from take all rule ):
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 3/3 ! Rule for deciding whether all includes people while taking ( this is the exclude people from take all rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Rule for deciding whether all includes scenery while taking ( this is the exclude scenery from take all rule ):
[ R_62 ;
   if ((((Adj_52_t1_v9(parameter_object))))) { ! Runs only when pattern matches
   if (((((action ==##Take) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_62, 62);
      ! phrase 1
      ! [1: rule fails]
       RulebookFails(); rtrue; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_62, 62, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Rule for deciding whether all includes fixed in place things while taking ( this is the exclude fixed in place things from take all rule ):
[ R_64 ;
   if (((parameter_object ofclass K2_thing) && ((Adj_50_t1_v9(parameter_object))))) { ! Runs only when pattern matches
   if (((((action ==##Take) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_64, 64);
      ! phrase 1
      ! [1: rule fails]
       RulebookFails(); rtrue; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_64, 64, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Rule for deciding whether all includes people while taking ( this is the exclude people from take all rule ):
[ R_63 ;
   if (((parameter_object ofclass K8_person))) { ! Runs only when pattern matches
   if (((((action ==##Take) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_63, 63);
      ! phrase 1
      ! [1: rule fails]
       RulebookFails(); rtrue; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_63, 63, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing a parser error (B93_for_printing_a_parser_er)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! rule for printing a parser error when dialyes/no is 1:
! ----------------------------------------------------------------------------------------------------
! No specific request
! rule for printing a parser error when dialyes/no is 1:
[ R_1207 ;
   if (((((((Global_Vars-->71) == 1)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1207, 1207);
      ! phrase 1
      ! [1: increment bored]
       (Global_Vars-->70) = (Global_Vars-->70) + 1; 
      ! phrase 2
      ! [2: say ~The customer doesn't understand you. Much like the rest of the world.~ instead]
      say__p=1;ParaContent();  print (PrintText) SC_211;  new_line; rtrue; .L_Say237; .L_SayX232; rtrue;
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1207, 1207, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Supplying a missing noun (B96_for_supplying_a_missing_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Rule for supplying a missing noun while an actor smelling ( this is the ambient odour rule ):
!   === which is equally specific with ===
! Rule 2/4 ! Rule for supplying a missing noun while an actor listening ( this is the ambient sound rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Rule for supplying a missing noun while an actor going ( this is the block vaguely going rule ):
! --- now the last-placed rules ---
! Rule 4/4 ! Rule for supplying a missing noun while entering ( this is the find what to enter rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Rule for supplying a missing noun while an actor smelling ( this is the ambient odour rule ):
[ R_65 ;
   if (((((action ==##Smell) && (act_requester==nothing))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_65, 65);
      ! phrase 1
      ! [1: now the noun is the location]
       noun = real_location; 
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_65, 65, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Rule for supplying a missing noun while an actor listening ( this is the ambient sound rule ):
[ R_66 ;
   if (((((action ==##Listen) && (act_requester==nothing))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_66, 66);
      ! phrase 1
      ! [1: now the noun is the location]
       noun = real_location; 
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_66, 66, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Rule for supplying a missing noun while an actor going ( this is the block vaguely going rule ):
[ R_67 ;
   if (((((action ==##Go) && (act_requester==nothing))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_67, 67);
      ! phrase 1
      ! [1: issue library message going action number 7]
       GL__M(##Go,7,noun); 
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_67, 67, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Rule for supplying a missing noun while entering ( this is the find what to enter rule ):
[ R_148 
    t_0 ! Local variable e.g. 'box' = thing
    ;
   if (((((action ==##Enter) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_148, 148);
      ! phrase 1
      ! [1: if something enterable ( called the box ) is in the location , now the noun is the box]
       if ((Prop_35() && (t_0=deferred_calling_list-->0, true))) {  noun = t_0;   }
      ! phrase 2
      ! [2: otherwise continue the activity]
       else {  rfalse;   }
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_148, 148, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Supplying a missing second noun (B99_for_supplying_a_missing_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for supplying a missing second noun while dialling:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Telephones" by George Tryfonas
! Rule for supplying a missing second noun while dialling:
[ R_1032 ;
   if (((((action ==##A113_dialling_it_on) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1032, 1032);
      ! phrase 1
      ! [1: assign a phone]
      (PHR_1033_r16 ());
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1032, 1032, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Handling the final question (B113_before_handling_the_fin)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! This is the print the final question rule:
!   === which is equally specific with ===
! Rule 2/3 ! This is the print the final prompt rule:
! --- now the last-placed rules ---
! Rule 3/3: READ_FINAL_ANSWER_R
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! This is the print the final question rule:
[ R_69 
    t_0 ! Local variable e.g. 'named options count' = number
    t_1 ! Local variable e.g. '?-1,-1?' = number
    t_2 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: let named options count be 0]
       t_0 = 0; 
      ! phrase 2
      ! [2: repeat through the table of final question options begin]
       @push ct_0; @push ct_1;
		for (t_1=T0_final_question_options,t_2=1,ct_0=t_1,ct_1=t_2:
			t_2<=TableRows(t_1):t_2++,ct_0=t_1,ct_1=t_2)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
         ! phrase 3
         ! [3: if the only if victorious entry is false or the story has ended finally begin]
          if (((((TableLookUpEntry(ct_0,101,ct_1) && true) == (0 && true)))) || (( (story_complete) )))  {
            ! phrase 4
            ! [4: if there is a final response rule entry or the final response activity entry is not empty begin]
             if ((( (ExistsTableLookUpEntry(ct_0,103,ct_1)) )) || (((~~(((Adj_16_t1_v29(TableLookUpEntry(ct_0,104,ct_1)))))))))  {
               ! phrase 5
               ! [5: if there is a final question wording entry , increase named options count by 1]
                if (( (ExistsTableLookUpEntry(ct_0,100,ct_1)) )) {  t_0 = t_0 + 1;   }
               ! phrase 6
               ! [6: end if]
               }

            ! phrase 7
            ! [7: end if]
            }

         ! phrase 8
         ! [8: end repeat]
         }
@pull ct_1; @pull ct_0;
      ! phrase 9
      ! [9: if the named options count is less than 1 , abide by the immediately quit rule]
       if (((t_0 < 1))) {  if (ProcessRulebook(IMMEDIATELY_QUIT_R)) rtrue;   }
      ! phrase 10
      ! [10: say ~Would you like to ~]
      say__p=1;ParaContent();  print (PrintText) SC_432;  .L_Say238; .L_SayX233;
      ! phrase 11
      ! [11: repeat through the table of final question options begin]
       @push ct_0; @push ct_1;
		for (t_1=T0_final_question_options,t_2=1,ct_0=t_1,ct_1=t_2:
			t_2<=TableRows(t_1):t_2++,ct_0=t_1,ct_1=t_2)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
         ! phrase 12
         ! [12: if the only if victorious entry is false or the story has ended finally begin]
          if (((((TableLookUpEntry(ct_0,101,ct_1) && true) == (0 && true)))) || (( (story_complete) )))  {
            ! phrase 13
            ! [13: if there is a final response rule entry or the final response activity entry is not empty begin]
             if ((( (ExistsTableLookUpEntry(ct_0,103,ct_1)) )) || (((~~(((Adj_16_t1_v29(TableLookUpEntry(ct_0,104,ct_1)))))))))  {
               ! phrase 14
               ! [14: if there is a final question wording entry begin]
                if (( (ExistsTableLookUpEntry(ct_0,100,ct_1)) ))  {
                  ! phrase 15
                  ! [15: say final question wording entry]
                  say__p=1;ParaContent();  print (PrintText) TableLookUpEntry(ct_0,100,ct_1);  .L_Say239; .L_SayX234;
                  ! phrase 16
                  ! [16: decrease named options count by 1]
                   t_0 = t_0 - 1; 
                  ! phrase 17
                  ! [17: if the named options count is 0 begin]
                   if (((t_0 == 0)))  {
                     ! phrase 18
                     ! [18: say ~?[line break]~]
                     say__p=1;ParaContent();  print (PrintText) SC_433; ParaContent();  new_line;  .L_Say240; .L_SayX235;
                     ! phrase 19
                     ! [19: otherwise if the named options count is 1]
                      } else if (((t_0 == 1))) { 
                     ! phrase 20
                     ! [20: if the serial comma option is active , say ~,~]
                      if ((((Adj_22_t1_v15(5))))) { say__p=1;ParaContent();  print (PrintText) SC_434;  .L_Say241; .L_SayX236;  }
                     ! phrase 21
                     ! [21: say ~ or ~]
                     say__p=1;ParaContent();  print (PrintText) SC_435;  .L_Say242; .L_SayX237;
                     ! phrase 22
                     ! [22: otherwise]
                     } else {

                     ! phrase 23
                     ! [23: say ~, ~]
                     say__p=1;ParaContent();  print (PrintText) SC_436;  .L_Say243; .L_SayX238;
                     ! phrase 24
                     ! [24: end if]
                     }

                  ! phrase 25
                  ! [25: end if]
                  }

               ! phrase 26
               ! [26: end if]
               }

            ! phrase 27
            ! [27: end if]
            }

         ! phrase 28
         ! [28: end repeat]
         }
@pull ct_1; @pull ct_0;
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the print the final prompt rule:
[ R_68 ;
      ! phrase 1
      ! [1: say ~> [run paragraph on]~]
      say__p=1;ParaContent();  print (PrintText) SC_437; ParaContent();  RunParagraphOn();  .L_Say244; .L_SayX239;
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Handling the final question (B114_for_handling_the_final_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! This is the standard respond to final question rule:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! This is the standard respond to final question rule:
[ R_70 
    t_0 ! Local variable e.g. '?-1,-1?' = number
    t_1 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: repeat through the table of final question options begin]
       @push ct_0; @push ct_1;
		for (t_0=T0_final_question_options,t_1=1,ct_0=t_0,ct_1=t_1:
			t_1<=TableRows(t_0):t_1++,ct_0=t_0,ct_1=t_1)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
         ! phrase 2
         ! [2: if the only if victorious entry is false or the story has ended finally begin]
          if (((((TableLookUpEntry(ct_0,101,ct_1) && true) == (0 && true)))) || (( (story_complete) )))  {
            ! phrase 3
            ! [3: if there is a final response rule entry or the final response activity entry is not empty begin]
             if ((( (ExistsTableLookUpEntry(ct_0,103,ct_1)) )) || (((~~(((Adj_16_t1_v29(TableLookUpEntry(ct_0,104,ct_1)))))))))  {
               ! phrase 4
               ! [4: if the player's command matches the topic entry begin]
                if (( (SnippetMatches(players_command, TableLookUpEntry(ct_0,102,ct_1))) ))  {
                  ! phrase 5
                  ! [5: if there is a final response rule entry , abide by final response rule entry]
                   if (( (ExistsTableLookUpEntry(ct_0,103,ct_1)) )) {  if (ProcessRulebook(TableLookUpEntry(ct_0,103,ct_1))) rtrue;   }
                  ! phrase 6
                  ! [6: otherwise carry out the final response activity entry activity]
                   else {  CarryOutActivity(TableLookUpEntry(ct_0,104,ct_1));   }
                  ! phrase 7
                  ! [7: rule succeeds]
                   RulebookSucceeds(); rtrue; 
                  ! phrase 8
                  ! [8: end if]
                  }

               ! phrase 9
               ! [9: end if]
               }

            ! phrase 10
            ! [10: end if]
            }

         ! phrase 11
         ! [11: end repeat]
         }
@pull ct_1; @pull ct_0;
      ! phrase 12
      ! [12: issue miscellaneous library message number 8]
       GL__M(##Miscellany,8); 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Printing the locale description (B116_before_printing_the_loc)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Before printing the locale description ( this is the initialise locale description rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Before printing the locale description ( this is the find notable locale objects rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Before printing the locale description ( this is the initialise locale description rule ):
[ R_73 
    t_0 ! Local variable e.g. '?-1,-1?' = number
    t_1 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: now the locale paragraph count is 0]
       (Global_Vars-->8) = 0; 
      ! phrase 2
      ! [2: repeat with item running through things begin]
       for (t_0=Prop_36(0), t_1=Prop_36(t_0): t_0: t_0=t_1, t_1=Prop_36(t_1))  {
         ! phrase 3
         ! [3: now the item is not mentioned]
          (Adj_60_t3_v9(t_0)); 
         ! phrase 4
         ! [4: end repeat]
         }

      ! phrase 5
      ! [5: repeat through the table of locale priorities begin]
       @push ct_0; @push ct_1;
		for (t_0=T1_locale_priorities,t_1=1,ct_0=t_0,ct_1=t_1:
			t_1<=TableRows(t_0):t_1++,ct_0=t_0,ct_1=t_1)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
         ! phrase 6
         ! [6: blank out the whole row]
          TableBlankOutRow(ct_0, ct_1); 
         ! phrase 7
         ! [7: end repeat]
         }
@pull ct_1; @pull ct_0;
   rfalse;
];
! No specific request
! From the Standard Rules
! Before printing the locale description ( this is the find notable locale objects rule ):
[ R_74 
    t_0 ! Local variable e.g. 'domain' = object
    ;
      ! phrase 1
      ! [1: let the domain be the parameter-object]
       t_0 = parameter_object; 
      ! phrase 2
      ! [2: carry out the choosing notable locale objects activity with the domain]
       CarryOutActivity(V30_choosing_notable_locale_, t_0); 
      ! phrase 3
      ! [3: continue the activity]
       rfalse; 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the locale description (B117_for_printing_the_locale)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! For printing the locale description ( this is the interesting locale paragraphs rule ):
!   === which is equally specific with ===
! Rule 2/2 ! For printing the locale description ( this is the you-can-also-see rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! For printing the locale description ( this is the interesting locale paragraphs rule ):
[ R_75 
    t_0 ! Local variable e.g. 'domain' = object
    t_1 ! Local variable e.g. '?-1,-1?' = number
    t_2 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: let the domain be the parameter-object]
       t_0 = parameter_object; 
      ! phrase 2
      ! [2: sort the table of locale priorities in locale description priority order]
       TableSort(T1_locale_priorities, 106, 1); 
      ! phrase 3
      ! [3: repeat through the table of locale priorities begin]
       @push ct_0; @push ct_1;
		for (t_1=T1_locale_priorities,t_2=1,ct_0=t_1,ct_1=t_2:
			t_2<=TableRows(t_1):t_2++,ct_0=t_1,ct_1=t_2)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
         ! phrase 4
         ! [4: carry out the printing a locale paragraph about activity with the notable-object entry]
          CarryOutActivity(V31_printing_a_locale_paragr, TableLookUpEntry(ct_0,105,ct_1)); 
         ! phrase 5
         ! [5: end repeat]
         }
@pull ct_1; @pull ct_0;
      ! phrase 6
      ! [6: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   rfalse;
];
! No specific request
! From the Standard Rules
! For printing the locale description ( this is the you-can-also-see rule ):
[ R_76 
    t_0 ! Local variable e.g. 'domain' = object
    t_1 ! Local variable e.g. 'mentionable count' = number
    t_2 ! Local variable e.g. '?-1,-1?' = object
    t_3 ! Local variable e.g. '?-1,-1?' = truth state
    t_4 ! Local variable e.g. '?-1,-1?' = thing
    t_5 ! Local variable e.g. '?-1,-1?' = thing
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: let the domain be the parameter-object]
       t_0 = parameter_object; 
      ! phrase 2
      ! [2: let the mentionable count be 0]
       t_1 = 0; 
      ! phrase 3
      ! [3: repeat with item running through things begin]
       for (t_2=Prop_37(0), t_3=Prop_37(t_2): t_2: t_2=t_3, t_3=Prop_37(t_3))  {
         ! phrase 4
         ! [4: now the item is not marked for listing]
          (Adj_58_t3_v9(t_2)); 
         ! phrase 5
         ! [5: end repeat]
         }

      ! phrase 6
      ! [6: repeat through the table of locale priorities begin]
       @push ct_0; @push ct_1;
		for (t_2=T1_locale_priorities,t_3=1,ct_0=t_2,ct_1=t_3:
			t_3<=TableRows(t_2):t_3++,ct_0=t_2,ct_1=t_3)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
         ! phrase 7
         ! [7: if the locale description priority entry is greater than 0 , now the notable-object entry is marked for listing]
          if (((TableLookUpEntry(ct_0,106,ct_1) > 0))) {  (Adj_58_t2_v9(TableLookUpEntry(ct_0,105,ct_1)));   }
         ! phrase 8
         ! [8: increase the mentionable count by 1]
          t_1 = t_1 + 1; 
         ! phrase 9
         ! [9: end repeat]
         }
@pull ct_1; @pull ct_0;
      ! phrase 10
      ! [10: if the mentionable count is greater than 0 begin]
       if (((t_1 > 0)))  {
         ! phrase 11
         ! [11: repeat with item running through things begin]
          for (t_2=Prop_38(0), t_3=Prop_38(t_2): t_2: t_2=t_3, t_3=Prop_38(t_3))  {
            ! phrase 12
            ! [12: if the item is mentioned begin]
             if ((((Adj_60_t1_v9(t_2)))))  {
               ! phrase 13
               ! [13: now the item is not marked for listing]
                (Adj_58_t3_v9(t_2)); 
               ! phrase 14
               ! [14: end if]
               }

            ! phrase 15
            ! [15: end repeat]
            }

         ! phrase 16
         ! [16: begin the listing nondescript items activity with the domain]
          BeginActivity(V7_listing_nondescript_items, t_0); 
         ! phrase 17
         ! [17: if the number of marked for listing things is 0 begin]
          if ((( (Prop_39())  == 0)))  {
            ! phrase 18
            ! [18: abandon the listing nondescript items activity with the domain]
             AbandonActivity(V7_listing_nondescript_items, t_0); 
            ! phrase 19
            ! [19: otherwise]
            } else {

            ! phrase 20
            ! [20: if handling the listing nondescript items activity begin]
             if (( (~~(ForActivity(V7_listing_nondescript_items))) ))  {
               ! phrase 21
               ! [21: if the domain is a room begin]
                if (((t_0 ofclass K1_room)))  {
                  ! phrase 22
                  ! [22: if the domain is the location , say ~You ~]
                   if (((t_0 == real_location))) { say__p=1;ParaContent();  print (PrintText) SC_438;  .L_Say245; .L_SayX240;  }
                  ! phrase 23
                  ! [23: otherwise say ~In [the domain] you ~]
                   else { say__p=1;ParaContent();  print (PrintText) SC_439; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_440;  .L_Say246; .L_SayX241;  }
                  ! phrase 24
                  ! [24: otherwise if the domain is a supporter]
                   } else if (((t_0 ofclass K6_supporter))) { 
                  ! phrase 25
                  ! [25: say ~On [the domain] you ~]
                  say__p=1;ParaContent();  print (PrintText) SC_441; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_440;  .L_Say247; .L_SayX242;
                  ! phrase 26
                  ! [26: otherwise if the domain is an animal]
                   } else if (((t_0 ofclass K12_animal))) { 
                  ! phrase 27
                  ! [27: say ~On [the domain] you ~]
                  say__p=1;ParaContent();  print (PrintText) SC_441; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_440;  .L_Say248; .L_SayX243;
                  ! phrase 28
                  ! [28: otherwise]
                  } else {

                  ! phrase 29
                  ! [29: say ~In [the domain] you ~]
                  say__p=1;ParaContent();  print (PrintText) SC_439; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_440;  .L_Say249; .L_SayX244;
                  ! phrase 30
                  ! [30: end if]
                  }

               ! phrase 31
               ! [31: say ~can [if the locale paragraph count is greater than 0]also [end if]see ~]
               say__p=1;ParaContent();  print (PrintText) SC_442; 
	if (~~(((((Global_Vars-->8) > 0))))) jump L_Say250;
		ParaContent();  print (PrintText) SC_443; 
	.L_Say250; .L_SayX245;
		ParaContent();  print (PrintText) SC_444;  .L_Say251; .L_SayX246;
               ! phrase 32
               ! [32: let the common holder be nothing]
                t_2 = nothing; 
               ! phrase 33
               ! [33: let contents form of list be true]
                t_3 = 1; 
               ! phrase 34
               ! [34: repeat with list item running through marked for listing things begin]
                for (t_4=Prop_40(0), t_5=Prop_40(t_4): t_4: t_4=t_5, t_5=Prop_40(t_5))  {
                  ! phrase 35
                  ! [35: if the holder of the list item is not the common holder begin]
                   if (((~~(( (HolderOf(t_4))  == t_2)))))  {
                     ! phrase 36
                     ! [36: if the common holder is nothing , now the common holder is the holder of the list item]
                      if (((t_2 == nothing))) {  t_2 =  (HolderOf(t_4)) ;   }
                     ! phrase 37
                     ! [37: otherwise now contents form of list is false]
                      else {  t_3 = 0;   }
                     ! phrase 38
                     ! [38: end if]
                     }

                  ! phrase 39
                  ! [39: if the list item is mentioned , now the list item is not marked for listing]
                   if ((((Adj_60_t1_v9(t_4))))) {  (Adj_58_t3_v9(t_4));   }
                  ! phrase 40
                  ! [40: end repeat]
                  }

               ! phrase 41
               ! [41: filter list recursion to unmentioned things]
                list_filter_routine = Prop_41; 
               ! phrase 42
               ! [42: if contents form of list is true and the common holder is not nothing , list the contents of the common holder , as a sentence , including contents , giving brief inventory information , tersely , not listing concealed items , listing marked items only]
                if (((((t_3 && true) == (1 && true)))) && (((~~((t_2 == nothing)))))) {  WriteListFrom(child(t_2), 2776);   }
               ! phrase 43
               ! [43: otherwise say ~[a list of marked for listing things including contents]~]
                else { say__p=1;ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && ((Adj_58_t1_v9(subst__v)))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT+RECURSE_BIT+PARTINV_BIT+
			TERSE_BIT+CONCEAL_BIT);
		@pull subst__v;  .L_Say252; .L_SayX247;  }
               ! phrase 44
               ! [44: if the domain is the location , say ~ here~]
                if (((t_0 == real_location))) { say__p=1;ParaContent();  print (PrintText) SC_445;  .L_Say253; .L_SayX248;  }
               ! phrase 45
               ! [45: say ~.[paragraph break]~]
               say__p=1;ParaContent();  print (PrintText) SC_201; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say254; .L_SayX249;
               ! phrase 46
               ! [46: unfilter list recursion]
                list_filter_routine = 0; 
               ! phrase 47
               ! [47: end if]
               }

            ! phrase 48
            ! [48: end the listing nondescript items activity with the domain]
             EndActivity(V7_listing_nondescript_items, t_0); 
            ! phrase 49
            ! [49: end if]
            }

         ! phrase 50
         ! [50: end if]
         }

      ! phrase 51
      ! [51: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Choosing notable locale objects (B120_for_choosing_notable_lo)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! For choosing notable locale objects ( this is the standard notable locale objects rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! For choosing notable locale objects ( this is the standard notable locale objects rule ):
[ R_77 
    t_0 ! Local variable e.g. 'domain' = object
    t_1 ! Local variable e.g. 'held item' = object
    ;
      ! phrase 1
      ! [1: let the domain be the parameter-object]
       t_0 = parameter_object; 
      ! phrase 2
      ! [2: let the held item be the first thing held by the domain]
       t_1 =  (child(t_0)) ; 
      ! phrase 3
      ! [3: while the held item is a thing begin]
       while (((t_1 ofclass K2_thing)))  {
         ! phrase 4
         ! [4: set the locale priority of the held item to 5]
         (PHR_72_r17 (t_1,5));
         ! phrase 5
         ! [5: now the held item is the next thing held after the held item]
          t_1 =  (sibling(t_1)) ; 
         ! phrase 6
         ! [6: end while]
         }

      ! phrase 7
      ! [7: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing a locale paragraph about (B123_for_printing_a_locale_p)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention player's supporter in room descriptions rule ):
!   === which is equally specific with ===
! Rule 2/7 ! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention scenery in room descriptions rule ):
!   === which is equally specific with ===
! Rule 3/7 ! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention undescribed items in room descriptions rule ):
!   === which is equally specific with ===
! Rule 4/7 ! For printing a locale paragraph about a thing ( called the item ) ( this is the set pronouns from items in room descriptions rule ):
!   === which is equally specific with ===
! Rule 5/7 ! For printing a locale paragraph about a thing ( called the item ) ( this is the offer items to writing a paragraph about rule ):
!   === which is equally specific with ===
! Rule 6/7 ! For printing a locale paragraph about a thing ( called the item ) ( this is the use initial appearance in room descriptions rule ):
!   === which is equally specific with ===
! Rule 7/7 ! For printing a locale paragraph about a thing ( called the item ) ( this is the describe what's on scenery supporters in room descriptions rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention player's supporter in room descriptions rule ):
[ R_78 
    t_0 ! Local variable e.g. 'item' = thing
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_78, 78);
      ! phrase 1
      ! [1: if the item encloses the player , set the locale priority of the item to 0]
       if (((IndirectlyContains(t_0,player)))) { (PHR_72_r17 (t_0,0));  }
      ! phrase 2
      ! [2: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_78, 78, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention scenery in room descriptions rule ):
[ R_79 
    t_0 ! Local variable e.g. 'item' = thing
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_79, 79);
      ! phrase 1
      ! [1: if the item is scenery , set the locale priority of the item to 0]
       if ((((Adj_52_t1_v9(t_0))))) { (PHR_72_r17 (t_0,0));  }
      ! phrase 2
      ! [2: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_79, 79, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention undescribed items in room descriptions rule ):
[ R_80 
    t_0 ! Local variable e.g. 'item' = thing
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_80, 80);
      ! phrase 1
      ! [1: if the item is undescribed begin]
       if ((((Adj_57_t1_v9(t_0)))))  {
         ! phrase 2
         ! [2: set the locale priority of the item to 0]
         (PHR_72_r17 (t_0,0));
         ! phrase 3
         ! [3: end if]
         }

      ! phrase 4
      ! [4: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_80, 80, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! For printing a locale paragraph about a thing ( called the item ) ( this is the set pronouns from items in room descriptions rule ):
[ R_81 
    t_0 ! Local variable e.g. 'item' = thing
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_81, 81);
      ! phrase 1
      ! [1: if the item is not mentioned , set pronouns from the item]
       if (((~~(((Adj_60_t1_v9(t_0))))))) {  PronounNotice(t_0);   }
      ! phrase 2
      ! [2: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_81, 81, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! For printing a locale paragraph about a thing ( called the item ) ( this is the offer items to writing a paragraph about rule ):
[ R_82 
    t_0 ! Local variable e.g. 'item' = thing
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_82, 82);
      ! phrase 1
      ! [1: if the item is not mentioned begin]
       if (((~~(((Adj_60_t1_v9(t_0)))))))  {
         ! phrase 2
         ! [2: if a paragraph break is pending , say ~[conditional paragraph break]~]
          if (( (say__p) )) { say__p=1;ParaContent();  DivideParagraphPoint();  .L_Say255; .L_SayX250;  }
         ! phrase 3
         ! [3: carry out the writing a paragraph about activity with the item]
          CarryOutActivity(V6_writing_a_paragraph_about, t_0); 
         ! phrase 4
         ! [4: if a paragraph break is pending begin]
          if (( (say__p) ))  {
            ! phrase 5
            ! [5: increase the locale paragraph count by 1]
             (Global_Vars-->8) = (Global_Vars-->8) + 1; 
            ! phrase 6
            ! [6: now the item is mentioned]
             (Adj_60_t2_v9(t_0)); 
            ! phrase 7
            ! [7: say ~[command clarification break]~]
            say__p=1;ParaContent();  CommandClarificationBreak();  .L_Say256; .L_SayX251;
            ! phrase 8
            ! [8: end if]
            }

         ! phrase 9
         ! [9: end if]
         }

      ! phrase 10
      ! [10: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_82, 82, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! For printing a locale paragraph about a thing ( called the item ) ( this is the use initial appearance in room descriptions rule ):
[ R_83 
    t_0 ! Local variable e.g. 'item' = thing
    t_1 ! Local variable e.g. '?-1,-1?' = thing
    t_2 ! Local variable e.g. '?-1,-1?' = thing
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_83, 83);
      ! phrase 1
      ! [1: if the item is not mentioned begin]
       if (((~~(((Adj_60_t1_v9(t_0)))))))  {
         ! phrase 2
         ! [2: if the item provides the property initial appearance and the item is not handled and the initial appearance of the item is not ~~ begin]
          if ((((WhetherProvides(t_0, false, initial)))) && ((((~~(((Adj_55_t1_v9(t_0))))))) && (((~~((GProperty(9, t_0,initial) == EMPTY_TEXT_VALUE)))))))  {
            ! phrase 3
            ! [3: increase the locale paragraph count by 1]
             (Global_Vars-->8) = (Global_Vars-->8) + 1; 
            ! phrase 4
            ! [4: say ~[initial appearance of the item]~]
            say__p=1;ParaContent(); @push self;  print (PrintText) GProperty(9, self=t_0,initial); @pull self;  .L_Say257; .L_SayX252;
            ! phrase 5
            ! [5: say ~[paragraph break]~]
            say__p=1;ParaContent();  DivideParagraphPoint(); new_line;  .L_Say258; .L_SayX253;
            ! phrase 6
            ! [6: if a locale-supportable thing is on the item begin]
             if ((Prop_42(,t_0)))  {
               ! phrase 7
               ! [7: repeat with possibility running through things on the item begin]
                for (t_1=Prop_43(,t_0,0), t_2=Prop_43(,t_0,t_1): t_1: t_1=t_2, t_2=Prop_43(,t_0,t_2))  {
                  ! phrase 8
                  ! [8: now the possibility is marked for listing]
                   (Adj_58_t2_v9(t_1)); 
                  ! phrase 9
                  ! [9: if the possibility is mentioned begin]
                   if ((((Adj_60_t1_v9(t_1)))))  {
                     ! phrase 10
                     ! [10: now the possibility is not marked for listing]
                      (Adj_58_t3_v9(t_1)); 
                     ! phrase 11
                     ! [11: end if]
                     }

                  ! phrase 12
                  ! [12: end repeat]
                  }

               ! phrase 13
               ! [13: say ~On [the item] ~]
               say__p=1;ParaContent();  print (PrintText) SC_441; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_88;  .L_Say259; .L_SayX254;
               ! phrase 14
               ! [14: list the contents of the item , as a sentence , including contents , giving brief inventory information , tersely , not listing concealed items , prefacing with is/are , listing marked items only]
                WriteListFrom(child(t_0), 3800); 
               ! phrase 15
               ! [15: say ~.[paragraph break]~]
               say__p=1;ParaContent();  print (PrintText) SC_201; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say260; .L_SayX255;
               ! phrase 16
               ! [16: end if]
               }

            ! phrase 17
            ! [17: now the item is mentioned]
             (Adj_60_t2_v9(t_0)); 
            ! phrase 18
            ! [18: end if]
            }

         ! phrase 19
         ! [19: end if]
         }

      ! phrase 20
      ! [20: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_83, 83, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! For printing a locale paragraph about a thing ( called the item ) ( this is the describe what's on scenery supporters in room descriptions rule ):
[ R_85 
    t_0 ! Local variable e.g. 'item' = thing
    t_1 ! Local variable e.g. '?-1,-1?' = thing
    t_2 ! Local variable e.g. '?-1,-1?' = thing
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_85, 85);
      ! phrase 1
      ! [1: if the item is scenery and the item does not enclose the player begin]
       if (((((Adj_52_t1_v9(t_0))))) && (((~~((IndirectlyContains(t_0,player)))))))  {
         ! phrase 2
         ! [2: if a locale-supportable thing is on the item begin]
          if ((Prop_44(,t_0)))  {
            ! phrase 3
            ! [3: set pronouns from the item]
             PronounNotice(t_0); 
            ! phrase 4
            ! [4: repeat with possibility running through things on the item begin]
             for (t_1=Prop_45(,t_0,0), t_2=Prop_45(,t_0,t_1): t_1: t_1=t_2, t_2=Prop_45(,t_0,t_2))  {
               ! phrase 5
               ! [5: now the possibility is marked for listing]
                (Adj_58_t2_v9(t_1)); 
               ! phrase 6
               ! [6: if the possibility is mentioned begin]
                if ((((Adj_60_t1_v9(t_1)))))  {
                  ! phrase 7
                  ! [7: now the possibility is not marked for listing]
                   (Adj_58_t3_v9(t_1)); 
                  ! phrase 8
                  ! [8: end if]
                  }

               ! phrase 9
               ! [9: end repeat]
               }

            ! phrase 10
            ! [10: increase the locale paragraph count by 1]
             (Global_Vars-->8) = (Global_Vars-->8) + 1; 
            ! phrase 11
            ! [11: say ~On [the item] ~]
            say__p=1;ParaContent();  print (PrintText) SC_441; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_88;  .L_Say261; .L_SayX256;
            ! phrase 12
            ! [12: list the contents of the item , as a sentence , including contents , giving brief inventory information , tersely , not listing concealed items , prefacing with is/are , listing marked items only]
             WriteListFrom(child(t_0), 3800); 
            ! phrase 13
            ! [13: say ~.[paragraph break]~]
            say__p=1;ParaContent();  print (PrintText) SC_201; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say262; .L_SayX257;
            ! phrase 14
            ! [14: end if]
            }

         ! phrase 15
         ! [15: end if]
         }

      ! phrase 16
      ! [16: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_85, 85, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Taking inventory (B126_carry_out_taking_invent)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out taking inventory ( this is the print empty inventory rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Carry out taking inventory ( this is the print standard inventory rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out taking inventory ( this is the print empty inventory rule ):
[ R_86 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_86, 86);
      ! phrase 1
      ! [1: if the first thing held by the player is nothing , stop the action with library message taking inventory action number 1]
       if ((( (child(player))  == nothing))) {  return GL__M(##Inv,1,noun);   }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_86, 86, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out taking inventory ( this is the print standard inventory rule ):
[ R_87 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_87, 87);
      ! phrase 1
      ! [1: issue library message taking inventory action number 2]
       GL__M(##Inv,2,noun); 
      ! phrase 2
      ! [2: say ~:[line break]~]
      say__p=1;ParaContent();  print (PrintText) SC_446; ParaContent();  new_line;  .L_Say263; .L_SayX258;
      ! phrase 3
      ! [3: list the contents of the player , with newlines , indented , including contents , giving inventory information , with extra indentation]
       WriteListFrom(child(player), 8215); 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_87, 87, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Taking inventory (B127_report_taking_inventory)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor taking inventory ( this is the report other people taking inventory rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor taking inventory ( this is the report other people taking inventory rule ):
[ R_88 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_88, 88);
      ! phrase 1
      ! [1: if the actor is not the player , issue actor-based library message taking inventory action number 5 for the actor]
       if (((~~((actor == player))))) {  AGL__M(##Inv,5,actor);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_88, 88, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Taking (B128_check_taking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/12 ! Check an actor taking ( this is the can't take yourself rule ):
!   === which is equally specific with ===
! Rule 2/12 ! Check an actor taking ( this is the can't take other people rule ):
!   === which is equally specific with ===
! Rule 3/12 ! Check an actor taking ( this is the can't take component parts rule ):
!   === which is equally specific with ===
! Rule 4/12 ! Check an actor taking ( this is the can't take people's possessions rule ):
!   === which is equally specific with ===
! Rule 5/12 ! Check an actor taking ( this is the can't take items out of play rule ):
!   === which is equally specific with ===
! Rule 6/12 ! Check an actor taking ( this is the can't take what you're inside rule ):
!   === which is equally specific with ===
! Rule 7/12 ! Check an actor taking ( this is the can't take what's already taken rule ):
!   === which is equally specific with ===
! Rule 8/12 ! Check an actor taking ( this is the can't take scenery rule ):
!   === which is equally specific with ===
! Rule 9/12 ! Check an actor taking ( this is the can only take things rule ):
!   === which is equally specific with ===
! Rule 10/12 ! Check an actor taking ( this is the can't take what's fixed in place rule ):
!   === which is equally specific with ===
! Rule 11/12 ! Check an actor taking ( this is the use player's holdall to avoid exceeding carrying capacity rule ):
!   === which is equally specific with ===
! Rule 12/12 ! Check an actor taking ( this is the can't exceed carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't take yourself rule ):
[ R_89 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_89, 89);
      ! phrase 1
      ! [1: if the actor is the noun , stop the action with library message taking action number 2 for the noun]
       if (((actor == noun))) {  return GL__M(##Take,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_89, 89, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't take other people rule ):
[ R_90 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_90, 90);
      ! phrase 1
      ! [1: if the noun is a person , stop the action with library message taking action number 3 for the noun]
       if (((noun ofclass K8_person))) {  return GL__M(##Take,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_90, 90, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't take component parts rule ):
[ R_91 
    t_0 ! Local variable e.g. 'whole' = thing
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_91, 91);
      ! phrase 1
      ! [1: if the noun is part of something ( called the whole ) , stop the action with library message taking action number 7 for the whole]
       if ((((noun.component_parent) ofclass K2_thing) && (t_0=((noun.component_parent)), true))) {  return GL__M(##Take,7,t_0);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_91, 91, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't take people's possessions rule ):
[ R_92 
    t_0 ! Local variable e.g. 'local ceiling' = object
    t_1 ! Local variable e.g. 'H' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_92, 92);
      ! phrase 1
      ! [1: let the local ceiling be the common ancestor of the actor with the noun]
       t_0 =  (CommonAncestor(actor, noun)) ; 
      ! phrase 2
      ! [2: let h be the not-counting-parts holder of the noun]
       t_1 =  (CoreOfParentOfCoreOf(noun)) ; 
      ! phrase 3
      ! [3: while h is not nothing and h is not the local ceiling begin]
       while ((((~~((t_1 == nothing))))) && (((~~((t_1 == t_0))))))  {
         ! phrase 4
         ! [4: if h is a person , stop the action with library message taking action number 6 for h]
          if (((t_1 ofclass K8_person))) {  return GL__M(##Take,6,t_1);   }
         ! phrase 5
         ! [5: let h be the not-counting-parts holder of h]
          t_1 =  (CoreOfParentOfCoreOf(t_1)) ; 
         ! phrase 6
         ! [6: end while]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_92, 92, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't take items out of play rule ):
[ R_93 
    t_0 ! Local variable e.g. 'H' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_93, 93);
      ! phrase 1
      ! [1: let h be the noun]
       t_0 = noun; 
      ! phrase 2
      ! [2: while h is not nothing and h is not a room begin]
       while ((((~~((t_0 == nothing))))) && (((~~((t_0 ofclass K1_room))))))  {
         ! phrase 3
         ! [3: let h be the not-counting-parts holder of h]
          t_0 =  (CoreOfParentOfCoreOf(t_0)) ; 
         ! phrase 4
         ! [4: end while]
         }

      ! phrase 5
      ! [5: if h is nothing , stop the action with library message taking action number 8 for the noun]
       if (((t_0 == nothing))) {  return GL__M(##Take,8,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_93, 93, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't take what you're inside rule ):
[ R_94 
    t_0 ! Local variable e.g. 'local ceiling' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_94, 94);
      ! phrase 1
      ! [1: let the local ceiling be the common ancestor of the actor with the noun]
       t_0 =  (CommonAncestor(actor, noun)) ; 
      ! phrase 2
      ! [2: if the local ceiling is the noun , stop the action with library message taking action number 4 for the noun]
       if (((t_0 == noun))) {  return GL__M(##Take,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_94, 94, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't take what's already taken rule ):
[ R_95 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_95, 95);
      ! phrase 1
      ! [1: if the actor is carrying the noun , stop the action with library message taking action number 5 for the noun]
       if (((actor == CarrierOf(noun)))) {  return GL__M(##Take,5,noun);   }
      ! phrase 2
      ! [2: if the actor is wearing the noun , stop the action with library message taking action number 5 for the noun]
       if (((actor == WearerOf(noun)))) {  return GL__M(##Take,5,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_95, 95, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't take scenery rule ):
[ R_96 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_96, 96);
      ! phrase 1
      ! [1: if the noun is scenery , stop the action with library message taking action number 10 for the noun]
       if ((((Adj_52_t1_v9(noun))))) {  return GL__M(##Take,10,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_96, 96, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can only take things rule ):
[ R_97 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_97, 97);
      ! phrase 1
      ! [1: if the noun is not a thing , stop the action with library message taking action number 15 for the noun]
       if (((~~((noun ofclass K2_thing))))) {  return GL__M(##Take,15,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_97, 97, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't take what's fixed in place rule ):
[ R_98 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_98, 98);
      ! phrase 1
      ! [1: if the noun is fixed in place , stop the action with library message taking action number 11 for the noun]
       if ((((Adj_50_t1_v9(noun))))) {  return GL__M(##Take,11,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_98, 98, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the use player's holdall to avoid exceeding carrying capacity rule ):
[ R_99 
    t_0 ! Local variable e.g. 'current working sack' = player's holdall
    t_1 ! Local variable e.g. '?-1,-1?' = object
    t_2 ! Local variable e.g. '?-1,-1?' = thing
    t_3 ! Local variable e.g. '?-1,-1?' = thing
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_99, 99);
      ! phrase 1
      ! [1: if the number of things carried by the actor is at least the carrying capacity of the actor begin]
       if ((( (Prop_46())  >= GProperty(9, actor,capacity))))  {
         ! phrase 2
         ! [2: if the actor is holding a player's holdall ( called the current working sack ) begin]
          if ((Prop_47() && (t_0=deferred_calling_list-->0, true)))  {
            ! phrase 3
            ! [3: let the transferred item be nothing]
             t_1 = nothing; 
            ! phrase 4
            ! [4: repeat with the possible item running through things carried by the actor begin]
             for (t_2=Prop_48(0), t_3=Prop_48(t_2): t_2: t_2=t_3, t_3=Prop_48(t_3))  {
               ! phrase 5
               ! [5: if the possible item is not lit and the possible item is not the current working sack , let the transferred item be the possible item]
                if ((((~~(((Adj_46_t1_v9(t_2))))))) && (((~~((t_2 == t_0)))))) {  t_1 = t_2;   }
               ! phrase 6
               ! [6: end repeat]
               }

            ! phrase 7
            ! [7: if the transferred item is not nothing begin]
             if (((~~((t_1 == nothing)))))  {
               ! phrase 8
               ! [8: issue library message taking action number 13 for the transferred item and the current working sack]
                GL__M(##Take,13,t_1,t_0); 
               ! phrase 9
               ! [9: silently try the actor trying inserting the transferred item into the current working sack]
                @push keep_silent; keep_silent=1; TryAction(0, actor, ##Insert, t_1, t_0);; @pull keep_silent; 
               ! phrase 10
               ! [10: if the transferred item is not in the current working sack , stop the action]
                if (((~~((t_0 == ContainerOf(t_1)))))) {  rtrue;   }
               ! phrase 11
               ! [11: end if]
               }

            ! phrase 12
            ! [12: end if]
            }

         ! phrase 13
         ! [13: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_99, 99, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't exceed carrying capacity rule ):
[ R_100 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_100, 100);
      ! phrase 1
      ! [1: if the number of things carried by the actor is at least the carrying capacity of the actor , stop the action with library message taking action number 12 for the actor]
       if ((( (Prop_49())  >= GProperty(9, actor,capacity)))) {  return GL__M(##Take,12,actor);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_100, 100, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Taking (B129_carry_out_taking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor taking ( this is the standard taking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor taking ( this is the standard taking rule ):
[ R_101 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_101, 101);
      ! phrase 1
      ! [1: now the actor carries the noun]
       MoveObject(noun,actor); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_101, 101, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Taking (B130_report_taking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! report taking suitcase:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 2/3 ! Report taking something:
!   >>> I - Number of aspects constrained >>>
! Rule 3/3 ! Report an actor taking ( this is the standard report taking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! report taking suitcase:
[ R_1145 ;
   if ( (actor==player) && ((noun == I228_suitcase) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1145, 1145);
      ! phrase 1
      ! [1: if already reported taking is 0 begin]
       if ((((Global_Vars-->16) == 0)))  {
         ! phrase 2
         ! [2: say ~You take the suitcase from [the previous locale].~ instead]
         say__p=1;ParaContent();  print (PrintText) SC_447; ParaContent();  print (the) (MStack-->MstVO(20001,0)); ParaContent();  print (PrintText) SC_201;  new_line; rtrue; .L_Say264; .L_SayX259; rtrue;
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: do nothing instead]
          ;  rtrue;
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1145, 1145, true);
   rfalse;
];
! No specific request
! Report taking something:
[ R_770 ;
   if ( (actor==player) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_770, 770);
      ! phrase 1
      ! [1: if already reported taking is 0 begin]
       if ((((Global_Vars-->16) == 0)))  {
         ! phrase 2
         ! [2: say ~You take [the noun] from [the previous locale].~ instead]
         say__p=1;ParaContent();  print (PrintText) SC_334; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_448; ParaContent();  print (the) (MStack-->MstVO(20001,0)); ParaContent();  print (PrintText) SC_201;  new_line; rtrue; .L_Say265; .L_SayX260; rtrue;
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: do nothing instead]
          ;  rtrue;
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_770, 770, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor taking ( this is the standard report taking rule ):
[ R_102 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_102, 102);
      ! phrase 1
      ! [1: if the actor is the player , issue library message taking action number 1 for the noun]
       if (((actor == player))) {  GL__M(##Take,1,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message taking action number 16 for the noun]
       else {  AGL__M(##Take,16,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_102, 102, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Removing it from (B131_check_removing_it_from)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check an actor taking ( this is the can't take component parts rule ):
!   <<< I - Number of aspects constrained <<<
! Rule 2/4 ! Check an actor removing something from ( this is the can't remove what's not inside rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Check an actor removing something from ( this is the can't remove from people rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Check an actor removing something from ( this is the convert remove to take rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor removing something from ( this is the can't remove what's not inside rule ):
[ R_103 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_103, 103);
      ! phrase 1
      ! [1: if the holder of the noun is not the second noun , stop the action with library message removing it from action number 2 for the noun]
       if (((~~(( (HolderOf(noun))  == second))))) {  return GL__M(##Remove,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_103, 103, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor removing something from ( this is the can't remove from people rule ):
[ R_104 
    t_0 ! Local variable e.g. 'owner' = object
    ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_104, 104);
      ! phrase 1
      ! [1: let the owner be the holder of the noun]
       t_0 =  (HolderOf(noun)) ; 
      ! phrase 2
      ! [2: if the owner is a person begin]
       if (((t_0 ofclass K8_person)))  {
         ! phrase 3
         ! [3: if the owner is the actor , convert to the taking off action on the noun]
          if (((t_0 == actor))) {  return GVS_Convert(##Disrobe,noun,0);   }
         ! phrase 4
         ! [4: stop the action with library message taking action number 6 for the owner]
          return GL__M(##Take,6,t_0); 
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_104, 104, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor removing something from ( this is the convert remove to take rule ):
[ R_105 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_105, 105);
      ! phrase 1
      ! [1: convert to the taking action on the noun]
       return GVS_Convert(##Take,noun,0); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_105, 105, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Dropping (B134_check_dropping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Check an actor dropping ( this is the can't drop yourself rule ):
!   === which is equally specific with ===
! Rule 2/5 ! Check an actor dropping ( this is the can't drop what's already dropped rule ):
!   === which is equally specific with ===
! Rule 3/5 ! Check an actor dropping ( this is the can't drop what's not held rule ):
!   === which is equally specific with ===
! Rule 4/5 ! Check an actor dropping ( this is the can't drop clothes being worn rule ):
!   === which is equally specific with ===
! Rule 5/5 ! Check an actor dropping ( this is the can't drop if this exceeds carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor dropping ( this is the can't drop yourself rule ):
[ R_106 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_106, 106);
      ! phrase 1
      ! [1: if the noun is the actor , stop the action with library message putting it on action number 4]
       if (((noun == actor))) {  return GL__M(##PutOn,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_106, 106, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor dropping ( this is the can't drop what's already dropped rule ):
[ R_107 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_107, 107);
      ! phrase 1
      ! [1: if the noun is in the holder of the actor , stop the action with library message dropping action number 1 for the noun]
       if ((( (HolderOf(actor))  == ContainerOf(noun)))) {  return GL__M(##Drop,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_107, 107, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor dropping ( this is the can't drop what's not held rule ):
[ R_108 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_108, 108);
      ! phrase 1
      ! [1: if the actor is carrying the noun , continue the action]
       if (((actor == CarrierOf(noun)))) {  rfalse;   }
      ! phrase 2
      ! [2: if the actor is wearing the noun , continue the action]
       if (((actor == WearerOf(noun)))) {  rfalse;   }
      ! phrase 3
      ! [3: stop the action with library message dropping action number 2 for the noun]
       return GL__M(##Drop,2,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_108, 108, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor dropping ( this is the can't drop clothes being worn rule ):
[ R_109 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_109, 109);
      ! phrase 1
      ! [1: if the actor is wearing the noun begin]
       if (((actor == WearerOf(noun))))  {
         ! phrase 2
         ! [2: issue library message dropping action number 3 for the noun]
          GL__M(##Drop,3,noun); 
         ! phrase 3
         ! [3: silently try the actor trying taking off the noun]
          @push keep_silent; keep_silent=1; TryAction(0, actor, ##Disrobe, noun, 0);; @pull keep_silent; 
         ! phrase 4
         ! [4: if the actor is wearing the noun , stop the action]
          if (((actor == WearerOf(noun)))) {  rtrue;   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_109, 109, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor dropping ( this is the can't drop if this exceeds carrying capacity rule ):
[ R_110 
    t_0 ! Local variable e.g. 'H' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_110, 110);
      ! phrase 1
      ! [1: let h be the holder of the actor]
       t_0 =  (HolderOf(actor)) ; 
      ! phrase 2
      ! [2: if h is a room , continue the action]
       if (((t_0 ofclass K1_room))) {  rfalse;   }
      ! phrase 3
      ! [3: if h provides the property carrying capacity begin]
       if (((WhetherProvides(t_0, false, capacity))))  {
         ! phrase 4
         ! [4: if h is a supporter begin]
          if (((t_0 ofclass K6_supporter)))  {
            ! phrase 5
            ! [5: if the number of things on h is at least the carrying capacity of h begin]
             if ((( (Prop_50(,t_0))  >= GProperty(OBJECT_TY, t_0,capacity))))  {
               ! phrase 6
               ! [6: if the actor is the player , issue library message dropping action number 5 for h]
                if (((actor == player))) {  GL__M(##Drop,5,t_0);   }
               ! phrase 7
               ! [7: stop the action]
                rtrue; 
               ! phrase 8
               ! [8: end if]
               }

            ! phrase 9
            ! [9: otherwise if h is a container]
             } else if (((t_0 ofclass K5_container))) { 
            ! phrase 10
            ! [10: if the number of things in h is at least the carrying capacity of h begin]
             if ((( (Prop_51(,t_0))  >= GProperty(OBJECT_TY, t_0,capacity))))  {
               ! phrase 11
               ! [11: if the actor is the player , issue library message dropping action number 6 for h]
                if (((actor == player))) {  GL__M(##Drop,6,t_0);   }
               ! phrase 12
               ! [12: stop the action]
                rtrue; 
               ! phrase 13
               ! [13: end if]
               }

            ! phrase 14
            ! [14: end if]
            }

         ! phrase 15
         ! [15: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_110, 110, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Dropping (B135_carry_out_dropping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor dropping ( this is the standard dropping rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor dropping ( this is the standard dropping rule ):
[ R_111 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_111, 111);
      ! phrase 1
      ! [1: now the noun is in the holder of the actor]
       MoveObject(noun, (HolderOf(actor)) ); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_111, 111, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Dropping (B136_report_dropping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor dropping ( this is the standard report dropping rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor dropping ( this is the standard report dropping rule ):
[ R_112 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_112, 112);
      ! phrase 1
      ! [1: if the actor is the player , issue library message dropping action number 4 for the noun]
       if (((actor == player))) {  GL__M(##Drop,4,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message dropping action number 7 for the noun]
       else {  AGL__M(##Drop,7,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_112, 112, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Putting it on (B137_check_putting_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! Check an actor putting something on ( this is the convert put to drop where possible rule ):
!   === which is equally specific with ===
! Rule 2/7 ! Check an actor putting something on ( this is the can't put what's not held rule ):
!   === which is equally specific with ===
! Rule 3/7 ! Check an actor putting something on ( this is the can't put something on itself rule ):
!   === which is equally specific with ===
! Rule 4/7 ! Check an actor putting something on ( this is the can't put onto what's not a supporter rule ):
!   === which is equally specific with ===
! Rule 5/7 ! Check an actor putting something on ( this is the can't put onto something being carried rule ):
!   === which is equally specific with ===
! Rule 6/7 ! Check an actor putting something on ( this is the can't put clothes being worn rule ):
!   === which is equally specific with ===
! Rule 7/7 ! Check an actor putting something on ( this is the can't put if this exceeds carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor putting something on ( this is the convert put to drop where possible rule ):
[ R_113 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_113, 113);
      ! phrase 1
      ! [1: if the second noun is down or the actor is on the second noun , convert to the dropping action on the noun]
       if ((((second == I55_down))) || (((second == SupporterOf(actor))))) {  return GVS_Convert(##Drop,noun,0);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_113, 113, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor putting something on ( this is the can't put what's not held rule ):
[ R_114 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_114, 114);
      ! phrase 1
      ! [1: if the actor is carrying the noun , continue the action]
       if (((actor == CarrierOf(noun)))) {  rfalse;   }
      ! phrase 2
      ! [2: if the actor is wearing the noun , continue the action]
       if (((actor == WearerOf(noun)))) {  rfalse;   }
      ! phrase 3
      ! [3: issue miscellaneous library message number 26 for the noun]
       GL__M(##Miscellany,26, noun); 
      ! phrase 4
      ! [4: silently try the actor taking the noun]
       @push keep_silent; keep_silent=1; TryAction(0, actor, ##Take, noun, 0);; @pull keep_silent; 
      ! phrase 5
      ! [5: if the actor is carrying the noun , continue the action]
       if (((actor == CarrierOf(noun)))) {  rfalse;   }
      ! phrase 6
      ! [6: stop the action with library message putting it on action number 1 for the noun]
       return GL__M(##PutOn,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_114, 114, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor putting something on ( this is the can't put something on itself rule ):
[ R_115 
    t_0 ! Local variable e.g. 'noun-CPC' = object
    t_1 ! Local variable e.g. 'second-CPC' = object
    t_2 ! Local variable e.g. 'transfer ceiling' = object
    ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_115, 115);
      ! phrase 1
      ! [1: let the noun-cpc be the component parts core of the noun]
       t_0 =  CoreOf(noun) ; 
      ! phrase 2
      ! [2: let the second-cpc be the component parts core of the second noun]
       t_1 =  CoreOf(second) ; 
      ! phrase 3
      ! [3: let the transfer ceiling be the common ancestor of the noun-cpc with the second-cpc]
       t_2 =  (CommonAncestor(t_0, t_1)) ; 
      ! phrase 4
      ! [4: if the transfer ceiling is the noun-cpc , stop the action with library message putting it on action number 2 for the noun]
       if (((t_2 == t_0))) {  return GL__M(##PutOn,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_115, 115, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor putting something on ( this is the can't put onto what's not a supporter rule ):
[ R_116 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_116, 116);
      ! phrase 1
      ! [1: if the second noun is not a supporter , stop the action with library message putting it on action number 3 for the second noun]
       if (((~~((second ofclass K6_supporter))))) {  return GL__M(##PutOn,3,second);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_116, 116, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor putting something on ( this is the can't put onto something being carried rule ):
[ R_117 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_117, 117);
      ! phrase 1
      ! [1: if the actor encloses the second noun , stop the action with library message putting it on action number 4 for the second noun]
       if (((IndirectlyContains(actor,second)))) {  return GL__M(##PutOn,4,second);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_117, 117, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor putting something on ( this is the can't put clothes being worn rule ):
[ R_118 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_118, 118);
      ! phrase 1
      ! [1: if the actor is wearing the noun begin]
       if (((actor == WearerOf(noun))))  {
         ! phrase 2
         ! [2: issue library message putting it on action number 5 for the noun]
          GL__M(##PutOn,5,noun); 
         ! phrase 3
         ! [3: silently try the actor trying taking off the noun]
          @push keep_silent; keep_silent=1; TryAction(0, actor, ##Disrobe, noun, 0);; @pull keep_silent; 
         ! phrase 4
         ! [4: if the actor is wearing the noun , stop the action]
          if (((actor == WearerOf(noun)))) {  rtrue;   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_118, 118, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor putting something on ( this is the can't put if this exceeds carrying capacity rule ):
[ R_119 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_119, 119);
      ! phrase 1
      ! [1: if the second noun provides the property carrying capacity begin]
       if (((WhetherProvides(second, false, capacity))))  {
         ! phrase 2
         ! [2: if the number of things on the second noun is at least the carrying capacity of the second noun , stop the action with library message putting it on action number 6 for the second noun]
          if ((( (Prop_52())  >= GProperty(OBJECT_TY, second,capacity)))) {  return GL__M(##PutOn,6,second);   }
         ! phrase 3
         ! [3: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_119, 119, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Putting it on (B138_carry_out_putting_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor putting something on ( this is the standard putting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor putting something on ( this is the standard putting rule ):
[ R_120 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_120, 120);
      ! phrase 1
      ! [1: now the noun is on the second noun]
       MoveObject(noun,second); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_120, 120, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Putting it on (B139_report_putting_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor putting something on ( this is the concise report putting rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Report an actor putting something on ( this is the standard report putting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor putting something on ( this is the concise report putting rule ):
[ R_121 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_121, 121);
      ! phrase 1
      ! [1: if the actor is the player and the i6 parser is running multiple actions , stop the action with library message putting it on action number 7 for the noun]
       if ((((actor == player))) && (( (multiflag==1) ))) {  return GL__M(##PutOn,7,noun);   }
      ! phrase 2
      ! [2: otherwise continue the action]
       else {  rfalse;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_121, 121, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor putting something on ( this is the standard report putting rule ):
[ R_122 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_122, 122);
      ! phrase 1
      ! [1: if the actor is the player , issue library message putting it on action number 8 for the noun]
       if (((actor == player))) {  GL__M(##PutOn,8,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message putting it on action number 9 for the noun]
       else {  AGL__M(##PutOn,9,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_122, 122, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Inserting it into (B140_check_inserting_it_into)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! Check an actor inserting something into ( this is the convert insert to drop where possible rule ):
!   === which is equally specific with ===
! Rule 2/7 ! Check an actor inserting something into ( this is the can't insert what's not held rule ):
!   === which is equally specific with ===
! Rule 3/7 ! Check an actor inserting something into ( this is the can't insert something into itself rule ):
!   === which is equally specific with ===
! Rule 4/7 ! Check an actor inserting something into ( this is the can't insert into closed containers rule ):
!   === which is equally specific with ===
! Rule 5/7 ! Check an actor inserting something into ( this is the can't insert into what's not a container rule ):
!   === which is equally specific with ===
! Rule 6/7 ! Check an actor inserting something into ( this is the can't insert clothes being worn rule ):
!   === which is equally specific with ===
! Rule 7/7 ! Check an actor inserting something into ( this is the can't insert if this exceeds carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor inserting something into ( this is the convert insert to drop where possible rule ):
[ R_123 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_123, 123);
      ! phrase 1
      ! [1: if the second noun is down or the actor is in the second noun , convert to the dropping action on the noun]
       if ((((second == I55_down))) || (((second == ContainerOf(actor))))) {  return GVS_Convert(##Drop,noun,0);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_123, 123, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert what's not held rule ):
[ R_124 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_124, 124);
      ! phrase 1
      ! [1: if the actor is carrying the noun , continue the action]
       if (((actor == CarrierOf(noun)))) {  rfalse;   }
      ! phrase 2
      ! [2: if the actor is wearing the noun , continue the action]
       if (((actor == WearerOf(noun)))) {  rfalse;   }
      ! phrase 3
      ! [3: issue miscellaneous library message number 26 for the noun]
       GL__M(##Miscellany,26, noun); 
      ! phrase 4
      ! [4: silently try the actor taking the noun]
       @push keep_silent; keep_silent=1; TryAction(0, actor, ##Take, noun, 0);; @pull keep_silent; 
      ! phrase 5
      ! [5: if the actor is carrying the noun , continue the action]
       if (((actor == CarrierOf(noun)))) {  rfalse;   }
      ! phrase 6
      ! [6: stop the action]
       rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_124, 124, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert something into itself rule ):
[ R_125 
    t_0 ! Local variable e.g. 'noun-CPC' = object
    t_1 ! Local variable e.g. 'second-CPC' = object
    t_2 ! Local variable e.g. 'transfer ceiling' = object
    ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_125, 125);
      ! phrase 1
      ! [1: let the noun-cpc be the component parts core of the noun]
       t_0 =  CoreOf(noun) ; 
      ! phrase 2
      ! [2: let the second-cpc be the component parts core of the second noun]
       t_1 =  CoreOf(second) ; 
      ! phrase 3
      ! [3: let the transfer ceiling be the common ancestor of the noun-cpc with the second-cpc]
       t_2 =  (CommonAncestor(t_0, t_1)) ; 
      ! phrase 4
      ! [4: if the transfer ceiling is the noun-cpc , stop the action with library message inserting it into action number 5 for the noun]
       if (((t_2 == t_0))) {  return GL__M(##Insert,5,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_125, 125, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert into closed containers rule ):
[ R_126 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_126, 126);
      ! phrase 1
      ! [1: if the second noun is a closed container , stop the action with library message inserting it into action number 3 for the second noun]
       if (((second ofclass K5_container) && ((Adj_66_t1_v9(second))))) {  return GL__M(##Insert,3,second);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_126, 126, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert into what's not a container rule ):
[ R_127 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_127, 127);
      ! phrase 1
      ! [1: if the second noun is not a container , stop the action with library message inserting it into action number 2 for the second noun]
       if (((~~((second ofclass K5_container))))) {  return GL__M(##Insert,2,second);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_127, 127, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert clothes being worn rule ):
[ R_128 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_128, 128);
      ! phrase 1
      ! [1: if the actor is wearing the noun begin]
       if (((actor == WearerOf(noun))))  {
         ! phrase 2
         ! [2: issue library message inserting it into action number 6 for the noun]
          GL__M(##Insert,6,noun); 
         ! phrase 3
         ! [3: silently try the actor trying taking off the noun]
          @push keep_silent; keep_silent=1; TryAction(0, actor, ##Disrobe, noun, 0);; @pull keep_silent; 
         ! phrase 4
         ! [4: if the actor is wearing the noun , stop the action]
          if (((actor == WearerOf(noun)))) {  rtrue;   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_128, 128, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert if this exceeds carrying capacity rule ):
[ R_129 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_129, 129);
      ! phrase 1
      ! [1: if the second noun provides the property carrying capacity begin]
       if (((WhetherProvides(second, false, capacity))))  {
         ! phrase 2
         ! [2: if the number of things in the second noun is at least the carrying capacity of the second noun , stop the action with library message inserting it into action number 7 for the second noun]
          if ((( (Prop_53())  >= GProperty(OBJECT_TY, second,capacity)))) {  return GL__M(##Insert,7,second);   }
         ! phrase 3
         ! [3: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_129, 129, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Inserting it into (B141_carry_out_inserting_it_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor inserting something into ( this is the standard inserting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor inserting something into ( this is the standard inserting rule ):
[ R_130 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_130, 130);
      ! phrase 1
      ! [1: now the noun is in the second noun]
       MoveObject(noun,second); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_130, 130, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Inserting it into (B142_report_inserting_it_int)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor inserting something into ( this is the concise report inserting rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Report an actor inserting something into ( this is the standard report inserting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor inserting something into ( this is the concise report inserting rule ):
[ R_131 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_131, 131);
      ! phrase 1
      ! [1: if the actor is the player and the i6 parser is running multiple actions , stop the action with library message inserting it into action number 8 for the noun]
       if ((((actor == player))) && (( (multiflag==1) ))) {  return GL__M(##Insert,8,noun);   }
      ! phrase 2
      ! [2: otherwise continue the action]
       else {  rfalse;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_131, 131, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor inserting something into ( this is the standard report inserting rule ):
[ R_132 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_132, 132);
      ! phrase 1
      ! [1: if the actor is the player , issue library message inserting it into action number 9 for the noun]
       if (((actor == player))) {  GL__M(##Insert,9,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message inserting it into action number 10 for the noun]
       else {  AGL__M(##Insert,10,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_132, 132, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Eating (B143_check_eating)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor eating ( this is the can't eat unless edible rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor eating ( this is the can't eat clothing without removing it first rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor eating ( this is the can't eat unless edible rule ):
[ R_133 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_133, 133);
      ! phrase 1
      ! [1: if the noun is not a thing or the noun is not edible , stop the action with library message eating action number 1 for the noun]
       if ((((~~((noun ofclass K2_thing))))) || (((~~(((Adj_48_t1_v9(noun)))))))) {  return GL__M(##Eat,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_133, 133, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor eating ( this is the can't eat clothing without removing it first rule ):
[ R_134 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_134, 134);
      ! phrase 1
      ! [1: if the actor is wearing the noun begin]
       if (((actor == WearerOf(noun))))  {
         ! phrase 2
         ! [2: issue library message dropping action number 3 for the noun]
          GL__M(##Drop,3,noun); 
         ! phrase 3
         ! [3: try the actor trying taking off the noun]
          TryAction(0, actor, ##Disrobe, noun, 0);; 
         ! phrase 4
         ! [4: if the actor is wearing the noun , stop the action]
          if (((actor == WearerOf(noun)))) {  rtrue;   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_134, 134, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Eating (B144_carry_out_eating)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor eating ( this is the standard eating rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor eating ( this is the standard eating rule ):
[ R_135 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_135, 135);
      ! phrase 1
      ! [1: remove the noun from play]
       RemoveFromPlay(noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_135, 135, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Eating (B145_report_eating)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor eating ( this is the standard report eating rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor eating ( this is the standard report eating rule ):
[ R_136 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_136, 136);
      ! phrase 1
      ! [1: if the actor is the player , issue library message eating action number 2 for the noun]
       if (((actor == player))) {  GL__M(##Eat,2,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message eating action number 3 for the noun]
       else {  AGL__M(##Eat,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_136, 136, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Going (B146_check_going)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Check an actor going somewhere ( this is the can't go without standing rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/6 ! Check an actor going ( this is the can't travel in what's not a vehicle rule ):
!   === which is equally specific with ===
! Rule 3/6 ! Check an actor going ( this is the can't go through undescribed doors rule ):
!   === which is equally specific with ===
! Rule 4/6 ! Check an actor going ( this is the can't go through closed doors rule ):
!   === which is equally specific with ===
! Rule 5/6 ! Check an actor going ( this is the determine map connection rule ):
!   === which is equally specific with ===
! Rule 6/6 ! Check an actor going ( this is the can't go that way rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Postures" by Emily Short
! Check an actor going somewhere ( this is the can't go without standing rule ):
[ R_1064 ;
   if ((act_requester==nothing) && (((MStack-->MstVON(20007,1)) ofclass K1_room))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1064, 1064);
      ! phrase 1
      ! [1: if the actor is in a room and the actor is not standing begin]
       if ((((ContainerOf(actor) ofclass K1_room))) && (((~~((actor.p73_posture == I116_standing))))))  {
         ! phrase 2
         ! [2: say ~([if the actor is not the player][the actor] [end if]first standing up)[command clarification break]~]
         say__p=1;ParaContent();  print (PrintText) SC_449; 
	if (~~((((~~((actor == player))))))) jump L_Say266;
		ParaContent();  print (the) actor; ParaContent();  print (PrintText) SC_88; 
	.L_Say266; .L_SayX261;
		ParaContent();  print (PrintText) SC_450; ParaContent();  CommandClarificationBreak();  .L_Say267; .L_SayX262;
         ! phrase 3
         ! [3: silently try the actor taking position standing]
          @push keep_silent; keep_silent=1; TryAction(0, actor, ##A121_taking_position, I116_standing, 0);; @pull keep_silent; 
         ! phrase 4
         ! [4: if the actor is not standing , stop the action]
          if (((~~((actor.p73_posture == I116_standing))))) {  rtrue;   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1064, 1064, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor going ( this is the can't travel in what's not a vehicle rule ):
[ R_139 
    t_0 ! Local variable e.g. 'H' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_139, 139);
      ! phrase 1
      ! [1: let h be the holder of the actor]
       t_0 =  (HolderOf(actor)) ; 
      ! phrase 2
      ! [2: if h is the room gone from , continue the action]
       if (((t_0 == (MStack-->MstVO(20007,0))))) {  rfalse;   }
      ! phrase 3
      ! [3: if h is the vehicle gone by , continue the action]
       if (((t_0 == (MStack-->MstVO(20007,3))))) {  rfalse;   }
      ! phrase 4
      ! [4: stop the action with library message going action number 1 for h]
       return GL__M(##Go,1,t_0); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_139, 139, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor going ( this is the can't go through undescribed doors rule ):
[ R_140 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_140, 140);
      ! phrase 1
      ! [1: if the door gone through is not nothing and the door gone through is undescribed , stop the action with library message going action number 2 for the room gone from]
       if ((((~~(((MStack-->MstVO(20007,2)) == nothing))))) && ((((Adj_57_t1_v9((MStack-->MstVO(20007,2)))))))) {  return GL__M(##Go,2,(MStack-->MstVO(20007,0)));   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_140, 140, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor going ( this is the can't go through closed doors rule ):
[ R_141 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_141, 141);
      ! phrase 1
      ! [1: if the door gone through is not nothing and the door gone through is closed begin]
       if ((((~~(((MStack-->MstVO(20007,2)) == nothing))))) && ((((Adj_66_t1_v9((MStack-->MstVO(20007,2))))))))  {
         ! phrase 2
         ! [2: issue library message going action number 28 for the door gone through]
          GL__M(##Go,28,(MStack-->MstVO(20007,2))); 
         ! phrase 3
         ! [3: silently try the actor opening the door gone through]
          @push keep_silent; keep_silent=1; TryAction(0, actor, ##Open, (MStack-->MstVO(20007,2)), 0);; @pull keep_silent; 
         ! phrase 4
         ! [4: if the door gone through is open , continue the action]
          if ((((Adj_65_t1_v9((MStack-->MstVO(20007,2))))))) {  rfalse;   }
         ! phrase 5
         ! [5: stop the action]
          rtrue; 
         ! phrase 6
         ! [6: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_141, 141, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor going ( this is the determine map connection rule ):
[ R_142 
    t_0 ! Local variable e.g. 'target' = object
    t_1 ! Local variable e.g. '?-1,-1?' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_142, 142);
      ! phrase 1
      ! [1: let the target be nothing]
       t_0 = nothing; 
      ! phrase 2
      ! [2: if the noun is a direction begin]
       if (((noun ofclass K3_direction)))  {
         ! phrase 3
         ! [3: let direction d be the noun]
          t_1 = noun; 
         ! phrase 4
         ! [4: let the target be the room-or-door direction d from the room gone from]
          t_0 = (Resolver_0(t_1,(MStack-->MstVO(20007,0)),"source", 1982)); 
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: if the noun is a door , let the target be the noun]
          if (((noun ofclass K4_door))) {  t_0 = noun;   }
         ! phrase 7
         ! [7: end if]
         }

      ! phrase 8
      ! [8: if the target is a door begin]
       if (((t_0 ofclass K4_door)))  {
         ! phrase 9
         ! [9: now the target is the other side of the target from the room gone from]
          t_0 = (Resolver_1(t_0,(MStack-->MstVO(20007,0)),"source", 1986)); 
         ! phrase 10
         ! [10: end if]
         }

      ! phrase 11
      ! [11: now the room gone to is the target]
       (MStack-->MstVO(20007,1)) = t_0; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_142, 142, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor going ( this is the can't go that way rule ):
[ R_143 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_143, 143);
      ! phrase 1
      ! [1: if the room gone to is nothing begin]
       if ((((MStack-->MstVO(20007,1)) == nothing)))  {
         ! phrase 2
         ! [2: if the door gone through is nothing , stop the action with library message going action number 2 for the room gone from]
          if ((((MStack-->MstVO(20007,2)) == nothing))) {  return GL__M(##Go,2,(MStack-->MstVO(20007,0)));   }
         ! phrase 3
         ! [3: stop the action with library message going action number 6 for the door gone through]
          return GL__M(##Go,6,(MStack-->MstVO(20007,2))); 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_143, 143, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Going (B147_carry_out_going)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! This is the say goodbye when moving rule:
! --- now the mid-placed rules ---
! Rule 2/4 ! Carry out an actor going ( this is the move player and vehicle rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Carry out an actor going ( this is the move floating objects rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Carry out an actor going ( this is the check light in new location rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework" by Eric Eve
! This is the say goodbye when moving rule:
[ R_984 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_984, 984);
      ! phrase 1
      ! [1: if the current interlocutor is a person enclosed by the location begin]
       if ((((Global_Vars-->36) ofclass K8_person) && (IndirectlyContains(real_location,(Global_Vars-->36)))))  {
         ! phrase 2
         ! [2: now the farewell type is implicit]
          (Global_Vars-->38) = I111_implicit; 
         ! phrase 3
         ! [3: try saying goodbye to the current interlocutor]
          TryAction(0, player, ##A112_saying_goodbye_to, (Global_Vars-->36), 0);; 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_984, 984, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out an actor going ( this is the move player and vehicle rule ):
[ R_144 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_144, 144);
      ! phrase 1
      ! [1: if the vehicle gone by is nothing , surreptitiously move the actor to the room gone to during going]
       if ((((MStack-->MstVO(20007,3)) == nothing))) {  MoveDuringGoing(actor, (MStack-->MstVO(20007,1)));   }
      ! phrase 2
      ! [2: otherwise surreptitiously move the vehicle gone by to the room gone to during going]
       else {  MoveDuringGoing((MStack-->MstVO(20007,3)), (MStack-->MstVO(20007,1)));   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_144, 144, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out an actor going ( this is the move floating objects rule ):
[ R_145 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_145, 145);
      ! phrase 1
      ! [1: if the actor is the player , update backdrop positions]
       if (((actor == player))) {  MoveFloatingObjects();   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_145, 145, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out an actor going ( this is the check light in new location rule ):
[ R_146 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_146, 146);
      ! phrase 1
      ! [1: if the actor is the player , surreptitiously reckon darkness]
       if (((actor == player))) {  SilentlyConsiderLight();   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_146, 146, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Going (B148_report_going)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor going ( this is the describe room gone into rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor going ( this is the describe room gone into rule ):
[ R_147 
    t_0 ! Local variable e.g. '?-1,-1?' = object
    t_1 ! Local variable e.g. '?-1,-1?' = object
    t_2 ! Local variable e.g. '?-1,-1?' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_147, 147);
      ! phrase 1
      ! [1: if the player is the actor begin]
       if (((player == actor)))  {
         ! phrase 2
         ! [2: produce a room description with going spacing conventions]
          LookAfterGoing(); 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: if the noun is a direction begin]
          if (((noun ofclass K3_direction)))  {
            ! phrase 5
            ! [5: if the location is the room gone from begin]
             if (((real_location == (MStack-->MstVO(20007,0)))))  {
               ! phrase 6
               ! [6: if the location is the room gone to begin]
                if (((real_location == (MStack-->MstVO(20007,1)))))  {
                  ! phrase 7
                  ! [7: continue the action]
                   rfalse; 
                  ! phrase 8
                  ! [8: otherwise]
                  } else {

                  ! phrase 9
                  ! [9: if the noun is up begin]
                   if (((noun == I54_up)))  {
                     ! phrase 10
                     ! [10: issue actor-based library message going action number 8]
                      AGL__M(##Go,8,noun); 
                     ! phrase 11
                     ! [11: otherwise if the noun is down]
                      } else if (((noun == I55_down))) { 
                     ! phrase 12
                     ! [12: issue actor-based library message going action number 9]
                      AGL__M(##Go,9,noun); 
                     ! phrase 13
                     ! [13: otherwise]
                     } else {

                     ! phrase 14
                     ! [14: issue actor-based library message going action number 10 for the noun]
                      AGL__M(##Go,10,noun); 
                     ! phrase 15
                     ! [15: end if]
                     }

                  ! phrase 16
                  ! [16: end if]
                  }

               ! phrase 17
               ! [17: otherwise]
               } else {

               ! phrase 18
               ! [18: let the back way be the opposite of the noun]
                t_0 = GProperty(OBJECT_TY, noun,p9_opposite); 
               ! phrase 19
               ! [19: if the location is the room gone to begin]
                if (((real_location == (MStack-->MstVO(20007,1)))))  {
                  ! phrase 20
                  ! [20: let the room back the other way be the room back way from the location]
                   t_1 = (Resolver_6(t_0,real_location,"source", 2027)); 
                  ! phrase 21
                  ! [21: let the room normally this way be the room noun from the room gone from]
                   t_2 = (Resolver_7(noun,(MStack-->MstVO(20007,0)),"source", 2029)); 
                  ! phrase 22
                  ! [22: if the room back the other way is the room gone from or the room back the other way is the room normally this way begin]
                   if ((((t_1 == (MStack-->MstVO(20007,0))))) || (((t_1 == t_2))))  {
                     ! phrase 23
                     ! [23: if the back way is up begin]
                      if (((t_0 == I54_up)))  {
                        ! phrase 24
                        ! [24: issue actor-based library message going action number 11]
                         AGL__M(##Go,11,noun); 
                        ! phrase 25
                        ! [25: otherwise if the back way is down]
                         } else if (((t_0 == I55_down))) { 
                        ! phrase 26
                        ! [26: issue actor-based library message going action number 12]
                         AGL__M(##Go,12,noun); 
                        ! phrase 27
                        ! [27: otherwise]
                        } else {

                        ! phrase 28
                        ! [28: issue actor-based library message going action number 13 for the back way]
                         AGL__M(##Go,13,t_0); 
                        ! phrase 29
                        ! [29: end if]
                        }

                     ! phrase 30
                     ! [30: otherwise]
                     } else {

                     ! phrase 31
                     ! [31: issue actor-based library message going action number 14]
                      AGL__M(##Go,14,noun); 
                     ! phrase 32
                     ! [32: end if]
                     }

                  ! phrase 33
                  ! [33: otherwise]
                  } else {

                  ! phrase 34
                  ! [34: if the back way is up begin]
                   if (((t_0 == I54_up)))  {
                     ! phrase 35
                     ! [35: issue actor-based library message going action number 15 for the room gone to]
                      AGL__M(##Go,15,(MStack-->MstVO(20007,1))); 
                     ! phrase 36
                     ! [36: otherwise if the back way is down]
                      } else if (((t_0 == I55_down))) { 
                     ! phrase 37
                     ! [37: issue actor-based library message going action number 16 for the room gone to]
                      AGL__M(##Go,16,(MStack-->MstVO(20007,1))); 
                     ! phrase 38
                     ! [38: otherwise]
                     } else {

                     ! phrase 39
                     ! [39: issue actor-based library message going action number 17 for the room gone to and the back way]
                      AGL__M(##Go,17,(MStack-->MstVO(20007,1)),t_0); 
                     ! phrase 40
                     ! [40: end if]
                     }

                  ! phrase 41
                  ! [41: end if]
                  }

               ! phrase 42
               ! [42: end if]
               }

            ! phrase 43
            ! [43: otherwise if the location is the room gone from]
             } else if (((real_location == (MStack-->MstVO(20007,0))))) { 
            ! phrase 44
            ! [44: issue actor-based library message going action number 18 for the noun]
             AGL__M(##Go,18,noun); 
            ! phrase 45
            ! [45: otherwise]
            } else {

            ! phrase 46
            ! [46: issue actor-based library message going action number 19 for the noun]
             AGL__M(##Go,19,noun); 
            ! phrase 47
            ! [47: end if]
            }

         ! phrase 48
         ! [48: if the vehicle gone by is not nothing begin]
          if (((~~(((MStack-->MstVO(20007,3)) == nothing)))))  {
            ! phrase 49
            ! [49: say ~ ~]
            say__p=1;ParaContent();  print (PrintText) SC_88;  .L_Say268; .L_SayX263;
            ! phrase 50
            ! [50: if the vehicle gone by is a supporter , issue actor-based library message going action number 20 for the vehicle gone by]
             if ((((MStack-->MstVO(20007,3)) ofclass K6_supporter))) {  AGL__M(##Go,20,(MStack-->MstVO(20007,3)));   }
            ! phrase 51
            ! [51: otherwise issue actor-based library message going action number 21 for the vehicle gone by]
             else {  AGL__M(##Go,21,(MStack-->MstVO(20007,3)));   }
            ! phrase 52
            ! [52: end if]
            }

         ! phrase 53
         ! [53: if the thing gone with is not nothing begin]
          if (((~~(((MStack-->MstVO(20007,4)) == nothing)))))  {
            ! phrase 54
            ! [54: if the player is within the thing gone with begin]
             if ((((MStack-->MstVO(20007,4)) == ContainerOf(player))))  {
               ! phrase 55
               ! [55: issue actor-based library message going action number 22 for the thing gone with]
                AGL__M(##Go,22,(MStack-->MstVO(20007,4))); 
               ! phrase 56
               ! [56: otherwise if the player is within the vehicle gone by]
                } else if ((((MStack-->MstVO(20007,3)) == ContainerOf(player)))) { 
               ! phrase 57
               ! [57: issue actor-based library message going action number 23 for the thing gone with]
                AGL__M(##Go,23,(MStack-->MstVO(20007,4))); 
               ! phrase 58
               ! [58: otherwise if the location is the room gone from]
                } else if (((real_location == (MStack-->MstVO(20007,0))))) { 
               ! phrase 59
               ! [59: issue actor-based library message going action number 24 for the thing gone with]
                AGL__M(##Go,24,(MStack-->MstVO(20007,4))); 
               ! phrase 60
               ! [60: otherwise]
               } else {

               ! phrase 61
               ! [61: issue actor-based library message going action number 25 for the thing gone with]
                AGL__M(##Go,25,(MStack-->MstVO(20007,4))); 
               ! phrase 62
               ! [62: end if]
               }

            ! phrase 63
            ! [63: end if]
            }

         ! phrase 64
         ! [64: if the player is within the vehicle gone by and the player is not within the thing gone with begin]
          if (((((MStack-->MstVO(20007,3)) == ContainerOf(player)))) && (((~~(((MStack-->MstVO(20007,4)) == ContainerOf(player)))))))  {
            ! phrase 65
            ! [65: issue actor-based library message going action number 26]
             AGL__M(##Go,26,noun); 
            ! phrase 66
            ! [66: say ~.~]
            say__p=1;ParaContent();  print (PrintText) SC_201;  new_line; .L_Say269; .L_SayX264;
            ! phrase 67
            ! [67: try looking]
             TryAction(0, player, ##Look, 0, 0);; 
            ! phrase 68
            ! [68: continue the action]
             rfalse; 
            ! phrase 69
            ! [69: end if]
            }

         ! phrase 70
         ! [70: say ~.~]
         say__p=1;ParaContent();  print (PrintText) SC_201;  new_line; .L_Say270; .L_SayX265;
         ! phrase 71
         ! [71: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_147, 147, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Entering (B149_check_entering)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! Check an actor entering ( this is the convert enter door into go rule ):
!   === which is equally specific with ===
! Rule 2/7 ! Check an actor entering ( this is the convert enter compass direction into go rule ):
!   === which is equally specific with ===
! Rule 3/7 ! Check an actor entering ( this is the can't enter what's already entered rule ):
!   === which is equally specific with ===
! Rule 4/7 ! Check an actor entering ( this is the can't enter what's not enterable rule ):
!   === which is equally specific with ===
! Rule 5/7 ! Check an actor entering ( this is the can't enter closed containers rule ):
!   === which is equally specific with ===
! Rule 6/7 ! Check an actor entering ( this is the can't enter something carried rule ):
!   === which is equally specific with ===
! Rule 7/7 ! Check an actor entering ( this is the implicitly pass through other barriers rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor entering ( this is the convert enter door into go rule ):
[ R_149 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_149, 149);
      ! phrase 1
      ! [1: if the noun is a door , convert to the going action on the noun]
       if (((noun ofclass K4_door))) {  return GVS_Convert(##Go,noun,0);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_149, 149, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor entering ( this is the convert enter compass direction into go rule ):
[ R_150 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_150, 150);
      ! phrase 1
      ! [1: if the noun is a direction , convert to the going action on the noun]
       if (((noun ofclass K3_direction))) {  return GVS_Convert(##Go,noun,0);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_150, 150, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor entering ( this is the can't enter what's already entered rule ):
[ R_151 
    t_0 ! Local variable e.g. 'local ceiling' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_151, 151);
      ! phrase 1
      ! [1: let the local ceiling be the common ancestor of the actor with the noun]
       t_0 =  (CommonAncestor(actor, noun)) ; 
      ! phrase 2
      ! [2: if the local ceiling is the noun , stop the action with library message entering action number 1 for the noun]
       if (((t_0 == noun))) {  return GL__M(##Enter,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_151, 151, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor entering ( this is the can't enter what's not enterable rule ):
[ R_152 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_152, 152);
      ! phrase 1
      ! [1: if the noun is not enterable , stop the action with library message entering action number 2 for the noun]
       if (((~~(((Adj_62_t1_v9(noun))))))) {  return GL__M(##Enter,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_152, 152, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor entering ( this is the can't enter closed containers rule ):
[ R_153 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_153, 153);
      ! phrase 1
      ! [1: if the noun is a closed container , stop the action with library message entering action number 3 for the noun]
       if (((noun ofclass K5_container) && ((Adj_66_t1_v9(noun))))) {  return GL__M(##Enter,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_153, 153, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor entering ( this is the can't enter something carried rule ):
[ R_154 
    t_0 ! Local variable e.g. 'local ceiling' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_154, 154);
      ! phrase 1
      ! [1: let the local ceiling be the common ancestor of the actor with the noun]
       t_0 =  (CommonAncestor(actor, noun)) ; 
      ! phrase 2
      ! [2: if the local ceiling is the actor , stop the action with library message entering action number 4 for the noun]
       if (((t_0 == actor))) {  return GL__M(##Enter,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_154, 154, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor entering ( this is the implicitly pass through other barriers rule ):
[ R_155 
    t_0 ! Local variable e.g. 'local ceiling' = object
    t_1 ! Local variable e.g. 'target' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_155, 155);
      ! phrase 1
      ! [1: if the holder of the actor is the holder of the noun , continue the action]
       if ((( (HolderOf(actor))  ==  (HolderOf(noun)) ))) {  rfalse;   }
      ! phrase 2
      ! [2: let the local ceiling be the common ancestor of the actor with the noun]
       t_0 =  (CommonAncestor(actor, noun)) ; 
      ! phrase 3
      ! [3: while the holder of the actor is not the local ceiling begin]
       while (((~~(( (HolderOf(actor))  == t_0)))))  {
         ! phrase 4
         ! [4: let the target be the holder of the actor]
          t_1 =  (HolderOf(actor)) ; 
         ! phrase 5
         ! [5: issue library message entering action number 6 for the target]
          GL__M(##Enter,6,t_1); 
         ! phrase 6
         ! [6: silently try the actor trying exiting]
          @push keep_silent; keep_silent=1; TryAction(0, actor, ##Exit, 0, 0);; @pull keep_silent; 
         ! phrase 7
         ! [7: if the holder of the actor is the target , stop the action]
          if ((( (HolderOf(actor))  == t_1))) {  rtrue;   }
         ! phrase 8
         ! [8: end while]
         }

      ! phrase 9
      ! [9: if the holder of the actor is the noun , stop the action]
       if ((( (HolderOf(actor))  == noun))) {  rtrue;   }
      ! phrase 10
      ! [10: if the holder of the actor is the holder of the noun , continue the action]
       if ((( (HolderOf(actor))  ==  (HolderOf(noun)) ))) {  rfalse;   }
      ! phrase 11
      ! [11: let the target be the holder of the noun]
       t_1 =  (HolderOf(noun)) ; 
      ! phrase 12
      ! [12: if the noun is part of the target , let the target be the holder of the target]
       if (((t_1 == (noun.component_parent)))) {  t_1 =  (HolderOf(t_1)) ;   }
      ! phrase 13
      ! [13: while the target is a thing begin]
       while (((t_1 ofclass K2_thing)))  {
         ! phrase 14
         ! [14: if the holder of the target is the local ceiling begin]
          if ((( (HolderOf(t_1))  == t_0)))  {
            ! phrase 15
            ! [15: issue library message entering action number 7 for the target]
             GL__M(##Enter,7,t_1); 
            ! phrase 16
            ! [16: silently try the actor trying entering the target]
             @push keep_silent; keep_silent=1; TryAction(0, actor, ##Enter, t_1, 0);; @pull keep_silent; 
            ! phrase 17
            ! [17: if the holder of the actor is not the target , stop the action]
             if (((~~(( (HolderOf(actor))  == t_1))))) {  rtrue;   }
            ! phrase 18
            ! [18: convert to the entering action on the noun]
             return GVS_Convert(##Enter,noun,0); 
            ! phrase 19
            ! [19: continue the action]
             rfalse; 
            ! phrase 20
            ! [20: end if]
            }

         ! phrase 21
         ! [21: let the target be the holder of the target]
          t_1 =  (HolderOf(t_1)) ; 
         ! phrase 22
         ! [22: end while]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_155, 155, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Entering (B150_carry_out_entering)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out an actor entering ( this is the standard entering rule ):
!   <<< I - Number of aspects constrained <<<
! Rule 2/2 ! Carry out an actor entering something ( this is the arrival-posture rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor entering ( this is the standard entering rule ):
[ R_156 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_156, 156);
      ! phrase 1
      ! [1: surreptitiously move the actor to the noun]
       move actor to noun; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_156, 156, true);
   rfalse;
];
! No specific request
! From "Postures" by Emily Short
! Carry out an actor entering something ( this is the arrival-posture rule ):
[ R_1063 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1063, 1063);
      ! phrase 1
      ! [1: if the noun is a container or the noun is a supporter , now the posture of the actor is the posture of the noun]
       if ((((noun ofclass K5_container))) || (((noun ofclass K6_supporter)))) {  WriteGProperty(9, actor,p73_posture,GProperty(OBJECT_TY, noun,p73_posture));   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1063, 1063, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Entering (B151_report_entering)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor entering ( this is the standard report entering rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Report an actor entering ( this is the describe contents entered into rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor entering ( this is the standard report entering rule ):
[ R_157 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_157, 157);
      ! phrase 1
      ! [1: if the actor is the player begin]
       if (((actor == player)))  {
         ! phrase 2
         ! [2: issue library message entering action number 5 for the noun]
          GL__M(##Enter,5,noun); 
         ! phrase 3
         ! [3: otherwise if the noun is a container]
          } else if (((noun ofclass K5_container))) { 
         ! phrase 4
         ! [4: issue actor-based library message entering action number 8 for the noun]
          AGL__M(##Enter,8,noun); 
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: issue actor-based library message entering action number 9 for the noun]
          AGL__M(##Enter,9,noun); 
         ! phrase 7
         ! [7: end if]
         }

      ! phrase 8
      ! [8: continue the action]
       rfalse; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_157, 157, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor entering ( this is the describe contents entered into rule ):
[ R_158 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_158, 158);
      ! phrase 1
      ! [1: if the actor is the player , describe locale for the noun]
       if (((actor == player))) { (PHR_71_r18 (noun));  }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_158, 158, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Exiting (B152_check_exiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Check an actor exiting when the holder of the actor is a room ( this is the convert exits to standing rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/5 ! Check an actor exiting ( this is the convert exit into go out rule ):
!   === which is equally specific with ===
! Rule 3/5 ! Check an actor exiting ( this is the can't exit when not inside anything rule ):
!   === which is equally specific with ===
! Rule 4/5 ! Check an actor exiting ( this is the can't exit closed containers rule ):
!   === which is equally specific with ===
! Rule 5/5 ! Check an actor exiting ( this is the convert exit into get off rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Postures" by Emily Short
! Check an actor exiting when the holder of the actor is a room ( this is the convert exits to standing rule ):
[ R_1065 ;
   if ((act_requester==nothing) && (self=actor,true) && ((( (HolderOf(actor))  ofclass K1_room)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1065, 1065);
      ! phrase 1
      ! [1: try the actor taking position standing instead]
       TryAction(0, actor, ##A121_taking_position, I116_standing, 0);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1065, 1065, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor exiting ( this is the convert exit into go out rule ):
[ R_160 
    t_0 ! Local variable e.g. 'local room' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_160, 160);
      ! phrase 1
      ! [1: let the local room be the location of the actor]
       t_0 =  LocationOf(actor) ; 
      ! phrase 2
      ! [2: if the container exited from is the local room begin]
       if ((((MStack-->MstVO(20009,0)) == t_0)))  {
         ! phrase 3
         ! [3: if the room-or-door outside from the local room is not nothing , convert to the going action on the outside]
          if (((~~(((Resolver_8(out_obj,t_0,"source", 2185)) == nothing))))) {  return GVS_Convert(##Go,out_obj,0);   }
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_160, 160, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor exiting ( this is the can't exit when not inside anything rule ):
[ R_161 
    t_0 ! Local variable e.g. 'local room' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_161, 161);
      ! phrase 1
      ! [1: let the local room be the location of the actor]
       t_0 =  LocationOf(actor) ; 
      ! phrase 2
      ! [2: if the container exited from is the local room , stop the action with library message exiting action number 1 for the actor]
       if ((((MStack-->MstVO(20009,0)) == t_0))) {  return GL__M(##Exit,1,actor);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_161, 161, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor exiting ( this is the can't exit closed containers rule ):
[ R_162 
    t_0 ! Local variable e.g. 'cage' = container
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_162, 162);
      ! phrase 1
      ! [1: if the actor is in a closed container ( called the cage ) , stop the action with library message exiting action number 2 for the cage]
       if (((ContainerOf(actor) ofclass K5_container) && (t_0=(ContainerOf(actor)), true) && ((Adj_66_t1_v9(ContainerOf(actor)))))) {  return GL__M(##Exit,2,t_0);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_162, 162, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor exiting ( this is the convert exit into get off rule ):
[ R_163 
    t_0 ! Local variable e.g. 'platform' = supporter
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_163, 163);
      ! phrase 1
      ! [1: if the actor is on a supporter ( called the platform ) , convert to the getting off action on the platform]
       if (((SupporterOf(actor) ofclass K6_supporter) && (t_0=(SupporterOf(actor)), true))) {  return GVS_Convert(##GetOff,t_0,0);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_163, 163, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Exiting (B153_carry_out_exiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out an actor exiting ( this is the standard exiting rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Carry out an actor exiting ( this is the departure-posture rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor exiting ( this is the standard exiting rule ):
[ R_164 
    t_0 ! Local variable e.g. 'former exterior' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_164, 164);
      ! phrase 1
      ! [1: let the former exterior be the not-counting-parts holder of the container exited from]
       t_0 =  (CoreOfParentOfCoreOf((MStack-->MstVO(20009,0)))) ; 
      ! phrase 2
      ! [2: surreptitiously move the actor to the former exterior]
       move actor to t_0; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_164, 164, true);
   rfalse;
];
! No specific request
! From "Postures" by Emily Short
! Carry out an actor exiting ( this is the departure-posture rule ):
[ R_1062 
    t_0 ! Local variable e.g. 'N' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1062, 1062);
      ! phrase 1
      ! [1: let n be the holder of the actor]
       t_0 =  (HolderOf(actor)) ; 
      ! phrase 2
      ! [2: if n is a container or n is a supporter , now the posture of the actor is the posture of n]
       if ((((t_0 ofclass K5_container))) || (((t_0 ofclass K6_supporter)))) {  WriteGProperty(9, actor,p73_posture,GProperty(OBJECT_TY, t_0,p73_posture));   }
      ! phrase 3
      ! [3: otherwise now the posture of the actor is standing]
       else {  WriteGProperty(9, actor,p73_posture,I116_standing);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1062, 1062, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Exiting (B154_report_exiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor exiting ( this is the standard report exiting rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Report an actor exiting ( this is the describe room emerged into rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor exiting ( this is the standard report exiting rule ):
[ R_165 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_165, 165);
      ! phrase 1
      ! [1: if the actor is the player begin]
       if (((actor == player)))  {
         ! phrase 2
         ! [2: issue library message exiting action number 3 for the container exited from]
          GL__M(##Exit,3,(MStack-->MstVO(20009,0))); 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: issue actor-based library message exiting action number 6 for the container exited from]
          AGL__M(##Exit,6,(MStack-->MstVO(20009,0))); 
         ! phrase 5
         ! [5: end if]
         }

      ! phrase 6
      ! [6: continue the action]
       rfalse; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_165, 165, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor exiting ( this is the describe room emerged into rule ):
[ R_166 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_166, 166);
      ! phrase 1
      ! [1: if the actor is the player , produce a room description with going spacing conventions]
       if (((actor == player))) {  LookAfterGoing();   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_166, 166, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Getting off (B155_check_getting_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor getting off ( this is the can't get off things rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor getting off ( this is the can't get off things rule ):
[ R_167 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_167, 167);
      ! phrase 1
      ! [1: if the actor is on the noun , continue the action]
       if (((noun == SupporterOf(actor)))) {  rfalse;   }
      ! phrase 2
      ! [2: if the actor is carried by the noun , continue the action]
       if (((noun == CarrierOf(actor)))) {  rfalse;   }
      ! phrase 3
      ! [3: stop the action with library message getting off action number 1 for the noun]
       return GL__M(##GetOff,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_167, 167, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Getting off (B156_carry_out_getting_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out an actor getting off ( this is the standard getting off rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Carry out an actor exiting ( this is the departure-posture rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor getting off ( this is the standard getting off rule ):
[ R_168 
    t_0 ! Local variable e.g. 'former exterior' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_168, 168);
      ! phrase 1
      ! [1: let the former exterior be the not-counting-parts holder of the noun]
       t_0 =  (CoreOfParentOfCoreOf(noun)) ; 
      ! phrase 2
      ! [2: surreptitiously move the actor to the former exterior]
       move actor to t_0; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_168, 168, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Getting off (B157_report_getting_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor getting off ( this is the standard report getting off rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Report an actor getting off ( this is the describe room stood up into rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor getting off ( this is the standard report getting off rule ):
[ R_169 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_169, 169);
      ! phrase 1
      ! [1: if the actor is the player begin]
       if (((actor == player)))  {
         ! phrase 2
         ! [2: issue library message exiting action number 3 for the noun]
          GL__M(##Exit,3,noun); 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: issue actor-based library message exiting action number 5 for the noun]
          AGL__M(##Exit,5,noun); 
         ! phrase 5
         ! [5: end if]
         }

      ! phrase 6
      ! [6: continue the action]
       rfalse; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_169, 169, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor getting off ( this is the describe room stood up into rule ):
[ R_170 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_170, 170);
      ! phrase 1
      ! [1: if the actor is the player , produce a room description with going spacing conventions]
       if (((actor == player))) {  LookAfterGoing();   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_170, 170, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Looking (B159_carry_out_looking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Carry out looking ( this is the room description heading rule ):
!   === which is equally specific with ===
! Rule 2/5 ! Carry out looking ( this is the room description body text rule ):
!   === which is equally specific with ===
! Rule 3/5 ! Carry out looking ( this is the room description paragraphs about objects rule ):
!   === which is equally specific with ===
! Rule 4/5 ! Carry out looking ( this is the check new arrival rule ):
!   === which is equally specific with ===
! Rule 5/5 ! Carry out looking ( this is the mark items as seen when looking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out looking ( this is the room description heading rule ):
[ R_172 
    t_0 ! Local variable e.g. 'intermediate level' = object
    t_1 ! Local variable e.g. '?-1,-1?' = number
    ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_172, 172);
      ! phrase 1
      ! [1: say bold type]
      say__p=1;ParaContent();  style bold;  .L_Say271; .L_SayX266;
      ! phrase 2
      ! [2: if the visibility level count is 0 begin]
       if ((((MStack-->MstVO(20011,2)) == 0)))  {
         ! phrase 3
         ! [3: begin the printing the name of a dark room activity]
          BeginActivity(V8_printing_the_name_of_a_da); 
         ! phrase 4
         ! [4: if handling the printing the name of a dark room activity , issue miscellaneous library message number 71]
          if (( (~~(ForActivity(V8_printing_the_name_of_a_da))) )) {  GL__M(##Miscellany,71);   }
         ! phrase 5
         ! [5: end the printing the name of a dark room activity]
          EndActivity(V8_printing_the_name_of_a_da); 
         ! phrase 6
         ! [6: otherwise if the visibility ceiling is the location]
          } else if ((((MStack-->MstVO(20011,3)) == real_location))) { 
         ! phrase 7
         ! [7: say ~[visibility ceiling]~]
         say__p=1;ParaContent();  print (PrintShortName) (MStack-->MstVO(20011,3));  .L_Say272; .L_SayX267;
         ! phrase 8
         ! [8: otherwise]
         } else {

         ! phrase 9
         ! [9: say ~[The visibility ceiling]~]
         say__p=1;ParaContent();  print (The) (MStack-->MstVO(20011,3));  .L_Say273; .L_SayX268;
         ! phrase 10
         ! [10: end if]
         }

      ! phrase 11
      ! [11: say roman type]
      say__p=1;ParaContent();  style roman;  .L_Say274; .L_SayX269;
      ! phrase 12
      ! [12: let intermediate level be the visibility-holder of the actor]
       t_0 =  VisibilityParent(actor) ; 
      ! phrase 13
      ! [13: repeat with intermediate level count running from 2 to the visibility level count begin]
       for (t_1=2: t_1<=(MStack-->MstVO(20011,2)): t_1++)  {
         ! phrase 14
         ! [14: issue library message looking action number 8 for the intermediate level]
          GL__M(##Look,8,t_0); 
         ! phrase 15
         ! [15: let the intermediate level be the visibility-holder of the intermediate level]
          t_0 =  VisibilityParent(t_0) ; 
         ! phrase 16
         ! [16: end repeat]
         }

      ! phrase 17
      ! [17: say line break]
      say__p=1;ParaContent();  new_line;  .L_Say275; .L_SayX270;
      ! phrase 18
      ! [18: say run paragraph on with special look spacing]
      say__p=1;ParaContent();  SpecialLookSpacingBreak();  .L_Say276; .L_SayX271;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_172, 172, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out looking ( this is the room description body text rule ):
[ R_173 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_173, 173);
      ! phrase 1
      ! [1: if the visibility level count is 0 begin]
       if ((((MStack-->MstVO(20011,2)) == 0)))  {
         ! phrase 2
         ! [2: if set to abbreviated room descriptions , continue the action]
          if (( (lookmode == 3) )) {  rfalse;   }
         ! phrase 3
         ! [3: if set to sometimes abbreviated room descriptions and abbreviated form allowed is true and darkness witnessed is true , continue the action]
          if ((( (lookmode == 1) )) && ((((((MStack-->MstVO(20011,1)) && true) == (1 && true)))) && (((((Global_Vars-->0) && true) == (1 && true)))))) {  rfalse;   }
         ! phrase 4
         ! [4: begin the printing the description of a dark room activity]
          BeginActivity(V9_printing_the_description_); 
         ! phrase 5
         ! [5: if handling the printing the description of a dark room activity , issue miscellaneous library message number 17]
          if (( (~~(ForActivity(V9_printing_the_description_))) )) {  GL__M(##Miscellany,17);   }
         ! phrase 6
         ! [6: end the printing the description of a dark room activity]
          EndActivity(V9_printing_the_description_); 
         ! phrase 7
         ! [7: otherwise if the visibility ceiling is the location]
          } else if ((((MStack-->MstVO(20011,3)) == real_location))) { 
         ! phrase 8
         ! [8: if set to abbreviated room descriptions , continue the action]
          if (( (lookmode == 3) )) {  rfalse;   }
         ! phrase 9
         ! [9: if set to sometimes abbreviated room descriptions and abbreviated form allowed is true and the location is visited , continue the action]
          if ((( (lookmode == 1) )) && ((((((MStack-->MstVO(20011,1)) && true) == (1 && true)))) && ((((Adj_44_t1_v9(real_location))))))) {  rfalse;   }
         ! phrase 10
         ! [10: print the location's description]
          PrintOrRun(location, description); 
         ! phrase 11
         ! [11: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_173, 173, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out looking ( this is the room description paragraphs about objects rule ):
[ R_174 
    t_0 ! Local variable e.g. '?-1,-1?' = object
    t_1 ! Local variable e.g. '?-1,-1?' = number
    t_2 ! Local variable e.g. '?-1,-1?' = number
    ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_174, 174);
      ! phrase 1
      ! [1: if the visibility level count is greater than 0 begin]
       if ((((MStack-->MstVO(20011,2)) > 0)))  {
         ! phrase 2
         ! [2: let the intermediate position be the actor]
          t_0 = actor; 
         ! phrase 3
         ! [3: let the ip count be the visibility level count]
          t_1 = (MStack-->MstVO(20011,2)); 
         ! phrase 4
         ! [4: while the ip count is greater than 0 begin]
          while (((t_1 > 0)))  {
            ! phrase 5
            ! [5: now the intermediate position is marked for listing]
             (Adj_58_t2_v9(t_0)); 
            ! phrase 6
            ! [6: let the intermediate position be the visibility-holder of the intermediate position]
             t_0 =  VisibilityParent(t_0) ; 
            ! phrase 7
            ! [7: decrease the ip count by 1]
             t_1 = t_1 - 1; 
            ! phrase 8
            ! [8: end while]
            }

         ! phrase 9
         ! [9: let the top-down ip count be the visibility level count]
          t_2 = (MStack-->MstVO(20011,2)); 
         ! phrase 10
         ! [10: while the top-down ip count is greater than 0 begin]
          while (((t_2 > 0)))  {
            ! phrase 11
            ! [11: let the intermediate position be the actor]
             t_0 = actor; 
            ! phrase 12
            ! [12: let the ip count be 0]
             t_1 = 0; 
            ! phrase 13
            ! [13: while the ip count is less than the top-down ip count begin]
             while (((t_1 < t_2)))  {
               ! phrase 14
               ! [14: let the intermediate position be the visibility-holder of the intermediate position]
                t_0 =  VisibilityParent(t_0) ; 
               ! phrase 15
               ! [15: increase the ip count by 1]
                t_1 = t_1 + 1; 
               ! phrase 16
               ! [16: end while]
               }

            ! phrase 17
            ! [17: describe locale for the intermediate position]
            (PHR_71_r18 (t_0));
            ! phrase 18
            ! [18: decrease the top-down ip count by 1]
             t_2 = t_2 - 1; 
            ! phrase 19
            ! [19: end while]
            }

         ! phrase 20
         ! [20: end if]
         }

      ! phrase 21
      ! [21: continue the action]
       rfalse; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_174, 174, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out looking ( this is the check new arrival rule ):
[ R_175 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_175, 175);
      ! phrase 1
      ! [1: if in darkness begin]
       if (( (location==thedark) ))  {
         ! phrase 2
         ! [2: now the darkness witnessed is true]
          (Global_Vars-->0) = 1; 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: if the location is a room , now the location is visited]
          if (((real_location ofclass K1_room))) {  (Adj_44_t2_v9(real_location));   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_175, 175, true);
   rfalse;
];
! No specific request
! From "Epistemology" by Eric eve
! Carry out looking ( this is the mark items as seen when looking rule ):
[ R_945 
    t_0 ! Local variable e.g. '?-1,-1?' = thing
    t_1 ! Local variable e.g. '?-1,-1?' = thing
    ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_945, 945);
      ! phrase 1
      ! [1: unless in darkness begin]
       if (~~(( (location==thedark) )))  {
         ! phrase 2
         ! [2: repeat with item running through things that are enclosed by the location begin]
          for (t_0=Prop_54(0), t_1=Prop_54(t_0): t_0: t_0=t_1, t_1=Prop_54(t_1))  {
            ! phrase 3
            ! [3: if the item is not enclosed by an opaque closed container , now the item is seen]
             if ((~~Prop_55(,t_0))) {  (Adj_85_t2_v9(t_0));   }
            ! phrase 4
            ! [4: end repeat]
            }

         ! phrase 5
         ! [5: end unless]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_945, 945, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Looking (B160_report_looking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor looking ( this is the other people looking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor looking ( this is the other people looking rule ):
[ R_176 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_176, 176);
      ! phrase 1
      ! [1: if the actor is not the player , issue actor-based library message looking action number 9]
       if (((~~((actor == player))))) {  AGL__M(##Look,9,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_176, 176, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Examining (B162_carry_out_examining)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! Carry out examining something visible ( this is the mark items as seen on examining rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/7 ! Carry out examining ( this is the standard examining rule ):
!   === which is equally specific with ===
! Rule 3/7 ! Carry out examining ( this is the examine directions rule ):
!   === which is equally specific with ===
! Rule 4/7 ! Carry out examining ( this is the examine containers rule ):
!   === which is equally specific with ===
! Rule 5/7 ! Carry out examining ( this is the examine supporters rule ):
!   === which is equally specific with ===
! Rule 6/7 ! Carry out examining ( this is the examine devices rule ):
!   === which is equally specific with ===
! Rule 7/7 ! Carry out examining ( this is the examine undescribed things rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Epistemology" by Eric eve
! Carry out examining something visible ( this is the mark items as seen on examining rule ):
[ R_947 ;
   if ( (actor==player) && ((noun ofclass K2_thing) && ((Adj_3_t1_v9(noun))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_947, 947);
      ! phrase 1
      ! [1: now the noun is familiar]
       (Adj_87_t2_v9(noun)); 
      ! phrase 2
      ! [2: now the noun is seen]
       (Adj_85_t2_v9(noun)); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_947, 947, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out examining ( this is the standard examining rule ):
[ R_177 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_177, 177);
      ! phrase 1
      ! [1: if the noun provides the property description and the description of the noun is not ~~ begin]
       if ((((WhetherProvides(noun, false, description)))) && (((~~((GProperty(OBJECT_TY, noun,description) == EMPTY_TEXT_VALUE))))))  {
         ! phrase 2
         ! [2: say ~[the description of the noun][line break]~]
         say__p=1;ParaContent(); @push self;  print (PrintText) GProperty(OBJECT_TY, self=noun,description); @pull self; ParaContent();  new_line;  .L_Say277; .L_SayX272;
         ! phrase 3
         ! [3: now examine text printed is true]
          (MStack-->MstVO(20012,0)) = 1; 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_177, 177, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out examining ( this is the examine directions rule ):
[ R_178 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_178, 178);
      ! phrase 1
      ! [1: if the noun is a direction begin]
       if (((noun ofclass K3_direction)))  {
         ! phrase 2
         ! [2: issue library message examining action number 5 for the noun]
          GL__M(##Examine,5,noun); 
         ! phrase 3
         ! [3: now examine text printed is true]
          (MStack-->MstVO(20012,0)) = 1; 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_178, 178, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out examining ( this is the examine containers rule ):
[ R_179 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_179, 179);
      ! phrase 1
      ! [1: if the noun is a container begin]
       if (((noun ofclass K5_container)))  {
         ! phrase 2
         ! [2: if the noun is open or the noun is transparent begin]
          if (((((Adj_65_t1_v9(noun))))) || ((((Adj_64_t1_v9(noun))))))  {
            ! phrase 3
            ! [3: if something described which is not scenery is in the noun and something which is not the player is in the noun begin]
             if (((Prop_56())) && ((Prop_57())))  {
               ! phrase 4
               ! [4: issue library message searching action number 7 for the noun]
                GL__M(##Search,7,noun); 
               ! phrase 5
               ! [5: now examine text printed is true]
                (MStack-->MstVO(20012,0)) = 1; 
               ! phrase 6
               ! [6: otherwise if examine text printed is false]
                } else if (((((MStack-->MstVO(20012,0)) && true) == (0 && true)))) { 
               ! phrase 7
               ! [7: if the player is in the noun begin]
                if (((noun == ContainerOf(player))))  {
                  ! phrase 8
                  ! [8: make no decision]
                   rfalse; 
                  ! phrase 9
                  ! [9: end if]
                  }

               ! phrase 10
               ! [10: issue library message searching action number 6 for the noun]
                GL__M(##Search,6,noun); 
               ! phrase 11
               ! [11: now examine text printed is true]
                (MStack-->MstVO(20012,0)) = 1; 
               ! phrase 12
               ! [12: end if]
               }

            ! phrase 13
            ! [13: end if]
            }

         ! phrase 14
         ! [14: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_179, 179, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out examining ( this is the examine supporters rule ):
[ R_180 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_180, 180);
      ! phrase 1
      ! [1: if the noun is a supporter begin]
       if (((noun ofclass K6_supporter)))  {
         ! phrase 2
         ! [2: if something described which is not scenery is on the noun and something which is not the player is on the noun begin]
          if (((Prop_58())) && ((Prop_59())))  {
            ! phrase 3
            ! [3: issue library message looking action number 4 for the noun]
             GL__M(##Look,4,noun); 
            ! phrase 4
            ! [4: now examine text printed is true]
             (MStack-->MstVO(20012,0)) = 1; 
            ! phrase 5
            ! [5: end if]
            }

         ! phrase 6
         ! [6: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_180, 180, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out examining ( this is the examine devices rule ):
[ R_181 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_181, 181);
      ! phrase 1
      ! [1: if the noun is a device begin]
       if (((noun ofclass K13_device)))  {
         ! phrase 2
         ! [2: issue library message examining action number 3 for the noun]
          GL__M(##Examine,3,noun); 
         ! phrase 3
         ! [3: now examine text printed is true]
          (MStack-->MstVO(20012,0)) = 1; 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_181, 181, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out examining ( this is the examine undescribed things rule ):
[ R_182 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_182, 182);
      ! phrase 1
      ! [1: if examine text printed is false begin]
       if (((((MStack-->MstVO(20012,0)) && true) == (0 && true))))  {
         ! phrase 2
         ! [2: issue library message examining action number 2 for the noun]
          GL__M(##Examine,2,noun); 
         ! phrase 3
         ! [3: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_182, 182, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Examining (B163_report_examining)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor examining ( this is the report other people examining rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor examining ( this is the report other people examining rule ):
[ R_183 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_183, 183);
      ! phrase 1
      ! [1: if the actor is not the player , issue actor-based library message examining action number 4 for the noun]
       if (((~~((actor == player))))) {  AGL__M(##Examine,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_183, 183, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Looking under (B165_carry_out_looking_under)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! carry out looking under a noun:
!   >>> I - Number of aspects constrained >>>
! Rule 2/2 ! Carry out an actor looking under ( this is the standard looking under rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! carry out looking under a noun:
[ R_750 ;
   if ( (actor==player) && ((noun == noun) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_750, 750);
      ! phrase 1
      ! [1: if there is one thing underlying the noun begin]
       if ((Prop_60()))  {
         ! phrase 2
         ! [2: say ~underneath the [noun] is [a list of things underlying the noun].~]
         say__p=1;ParaContent();  print (PrintText) SC_451; ParaContent();  print (PrintShortName) noun; ParaContent();  print (PrintText) SC_301; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && ((subst__v.p59_underlying) == noun)))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say278; .L_SayX273;
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~There is nothing underneath [the noun].~ instead]
         say__p=1;ParaContent();  print (PrintText) SC_452; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_201;  new_line; rtrue; .L_Say279; .L_SayX274; rtrue;
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_750, 750, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out an actor looking under ( this is the standard looking under rule ):
[ R_184 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_184, 184);
      ! phrase 1
      ! [1: stop the action with library message looking under action number 2 for the noun]
       return GL__M(##LookUnder,2,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_184, 184, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Looking under (B166_report_looking_under)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor looking under ( this is the report other people looking under rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor looking under ( this is the report other people looking under rule ):
[ R_185 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_185, 185);
      ! phrase 1
      ! [1: if the actor is not the player , issue actor-based library message looking under action number 3 for the noun]
       if (((~~((actor == player))))) {  AGL__M(##LookUnder,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_185, 185, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Searching (B167_check_searching)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor searching ( this is the can't search unless container or supporter rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor searching ( this is the can't search closed opaque containers rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor searching ( this is the can't search unless container or supporter rule ):
[ R_186 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_186, 186);
      ! phrase 1
      ! [1: if the noun is not a container and the noun is not a supporter , stop the action with library message searching action number 4 for the noun]
       if ((((~~((noun ofclass K5_container))))) && (((~~((noun ofclass K6_supporter)))))) {  return GL__M(##Search,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_186, 186, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor searching ( this is the can't search closed opaque containers rule ):
[ R_187 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_187, 187);
      ! phrase 1
      ! [1: if the noun is a closed opaque container , stop the action with library message searching action number 5 for the noun]
       if (((noun ofclass K5_container) && ((Adj_66_t1_v9(noun))) && ((Adj_63_t1_v9(noun))))) {  return GL__M(##Search,5,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_187, 187, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Searching (B169_report_searching)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Report searching a container ( this is the standard search containers rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Report searching a supporter ( this is the standard search supporters rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 3/3 ! Report an actor searching ( this is the report other people searching rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report searching a container ( this is the standard search containers rule ):
[ R_188 ;
   if ( (actor==player) && ((noun ofclass K5_container))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_188, 188);
      ! phrase 1
      ! [1: if the noun contains a described thing which is not scenery , issue library message searching action number 7 for the noun]
       if ((Prop_61())) {  GL__M(##Search,7,noun);   }
      ! phrase 2
      ! [2: otherwise issue library message searching action number 6 for the noun]
       else {  GL__M(##Search,6,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_188, 188, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report searching a supporter ( this is the standard search supporters rule ):
[ R_189 ;
   if ( (actor==player) && ((noun ofclass K6_supporter))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_189, 189);
      ! phrase 1
      ! [1: if the noun supports a described thing which is not scenery , issue library message searching action number 3 for the noun]
       if ((Prop_62())) {  GL__M(##Search,3,noun);   }
      ! phrase 2
      ! [2: otherwise issue library message searching action number 2 for the noun]
       else {  GL__M(##Search,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_189, 189, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor searching ( this is the report other people searching rule ):
[ R_190 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_190, 190);
      ! phrase 1
      ! [1: if the actor is not the player , issue actor-based library message searching action number 8 for the noun]
       if (((~~((actor == player))))) {  AGL__M(##Search,8,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_190, 190, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Consulting it about (B172_report_consulting_it_ab)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor consulting something about ( this is the block consulting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor consulting something about ( this is the block consulting rule ):
[ R_191 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_191, 191);
      ! phrase 1
      ! [1: if the actor is the player , issue library message consulting it about action number 1 for the noun]
       if (((actor == player))) {  GL__M(##Consult,1,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message consulting it about action number 2 for the noun]
       else {  AGL__M(##Consult,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_191, 191, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Locking it with (B173_check_locking_it_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check an actor locking something with ( this is the can't lock without a lock rule ):
!   === which is equally specific with ===
! Rule 2/4 ! Check an actor locking something with ( this is the can't lock what's already locked rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Check an actor locking something with ( this is the can't lock what's open rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Check an actor locking something with ( this is the can't lock without the correct key rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor locking something with ( this is the can't lock without a lock rule ):
[ R_192 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_192, 192);
      ! phrase 1
      ! [1: if the noun provides the property lockable and the noun is lockable , continue the action]
       if ((((WhetherProvides(noun, true, lockable)))) && ((((Adj_69_t1_v9(noun)))))) {  rfalse;   }
      ! phrase 2
      ! [2: stop the action with library message locking it with action number 1 for the noun]
       return GL__M(##Lock,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_192, 192, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor locking something with ( this is the can't lock what's already locked rule ):
[ R_193 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_193, 193);
      ! phrase 1
      ! [1: if the noun is locked , stop the action with library message locking it with action number 2 for the noun]
       if ((((Adj_70_t1_v9(noun))))) {  return GL__M(##Lock,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_193, 193, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor locking something with ( this is the can't lock what's open rule ):
[ R_194 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_194, 194);
      ! phrase 1
      ! [1: if the noun is open , stop the action with library message locking it with action number 3 for the noun]
       if ((((Adj_65_t1_v9(noun))))) {  return GL__M(##Lock,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_194, 194, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor locking something with ( this is the can't lock without the correct key rule ):
[ R_195 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_195, 195);
      ! phrase 1
      ! [1: if the holder of the second noun is not the actor or the noun does not provide the property matching key or the matching key of the noun is not the second noun , stop the action with library message locking it with action number 4 for the second noun]
       if ((((~~(( (HolderOf(second))  == actor))))) || ((((~~((WhetherProvides(noun, false, with_key)))))) || (((~~((GProperty(OBJECT_TY, noun,with_key) == second))))))) {  return GL__M(##Lock,4,second);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_195, 195, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Locking it with (B174_carry_out_locking_it_wi)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor locking something with ( this is the standard locking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor locking something with ( this is the standard locking rule ):
[ R_196 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_196, 196);
      ! phrase 1
      ! [1: now the noun is locked]
       (Adj_70_t2_v9(noun)); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_196, 196, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Locking it with (B175_report_locking_it_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor locking something with ( this is the standard report locking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor locking something with ( this is the standard report locking rule ):
[ R_197 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_197, 197);
      ! phrase 1
      ! [1: if the actor is the player begin]
       if (((actor == player)))  {
         ! phrase 2
         ! [2: issue library message locking it with action number 5 for the noun]
          GL__M(##Lock,5,noun); 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: if the actor is visible , issue actor-based library message locking it with action number 6 for the noun]
          if ((((Adj_3_t1_v9(actor))))) {  AGL__M(##Lock,6,noun);   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_197, 197, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Unlocking it with (B176_check_unlocking_it_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! check unlocking suitcase with:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 2/4 ! Check an actor unlocking something with ( this is the can't unlock without a lock rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Check an actor unlocking something with ( this is the can't unlock what's already unlocked rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Check an actor unlocking something with ( this is the can't unlock without the correct key rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! check unlocking suitcase with:
[ R_1146 ;
   if ( (actor==player) && ((noun == I228_suitcase) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1146, 1146);
      ! phrase 1
      ! [1: say ~Enter the combination lock code:~]
      say__p=1;ParaContent();  print (PrintText) SC_232;  .L_Say280; .L_SayX275;
      ! phrase 2
      ! [2: rule succeeds]
       RulebookSucceeds(); rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1146, 1146, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor unlocking something with ( this is the can't unlock without a lock rule ):
[ R_198 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_198, 198);
      ! phrase 1
      ! [1: if the noun provides the property lockable and the noun is lockable , continue the action]
       if ((((WhetherProvides(noun, true, lockable)))) && ((((Adj_69_t1_v9(noun)))))) {  rfalse;   }
      ! phrase 2
      ! [2: stop the action with library message unlocking it with action number 1 for the noun]
       return GL__M(##Unlock,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_198, 198, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor unlocking something with ( this is the can't unlock what's already unlocked rule ):
[ R_199 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_199, 199);
      ! phrase 1
      ! [1: if the noun is not locked , stop the action with library message unlocking it with action number 2 for the noun]
       if (((~~(((Adj_70_t1_v9(noun))))))) {  return GL__M(##Unlock,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_199, 199, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor unlocking something with ( this is the can't unlock without the correct key rule ):
[ R_200 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_200, 200);
      ! phrase 1
      ! [1: if the holder of the second noun is not the actor or the noun does not provide the property matching key or the matching key of the noun is not the second noun , stop the action with library message unlocking it with action number 3 for the second noun]
       if ((((~~(( (HolderOf(second))  == actor))))) || ((((~~((WhetherProvides(noun, false, with_key)))))) || (((~~((GProperty(OBJECT_TY, noun,with_key) == second))))))) {  return GL__M(##Unlock,3,second);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_200, 200, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Unlocking it with (B177_carry_out_unlocking_it_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor unlocking something with ( this is the standard unlocking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor unlocking something with ( this is the standard unlocking rule ):
[ R_201 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_201, 201);
      ! phrase 1
      ! [1: now the noun is not locked]
       (Adj_70_t3_v9(noun)); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_201, 201, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Unlocking it with (B178_report_unlocking_it_wit)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor unlocking something with ( this is the standard report unlocking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor unlocking something with ( this is the standard report unlocking rule ):
[ R_202 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_202, 202);
      ! phrase 1
      ! [1: if the actor is the player begin]
       if (((actor == player)))  {
         ! phrase 2
         ! [2: issue library message unlocking it with action number 4 for the noun]
          GL__M(##Unlock,4,noun); 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: if the actor is visible , issue actor-based library message unlocking it with action number 5 for the noun]
          if ((((Adj_3_t1_v9(actor))))) {  AGL__M(##Unlock,5,noun);   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_202, 202, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Switching on (B179_check_switching_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor switching on ( this is the can't switch on unless switchable rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor switching on ( this is the can't switch on what's already on rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor switching on ( this is the can't switch on unless switchable rule ):
[ R_203 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_203, 203);
      ! phrase 1
      ! [1: if the noun provides the property switched on , continue the action]
       if (((WhetherProvides(noun, true, on)))) {  rfalse;   }
      ! phrase 2
      ! [2: stop the action with library message switching on action number 1 for the noun]
       return GL__M(##SwitchOn,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_203, 203, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor switching on ( this is the can't switch on what's already on rule ):
[ R_204 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_204, 204);
      ! phrase 1
      ! [1: if the noun is switched on , stop the action with library message switching on action number 2 for the noun]
       if ((((Adj_75_t1_v9(noun))))) {  return GL__M(##SwitchOn,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_204, 204, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Switching on (B180_carry_out_switching_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor switching on ( this is the standard switching on rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor switching on ( this is the standard switching on rule ):
[ R_205 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_205, 205);
      ! phrase 1
      ! [1: now the noun is switched on]
       (Adj_75_t2_v9(noun)); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_205, 205, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Switching on (B181_report_switching_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! report switching on television when the venture of work is not incomplete:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 2/4 ! report switching on television when the venture of work is incomplete:
!   >>> I - Number of aspects constrained >>>
! Rule 3/4 ! report switching on start button:
!   >>> I - Number of aspects constrained >>>
! Rule 4/4 ! Report an actor switching on ( this is the standard report switching on rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! report switching on television when the venture of work is not incomplete:
[ R_1292 ;
   if ( (actor==player) && ((noun == I324_television) && (true)) && (self=actor,true) && (((~~((GProperty(SCENE_TY, I238_work,p80_venture) == I268_incomplete)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1292, 1292);
      ! phrase 1
      ! [1: say ~[one of]As you switch in the television, you are greeted with the sight of the last few minutes of the evening news.[paragraph break][italic type]'And finally, bird-watchers everywhere have reported that the nation's owls have been behaving very unusually today.[line break]Although owls normally hunt at night and are hardly ever seen in daylight, there have been hundreds of sightings of these birds flying in every direction since sunrise.[paragraph break]Experts are unable to explain why the owls have suddenly changed their sleeping pattern. Most mysterious.[paragraph break]And now, over to Jim McGuffin with the weather. Going to be any more showers of owls tonight, Jim?'.[roman type][run paragraph on][or]You turn the tv on, but there's nothing good to watch.[stopping]~]
      say__p=1;ParaContent();  I7_ST_say_one_of-->4 =
	i7_soo_stop(I7_ST_say_one_of-->4, 2);
	switch((I7_ST_say_one_of-->4)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_453; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  style underline; ParaContent();  print (PrintText) SC_454; ParaContent();  new_line; ParaContent();  print (PrintText) SC_455; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_456; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_457; ParaContent();  style roman; ParaContent();  RunParagraphOn(); ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_458;  new_line;ParaContent();  }  .L_Say281; .L_SayX276;
      ! phrase 2
      ! [2: if tvonafterwork is 0 begin]
       if ((((Global_Vars-->80) == 0)))  {
         ! phrase 3
         ! [3: if glulx timekeeping is supported begin]
          if (( ( glk_gestalt(gestalt_Timer, 0) ) ))  {
            ! phrase 4
            ! [4: wait 7000 ms before continuing]
            (PHR_1016_r6 (7000));
            ! phrase 5
            ! [5: end if]
            }

         ! phrase 6
         ! [6: now tvonafterwork is 1]
          (Global_Vars-->80) = 1; 
         ! phrase 7
         ! [7: say ~[paragraph break][italic type]'Well, Ted, I don[']t know about that, but it's not only the owls that have been acting oddly today.[line break]Viewers as far apart as Kent, Yorkshire, and Dundee have been phoning in to tell me that instead of the rain I promised yesterday, they've had a downpour of shooting stars![line break]Perhaps people have been celebrating Bonfire Night early - it's not untill next week, folks! But I can promise a wet night tonight.[roman type][line break]~ instead]
         say__p=1;ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  style underline; ParaContent();  print (PrintText) SC_459; ParaContent();  print "'"; ParaContent();  print (PrintText) SC_460; ParaContent();  new_line; ParaContent();  print (PrintText) SC_461; ParaContent();  new_line; ParaContent();  print (PrintText) SC_462; ParaContent();  style roman; ParaContent();  new_line;  rtrue; .L_Say282; .L_SayX277; rtrue;
         ! phrase 8
         ! [8: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1292, 1292, true);
   rfalse;
];
! No specific request
! report switching on television when the venture of work is incomplete:
[ R_1291 ;
   if ( (actor==player) && ((noun == I324_television) && (true)) && (self=actor,true) && (((GProperty(SCENE_TY, I238_work,p80_venture) == I268_incomplete)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1291, 1291);
      ! phrase 1
      ! [1: say ~You turn on the Television, but the only thing on is children's shows.~]
      say__p=1;ParaContent();  print (PrintText) SC_463;  new_line; .L_Say283; .L_SayX278;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1291, 1291, true);
   rfalse;
];
! No specific request
! report switching on start button:
[ R_1164 ;
   if ( (actor==player) && ((noun == I235_start_button) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1164, 1164);
      ! phrase 1
      ! [1: if ferrari enzo is in garage begin]
       if (((I201_garage == ContainerOf(I234_ferrari_enzo))))  {
         ! phrase 2
         ! [2: if player is in ferrari enzo begin]
          if (((I234_ferrari_enzo == ContainerOf(player))))  {
            ! phrase 3
            ! [3: if garage is open begin]
             if ((((Adj_65_t1_v9(I201_garage)))))  {
               ! phrase 4
               ! [4: say ~you gently move the priceless car to the Garden.~ instead]
               say__p=1;ParaContent();  print (PrintText) SC_464;  new_line; rtrue; .L_Say284; .L_SayX279; rtrue;
               ! phrase 5
               ! [5: end if]
               }

            ! phrase 6
            ! [6: end if]
            }

         ! phrase 7
         ! [7: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1164, 1164, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor switching on ( this is the standard report switching on rule ):
[ R_206 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_206, 206);
      ! phrase 1
      ! [1: if the actor is the player , issue library message switching on action number 3 for the noun]
       if (((actor == player))) {  GL__M(##SwitchOn,3,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message switching on action number 4 for the noun]
       else {  AGL__M(##SwitchOn,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_206, 206, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Switching off (B182_check_switching_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor switching off ( this is the can't switch off unless switchable rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor switching off ( this is the can't switch off what's already off rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor switching off ( this is the can't switch off unless switchable rule ):
[ R_207 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_207, 207);
      ! phrase 1
      ! [1: if the noun provides the property switched on , continue the action]
       if (((WhetherProvides(noun, true, on)))) {  rfalse;   }
      ! phrase 2
      ! [2: stop the action with library message switching off action number 1 for the noun]
       return GL__M(##SwitchOff,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_207, 207, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor switching off ( this is the can't switch off what's already off rule ):
[ R_208 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_208, 208);
      ! phrase 1
      ! [1: if the noun is switched off , stop the action with library message switching off action number 2 for the noun]
       if ((((Adj_76_t1_v9(noun))))) {  return GL__M(##SwitchOff,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_208, 208, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Switching off (B183_carry_out_switching_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor switching off ( this is the standard switching off rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor switching off ( this is the standard switching off rule ):
[ R_209 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_209, 209);
      ! phrase 1
      ! [1: now the noun is switched off]
       (Adj_76_t2_v9(noun)); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_209, 209, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Switching off (B184_report_switching_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor switching off ( this is the standard report switching off rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor switching off ( this is the standard report switching off rule ):
[ R_210 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_210, 210);
      ! phrase 1
      ! [1: if the actor is the player , issue library message switching off action number 3 for the noun]
       if (((actor == player))) {  GL__M(##SwitchOff,3,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message switching off action number 4 for the noun]
       else {  AGL__M(##SwitchOff,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_210, 210, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Opening (B185_check_opening)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor opening ( this is the can't open unless openable rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor opening ( this is the can't open what's locked rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor opening ( this is the can't open what's already open rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor opening ( this is the can't open unless openable rule ):
[ R_211 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_211, 211);
      ! phrase 1
      ! [1: if the noun provides the property openable and the noun is openable , continue the action]
       if ((((WhetherProvides(noun, true, openable)))) && ((((Adj_67_t1_v9(noun)))))) {  rfalse;   }
      ! phrase 2
      ! [2: stop the action with library message opening action number 1 for the noun]
       return GL__M(##Open,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_211, 211, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor opening ( this is the can't open what's locked rule ):
[ R_212 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_212, 212);
      ! phrase 1
      ! [1: if the noun provides the property lockable and the noun is locked , stop the action with library message opening action number 2 for the noun]
       if ((((WhetherProvides(noun, true, lockable)))) && ((((Adj_70_t1_v9(noun)))))) {  return GL__M(##Open,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_212, 212, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor opening ( this is the can't open what's already open rule ):
[ R_213 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_213, 213);
      ! phrase 1
      ! [1: if the noun is open , stop the action with library message opening action number 3 for the noun]
       if ((((Adj_65_t1_v9(noun))))) {  return GL__M(##Open,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_213, 213, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Opening (B186_carry_out_opening)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out an actor opening ( this is the standard opening rule ):
!   <<< I - Number of aspects constrained <<<
! Rule 2/2 ! Carry out opening a container ( this is the mark items as seen on opening a container rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor opening ( this is the standard opening rule ):
[ R_214 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_214, 214);
      ! phrase 1
      ! [1: now the noun is open]
       (Adj_65_t2_v9(noun)); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_214, 214, true);
   rfalse;
];
! No specific request
! From "Epistemology" by Eric eve
! Carry out opening a container ( this is the mark items as seen on opening a container rule ):
[ R_946 
    t_0 ! Local variable e.g. '?-1,-1?' = thing
    t_1 ! Local variable e.g. '?-1,-1?' = thing
    ;
   if ( (actor==player) && ((noun ofclass K5_container))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_946, 946);
      ! phrase 1
      ! [1: repeat with item running through things that are enclosed by the noun begin]
       for (t_0=Prop_63(0), t_1=Prop_63(t_0): t_0: t_0=t_1, t_1=Prop_63(t_1))  {
         ! phrase 2
         ! [2: if the item is unseen and the item is visible , now the item is seen]
          if (((((Adj_86_t1_v9(t_0))))) && ((((Adj_3_t1_v9(t_0)))))) {  (Adj_85_t2_v9(t_0));   }
         ! phrase 3
         ! [3: end repeat]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_946, 946, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Opening (B187_report_opening)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor opening ( this is the reveal any newly visible interior rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Report an actor opening ( this is the standard report opening rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor opening ( this is the reveal any newly visible interior rule ):
[ R_215 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_215, 215);
      ! phrase 1
      ! [1: if the actor is the player and the noun is an opaque container and the first thing held by the noun is not nothing and the noun does not enclose the actor , stop the action with library message opening action number 4 for the noun]
       if ((((actor == player))) && ((((noun ofclass K5_container) && ((Adj_63_t1_v9(noun))))) && ((((~~(( (child(noun))  == nothing))))) && (((~~((IndirectlyContains(noun,actor))))))))) {  return GL__M(##Open,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_215, 215, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor opening ( this is the standard report opening rule ):
[ R_216 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_216, 216);
      ! phrase 1
      ! [1: if the actor is the player begin]
       if (((actor == player)))  {
         ! phrase 2
         ! [2: issue library message opening action number 5 for the noun]
          GL__M(##Open,5,noun); 
         ! phrase 3
         ! [3: otherwise if the player can see the actor]
          } else if (((TestVisibility(player,actor)))) { 
         ! phrase 4
         ! [4: issue actor-based library message opening action number 6 for the noun]
          AGL__M(##Open,6,noun); 
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: issue actor-based library message opening action number 7 for the noun]
          AGL__M(##Open,7,noun); 
         ! phrase 7
         ! [7: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_216, 216, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Closing (B188_check_closing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor closing ( this is the can't close unless openable rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor closing ( this is the can't close what's already closed rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor closing ( this is the can't close unless openable rule ):
[ R_217 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_217, 217);
      ! phrase 1
      ! [1: if the noun provides the property openable and the noun is openable , continue the action]
       if ((((WhetherProvides(noun, true, openable)))) && ((((Adj_67_t1_v9(noun)))))) {  rfalse;   }
      ! phrase 2
      ! [2: stop the action with library message closing action number 1 for the noun]
       return GL__M(##Close,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_217, 217, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor closing ( this is the can't close what's already closed rule ):
[ R_218 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_218, 218);
      ! phrase 1
      ! [1: if the noun is closed , stop the action with library message closing action number 2 for the noun]
       if ((((Adj_66_t1_v9(noun))))) {  return GL__M(##Close,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_218, 218, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Closing (B189_carry_out_closing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor closing ( this is the standard closing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor closing ( this is the standard closing rule ):
[ R_219 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_219, 219);
      ! phrase 1
      ! [1: now the noun is closed]
       (Adj_66_t2_v9(noun)); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_219, 219, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Closing (B190_report_closing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor closing ( this is the standard report closing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor closing ( this is the standard report closing rule ):
[ R_220 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_220, 220);
      ! phrase 1
      ! [1: if the actor is the player begin]
       if (((actor == player)))  {
         ! phrase 2
         ! [2: issue library message closing action number 3 for the noun]
          GL__M(##Close,3,noun); 
         ! phrase 3
         ! [3: otherwise if the player can see the actor]
          } else if (((TestVisibility(player,actor)))) { 
         ! phrase 4
         ! [4: issue actor-based library message closing action number 4 for the noun]
          AGL__M(##Close,4,noun); 
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: issue actor-based library message closing action number 5 for the noun]
          AGL__M(##Close,5,noun); 
         ! phrase 7
         ! [7: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_220, 220, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Wearing (B191_check_wearing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor wearing ( this is the can't wear what's not clothing rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor wearing ( this is the can't wear what's not held rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor wearing ( this is the can't wear what's already worn rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor wearing ( this is the can't wear what's not clothing rule ):
[ R_221 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_221, 221);
      ! phrase 1
      ! [1: if the noun is not a thing or the noun is not wearable , stop the action with library message wearing action number 1 for the noun]
       if ((((~~((noun ofclass K2_thing))))) || (((~~(((Adj_53_t1_v9(noun)))))))) {  return GL__M(##Wear,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_221, 221, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor wearing ( this is the can't wear what's not held rule ):
[ R_222 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_222, 222);
      ! phrase 1
      ! [1: if the holder of the noun is not the actor , stop the action with library message wearing action number 2 for the noun]
       if (((~~(( (HolderOf(noun))  == actor))))) {  return GL__M(##Wear,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_222, 222, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor wearing ( this is the can't wear what's already worn rule ):
[ R_223 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_223, 223);
      ! phrase 1
      ! [1: if the actor is wearing the noun , stop the action with library message wearing action number 3 for the noun]
       if (((actor == WearerOf(noun)))) {  return GL__M(##Wear,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_223, 223, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Wearing (B192_carry_out_wearing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor wearing ( this is the standard wearing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor wearing ( this is the standard wearing rule ):
[ R_224 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_224, 224);
      ! phrase 1
      ! [1: now the actor wears the noun]
       WearObject(noun,actor); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_224, 224, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Wearing (B193_report_wearing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor wearing ( this is the standard report wearing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor wearing ( this is the standard report wearing rule ):
[ R_225 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_225, 225);
      ! phrase 1
      ! [1: if the actor is the player , issue library message wearing action number 4 for the noun]
       if (((actor == player))) {  GL__M(##Wear,4,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message wearing action number 5 for the noun]
       else {  AGL__M(##Wear,5,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_225, 225, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Taking off (B194_check_taking_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor taking off ( this is the can't take off what's not worn rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor taking off ( this is the can't take off what's not worn rule ):
[ R_226 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_226, 226);
      ! phrase 1
      ! [1: if the actor is not wearing the noun , stop the action with library message taking off action number 1 for the noun]
       if (((~~((actor == WearerOf(noun)))))) {  return GL__M(##Disrobe,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_226, 226, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Taking off (B195_carry_out_taking_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor taking off ( this is the standard taking off rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor taking off ( this is the standard taking off rule ):
[ R_227 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_227, 227);
      ! phrase 1
      ! [1: now the actor carries the noun]
       MoveObject(noun,actor); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_227, 227, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Taking off (B196_report_taking_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor taking off ( this is the standard report taking off rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor taking off ( this is the standard report taking off rule ):
[ R_228 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_228, 228);
      ! phrase 1
      ! [1: if the actor is the player , issue library message taking off action number 2 for the noun]
       if (((actor == player))) {  GL__M(##Disrobe,2,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message taking off action number 3 for the noun]
       else {  AGL__M(##Disrobe,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_228, 228, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Giving it to (B197_check_giving_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Check an actor giving something to ( this is the can't give what you haven't got rule ):
!   === which is equally specific with ===
! Rule 2/5 ! Check an actor giving something to ( this is the can't give to yourself rule ):
!   === which is equally specific with ===
! Rule 3/5 ! Check an actor giving something to ( this is the can't give to a non-person rule ):
!   === which is equally specific with ===
! Rule 4/5 ! Check an actor giving something to ( this is the can't give clothes being worn rule ):
!   === which is equally specific with ===
! Rule 5/5 ! Check an actor giving something to ( this is the block giving rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor giving something to ( this is the can't give what you haven't got rule ):
[ R_229 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_229, 229);
      ! phrase 1
      ! [1: if the actor is not the holder of the noun , stop the action with library message giving it to action number 1 for the noun]
       if (((~~((actor ==  (HolderOf(noun)) ))))) {  return GL__M(##Give,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_229, 229, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor giving something to ( this is the can't give to yourself rule ):
[ R_230 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_230, 230);
      ! phrase 1
      ! [1: if the actor is the second noun , stop the action with library message giving it to action number 2 for the noun]
       if (((actor == second))) {  return GL__M(##Give,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_230, 230, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor giving something to ( this is the can't give to a non-person rule ):
[ R_231 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_231, 231);
      ! phrase 1
      ! [1: if the second noun is not a person , stop the action with library message giving it to action number 4 for the second noun]
       if (((~~((second ofclass K8_person))))) {  return GL__M(##Give,4,second);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_231, 231, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor giving something to ( this is the can't give clothes being worn rule ):
[ R_232 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_232, 232);
      ! phrase 1
      ! [1: if the actor is wearing the noun begin]
       if (((actor == WearerOf(noun))))  {
         ! phrase 2
         ! [2: issue library message dropping action number 3 for the noun]
          GL__M(##Drop,3,noun); 
         ! phrase 3
         ! [3: silently try the actor trying taking off the noun]
          @push keep_silent; keep_silent=1; TryAction(0, actor, ##Disrobe, noun, 0);; @pull keep_silent; 
         ! phrase 4
         ! [4: if the actor is wearing the noun , stop the action]
          if (((actor == WearerOf(noun)))) {  rtrue;   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_232, 232, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor giving something to ( this is the block giving rule ):
[ R_233 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_233, 233);
      ! phrase 1
      ! [1: stop the action with library message giving it to action number 3 for the second noun]
       return GL__M(##Give,3,second); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_233, 233, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Giving it to (B198_carry_out_giving_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor giving something to ( this is the standard giving rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor giving something to ( this is the standard giving rule ):
[ R_234 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_234, 234);
      ! phrase 1
      ! [1: move the noun to the second noun]
       MoveObject(noun, second, 0, false); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_234, 234, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Giving it to (B199_report_giving_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor giving something to ( this is the standard report giving rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor giving something to ( this is the standard report giving rule ):
[ R_235 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_235, 235);
      ! phrase 1
      ! [1: if the actor is the player begin]
       if (((actor == player)))  {
         ! phrase 2
         ! [2: issue library message giving it to action number 5 for the noun]
          GL__M(##Give,5,noun); 
         ! phrase 3
         ! [3: otherwise if the second noun is the player]
          } else if (((second == player))) { 
         ! phrase 4
         ! [4: issue actor-based library message giving it to action number 6 for the noun]
          AGL__M(##Give,6,noun); 
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: issue actor-based library message giving it to action number 7 for the noun]
          AGL__M(##Give,7,noun); 
         ! phrase 7
         ! [7: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_235, 235, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Showing it to (B200_check_showing_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor showing something to ( this is the can't show what you haven't got rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor showing something to ( this is the convert show to yourself to examine rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor showing something to ( this is the block showing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor showing something to ( this is the can't show what you haven't got rule ):
[ R_236 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_236, 236);
      ! phrase 1
      ! [1: if the actor is not the holder of the noun , stop the action with library message showing it to action number 1 for the noun]
       if (((~~((actor ==  (HolderOf(noun)) ))))) {  return GL__M(##Show,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_236, 236, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor showing something to ( this is the convert show to yourself to examine rule ):
[ R_237 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_237, 237);
      ! phrase 1
      ! [1: if the actor is the second noun , convert to the examining action on the noun]
       if (((actor == second))) {  return GVS_Convert(##Examine,noun,0);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_237, 237, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor showing something to ( this is the block showing rule ):
[ R_238 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_238, 238);
      ! phrase 1
      ! [1: stop the action with library message showing it to action number 2 for the second noun]
       return GL__M(##Show,2,second); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_238, 238, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waking (B203_check_waking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor waking ( this is the block waking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor waking ( this is the block waking rule ):
[ R_239 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_239, 239);
      ! phrase 1
      ! [1: stop the action with library message waking action number 1 for the noun]
       return GL__M(##WakeOther,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_239, 239, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Throwing it at (B206_check_throwing_it_at)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor throwing something at ( this is the implicitly remove thrown clothing rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor throwing something at ( this is the futile to throw things at inanimate objects rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor throwing something at ( this is the block throwing at rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor throwing something at ( this is the implicitly remove thrown clothing rule ):
[ R_240 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_240, 240);
      ! phrase 1
      ! [1: if the actor is wearing the noun begin]
       if (((actor == WearerOf(noun))))  {
         ! phrase 2
         ! [2: issue library message dropping action number 3 for the noun]
          GL__M(##Drop,3,noun); 
         ! phrase 3
         ! [3: silently try the actor trying taking off the noun]
          @push keep_silent; keep_silent=1; TryAction(0, actor, ##Disrobe, noun, 0);; @pull keep_silent; 
         ! phrase 4
         ! [4: if the actor is wearing the noun , stop the action]
          if (((actor == WearerOf(noun)))) {  rtrue;   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_240, 240, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor throwing something at ( this is the futile to throw things at inanimate objects rule ):
[ R_241 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_241, 241);
      ! phrase 1
      ! [1: if the second noun is not a person , stop the action with library message throwing it at action number 1 for the second noun]
       if (((~~((second ofclass K8_person))))) {  return GL__M(##ThrowAt,1,second);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_241, 241, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor throwing something at ( this is the block throwing at rule ):
[ R_242 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_242, 242);
      ! phrase 1
      ! [1: stop the action with library message throwing it at action number 2 for the noun]
       return GL__M(##ThrowAt,2,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_242, 242, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Attacking (B209_check_attacking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor attacking ( this is the block attacking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor attacking ( this is the block attacking rule ):
[ R_243 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_243, 243);
      ! phrase 1
      ! [1: stop the action with library message attacking action number 1 for the noun]
       return GL__M(##Attack,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_243, 243, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Attacking (B210_carry_out_attacking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! carry out attacking:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Cheats" by Orion Zymaris
! carry out attacking:
[ R_900 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_900, 900);
      ! phrase 1
      ! [1: if the player's command includes ~kill~ begin]
       if (( (matched_text=SnippetIncludes(Consult_Grammar_313,players_command)) ))  {
         ! phrase 2
         ! [2: remove the noun from play]
          RemoveFromPlay(noun); 
         ! phrase 3
         ! [3: end if]
         }

      ! phrase 4
      ! [4: say ~you [player's command].~]
      say__p=1;ParaContent();  print (PrintText) SC_465; ParaContent();  print (PrintSnippet) players_command; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say285; .L_SayX280;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_900, 900, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Kissing (B212_check_kissing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor kissing ( this is the kissing yourself rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor kissing ( this is the block kissing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor kissing ( this is the kissing yourself rule ):
[ R_244 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_244, 244);
      ! phrase 1
      ! [1: if the noun is the actor , stop the action with library message touching action number 3 for the noun]
       if (((noun == actor))) {  return GL__M(##Touch,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_244, 244, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor kissing ( this is the block kissing rule ):
[ R_245 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_245, 245);
      ! phrase 1
      ! [1: stop the action with library message kissing action number 1 for the noun]
       return GL__M(##Kiss,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_245, 245, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Answering it that (B216_carry_out_answering_it_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! carry out answering petunia that ~[Potters]~ during uncle vernon's scene:
! ----------------------------------------------------------------------------------------------------
! No specific request
! carry out answering petunia that ~[Potters]~ during uncle vernon's scene:
[ R_1310 ;
   if (scene_status-->1 == 1) { ! Runs only during scene
   if ( (actor==player) && ((noun == I202_petunia) && (true)) && (Consult_Grammar_314(consult_from, consult_words)~=GPR_FAIL)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1310, 1310);
      ! phrase 1
      ! [1: say ~[one of]'Er - Petunia, dear - you haven't heard from your sister lately, have you?'[paragraph break]'No. Why?' Says Petunia, rather sharply.[or]'Er - Petunia, dear - you haven't heard from your sister lately, have you?'[paragraph break]'No. Why?' Says Petunia, rather sharply.[or]'No, and will you please not mention her unless you have to?' says Petunia.[stopping][line break][run paragraph on]~ instead]
      say__p=1;ParaContent();  I7_ST_say_one_of-->5 =
	i7_soo_stop(I7_ST_say_one_of-->5, 3);
	switch((I7_ST_say_one_of-->5)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_365; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_366;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_365; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_366;  new_line;ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_367;  new_line;ParaContent();  } ParaContent();  new_line; ParaContent();  RunParagraphOn();  rtrue; .L_Say286; .L_SayX281; rtrue;
      ! phrase 2
      ! [2: now the venture of living-room cut scene is half-complete]
       WriteGProperty(SCENE_TY, I328_living_room_cut_scene,p80_venture,I270_half_complete); 
      ! phrase 3
      ! [3: rule succeeds]
       RulebookSucceeds(); rtrue; 
   } ! Runs only during scene
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1310, 1310, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Answering it that (B217_report_answering_it_tha)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor answering something that ( this is the block answering rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor answering something that ( this is the block answering rule ):
[ R_246 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_246, 246);
      ! phrase 1
      ! [1: stop the action with library message answering it that action number 1 for the noun]
       return GL__M(##Answer,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_246, 246, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Telling it about (B218_check_telling_it_about)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor telling something about ( this is the telling yourself rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor telling something about ( this is the telling yourself rule ):
[ R_247 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_247, 247);
      ! phrase 1
      ! [1: if the actor is the noun , stop the action with library message telling it about action number 1 for the noun]
       if (((actor == noun))) {  return GL__M(##Tell,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_247, 247, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Telling it about (B219_carry_out_telling_it_ab)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! carry out telling petunia about ~[Potters]~ during uncle vernon's scene:
! ----------------------------------------------------------------------------------------------------
! No specific request
! carry out telling petunia about ~[Potters]~ during uncle vernon's scene:
[ R_1311 ;
   if (scene_status-->1 == 1) { ! Runs only during scene
   if ( (actor==player) && ((noun == I202_petunia) && (true)) && (Consult_Grammar_315(consult_from, consult_words)~=GPR_FAIL)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1311, 1311);
      ! phrase 1
      ! [1: say ~[one of]'Er - Petunia, dear - you haven't heard from your sister lately, have you?'[paragraph break]'No. Why?' Says Petunia, rather sharply.[or]'Er - Petunia, dear - you haven't heard from your sister lately, have you?'[paragraph break]'No. Why?' Says Petunia, rather sharply.[or]'No, and will you please not mention her unless you have to?' says Petunia.[stopping][line break][run paragraph on]~ instead]
      say__p=1;ParaContent();  I7_ST_say_one_of-->6 =
	i7_soo_stop(I7_ST_say_one_of-->6, 3);
	switch((I7_ST_say_one_of-->6)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_365; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_366;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_365; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_366;  new_line;ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_367;  new_line;ParaContent();  } ParaContent();  new_line; ParaContent();  RunParagraphOn();  rtrue; .L_Say287; .L_SayX282; rtrue;
      ! phrase 2
      ! [2: now the venture of living-room cut scene is half-complete]
       WriteGProperty(SCENE_TY, I328_living_room_cut_scene,p80_venture,I270_half_complete); 
      ! phrase 3
      ! [3: rule succeeds]
       RulebookSucceeds(); rtrue; 
   } ! Runs only during scene
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1311, 1311, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Telling it about (B220_report_telling_it_about)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor telling something about ( this is the block telling rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor telling something about ( this is the block telling rule ):
[ R_248 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_248, 248);
      ! phrase 1
      ! [1: stop the action with library message telling it about action number 2 for the noun]
       return GL__M(##Tell,2,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_248, 248, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Asking it about (B222_carry_out_asking_it_abo)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! carry out asking petunia about ~[potters]~ during uncle vernon's scene:
! ----------------------------------------------------------------------------------------------------
! No specific request
! carry out asking petunia about ~[potters]~ during uncle vernon's scene:
[ R_1308 ;
   if (scene_status-->1 == 1) { ! Runs only during scene
   if ( (actor==player) && ((noun == I202_petunia) && (true)) && (Consult_Grammar_316(consult_from, consult_words)~=GPR_FAIL)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1308, 1308);
      ! phrase 1
      ! [1: say ~[one of]'Er - Petunia, dear - you haven't heard from your sister lately, have you?'[paragraph break]'No. Why?' Says Petunia, rather sharply.[or]'Er - Petunia, dear - you haven't heard from your sister lately, have you?'[paragraph break]'No. Why?' Says Petunia, rather sharply.[or]'No, and will you please not mention her unless you have to?' says Petunia.[stopping][line break][run paragraph on]~ instead]
      say__p=1;ParaContent();  I7_ST_say_one_of-->7 =
	i7_soo_stop(I7_ST_say_one_of-->7, 3);
	switch((I7_ST_say_one_of-->7)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_365; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_366;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_365; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_366;  new_line;ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_367;  new_line;ParaContent();  } ParaContent();  new_line; ParaContent();  RunParagraphOn();  rtrue; .L_Say288; .L_SayX283; rtrue;
      ! phrase 2
      ! [2: now the venture of living-room cut scene is half-complete]
       WriteGProperty(SCENE_TY, I328_living_room_cut_scene,p80_venture,I270_half_complete); 
      ! phrase 3
      ! [3: rule succeeds]
       RulebookSucceeds(); rtrue; 
   } ! Runs only during scene
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1308, 1308, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Asking it about (B223_report_asking_it_about)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor asking something about ( this is the block asking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor asking something about ( this is the block asking rule ):
[ R_249 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_249, 249);
      ! phrase 1
      ! [1: stop the action with library message asking it about action number 1 for the noun]
       return GL__M(##Ask,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_249, 249, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Asking it for (B224_check_asking_it_for)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor asking something for ( this is the asking yourself for something rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor asking something for ( this is the translate asking for to giving rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor asking something for ( this is the asking yourself for something rule ):
[ R_250 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_250, 250);
      ! phrase 1
      ! [1: if the actor is the noun and the actor is the player , try taking inventory instead]
       if ((((actor == noun))) && (((actor == player)))) {  TryAction(0, player, ##Inv, 0, 0);;   rtrue; }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_250, 250, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor asking something for ( this is the translate asking for to giving rule ):
[ R_251 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_251, 251);
      ! phrase 1
      ! [1: convert to request of the noun to perform giving it to action with the second noun and the actor]
       TryAction(true, noun, ##Give, second, actor); rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_251, 251, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Waiting (B229_report_waiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor waiting ( this is the standard report waiting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor waiting ( this is the standard report waiting rule ):
[ R_252 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_252, 252);
      ! phrase 1
      ! [1: if the actor is the player , stop the action with library message waiting action number 1 for the actor]
       if (((actor == player))) {  return GL__M(##Wait,1,actor);   }
      ! phrase 2
      ! [2: issue actor-based library message waiting action number 2]
       AGL__M(##Wait,2,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_252, 252, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Touching (B232_report_touching)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Report an actor touching ( this is the report touching yourself rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Report an actor touching ( this is the report touching other people rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Report an actor touching ( this is the report touching things rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor touching ( this is the report touching yourself rule ):
[ R_253 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_253, 253);
      ! phrase 1
      ! [1: if the noun is the actor begin]
       if (((noun == actor)))  {
         ! phrase 2
         ! [2: if the actor is the player , issue library message touching action number 3 for the noun]
          if (((actor == player))) {  GL__M(##Touch,3,noun);   }
         ! phrase 3
         ! [3: otherwise issue actor-based library message touching action number 4]
          else {  AGL__M(##Touch,4,noun);   }
         ! phrase 4
         ! [4: stop the action]
          rtrue; 
         ! phrase 5
         ! [5: end if]
         }

      ! phrase 6
      ! [6: continue the action]
       rfalse; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_253, 253, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor touching ( this is the report touching other people rule ):
[ R_254 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_254, 254);
      ! phrase 1
      ! [1: if the noun is a person begin]
       if (((noun ofclass K8_person)))  {
         ! phrase 2
         ! [2: if the actor is the player begin]
          if (((actor == player)))  {
            ! phrase 3
            ! [3: issue library message touching action number 1 for the noun]
             GL__M(##Touch,1,noun); 
            ! phrase 4
            ! [4: otherwise if the noun is the player]
             } else if (((noun == player))) { 
            ! phrase 5
            ! [5: issue actor-based library message touching action number 5]
             AGL__M(##Touch,5,noun); 
            ! phrase 6
            ! [6: otherwise]
            } else {

            ! phrase 7
            ! [7: issue actor-based library message touching action number 6 for the noun]
             AGL__M(##Touch,6,noun); 
            ! phrase 8
            ! [8: end if]
            }

         ! phrase 9
         ! [9: stop the action]
          rtrue; 
         ! phrase 10
         ! [10: end if]
         }

      ! phrase 11
      ! [11: continue the action]
       rfalse; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_254, 254, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor touching ( this is the report touching things rule ):
[ R_255 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_255, 255);
      ! phrase 1
      ! [1: if the actor is the player , issue library message touching action number 2 for the noun]
       if (((actor == player))) {  GL__M(##Touch,2,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message touching action number 6 for the noun]
       else {  AGL__M(##Touch,6,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_255, 255, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waving (B233_check_waving)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor waving ( this is the can't wave what's not held rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor waving ( this is the can't wave what's not held rule ):
[ R_256 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_256, 256);
      ! phrase 1
      ! [1: if the actor is not the holder of the noun , stop the action with library message waving action number 1 for the noun]
       if (((~~((actor ==  (HolderOf(noun)) ))))) {  return GL__M(##Wave,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_256, 256, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Waving (B235_report_waving)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor waving ( this is the report waving things rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor waving ( this is the report waving things rule ):
[ R_257 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_257, 257);
      ! phrase 1
      ! [1: if the actor is the player , issue library message waving action number 2 for the noun]
       if (((actor == player))) {  GL__M(##Wave,2,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message waving action number 3 for the noun]
       else {  AGL__M(##Wave,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_257, 257, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Pulling (B236_check_pulling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor pulling ( this is the can't pull what's fixed in place rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor pulling ( this is the can't pull scenery rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor pulling ( this is the can't pull people rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor pulling ( this is the can't pull what's fixed in place rule ):
[ R_258 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_258, 258);
      ! phrase 1
      ! [1: if the noun is fixed in place , stop the action with library message pulling action number 1 for the noun]
       if ((((Adj_50_t1_v9(noun))))) {  return GL__M(##Pull,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_258, 258, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor pulling ( this is the can't pull scenery rule ):
[ R_259 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_259, 259);
      ! phrase 1
      ! [1: if the noun is scenery , stop the action with library message pulling action number 2 for the noun]
       if ((((Adj_52_t1_v9(noun))))) {  return GL__M(##Pull,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_259, 259, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor pulling ( this is the can't pull people rule ):
[ R_260 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_260, 260);
      ! phrase 1
      ! [1: if the noun is a person , stop the action with library message pulling action number 4 for the noun]
       if (((noun ofclass K8_person))) {  return GL__M(##Pull,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_260, 260, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Pulling (B238_report_pulling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor pulling ( this is the report pulling rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor pulling ( this is the report pulling rule ):
[ R_261 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_261, 261);
      ! phrase 1
      ! [1: if the actor is the player , issue library message pulling action number 3 for the noun]
       if (((actor == player))) {  GL__M(##Pull,3,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message pulling action number 5 for the noun]
       else {  AGL__M(##Pull,5,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_261, 261, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Pushing (B239_check_pushing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor pushing something ( this is the can't push what's fixed in place rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor pushing something ( this is the can't push scenery rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor pushing something ( this is the can't push people rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor pushing something ( this is the can't push what's fixed in place rule ):
[ R_262 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_262, 262);
      ! phrase 1
      ! [1: if the noun is fixed in place , stop the action with library message pushing action number 1 for the noun]
       if ((((Adj_50_t1_v9(noun))))) {  return GL__M(##Push,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_262, 262, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor pushing something ( this is the can't push scenery rule ):
[ R_263 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_263, 263);
      ! phrase 1
      ! [1: if the noun is scenery , stop the action with library message pushing action number 2 for the noun]
       if ((((Adj_52_t1_v9(noun))))) {  return GL__M(##Push,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_263, 263, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor pushing something ( this is the can't push people rule ):
[ R_264 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_264, 264);
      ! phrase 1
      ! [1: if the noun is a person , stop the action with library message pushing action number 4 for the noun]
       if (((noun ofclass K8_person))) {  return GL__M(##Push,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_264, 264, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Pushing (B241_report_pushing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor pushing something ( this is the report pushing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor pushing something ( this is the report pushing rule ):
[ R_265 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_265, 265);
      ! phrase 1
      ! [1: if the actor is the player , issue library message pushing action number 3 for the noun]
       if (((actor == player))) {  GL__M(##Push,3,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message pushing action number 6 for the noun]
       else {  AGL__M(##Push,6,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_265, 265, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Turning (B242_check_turning)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor turning ( this is the can't turn what's fixed in place rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor turning ( this is the can't turn scenery rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor turning ( this is the can't turn people rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor turning ( this is the can't turn what's fixed in place rule ):
[ R_266 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_266, 266);
      ! phrase 1
      ! [1: if the noun is fixed in place , stop the action with library message turning action number 1 for the noun]
       if ((((Adj_50_t1_v9(noun))))) {  return GL__M(##Turn,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_266, 266, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor turning ( this is the can't turn scenery rule ):
[ R_267 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_267, 267);
      ! phrase 1
      ! [1: if the noun is scenery , stop the action with library message turning action number 2 for the noun]
       if ((((Adj_52_t1_v9(noun))))) {  return GL__M(##Turn,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_267, 267, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor turning ( this is the can't turn people rule ):
[ R_268 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_268, 268);
      ! phrase 1
      ! [1: if the noun is a person , stop the action with library message turning action number 4 for the noun]
       if (((noun ofclass K8_person))) {  return GL__M(##Turn,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_268, 268, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Turning (B244_report_turning)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor turning ( this is the report turning rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor turning ( this is the report turning rule ):
[ R_269 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_269, 269);
      ! phrase 1
      ! [1: if the actor is the player , issue library message turning action number 3 for the noun]
       if (((actor == player))) {  GL__M(##Turn,3,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message turning action number 7 for the noun]
       else {  AGL__M(##Turn,7,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_269, 269, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Pushing it to (B245_check_pushing_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Check an actor pushing something to ( this is the can't push unpushable things rule ):
!   === which is equally specific with ===
! Rule 2/5 ! Check an actor pushing something to ( this is the can't push to non-directions rule ):
!   === which is equally specific with ===
! Rule 3/5 ! Check an actor pushing something to ( this is the can't push vertically rule ):
!   === which is equally specific with ===
! Rule 4/5 ! Check an actor pushing something to ( this is the standard pushing in directions rule ):
!   === which is equally specific with ===
! Rule 5/5 ! Check an actor pushing something to ( this is the block pushing in directions rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor pushing something to ( this is the can't push unpushable things rule ):
[ R_270 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_270, 270);
      ! phrase 1
      ! [1: if the noun is not pushable between rooms , stop the action with library message pushing it to action number 1 for the noun]
       if (((~~(((Adj_54_t1_v9(noun))))))) {  return GL__M(##PushDir,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_270, 270, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor pushing something to ( this is the can't push to non-directions rule ):
[ R_271 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_271, 271);
      ! phrase 1
      ! [1: if the second noun is not a direction , stop the action with library message pushing it to action number 2 for the noun]
       if (((~~((second ofclass K3_direction))))) {  return GL__M(##PushDir,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_271, 271, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor pushing something to ( this is the can't push vertically rule ):
[ R_272 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_272, 272);
      ! phrase 1
      ! [1: if the second noun is up or the second noun is down , stop the action with library message pushing it to action number 3 for the noun]
       if ((((second == I54_up))) || (((second == I55_down)))) {  return GL__M(##PushDir,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_272, 272, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor pushing something to ( this is the standard pushing in directions rule ):
[ R_273 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_273, 273);
      ! phrase 1
      ! [1: convert to special going-with-push action]
       ConvertToGoingWithPush(); rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_273, 273, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor pushing something to ( this is the block pushing in directions rule ):
[ R_274 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_274, 274);
      ! phrase 1
      ! [1: stop the action with library message pushing it to action number 1 for the noun]
       return GL__M(##PushDir,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_274, 274, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Squeezing (B248_check_squeezing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor squeezing ( this is the innuendo about squeezing people rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor squeezing ( this is the innuendo about squeezing people rule ):
[ R_275 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_275, 275);
      ! phrase 1
      ! [1: if the noun is a person , stop the action with library message squeezing action number 1 for the noun]
       if (((noun ofclass K8_person))) {  return GL__M(##Squeeze,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_275, 275, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Squeezing (B250_report_squeezing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor squeezing ( this is the report squeezing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor squeezing ( this is the report squeezing rule ):
[ R_276 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_276, 276);
      ! phrase 1
      ! [1: if the actor is the player , issue library message squeezing action number 2 for the noun]
       if (((actor == player))) {  GL__M(##Squeeze,2,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message squeezing action number 3 for the noun]
       else {  AGL__M(##Squeeze,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_276, 276, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Saying yes (B251_check_saying_yes)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor saying yes ( this is the block saying yes rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor saying yes ( this is the block saying yes rule ):
[ R_277 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_277, 277);
      ! phrase 1
      ! [1: stop the action with library message saying yes action number 1]
       return GL__M(##Yes,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_277, 277, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Saying no (B254_check_saying_no)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor saying no ( this is the block saying no rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor saying no ( this is the block saying no rule ):
[ R_278 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_278, 278);
      ! phrase 1
      ! [1: stop the action with library message saying no action number 1]
       return GL__M(##No,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_278, 278, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Burning (B257_check_burning)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor burning ( this is the block burning rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor burning ( this is the block burning rule ):
[ R_279 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_279, 279);
      ! phrase 1
      ! [1: stop the action with library message burning action number 1]
       return GL__M(##Burn,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_279, 279, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waking up (B260_check_waking_up)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor waking up ( this is the block waking up rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor waking up ( this is the block waking up rule ):
[ R_280 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_280, 280);
      ! phrase 1
      ! [1: stop the action with library message waking up action number 1]
       return GL__M(##Wake,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_280, 280, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Thinking (B263_check_thinking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor thinking ( this is the block thinking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor thinking ( this is the block thinking rule ):
[ R_281 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_281, 281);
      ! phrase 1
      ! [1: stop the action with library message thinking action number 1]
       return GL__M(##Think,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_281, 281, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Thinking (B265_report_thinking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! report thinking during uncle vernon's scene:
!   === which is equally specific with ===
! Rule 2/3 ! report thinking during uncle vernon's scene:
!   >>> I - Number of aspects constrained >>>
! Rule 3/3 ! report thinking:
! ----------------------------------------------------------------------------------------------------
! No specific request
! report thinking during uncle vernon's scene:
[ R_1296 ;
   if (scene_status-->1 == 1) { ! Runs only during scene
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1296, 1296);
      ! phrase 1
      ! [1: if the venture of work is not incomplete begin]
       if (((~~((GProperty(SCENE_TY, I238_work,p80_venture) == I268_incomplete)))))  {
         ! phrase 2
         ! [2: if the location is living-room begin]
          if (((real_location == I304_living_room)))  {
            ! phrase 3
            ! [3: if tvonafterwork is 0 begin]
             if ((((Global_Vars-->80) == 0)))  {
               ! phrase 4
               ! [4: say ~Shooting stars all over Britain Owls flying by daylight? Mysterious people in cloaks all over the place? And a whisper, a whisper about the Potters... Maybe you should ask Petunia about this.~ instead]
               say__p=1;ParaContent();  print (PrintText) SC_466;  new_line; rtrue; .L_Say289; .L_SayX284; rtrue;
               ! phrase 5
               ! [5: otherwise]
               } else {

               ! phrase 6
               ! [6: continue the action]
                rfalse; 
               ! phrase 7
               ! [7: end if]
               }

            ! phrase 8
            ! [8: otherwise]
            } else {

            ! phrase 9
            ! [9: continue the action]
             rfalse; 
            ! phrase 10
            ! [10: end if]
            }

         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: continue the action]
          rfalse; 
         ! phrase 13
         ! [13: end if]
         }

   } ! Runs only during scene
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1296, 1296, true);
   rfalse;
];
! No specific request
! report thinking during uncle vernon's scene:
[ R_1297 ;
   if (scene_status-->1 == 1) { ! Runs only during scene
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1297, 1297);
      ! phrase 1
      ! [1: if the venture of work is not incomplete begin]
       if (((~~((GProperty(SCENE_TY, I238_work,p80_venture) == I268_incomplete)))))  {
         ! phrase 2
         ! [2: if the location is living-room begin]
          if (((real_location == I304_living_room)))  {
            ! phrase 3
            ! [3: if tvonafterwork is 1 begin]
             if ((((Global_Vars-->80) == 1)))  {
               ! phrase 4
               ! [4: say ~Shooting stars all over Britain Owls flying by daylight? Mysterious people in cloaks all over the place? And a whisper, a whisper about the Potters... Maybe you should ask Petunia about this.~]
               say__p=1;ParaContent();  print (PrintText) SC_466;  new_line; .L_Say290; .L_SayX285;
               ! phrase 5
               ! [5: now petunia is in living-room]
                MoveObject(I202_petunia,I304_living_room); 
               ! phrase 6
               ! [6: now petunia is carrying a tray]
                MoveObject(I325_tray,I202_petunia); 
               ! phrase 7
               ! [7: now dursley is carrying vernon's cup]
                MoveObject(I326_vernon_s_cup,I97_dursley); 
               ! phrase 8
               ! [8: try silently saying hello to petunia]
                @push keep_silent; keep_silent=1; TryAction(0, player, ##A109_saying_hello_to, I202_petunia, 0);; @pull keep_silent; 
               ! phrase 9
               ! [9: now tvonafterwork is 2]
                (Global_Vars-->80) = 2; 
               ! phrase 10
               ! [10: say ~As you sit there thinking about your day, Petunia comes into the room, carrying a tray with 2 cups of tea.'Here's your tea, Vernon'.~ instead]
               say__p=1;ParaContent();  print (PrintText) SC_192;  new_line; rtrue; .L_Say291; .L_SayX286; rtrue;
               ! phrase 11
               ! [11: otherwise]
               } else {

               ! phrase 12
               ! [12: continue the action]
                rfalse; 
               ! phrase 13
               ! [13: end if]
               }

            ! phrase 14
            ! [14: otherwise]
            } else {

            ! phrase 15
            ! [15: continue the action]
             rfalse; 
            ! phrase 16
            ! [16: end if]
            }

         ! phrase 17
         ! [17: otherwise]
         } else {

         ! phrase 18
         ! [18: continue the action]
          rfalse; 
         ! phrase 19
         ! [19: end if]
         }

   } ! Runs only during scene
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1297, 1297, true);
   rfalse;
];
! No specific request
! report thinking:
[ R_1295 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1295, 1295);
      ! phrase 1
      ! [1: say ~What a good idea.[line break]~]
      say__p=1;ParaContent();  print (PrintText) SC_467; ParaContent();  new_line;  .L_Say292; .L_SayX287;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1295, 1295, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Smelling (B266_check_smelling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor smelling ( this is the block smelling rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor smelling ( this is the block smelling rule ):
[ R_282 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_282, 282);
      ! phrase 1
      ! [1: stop the action with library message smelling action number 1 for the noun]
       return GL__M(##Smell,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_282, 282, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Listening to (B269_check_listening_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor listening ( this is the block listening rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor listening ( this is the block listening rule ):
[ R_283 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_283, 283);
      ! phrase 1
      ! [1: stop the action with library message listening to action number 1 for the noun]
       return GL__M(##Listen,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_283, 283, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Listening to (B270_carry_out_listening_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! carry out listening when the location is street:
! ----------------------------------------------------------------------------------------------------
! No specific request
! carry out listening when the location is street:
[ R_1272 ;
   if ( (actor==player) && (self=actor,true) && (((real_location == I285_street)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1272, 1272);
      ! phrase 1
      ! [1: say ~'The Potters, that's right, that's what I heard -'[line break]'-yes, their son, Harry-'[line break]Potter? Petunia's sister's husband? I need to get back to the office and call petunia.~]
      say__p=1;ParaContent();  print (PrintText) SC_468; ParaContent();  new_line; ParaContent();  print (PrintText) SC_469; ParaContent();  new_line; ParaContent();  print (PrintText) SC_470;  new_line; .L_Say293; .L_SayX288;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1272, 1272, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Tasting (B272_check_tasting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor tasting ( this is the block tasting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor tasting ( this is the block tasting rule ):
[ R_284 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_284, 284);
      ! phrase 1
      ! [1: stop the action with library message tasting action number 1 for the noun]
       return GL__M(##Taste,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_284, 284, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Cutting (B275_check_cutting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor cutting ( this is the block cutting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor cutting ( this is the block cutting rule ):
[ R_285 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_285, 285);
      ! phrase 1
      ! [1: stop the action with library message cutting action number 1 for the noun]
       return GL__M(##Cut,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_285, 285, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Jumping (B278_check_jumping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor jumping ( this is the block jumping rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor jumping ( this is the block jumping rule ):
[ R_286 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_286, 286);
      ! phrase 1
      ! [1: stop the action with library message jumping action number 1]
       return GL__M(##Jump,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_286, 286, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Tying it to (B281_check_tying_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor tying something to ( this is the block tying rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor tying something to ( this is the block tying rule ):
[ R_287 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_287, 287);
      ! phrase 1
      ! [1: stop the action with library message tying it to action number 1 for the noun]
       return GL__M(##Tie,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_287, 287, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Drinking (B284_check_drinking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor drinking ( this is the block drinking rule ):
!   >>> III - Action requirement >>>
! Rule 2/2 ! check drinking:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor drinking ( this is the block drinking rule ):
[ R_288 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_288, 288);
      ! phrase 1
      ! [1: stop the action with library message drinking action number 1 for the noun]
       return GL__M(##Drink,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_288, 288, true);
   rfalse;
];
! No specific request
! check drinking:
[ R_1130 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1130, 1130);
      ! phrase 1
      ! [1: if the drinklevel of the noun is droplets begin]
       if (((GProperty(OBJECT_TY, noun,p79_drinklevel) == I220_droplets)))  {
         ! phrase 2
         ! [2: say ~how can you drink from an empty cup?~ instead]
         say__p=1;ParaContent();  print (PrintText) SC_471;  new_line; rtrue; .L_Say294; .L_SayX289; rtrue;
         ! phrase 3
         ! [3: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1130, 1130, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Drinking (B286_report_drinking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! report drinking:
! ----------------------------------------------------------------------------------------------------
! No specific request
! report drinking:
[ R_1129 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1129, 1129);
      ! phrase 1
      ! [1: if the drinklevel of the noun is overflowing begin]
       if (((GProperty(OBJECT_TY, noun,p79_drinklevel) == I218_overflowing)))  {
         ! phrase 2
         ! [2: say ~You gulp down some [noun].~]
         say__p=1;ParaContent();  print (PrintText) SC_364; ParaContent();  print (PrintShortName) noun; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say295; .L_SayX290;
         ! phrase 3
         ! [3: now the drinklevel of the noun is half-empty]
          WriteGProperty(OBJECT_TY, noun,p79_drinklevel,I219_half_empty); 
         ! phrase 4
         ! [4: otherwise if the drinklevel of the noun is half-empty]
          } else if (((GProperty(OBJECT_TY, noun,p79_drinklevel) == I219_half_empty))) { 
         ! phrase 5
         ! [5: say ~You gulp down some [noun]. Now the cup is empty.~]
         say__p=1;ParaContent();  print (PrintText) SC_364; ParaContent();  print (PrintShortName) noun; ParaContent();  print (PrintText) SC_472;  new_line; .L_Say296; .L_SayX291;
         ! phrase 6
         ! [6: now the drinklevel of the noun is droplets]
          WriteGProperty(OBJECT_TY, noun,p79_drinklevel,I220_droplets); 
         ! phrase 7
         ! [7: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1129, 1129, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Saying sorry (B287_check_saying_sorry)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor saying sorry ( this is the block saying sorry rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor saying sorry ( this is the block saying sorry rule ):
[ R_289 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_289, 289);
      ! phrase 1
      ! [1: stop the action with library message saying sorry action number 1]
       return GL__M(##Sorry,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_289, 289, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Swearing obscenely (B290_check_swearing_obscenel)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor swearing obscenely ( this is the block swearing obscenely rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor swearing obscenely ( this is the block swearing obscenely rule ):
[ R_290 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_290, 290);
      ! phrase 1
      ! [1: stop the action with library message swearing obscenely action number 1]
       return GL__M(##Strong,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_290, 290, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Swearing mildly (B293_check_swearing_mildly)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor swearing mildly ( this is the block swearing mildly rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor swearing mildly ( this is the block swearing mildly rule ):
[ R_291 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_291, 291);
      ! phrase 1
      ! [1: stop the action with library message swearing mildly action number 1]
       return GL__M(##Mild,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_291, 291, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Swinging (B296_check_swinging)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor swinging ( this is the block swinging rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor swinging ( this is the block swinging rule ):
[ R_292 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_292, 292);
      ! phrase 1
      ! [1: stop the action with library message swinging action number 1 for the noun]
       return GL__M(##Swing,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_292, 292, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Rubbing (B299_check_rubbing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! check rubbing cereal:
!   === which is equally specific with ===
! Rule 2/3 ! check rubbing cereal:
!   >>> I - Number of aspects constrained >>>
! Rule 3/3 ! Check an actor rubbing ( this is the block rubbing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! check rubbing cereal:
[ R_1139 ;
   if ( (actor==player) && ((noun == I225_cereal) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1139, 1139);
      ! phrase 1
      ! [1: if in kitchen begin]
       if (( (WhetherIn(I198_kitchen)) ))  {
         ! phrase 2
         ! [2: if player is carrying a broom begin]
          if ((Prop_64()))  {
            ! phrase 3
            ! [3: say ~you grab the broom and clean the mess up. 'Thank you Vernon'.~]
            say__p=1;ParaContent();  print (PrintText) SC_473;  new_line; .L_Say297; .L_SayX292;
            ! phrase 4
            ! [4: now cereal is off-stage instead]
             (Adj_9_t3_v9(I225_cereal));  rtrue;
            ! phrase 5
            ! [5: end if]
            }

         ! phrase 6
         ! [6: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1139, 1139, true);
   rfalse;
];
! No specific request
! check rubbing cereal:
[ R_1140 ;
   if ( (actor==player) && ((noun == I225_cereal) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1140, 1140);
      ! phrase 1
      ! [1: if in kitchen begin]
       if (( (WhetherIn(I198_kitchen)) ))  {
         ! phrase 2
         ! [2: if player is not carrying a broom begin]
          if ((Prop_65()))  {
            ! phrase 3
            ! [3: say ~With what?~ instead]
            say__p=1;ParaContent();  print (PrintText) SC_474;  new_line; rtrue; .L_Say298; .L_SayX293; rtrue;
            ! phrase 4
            ! [4: end if]
            }

         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1140, 1140, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor rubbing ( this is the block rubbing rule ):
[ R_293 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_293, 293);
      ! phrase 1
      ! [1: stop the action with library message rubbing action number 1 for the noun]
       return GL__M(##Rub,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_293, 293, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Setting it to (B302_check_setting_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor setting something to ( this is the block setting it to rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor setting something to ( this is the block setting it to rule ):
[ R_294 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_294, 294);
      ! phrase 1
      ! [1: stop the action with library message setting it to action number 1 for the noun]
       return GL__M(##SetTo,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_294, 294, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waving hands (B305_check_waving_hands)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor waving hands ( this is the block waving hands rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor waving hands ( this is the block waving hands rule ):
[ R_295 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_295, 295);
      ! phrase 1
      ! [1: stop the action with library message waving hands action number 1]
       return GL__M(##WaveHands,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_295, 295, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Buying (B308_check_buying)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor buying ( this is the block buying rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor buying ( this is the block buying rule ):
[ R_296 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_296, 296);
      ! phrase 1
      ! [1: stop the action with library message buying action number 1 for the noun]
       return GL__M(##Buy,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_296, 296, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Singing (B311_check_singing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor singing ( this is the block singing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor singing ( this is the block singing rule ):
[ R_297 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_297, 297);
      ! phrase 1
      ! [1: stop the action with library message singing action number 1]
       return GL__M(##Sing,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_297, 297, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Climbing (B314_check_climbing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor climbing ( this is the block climbing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor climbing ( this is the block climbing rule ):
[ R_298 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_298, 298);
      ! phrase 1
      ! [1: stop the action with library message climbing action number 1 for the noun]
       return GL__M(##Climb,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_298, 298, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Climbing (B315_carry_out_climbing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! carry out climbing:
! ----------------------------------------------------------------------------------------------------
! No specific request
! carry out climbing:
[ R_1106 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1106, 1106);
      ! phrase 1
      ! [1: if player's command includes ~climb up~ begin]
       if (( (matched_text=SnippetIncludes(Consult_Grammar_317,players_command)) ))  {
         ! phrase 2
         ! [2: try going up]
          TryAction(0, player, ##Go, I54_up, 0);; 
         ! phrase 3
         ! [3: otherwise if player's command includes ~climb down~]
          } else if (( (matched_text=SnippetIncludes(Consult_Grammar_318,players_command)) )) { 
         ! phrase 4
         ! [4: try going down]
          TryAction(0, player, ##Go, I55_down, 0);; 
         ! phrase 5
         ! [5: otherwise if player's command includes ~climb~]
          } else if (( (matched_text=SnippetIncludes(Consult_Grammar_319,players_command)) )) { 
         ! phrase 6
         ! [6: try going up]
          TryAction(0, player, ##Go, I54_up, 0);; 
         ! phrase 7
         ! [7: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1106, 1106, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Sleeping (B317_check_sleeping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor sleeping ( this is the block sleeping rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor sleeping ( this is the block sleeping rule ):
[ R_299 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_299, 299);
      ! phrase 1
      ! [1: stop the action with library message sleeping action number 1]
       return GL__M(##Sleep,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_299, 299, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Quitting the game (B320_check_quitting_the_game)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! check quitting the game:
! ----------------------------------------------------------------------------------------------------
! No specific request
! check quitting the game:
[ R_752 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_752, 752);
      ! phrase 1
      ! [1: try saving the game]
       TryAction(0, player, ##Save, 0, 0);; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_752, 752, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Restarting the game (B329_check_restarting_the_ga)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check restarting the game:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check restarting the game:
[ R_753 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_753, 753);
      ! phrase 1
      ! [1: try saving the game]
       TryAction(0, player, ##Save, 0, 0);; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_753, 753, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check putting it under (B367_check_putting_it_under)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! check putting it under:
! ----------------------------------------------------------------------------------------------------
! No specific request
! check putting it under:
[ R_745 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_745, 745);
      ! phrase 1
      ! [1: if the noun is underlying the second noun begin]
       if ((((noun.p59_underlying) == second)))  {
         ! phrase 2
         ! [2: say ~That's already under there!~]
         say__p=1;ParaContent();  print (PrintText) SC_475;  new_line; .L_Say299; .L_SayX294;
         ! phrase 3
         ! [3: stop the action]
          rtrue; 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_745, 745, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out putting it under (B368_carry_out_putting_it_un)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! carry out putting under:
! ----------------------------------------------------------------------------------------------------
! No specific request
! carry out putting under:
[ R_746 ;
   if ( (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_746, 746);
      ! phrase 1
      ! [1: now the noun is underlying the second noun]
       noun.p59_underlying = second; 
      ! phrase 2
      ! [2: now the second noun is overlaying the noun]
       noun.p59_underlying = second; 
      ! phrase 3
      ! [3: now the noun is off-stage]
       (Adj_9_t3_v9(noun)); 
      ! phrase 4
      ! [4: continue the action]
       rfalse; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_746, 746, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report putting it under (B369_report_putting_it_under)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! report putting under:
! ----------------------------------------------------------------------------------------------------
! No specific request
! report putting under:
[ R_748 ;
   if ( (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_748, 748);
      ! phrase 1
      ! [1: say ~You put [noun] under [second noun].~]
      say__p=1;ParaContent();  print (PrintText) SC_476; ParaContent();  print (PrintShortName) noun; ParaContent();  print (PrintText) SC_477; ParaContent();  print (PrintShortName) second; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say300; .L_SayX295;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_748, 748, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out going under (B374_carry_out_going_under)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! carry out going under:
! ----------------------------------------------------------------------------------------------------
! No specific request
! carry out going under:
[ R_765 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_765, 765);
      ! phrase 1
      ! [1: say ~You go under [noun].[line break]~]
      say__p=1;ParaContent();  print (PrintText) SC_478; ParaContent();  print (PrintShortName) noun; ParaContent();  print (PrintText) SC_201; ParaContent();  new_line;  .L_Say301; .L_SayX296;
      ! phrase 2
      ! [2: now the player underlies the noun]
       player.p59_underlying = noun; 
      ! phrase 3
      ! [3: now underly is 1]
       (Global_Vars-->14) = 1; 
      ! phrase 4
      ! [4: now the player is reclining]
       player.p73_posture = I117_reclining; 
      ! phrase 5
      ! [5: now overlay is the noun]
       (Global_Vars-->15) = noun; if (~~((Global_Vars-->15) ofclass K2_thing)) RunTimeProblem(RTP_WRONGASSIGNEDKIND, (Global_Vars-->15), "now overlay is the noun", "thing");; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_765, 765, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out getting out from under (B377_carry_out_getting_out_f)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! carry out getting out from under:
! ----------------------------------------------------------------------------------------------------
! No specific request
! carry out getting out from under:
[ R_767 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_767, 767);
      ! phrase 1
      ! [1: say ~You get out from under [the noun].[line break]~]
      say__p=1;ParaContent();  print (PrintText) SC_479; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_201; ParaContent();  new_line;  .L_Say302; .L_SayX297;
      ! phrase 2
      ! [2: now the player is not underlying anything]
       Prop_66(); 
      ! phrase 3
      ! [3: now the noun is not overlaying the player]
       Relation_NowN1toV(player,p59_underlying,noun); 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_767, 767, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Mounting (B379_check_mounting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Check an actor mounting ( this is the can't mount when mounted on an animal rule ):
!   === which is equally specific with ===
! Rule 2/5 ! Check an actor mounting ( this is the can't mount when mounted on a vehicle rule ):
!   === which is equally specific with ===
! Rule 3/5 ! Check an actor mounting ( this is the can't mount something unrideable rule ):
!   === which is equally specific with ===
! Rule 4/5 ! Check an actor mounting ( this is the can't mount something carried rule ):
!   === which is equally specific with ===
! Rule 5/5 ! Check an actor mounting ( this is the can't mount something unreachable rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Check an actor mounting ( this is the can't mount when mounted on an animal rule ):
[ R_849 
    t_0 ! Local variable e.g. 'steed' = rideable animal
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_849, 849);
      ! phrase 1
      ! [1: if the actor is carried by a rideable animal ( called the steed ) begin]
       if (((CarrierOf(actor) ofclass K21_rideable_animal) && (t_0=(CarrierOf(actor)), true)))  {
         ! phrase 2
         ! [2: if the actor is the player , say ~You are already riding [the steed].~]
          if (((actor == player))) { say__p=1;ParaContent();  print (PrintText) SC_480; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say303; .L_SayX298;  }
         ! phrase 3
         ! [3: stop the action]
          rtrue; 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_849, 849, true);
   rfalse;
];
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Check an actor mounting ( this is the can't mount when mounted on a vehicle rule ):
[ R_850 
    t_0 ! Local variable e.g. 'conveyance' = rideable vehicle
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_850, 850);
      ! phrase 1
      ! [1: if the actor is on a rideable vehicle ( called the conveyance ) begin]
       if (((SupporterOf(actor) ofclass K22_rideable_vehicle) && (t_0=(SupporterOf(actor)), true)))  {
         ! phrase 2
         ! [2: if the actor is the player , say ~You are already riding [the conveyance].~]
          if (((actor == player))) { say__p=1;ParaContent();  print (PrintText) SC_480; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say304; .L_SayX299;  }
         ! phrase 3
         ! [3: stop the action]
          rtrue; 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_850, 850, true);
   rfalse;
];
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Check an actor mounting ( this is the can't mount something unrideable rule ):
[ R_851 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_851, 851);
      ! phrase 1
      ! [1: if the noun is not a rideable animal and the noun is not a rideable vehicle begin]
       if ((((~~((noun ofclass K21_rideable_animal))))) && (((~~((noun ofclass K22_rideable_vehicle))))))  {
         ! phrase 2
         ! [2: if the actor is the player , say ~[The noun] cannot be ridden.~ instead]
          if (((actor == player))) { say__p=1;ParaContent();  print (The) noun; ParaContent();  print (PrintText) SC_202;  new_line; .L_Say305; .L_SayX300;  rtrue; }
         ! phrase 3
         ! [3: stop the action]
          rtrue; 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_851, 851, true);
   rfalse;
];
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Check an actor mounting ( this is the can't mount something carried rule ):
[ R_852 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_852, 852);
      ! phrase 1
      ! [1: abide by the can't enter something carried rule]
       if (ProcessRulebook(R_154)) rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_852, 852, true);
   rfalse;
];
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Check an actor mounting ( this is the can't mount something unreachable rule ):
[ R_853 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_853, 853);
      ! phrase 1
      ! [1: abide by the implicitly pass through other barriers rule]
       if (ProcessRulebook(R_155)) rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_853, 853, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Mounting (B380_carry_out_mounting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor mounting ( this is the standard mounting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Carry out an actor mounting ( this is the standard mounting rule ):
[ R_854 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_854, 854);
      ! phrase 1
      ! [1: surreptitiously move the actor to the noun]
       move actor to noun; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_854, 854, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Mounting (B381_report_mounting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor mounting ( this is the standard report mounting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Report an actor mounting ( this is the standard report mounting rule ):
[ R_855 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_855, 855);
      ! phrase 1
      ! [1: if the actor is the player begin]
       if (((actor == player)))  {
         ! phrase 2
         ! [2: say ~You mount [the noun].~]
         say__p=1;ParaContent();  print (PrintText) SC_481; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say306; .L_SayX301;
         ! phrase 3
         ! [3: describe locale for the noun]
         (PHR_71_r18 (noun));
         ! phrase 4
         ! [4: otherwise]
         } else {

         ! phrase 5
         ! [5: say ~[The actor] mount[s] [the noun].~ instead]
         say__p=1;ParaContent();  print (The) actor; ParaContent();  print (PrintText) SC_482; ParaContent();  STextSubstitution(); ParaContent();  print (PrintText) SC_88; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_201;  new_line; rtrue; .L_Say307; .L_SayX302; rtrue;
         ! phrase 6
         ! [6: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_855, 855, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Dismounting (B382_check_dismounting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor dismounting ( this is the can't dismount when not mounted rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Check an actor dismounting ( this is the can't dismount when not mounted rule ):
[ R_857 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_857, 857);
      ! phrase 1
      ! [1: if the actor is not carried by a rideable animal and the actor is not on a rideable vehicle begin]
       if (((Prop_67())) && ((Prop_68())))  {
         ! phrase 2
         ! [2: if the actor is a player , say ~You are not riding anything.~]
          if (((actor == player))) { say__p=1;ParaContent();  print (PrintText) SC_483;  new_line; .L_Say308; .L_SayX303;  }
         ! phrase 3
         ! [3: stop the action]
          rtrue; 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_857, 857, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Dismounting (B383_carry_out_dismounting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor dismounting ( this is the standard dismounting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Carry out an actor dismounting ( this is the standard dismounting rule ):
[ R_858 
    t_0 ! Local variable e.g. 'steed' = rideable animal
    t_1 ! Local variable e.g. 'conveyance' = rideable vehicle
    t_2 ! Local variable e.g. 'former exterior' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_858, 858);
      ! phrase 1
      ! [1: if the actor is carried by a rideable animal ( called the steed ) , now the noun is the steed]
       if (((CarrierOf(actor) ofclass K21_rideable_animal) && (t_0=(CarrierOf(actor)), true))) {  noun = t_0;   }
      ! phrase 2
      ! [2: if the actor is on a rideable vehicle ( called the conveyance ) , now the noun is the conveyance]
       if (((SupporterOf(actor) ofclass K22_rideable_vehicle) && (t_1=(SupporterOf(actor)), true))) {  noun = t_1;   }
      ! phrase 3
      ! [3: let the former exterior be the holder of the noun]
       t_2 =  (HolderOf(noun)) ; 
      ! phrase 4
      ! [4: surreptitiously move the actor to the former exterior]
       move actor to t_2; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_858, 858, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Dismounting (B384_report_dismounting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor dismounting ( this is the standard report dismounting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Report an actor dismounting ( this is the standard report dismounting rule ):
[ R_859 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_859, 859);
      ! phrase 1
      ! [1: if the actor is the player begin]
       if (((actor == player)))  {
         ! phrase 2
         ! [2: say ~You dismount [the noun].[line break][run paragraph on]~]
         say__p=1;ParaContent();  print (PrintText) SC_484; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_201; ParaContent();  new_line; ParaContent();  RunParagraphOn();  .L_Say309; .L_SayX304;
         ! phrase 3
         ! [3: produce a room description with going spacing conventions]
          LookAfterGoing(); 
         ! phrase 4
         ! [4: otherwise]
         } else {

         ! phrase 5
         ! [5: say ~[The actor] dismount[s] [the noun].~]
         say__p=1;ParaContent();  print (The) actor; ParaContent();  print (PrintText) SC_485; ParaContent();  STextSubstitution(); ParaContent();  print (PrintText) SC_88; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say310; .L_SayX305;
         ! phrase 6
         ! [6: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_859, 859, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Displaying (B386_for_displaying)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for displaying ( this is the basic menu contents rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Menus" by Emily Short
! Rule for displaying ( this is the basic menu contents rule ):
[ R_869 ;
      ! phrase 1
      ! [1: now current menu selection is 1]
       (Global_Vars-->22) = 1; 
      ! phrase 2
      ! [2: show menu contents]
      (PHR_868_r19 ());
      RulebookSucceeds(); rtrue;
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Asking for help (B389_carry_out_asking_for_he)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out asking for help:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "HPMenu" by Orion Zymaris
! Carry out asking for help:
[ R_893 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_893, 893);
      ! phrase 1
      ! [1: now the current menu is the table of options]
       (Global_Vars-->21) = T8_options; 
      ! phrase 2
      ! [2: carry out the displaying activity]
       CarryOutActivity(V32_displaying); 
      ! phrase 3
      ! [3: clear the screen]
       VM_ClearScreen(0); 
      ! phrase 4
      ! [4: try looking]
       TryAction(0, player, ##Look, 0, 0);; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_893, 893, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check switching cheats on (B391_check_switching_cheats_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! check switching cheats on:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Cheats" by Orion Zymaris
! check switching cheats on:
[ R_911 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_911, 911);
      ! phrase 1
      ! [1: if cheats_bin is 0 begin]
       if ((((Global_Vars-->25) == 0)))  {
         ! phrase 2
         ! [2: say ~Now cheats are on.[no line break]~]
         say__p=1;ParaContent();  print (PrintText) SC_486; ParaContent(); (PHR_335_r7 ()); .L_Say311; .L_SayX306;
         ! phrase 3
         ! [3: now cheats_bin is 1]
          (Global_Vars-->25) = 1; 
         ! phrase 4
         ! [4: otherwise]
         } else {

         ! phrase 5
         ! [5: say ~Cheats are already on.[no line break]~]
         say__p=1;ParaContent();  print (PrintText) SC_487; ParaContent(); (PHR_335_r7 ()); .L_Say312; .L_SayX307;
         ! phrase 6
         ! [6: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_911, 911, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check switching cheats off (B394_check_switching_cheats_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! check switching cheats off:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Cheats" by Orion Zymaris
! check switching cheats off:
[ R_912 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_912, 912);
      ! phrase 1
      ! [1: if cheats_bin is 1 begin]
       if ((((Global_Vars-->25) == 1)))  {
         ! phrase 2
         ! [2: now cheats_bin is 0]
          (Global_Vars-->25) = 0; 
         ! phrase 3
         ! [3: say ~Now cheats are off.[no line break]~]
         say__p=1;ParaContent();  print (PrintText) SC_488; ParaContent(); (PHR_335_r7 ()); .L_Say313; .L_SayX308;
         ! phrase 4
         ! [4: otherwise]
         } else {

         ! phrase 5
         ! [5: say ~Cheats are already off.[no line break]~]
         say__p=1;ParaContent();  print (PrintText) SC_489; ParaContent(); (PHR_335_r7 ()); .L_Say314; .L_SayX309;
         ! phrase 6
         ! [6: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_912, 912, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check moving to (B400_check_moving_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! check moving to:
!   === which is equally specific with ===
! Rule 2/4 ! check moving to:
!   === which is equally specific with ===
! Rule 3/4 ! check moving to:
!   === which is equally specific with ===
! Rule 4/4 ! check moving to:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Cheats" by Orion Zymaris
! check moving to:
[ R_905 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_905, 905);
      ! phrase 1
      ! [1: if the noun is the second noun begin]
       if (((noun == second)))  {
         ! phrase 2
         ! [2: say ~Even with cheats on, that's impossible.~]
         say__p=1;ParaContent();  print (PrintText) SC_490;  new_line; .L_Say315; .L_SayX310;
         ! phrase 3
         ! [3: stop the action]
          rtrue; 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_905, 905, true);
   rfalse;
];
! No specific request
! From "Cheats" by Orion Zymaris
! check moving to:
[ R_906 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_906, 906);
      ! phrase 1
      ! [1: if the noun is the player begin]
       if (((noun == player)))  {
         ! phrase 2
         ! [2: if the player has the second noun begin]
          if (((player == OwnerOf(second))))  {
            ! phrase 3
            ! [3: try silently dropping the second noun]
             @push keep_silent; keep_silent=1; TryAction(0, player, ##Drop, second, 0);; @pull keep_silent; 
            ! phrase 4
            ! [4: continue the action]
             rfalse; 
            ! phrase 5
            ! [5: end if]
            }

         ! phrase 6
         ! [6: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_906, 906, true);
   rfalse;
];
! No specific request
! From "Cheats" by Orion Zymaris
! check moving to:
[ R_907 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_907, 907);
      ! phrase 1
      ! [1: if the second noun is the player begin]
       if (((second == player)))  {
         ! phrase 2
         ! [2: if the player has the noun begin]
          if (((player == OwnerOf(noun))))  {
            ! phrase 3
            ! [3: try silently dropping the noun]
             @push keep_silent; keep_silent=1; TryAction(0, player, ##Drop, noun, 0);; @pull keep_silent; 
            ! phrase 4
            ! [4: continue the action]
             rfalse; 
            ! phrase 5
            ! [5: end if]
            }

         ! phrase 6
         ! [6: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_907, 907, true);
   rfalse;
];
! No specific request
! From "Cheats" by Orion Zymaris
! check moving to:
[ R_908 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_908, 908);
      ! phrase 1
      ! [1: if the second noun is the player begin]
       if (((second == player)))  {
         ! phrase 2
         ! [2: if the player is in the noun begin]
          if (((noun == ContainerOf(player))))  {
            ! phrase 3
            ! [3: now the player is in the location]
             MoveObject(player,real_location); 
            ! phrase 4
            ! [4: continue the action]
             rfalse; 
            ! phrase 5
            ! [5: end if]
            }

         ! phrase 6
         ! [6: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_908, 908, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out moving to (B401_carry_out_moving_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! carry out moving to:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Cheats" by Orion Zymaris
! carry out moving to:
[ R_909 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_909, 909);
      ! phrase 1
      ! [1: say ~You move [the noun] to [the second noun].~]
      say__p=1;ParaContent();  print (PrintText) SC_491; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_492; ParaContent();  print (the) second; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say316; .L_SayX311;
      ! phrase 2
      ! [2: move the noun to the second noun]
       MoveObject(noun, second, 0, false); 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_909, 909, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check putting back (B403_check_putting_back)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! check putting back:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Cheats" by Orion Zymaris
! check putting back:
[ R_922 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_922, 922);
      ! phrase 1
      ! [1: unless the noun is in the second noun begin]
       if (~~(((second == ContainerOf(noun)))))  {
         ! phrase 2
         ! [2: unless the noun is on the second noun begin]
          if (~~(((second == SupporterOf(noun)))))  {
            ! phrase 3
            ! [3: say ~You move the [noun] back to the [second noun].~]
            say__p=1;ParaContent();  print (PrintText) SC_493; ParaContent();  print (PrintShortName) noun; ParaContent();  print (PrintText) SC_494; ParaContent();  print (PrintShortName) second; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say317; .L_SayX312;
            ! phrase 4
            ! [4: end unless]
            }

         ! phrase 5
         ! [5: end unless]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_922, 922, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out putting back (B404_carry_out_putting_back)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! carry out putting back:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Cheats" by Orion Zymaris
! carry out putting back:
[ R_921 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_921, 921);
      ! phrase 1
      ! [1: now the noun is in the second noun]
       MoveObject(noun,second); 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_921, 921, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out universal opening (B407_carry_out_universal_ope)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! carry out universal opening:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Cheats" by Orion Zymaris
! carry out universal opening:
[ R_924 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_924, 924);
      ! phrase 1
      ! [1: now all doors are unlocked]
       Prop_69(); 
      ! phrase 2
      ! [2: now all containers are unlocked]
       Prop_70(); 
      ! phrase 3
      ! [3: now all doors are open]
       Prop_71(); 
      ! phrase 4
      ! [4: now all containers are open]
       Prop_72(); 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_924, 924, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report universal opening (B408_report_universal_openin)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report universal opening:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Cheats" by Orion Zymaris
! Report universal opening:
[ R_925 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_925, 925);
      ! phrase 1
      ! [1: say ~Now all doors, vehicles, and containers are unlocked and open.[no line break]~]
      say__p=1;ParaContent();  print (PrintText) SC_495; ParaContent(); (PHR_335_r7 ()); .L_Say318; .L_SayX313;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_925, 925, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Changing player (B411_report_changing_player)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! report changing player:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Cheats" by Orion Zymaris
! report changing player:
[ R_926 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_926, 926);
      ! phrase 1
      ! [1: now the player is the noun]
       ChangePlayer(noun); 
      ! phrase 2
      ! [2: continue the action]
       rfalse; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_926, 926, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out restoring score (B416_carry_out_restoring_sco)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! carry out restoring score:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Cheats" by Orion Zymaris
! carry out restoring score:
[ R_930 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_930, 930);
      ! phrase 1
      ! [1: decrease score by added score]
       score = score - (Global_Vars-->26); 
      ! phrase 2
      ! [2: now added score is 0]
       (Global_Vars-->26) = 0; 
      ! phrase 3
      ! [3: now onactualscore is 1]
       (Global_Vars-->27) = 1; 
      ! phrase 4
      ! [4: say ~You restore the score to [score].~ instead]
      say__p=1;ParaContent();  print (PrintText) SC_496; ParaContent();  print (say__n=score); ParaContent();  print (PrintText) SC_201;  new_line; rtrue; .L_Say319; .L_SayX314; rtrue;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_930, 930, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Removing (B419_carry_out_removing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! carry out removing:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Cheats" by Orion Zymaris
! carry out removing:
[ R_931 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_931, 931);
      ! phrase 1
      ! [1: if the noun is a door begin]
       if (((noun ofclass K4_door)))  {
         ! phrase 2
         ! [2: now the noun is undescribed]
          (Adj_57_t2_v9(noun)); 
         ! phrase 3
         ! [3: say ~you remove [noun] from play.~]
         say__p=1;ParaContent();  print (PrintText) SC_497; ParaContent();  print (PrintShortName) noun; ParaContent();  print (PrintText) SC_498;  new_line; .L_Say320; .L_SayX315;
         ! phrase 4
         ! [4: otherwise if the noun is the player]
          } else if (((noun == player))) { 
         ! phrase 5
         ! [5: say ~you can't do that.~]
         say__p=1;ParaContent();  print (PrintText) SC_499;  new_line; .L_Say321; .L_SayX316;
         ! phrase 6
         ! [6: otherwise]
         } else {

         ! phrase 7
         ! [7: say ~you remove [noun] from play.~]
         say__p=1;ParaContent();  print (PrintText) SC_497; ParaContent();  print (PrintShortName) noun; ParaContent();  print (PrintText) SC_498;  new_line; .L_Say322; .L_SayX317;
         ! phrase 8
         ! [8: remove the noun from play]
          RemoveFromPlay(noun); 
         ! phrase 9
         ! [9: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_931, 931, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Inputting (B425_carry_out_inputting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! carry out inputting when first tumbler is 0:
!   === which is equally specific with ===
! Rule 2/4 ! carry out inputting when second tumbler is 0:
!   === which is equally specific with ===
! Rule 3/4 ! carry out inputting when third tumbler is 0:
!   >>> II - When/while requirement >>>
! Rule 4/4 ! carry out inputting in the presence of a number unlockable ( called pnu ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "3 Digit Number Lock" by Orion Zymaris
! carry out inputting when first tumbler is 0:
[ R_940 ;blockv_stack-->(blockv_sp+29) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+28) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+27) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+26) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+25) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+24) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+23) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+22) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+21) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+20) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+19) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+18) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+17) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+16) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+15) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+14) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+13) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+12) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+11) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+10) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+9) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+8) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+7) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+6) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+5) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+4) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+3) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+2) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+1) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+0) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_sp = blockv_sp + 30;
    blockv_stack-->(blockv_sp++) = R_SHELL_10(blockv_sp-30);
    blockv_sp = blockv_sp - 31;
    BlkFree(blockv_stack-->(blockv_sp+29));
    BlkFree(blockv_stack-->(blockv_sp+28));
    BlkFree(blockv_stack-->(blockv_sp+27));
    BlkFree(blockv_stack-->(blockv_sp+26));
    BlkFree(blockv_stack-->(blockv_sp+25));
    BlkFree(blockv_stack-->(blockv_sp+24));
    BlkFree(blockv_stack-->(blockv_sp+23));
    BlkFree(blockv_stack-->(blockv_sp+22));
    BlkFree(blockv_stack-->(blockv_sp+21));
    BlkFree(blockv_stack-->(blockv_sp+20));
    BlkFree(blockv_stack-->(blockv_sp+19));
    BlkFree(blockv_stack-->(blockv_sp+18));
    BlkFree(blockv_stack-->(blockv_sp+17));
    BlkFree(blockv_stack-->(blockv_sp+16));
    BlkFree(blockv_stack-->(blockv_sp+15));
    BlkFree(blockv_stack-->(blockv_sp+14));
    BlkFree(blockv_stack-->(blockv_sp+13));
    BlkFree(blockv_stack-->(blockv_sp+12));
    BlkFree(blockv_stack-->(blockv_sp+11));
    BlkFree(blockv_stack-->(blockv_sp+10));
    BlkFree(blockv_stack-->(blockv_sp+9));
    BlkFree(blockv_stack-->(blockv_sp+8));
    BlkFree(blockv_stack-->(blockv_sp+7));
    BlkFree(blockv_stack-->(blockv_sp+6));
    BlkFree(blockv_stack-->(blockv_sp+5));
    BlkFree(blockv_stack-->(blockv_sp+4));
    BlkFree(blockv_stack-->(blockv_sp+3));
    BlkFree(blockv_stack-->(blockv_sp+2));
    BlkFree(blockv_stack-->(blockv_sp+1));
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+30);
];
[ R_SHELL_10 I7BASPL 
    t_0 ! Local variable e.g. '?-1,-1?' = indexed text
    ;
   if (actor == player) {
   if (((((((Global_Vars-->31) == 0)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_940, 940);
      ! phrase 1
      ! [1: if first digit is 0 begin]
       if ((((Global_Vars-->28) == 0)))  {
         ! phrase 2
         ! [2: let t be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+0)); 
         ! phrase 3
         ! [3: let t be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 4
         ! [4: if character number 1 in t is ~0~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+2)), t_0, 1, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+1)), INDEXED_TEXT_TY, TEXT_TY, SC_500))==0)))  {
            ! phrase 5
            ! [5: now first tumbler is 1]
             (Global_Vars-->31) = 1; 
            ! phrase 6
            ! [6: end if]
            }

         ! phrase 7
         ! [7: otherwise if first digit is 1]
          } else if ((((Global_Vars-->28) == 1))) { 
         ! phrase 8
         ! [8: let t be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+3)); 
         ! phrase 9
         ! [9: let t be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 10
         ! [10: if character number 1 in t is ~1~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+5)), t_0, 1, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+4)), INDEXED_TEXT_TY, TEXT_TY, SC_501))==0)))  {
            ! phrase 11
            ! [11: now first tumbler is 1]
             (Global_Vars-->31) = 1; 
            ! phrase 12
            ! [12: end if]
            }

         ! phrase 13
         ! [13: otherwise if first digit is 2]
          } else if ((((Global_Vars-->28) == 2))) { 
         ! phrase 14
         ! [14: let t be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+6)); 
         ! phrase 15
         ! [15: let t be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 16
         ! [16: if character number 1 in t is ~2~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+8)), t_0, 1, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+7)), INDEXED_TEXT_TY, TEXT_TY, SC_502))==0)))  {
            ! phrase 17
            ! [17: now first tumbler is 1]
             (Global_Vars-->31) = 1; 
            ! phrase 18
            ! [18: end if]
            }

         ! phrase 19
         ! [19: otherwise if first digit is 3]
          } else if ((((Global_Vars-->28) == 3))) { 
         ! phrase 20
         ! [20: let t be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+9)); 
         ! phrase 21
         ! [21: let t be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 22
         ! [22: if character number 1 in t is ~3~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+11)), t_0, 1, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+10)), INDEXED_TEXT_TY, TEXT_TY, SC_503))==0)))  {
            ! phrase 23
            ! [23: now first tumbler is 1]
             (Global_Vars-->31) = 1; 
            ! phrase 24
            ! [24: end if]
            }

         ! phrase 25
         ! [25: otherwise if first digit is 4]
          } else if ((((Global_Vars-->28) == 4))) { 
         ! phrase 26
         ! [26: let t be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+12)); 
         ! phrase 27
         ! [27: let t be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 28
         ! [28: if character number 1 in t is ~4~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+14)), t_0, 1, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+13)), INDEXED_TEXT_TY, TEXT_TY, SC_504))==0)))  {
            ! phrase 29
            ! [29: now first tumbler is 1]
             (Global_Vars-->31) = 1; 
            ! phrase 30
            ! [30: end if]
            }

         ! phrase 31
         ! [31: otherwise if first digit is 5]
          } else if ((((Global_Vars-->28) == 5))) { 
         ! phrase 32
         ! [32: let t be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+15)); 
         ! phrase 33
         ! [33: let t be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 34
         ! [34: if character number 1 in t is ~5~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+17)), t_0, 1, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+16)), INDEXED_TEXT_TY, TEXT_TY, SC_505))==0)))  {
            ! phrase 35
            ! [35: now first tumbler is 1]
             (Global_Vars-->31) = 1; 
            ! phrase 36
            ! [36: end if]
            }

         ! phrase 37
         ! [37: otherwise if first digit is 6]
          } else if ((((Global_Vars-->28) == 6))) { 
         ! phrase 38
         ! [38: let t be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+18)); 
         ! phrase 39
         ! [39: let t be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 40
         ! [40: if character number 1 in t is ~6~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+20)), t_0, 1, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+19)), INDEXED_TEXT_TY, TEXT_TY, SC_506))==0)))  {
            ! phrase 41
            ! [41: now first tumbler is 1]
             (Global_Vars-->31) = 1; 
            ! phrase 42
            ! [42: end if]
            }

         ! phrase 43
         ! [43: otherwise if first digit is 7]
          } else if ((((Global_Vars-->28) == 7))) { 
         ! phrase 44
         ! [44: let t be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+21)); 
         ! phrase 45
         ! [45: let t be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 46
         ! [46: if character number 1 in t is ~7~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+23)), t_0, 1, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+22)), INDEXED_TEXT_TY, TEXT_TY, SC_507))==0)))  {
            ! phrase 47
            ! [47: now first tumbler is 1]
             (Global_Vars-->31) = 1; 
            ! phrase 48
            ! [48: end if]
            }

         ! phrase 49
         ! [49: otherwise if first digit is 8]
          } else if ((((Global_Vars-->28) == 8))) { 
         ! phrase 50
         ! [50: let t be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+24)); 
         ! phrase 51
         ! [51: let t be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 52
         ! [52: if character number 1 in t is ~8~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+26)), t_0, 1, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+25)), INDEXED_TEXT_TY, TEXT_TY, SC_508))==0)))  {
            ! phrase 53
            ! [53: now first tumbler is 1]
             (Global_Vars-->31) = 1; 
            ! phrase 54
            ! [54: end if]
            }

         ! phrase 55
         ! [55: otherwise if first digit is 9]
          } else if ((((Global_Vars-->28) == 9))) { 
         ! phrase 56
         ! [56: let t be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+27)); 
         ! phrase 57
         ! [57: let t be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 58
         ! [58: if character number 1 in t is ~9~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+29)), t_0, 1, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+28)), INDEXED_TEXT_TY, TEXT_TY, SC_509))==0)))  {
            ! phrase 59
            ! [59: now first tumbler is 1]
             (Global_Vars-->31) = 1; 
            ! phrase 60
            ! [60: end if]
            }

         ! phrase 61
         ! [61: end if]
         }

   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_940, 940, true);
   rfalse;
];
! No specific request
! From "3 Digit Number Lock" by Orion Zymaris
! carry out inputting when second tumbler is 0:
[ R_941 ;blockv_stack-->(blockv_sp+29) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+28) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+27) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+26) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+25) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+24) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+23) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+22) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+21) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+20) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+19) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+18) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+17) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+16) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+15) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+14) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+13) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+12) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+11) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+10) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+9) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+8) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+7) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+6) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+5) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+4) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+3) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+2) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+1) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+0) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_sp = blockv_sp + 30;
    blockv_stack-->(blockv_sp++) = R_SHELL_11(blockv_sp-30);
    blockv_sp = blockv_sp - 31;
    BlkFree(blockv_stack-->(blockv_sp+29));
    BlkFree(blockv_stack-->(blockv_sp+28));
    BlkFree(blockv_stack-->(blockv_sp+27));
    BlkFree(blockv_stack-->(blockv_sp+26));
    BlkFree(blockv_stack-->(blockv_sp+25));
    BlkFree(blockv_stack-->(blockv_sp+24));
    BlkFree(blockv_stack-->(blockv_sp+23));
    BlkFree(blockv_stack-->(blockv_sp+22));
    BlkFree(blockv_stack-->(blockv_sp+21));
    BlkFree(blockv_stack-->(blockv_sp+20));
    BlkFree(blockv_stack-->(blockv_sp+19));
    BlkFree(blockv_stack-->(blockv_sp+18));
    BlkFree(blockv_stack-->(blockv_sp+17));
    BlkFree(blockv_stack-->(blockv_sp+16));
    BlkFree(blockv_stack-->(blockv_sp+15));
    BlkFree(blockv_stack-->(blockv_sp+14));
    BlkFree(blockv_stack-->(blockv_sp+13));
    BlkFree(blockv_stack-->(blockv_sp+12));
    BlkFree(blockv_stack-->(blockv_sp+11));
    BlkFree(blockv_stack-->(blockv_sp+10));
    BlkFree(blockv_stack-->(blockv_sp+9));
    BlkFree(blockv_stack-->(blockv_sp+8));
    BlkFree(blockv_stack-->(blockv_sp+7));
    BlkFree(blockv_stack-->(blockv_sp+6));
    BlkFree(blockv_stack-->(blockv_sp+5));
    BlkFree(blockv_stack-->(blockv_sp+4));
    BlkFree(blockv_stack-->(blockv_sp+3));
    BlkFree(blockv_stack-->(blockv_sp+2));
    BlkFree(blockv_stack-->(blockv_sp+1));
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+30);
];
[ R_SHELL_11 I7BASPL 
    t_0 ! Local variable e.g. '?-1,-1?' = indexed text
    ;
   if (actor == player) {
   if (((((((Global_Vars-->32) == 0)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_941, 941);
      ! phrase 1
      ! [1: if second digit is 0 begin]
       if ((((Global_Vars-->29) == 0)))  {
         ! phrase 2
         ! [2: let u be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+0)); 
         ! phrase 3
         ! [3: let u be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 4
         ! [4: if character number 2 in u is ~0~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+2)), t_0, 2, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+1)), INDEXED_TEXT_TY, TEXT_TY, SC_500))==0)))  {
            ! phrase 5
            ! [5: now second tumbler is 1]
             (Global_Vars-->32) = 1; 
            ! phrase 6
            ! [6: end if]
            }

         ! phrase 7
         ! [7: otherwise if second digit is 1]
          } else if ((((Global_Vars-->29) == 1))) { 
         ! phrase 8
         ! [8: let u be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+3)); 
         ! phrase 9
         ! [9: let u be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 10
         ! [10: if character number 2 in u is ~1~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+5)), t_0, 2, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+4)), INDEXED_TEXT_TY, TEXT_TY, SC_501))==0)))  {
            ! phrase 11
            ! [11: now second tumbler is 1]
             (Global_Vars-->32) = 1; 
            ! phrase 12
            ! [12: end if]
            }

         ! phrase 13
         ! [13: otherwise if second digit is 2]
          } else if ((((Global_Vars-->29) == 2))) { 
         ! phrase 14
         ! [14: let u be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+6)); 
         ! phrase 15
         ! [15: let u be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 16
         ! [16: if character number 2 in u is ~2~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+8)), t_0, 2, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+7)), INDEXED_TEXT_TY, TEXT_TY, SC_502))==0)))  {
            ! phrase 17
            ! [17: now second tumbler is 1]
             (Global_Vars-->32) = 1; 
            ! phrase 18
            ! [18: end if]
            }

         ! phrase 19
         ! [19: otherwise if second digit is 3]
          } else if ((((Global_Vars-->29) == 3))) { 
         ! phrase 20
         ! [20: let u be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+9)); 
         ! phrase 21
         ! [21: let u be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 22
         ! [22: if character number 2 in u is ~3~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+11)), t_0, 2, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+10)), INDEXED_TEXT_TY, TEXT_TY, SC_503))==0)))  {
            ! phrase 23
            ! [23: now second tumbler is 1]
             (Global_Vars-->32) = 1; 
            ! phrase 24
            ! [24: end if]
            }

         ! phrase 25
         ! [25: otherwise if second digit is 4]
          } else if ((((Global_Vars-->29) == 4))) { 
         ! phrase 26
         ! [26: let u be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+12)); 
         ! phrase 27
         ! [27: let u be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 28
         ! [28: if character number 2 in u is ~4~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+14)), t_0, 2, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+13)), INDEXED_TEXT_TY, TEXT_TY, SC_504))==0)))  {
            ! phrase 29
            ! [29: now second tumbler is 1]
             (Global_Vars-->32) = 1; 
            ! phrase 30
            ! [30: end if]
            }

         ! phrase 31
         ! [31: otherwise if second digit is 5]
          } else if ((((Global_Vars-->29) == 5))) { 
         ! phrase 32
         ! [32: let u be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+15)); 
         ! phrase 33
         ! [33: let u be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 34
         ! [34: if character number 2 in u is ~5~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+17)), t_0, 2, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+16)), INDEXED_TEXT_TY, TEXT_TY, SC_505))==0)))  {
            ! phrase 35
            ! [35: now second tumbler is 1]
             (Global_Vars-->32) = 1; 
            ! phrase 36
            ! [36: end if]
            }

         ! phrase 37
         ! [37: otherwise if second digit is 6]
          } else if ((((Global_Vars-->29) == 6))) { 
         ! phrase 38
         ! [38: let u be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+18)); 
         ! phrase 39
         ! [39: let u be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 40
         ! [40: if character number 2 in u is ~6~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+20)), t_0, 2, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+19)), INDEXED_TEXT_TY, TEXT_TY, SC_506))==0)))  {
            ! phrase 41
            ! [41: now second tumbler is 1]
             (Global_Vars-->32) = 1; 
            ! phrase 42
            ! [42: end if]
            }

         ! phrase 43
         ! [43: otherwise if second digit is 7]
          } else if ((((Global_Vars-->29) == 7))) { 
         ! phrase 44
         ! [44: let u be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+21)); 
         ! phrase 45
         ! [45: let u be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 46
         ! [46: if character number 2 in u is ~7~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+23)), t_0, 2, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+22)), INDEXED_TEXT_TY, TEXT_TY, SC_507))==0)))  {
            ! phrase 47
            ! [47: now second tumbler is 1]
             (Global_Vars-->32) = 1; 
            ! phrase 48
            ! [48: end if]
            }

         ! phrase 49
         ! [49: otherwise if second digit is 8]
          } else if ((((Global_Vars-->29) == 8))) { 
         ! phrase 50
         ! [50: let u be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+24)); 
         ! phrase 51
         ! [51: let u be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 52
         ! [52: if character number 2 in u is ~8~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+26)), t_0, 2, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+25)), INDEXED_TEXT_TY, TEXT_TY, SC_508))==0)))  {
            ! phrase 53
            ! [53: now second tumbler is 1]
             (Global_Vars-->32) = 1; 
            ! phrase 54
            ! [54: end if]
            }

         ! phrase 55
         ! [55: otherwise if second digit is 9]
          } else if ((((Global_Vars-->29) == 9))) { 
         ! phrase 56
         ! [56: let u be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+27)); 
         ! phrase 57
         ! [57: let u be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 58
         ! [58: if character number 2 in u is ~9~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+29)), t_0, 2, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+28)), INDEXED_TEXT_TY, TEXT_TY, SC_509))==0)))  {
            ! phrase 59
            ! [59: now second tumbler is 1]
             (Global_Vars-->32) = 1; 
            ! phrase 60
            ! [60: end if]
            }

         ! phrase 61
         ! [61: end if]
         }

   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_941, 941, true);
   rfalse;
];
! No specific request
! From "3 Digit Number Lock" by Orion Zymaris
! carry out inputting when third tumbler is 0:
[ R_942 ;blockv_stack-->(blockv_sp+29) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+28) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+27) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+26) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+25) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+24) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+23) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+22) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+21) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+20) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+19) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+18) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+17) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+16) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+15) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+14) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+13) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+12) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+11) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+10) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+9) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+8) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+7) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+6) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+5) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+4) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+3) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+2) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+1) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+0) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_sp = blockv_sp + 30;
    blockv_stack-->(blockv_sp++) = R_SHELL_12(blockv_sp-30);
    blockv_sp = blockv_sp - 31;
    BlkFree(blockv_stack-->(blockv_sp+29));
    BlkFree(blockv_stack-->(blockv_sp+28));
    BlkFree(blockv_stack-->(blockv_sp+27));
    BlkFree(blockv_stack-->(blockv_sp+26));
    BlkFree(blockv_stack-->(blockv_sp+25));
    BlkFree(blockv_stack-->(blockv_sp+24));
    BlkFree(blockv_stack-->(blockv_sp+23));
    BlkFree(blockv_stack-->(blockv_sp+22));
    BlkFree(blockv_stack-->(blockv_sp+21));
    BlkFree(blockv_stack-->(blockv_sp+20));
    BlkFree(blockv_stack-->(blockv_sp+19));
    BlkFree(blockv_stack-->(blockv_sp+18));
    BlkFree(blockv_stack-->(blockv_sp+17));
    BlkFree(blockv_stack-->(blockv_sp+16));
    BlkFree(blockv_stack-->(blockv_sp+15));
    BlkFree(blockv_stack-->(blockv_sp+14));
    BlkFree(blockv_stack-->(blockv_sp+13));
    BlkFree(blockv_stack-->(blockv_sp+12));
    BlkFree(blockv_stack-->(blockv_sp+11));
    BlkFree(blockv_stack-->(blockv_sp+10));
    BlkFree(blockv_stack-->(blockv_sp+9));
    BlkFree(blockv_stack-->(blockv_sp+8));
    BlkFree(blockv_stack-->(blockv_sp+7));
    BlkFree(blockv_stack-->(blockv_sp+6));
    BlkFree(blockv_stack-->(blockv_sp+5));
    BlkFree(blockv_stack-->(blockv_sp+4));
    BlkFree(blockv_stack-->(blockv_sp+3));
    BlkFree(blockv_stack-->(blockv_sp+2));
    BlkFree(blockv_stack-->(blockv_sp+1));
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+30);
];
[ R_SHELL_12 I7BASPL 
    t_0 ! Local variable e.g. '?-1,-1?' = indexed text
    ;
   if (actor == player) {
   if (((((((Global_Vars-->33) == 0)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_942, 942);
      ! phrase 1
      ! [1: if third digit is 0 begin]
       if ((((Global_Vars-->30) == 0)))  {
         ! phrase 2
         ! [2: let v be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+0)); 
         ! phrase 3
         ! [3: let v be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 4
         ! [4: if character number 3 in v is ~0~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+2)), t_0, 3, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+1)), INDEXED_TEXT_TY, TEXT_TY, SC_500))==0)))  {
            ! phrase 5
            ! [5: now third tumbler is 1]
             (Global_Vars-->33) = 1; 
            ! phrase 6
            ! [6: end if]
            }

         ! phrase 7
         ! [7: otherwise if third digit is 1]
          } else if ((((Global_Vars-->30) == 1))) { 
         ! phrase 8
         ! [8: let v be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+3)); 
         ! phrase 9
         ! [9: let v be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 10
         ! [10: if character number 3 in v is ~1~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+5)), t_0, 3, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+4)), INDEXED_TEXT_TY, TEXT_TY, SC_501))==0)))  {
            ! phrase 11
            ! [11: now third tumbler is 1]
             (Global_Vars-->33) = 1; 
            ! phrase 12
            ! [12: end if]
            }

         ! phrase 13
         ! [13: otherwise if third digit is 2]
          } else if ((((Global_Vars-->30) == 2))) { 
         ! phrase 14
         ! [14: let v be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+6)); 
         ! phrase 15
         ! [15: let v be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 16
         ! [16: if character number 3 in v is ~2~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+8)), t_0, 3, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+7)), INDEXED_TEXT_TY, TEXT_TY, SC_502))==0)))  {
            ! phrase 17
            ! [17: now third tumbler is 1]
             (Global_Vars-->33) = 1; 
            ! phrase 18
            ! [18: end if]
            }

         ! phrase 19
         ! [19: otherwise if third digit is 3]
          } else if ((((Global_Vars-->30) == 3))) { 
         ! phrase 20
         ! [20: let v be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+9)); 
         ! phrase 21
         ! [21: let v be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 22
         ! [22: if character number 3 in v is ~3~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+11)), t_0, 3, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+10)), INDEXED_TEXT_TY, TEXT_TY, SC_503))==0)))  {
            ! phrase 23
            ! [23: now third tumbler is 1]
             (Global_Vars-->33) = 1; 
            ! phrase 24
            ! [24: end if]
            }

         ! phrase 25
         ! [25: otherwise if third digit is 4]
          } else if ((((Global_Vars-->30) == 4))) { 
         ! phrase 26
         ! [26: let v be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+12)); 
         ! phrase 27
         ! [27: let v be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 28
         ! [28: if character number 3 in v is ~4~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+14)), t_0, 3, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+13)), INDEXED_TEXT_TY, TEXT_TY, SC_504))==0)))  {
            ! phrase 29
            ! [29: now third tumbler is 1]
             (Global_Vars-->33) = 1; 
            ! phrase 30
            ! [30: end if]
            }

         ! phrase 31
         ! [31: otherwise if third digit is 5]
          } else if ((((Global_Vars-->30) == 5))) { 
         ! phrase 32
         ! [32: let v be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+15)); 
         ! phrase 33
         ! [33: let v be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 34
         ! [34: if character number 3 in v is ~5~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+17)), t_0, 3, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+16)), INDEXED_TEXT_TY, TEXT_TY, SC_505))==0)))  {
            ! phrase 35
            ! [35: now third tumbler is 1]
             (Global_Vars-->33) = 1; 
            ! phrase 36
            ! [36: end if]
            }

         ! phrase 37
         ! [37: otherwise if third digit is 6]
          } else if ((((Global_Vars-->30) == 6))) { 
         ! phrase 38
         ! [38: let v be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+18)); 
         ! phrase 39
         ! [39: let v be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 40
         ! [40: if character number 3 in v is ~6~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+20)), t_0, 3, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+19)), INDEXED_TEXT_TY, TEXT_TY, SC_506))==0)))  {
            ! phrase 41
            ! [41: now third tumbler is 1]
             (Global_Vars-->33) = 1; 
            ! phrase 42
            ! [42: end if]
            }

         ! phrase 43
         ! [43: otherwise if third digit is 7]
          } else if ((((Global_Vars-->30) == 7))) { 
         ! phrase 44
         ! [44: let v be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+21)); 
         ! phrase 45
         ! [45: let v be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 46
         ! [46: if character number 3 in v is ~7~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+23)), t_0, 3, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+22)), INDEXED_TEXT_TY, TEXT_TY, SC_507))==0)))  {
            ! phrase 47
            ! [47: now third tumbler is 1]
             (Global_Vars-->33) = 1; 
            ! phrase 48
            ! [48: end if]
            }

         ! phrase 49
         ! [49: otherwise if third digit is 8]
          } else if ((((Global_Vars-->30) == 8))) { 
         ! phrase 50
         ! [50: let v be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+24)); 
         ! phrase 51
         ! [51: let v be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 52
         ! [52: if character number 3 in v is ~8~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+26)), t_0, 3, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+25)), INDEXED_TEXT_TY, TEXT_TY, SC_508))==0)))  {
            ! phrase 53
            ! [53: now third tumbler is 1]
             (Global_Vars-->33) = 1; 
            ! phrase 54
            ! [54: end if]
            }

         ! phrase 55
         ! [55: otherwise if third digit is 9]
          } else if ((((Global_Vars-->30) == 9))) { 
         ! phrase 56
         ! [56: let v be indexed text]
          t_0 = (blockv_stack-->(I7BASPL+27)); 
         ! phrase 57
         ! [57: let v be the player's command]
          BlkValueCast(t_0, INDEXED_TEXT_TY, SNIPPET_TY, players_command); 
         ! phrase 58
         ! [58: if character number 3 in v is ~9~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+29)), t_0, 3, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+28)), INDEXED_TEXT_TY, TEXT_TY, SC_509))==0)))  {
            ! phrase 59
            ! [59: now third tumbler is 1]
             (Global_Vars-->33) = 1; 
            ! phrase 60
            ! [60: end if]
            }

         ! phrase 61
         ! [61: end if]
         }

   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_942, 942, true);
   rfalse;
];
! No specific request
! From "3 Digit Number Lock" by Orion Zymaris
! carry out inputting in the presence of a number unlockable ( called pnu ):
[ R_943 
    t_0 ! Local variable e.g. 'pnu' = number unlockable
    ;
   if ( (actor==player) && (los_rv=false, LoopOverScope(LOS_0, actor), t_0=los_rv)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_943, 943);
      ! phrase 1
      ! [1: unless pnu is unlocked begin]
       if (~~((((Adj_71_t1_v9(t_0))))))  {
         ! phrase 2
         ! [2: if first tumbler is 1 begin]
          if ((((Global_Vars-->31) == 1)))  {
            ! phrase 3
            ! [3: if second tumbler is 1 begin]
             if ((((Global_Vars-->32) == 1)))  {
               ! phrase 4
               ! [4: if third tumbler is 1 begin]
                if ((((Global_Vars-->33) == 1)))  {
                  ! phrase 5
                  ! [5: say ~You unlock [pnu].~]
                  say__p=1;ParaContent();  print (PrintText) SC_510; ParaContent();  print (PrintShortName) t_0; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say323; .L_SayX318;
                  ! phrase 6
                  ! [6: now pnu is unlocked]
                   (Adj_71_t2_v9(t_0)); 
                  ! phrase 7
                  ! [7: now first tumbler is 0]
                   (Global_Vars-->31) = 0; 
                  ! phrase 8
                  ! [8: now second tumbler is 0]
                   (Global_Vars-->32) = 0; 
                  ! phrase 9
                  ! [9: now third tumbler is 0 instead]
                   (Global_Vars-->33) = 0;  rtrue;
                  ! phrase 10
                  ! [10: end if]
                  }

               ! phrase 11
               ! [11: end if]
               }

            ! phrase 12
            ! [12: end if]
            }

         ! phrase 13
         ! [13: otherwise if pnu is unlocked]
          } else if ((((Adj_71_t1_v9(t_0))))) { 
         ! phrase 14
         ! [14: say ~[stop if already unlocked]~]
         say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->35);  .L_Say324; .L_SayX319;
         ! phrase 15
         ! [15: end unless]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_943, 943, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Inputting (B426_report_inputting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! report inputting in the presence of a number unlockable ( called prnu ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "3 Digit Number Lock" by Orion Zymaris
! report inputting in the presence of a number unlockable ( called prnu ):
[ R_944 
    t_0 ! Local variable e.g. 'prnu' = number unlockable
    ;
   if ( (actor==player) && (los_rv=false, LoopOverScope(LOS_1, actor), t_0=los_rv)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_944, 944);
      ! phrase 1
      ! [1: unless prnu is unlocked begin]
       if (~~((((Adj_71_t1_v9(t_0))))))  {
         ! phrase 2
         ! [2: say ~[Incorrect number lock]~]
         say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->34);  .L_Say325; .L_SayX320;
         ! phrase 3
         ! [3: now first tumbler is 0]
          (Global_Vars-->31) = 0; 
         ! phrase 4
         ! [4: now second tumbler is 0]
          (Global_Vars-->32) = 0; 
         ! phrase 5
         ! [5: now third tumbler is 0]
          (Global_Vars-->33) = 0; 
         ! phrase 6
         ! [6: end unless]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_944, 944, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Imploring it for (B431_carry_out_imploring_it_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! carry out imploring Petunia for ~[Potters]~ during uncle vernon's scene:
! ----------------------------------------------------------------------------------------------------
! No specific request
! carry out imploring Petunia for ~[Potters]~ during uncle vernon's scene:
[ R_1309 ;
   if (scene_status-->1 == 1) { ! Runs only during scene
   if ( (actor==player) && ((noun == I202_petunia) && (true)) && (Consult_Grammar_320(consult_from, consult_words)~=GPR_FAIL)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1309, 1309);
      ! phrase 1
      ! [1: say ~[one of]'Er - Petunia, dear - you haven't heard from your sister lately, have you?'[paragraph break]'No. Why?' Says Petunia, rather sharply.[or]'Er - Petunia, dear - you haven't heard from your sister lately, have you?'[paragraph break]'No. Why?' Says Petunia, rather sharply.[or]'No, and will you please not mention her unless you have to?' says Petunia.[stopping][line break][run paragraph on]~ instead]
      say__p=1;ParaContent();  I7_ST_say_one_of-->8 =
	i7_soo_stop(I7_ST_say_one_of-->8, 3);
	switch((I7_ST_say_one_of-->8)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_365; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_366;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_365; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_366;  new_line;ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_367;  new_line;ParaContent();  } ParaContent();  new_line; ParaContent();  RunParagraphOn();  rtrue; .L_Say326; .L_SayX321; rtrue;
      ! phrase 2
      ! [2: now the venture of living-room cut scene is half-complete]
       WriteGProperty(SCENE_TY, I328_living_room_cut_scene,p80_venture,I270_half_complete); 
      ! phrase 3
      ! [3: rule succeeds]
       RulebookSucceeds(); rtrue; 
   } ! Runs only during scene
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1309, 1309, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Quizzing it about (B433_check_quizzing_it_about)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check quizzing someone about something unknown ( this is the block asking about something unknown rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework" by Eric Eve
! Check quizzing someone about something unknown ( this is the block asking about something unknown rule ):
[ R_992 ;
   if ( (actor==player) && ((noun ofclass K8_person)) && ((second ofclass K2_thing) && ((Adj_33_t1_v9(second))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_992, 992);
      ! phrase 1
      ! [1: abide by the block asking rule]
       if (ProcessRulebook(R_249)) rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_992, 992, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Quizzing it about (B435_report_quizzing_it_abou)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report quizzing someone about something ( this is the block quizzing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework" by Eric Eve
! Report quizzing someone about something ( this is the block quizzing rule ):
[ R_951 ;
   if ( (actor==player) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_951, 951);
      ! phrase 1
      ! [1: say ~There is no reply.~]
      say__p=1;ParaContent();  print (PrintText) SC_511;  new_line; .L_Say327; .L_SayX322;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_951, 951, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Informing it about (B436_check_informing_it_abou)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check informing someone about something unknown ( this is the block telling about something unknown rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework" by Eric Eve
! Check informing someone about something unknown ( this is the block telling about something unknown rule ):
[ R_993 ;
   if ( (actor==player) && ((noun ofclass K8_person)) && ((second ofclass K2_thing) && ((Adj_33_t1_v9(second))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_993, 993);
      ! phrase 1
      ! [1: abide by the block telling rule]
       if (ProcessRulebook(R_248)) rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_993, 993, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Informing it about (B438_report_informing_it_abo)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report informing someone about something ( this is the block informing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework" by Eric Eve
! Report informing someone about something ( this is the block informing rule ):
[ R_950 ;
   if ( (actor==player) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_950, 950);
      ! phrase 1
      ! [1: say ~There is no reply.~]
      say__p=1;ParaContent();  print (PrintText) SC_511;  new_line; .L_Say328; .L_SayX323;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_950, 950, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Saying hello to (B457_check_saying_hello_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check saying hello to a person when the noun is the current interlocutor ( this is the can't greet current interlocutor rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework" by Eric Eve
! Check saying hello to a person when the noun is the current interlocutor ( this is the can't greet current interlocutor rule ):
[ R_967 ;
   if ( (actor==player) && ((noun ofclass K8_person)) && (self=actor,true) && (((noun == (Global_Vars-->36))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_967, 967);
      ! phrase 1
      ! [1: if the noun is the player , say ~Talking to yourself is unrewarding.~ instead]
       if (((noun == player))) { say__p=1;ParaContent();  print (PrintText) SC_512;  new_line; .L_Say329; .L_SayX324;  rtrue; }
      ! phrase 2
      ! [2: say ~You are already talking to [the noun].~ instead]
      say__p=1;ParaContent();  print (PrintText) SC_513; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_201;  new_line; rtrue; .L_Say330; .L_SayX325; rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_967, 967, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Saying hello to (B458_carry_out_saying_hello_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! carry out saying hello to petunia during uncle vernon's scene:
!   >>> I - Number of aspects constrained >>>
! Rule 2/2 ! Carry out saying hello to a person ( this is the note current interlocutor when greeted rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! carry out saying hello to petunia during uncle vernon's scene:
[ R_1280 ;
   if (scene_status-->1 == 1) { ! Runs only during scene
   if ( (actor==player) && ((noun == I202_petunia) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1280, 1280);
      ! phrase 1
      ! [1: if the venture of work is success begin]
       if (((GProperty(SCENE_TY, I238_work,p80_venture) == I266_success)))  {
         ! phrase 2
         ! [2: unless tvonafterwork is 1 begin]
          if (~~((((Global_Vars-->80) == 1))))  {
            ! phrase 3
            ! [3: say ~'Good afternoon. How was your day, Vernon?' Asks petunia.~]
            say__p=1;ParaContent();  print (PrintText) SC_514;  new_line; .L_Say331; .L_SayX326;
            ! phrase 4
            ! [4: otherwise]
            } else {

            ! phrase 5
            ! [5: continue the action]
             rfalse; 
            ! phrase 6
            ! [6: end unless]
            }

         ! phrase 7
         ! [7: otherwise]
         } else {

         ! phrase 8
         ! [8: continue the action]
          rfalse; 
         ! phrase 9
         ! [9: end if]
         }

   } ! Runs only during scene
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1280, 1280, true);
   rfalse;
];
! No specific request
! From "Conversation Framework" by Eric Eve
! Carry out saying hello to a person ( this is the note current interlocutor when greeted rule ):
[ R_968 ;
   if ( (actor==player) && ((noun ofclass K8_person))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_968, 968);
      ! phrase 1
      ! [1: now the current interlocutor is the noun]
       (Global_Vars-->36) = noun; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_968, 968, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Saying hello to (B459_report_saying_hello_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report saying hello to someone when the greeting type is explicit ( this is the default greeting rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/2 ! Report saying hello to something that is not a person ( this is the can't greet inanimate objects rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework" by Eric Eve
! Report saying hello to someone when the greeting type is explicit ( this is the default greeting rule ):
[ R_970 ;
   if ( (actor==player) && ((noun ofclass K8_person)) && (self=actor,true) && ((((Global_Vars-->37) == I112_explicit)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_970, 970);
      ! phrase 1
      ! [1: say ~You say hello to [the noun].~]
      say__p=1;ParaContent();  print (PrintText) SC_515; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say332; .L_SayX327;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_970, 970, true);
   rfalse;
];
! No specific request
! From "Conversation Framework" by Eric Eve
! Report saying hello to something that is not a person ( this is the can't greet inanimate objects rule ):
[ R_969 ;
   if ( (actor==player) && ((noun ofclass K2_thing) && (~~((noun ofclass K8_person))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_969, 969);
      ! phrase 1
      ! [1: say ~[The noun] do[if the noun is not plural-named and the noun is not the player]es[end if] not respond.~]
      say__p=1;ParaContent();  print (The) noun; ParaContent();  print (PrintText) SC_516; 
	if (~~(((((~~(((Adj_36_t1_v9(noun))))))) && (((~~((noun == player)))))))) jump L_Say333;
		ParaContent();  print (PrintText) SC_517; 
	.L_Say333; .L_SayX328;
		ParaContent();  print (PrintText) SC_518;  new_line; .L_Say334; .L_SayX329;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_969, 969, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Hailing (B460_check_hailing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check hailing ( this is the check what's being hailed rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework" by Eric Eve
! Check hailing ( this is the check what's being hailed rule ):
[ R_972 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_972, 972);
      ! phrase 1
      ! [1: if the current interlocutor is a visible person , say ~You are already talking to [the current interlocutor].~ instead]
       if ((((Global_Vars-->36) ofclass K8_person) && ((Adj_3_t1_v9((Global_Vars-->36)))))) { say__p=1;ParaContent();  print (PrintText) SC_513; ParaContent();  print (the) (Global_Vars-->36); ParaContent();  print (PrintText) SC_201;  new_line; .L_Say335; .L_SayX330;  rtrue; }
      ! phrase 2
      ! [2: now the noun is a random visible person who is not the player]
       noun =  (Prop_73()) ; 
      ! phrase 3
      ! [3: if the noun is a person and the noun is not yourself and the noun is not the player , say ~(addressing [the noun])~]
       if ((((noun ofclass K8_person))) && ((((~~((noun == selfobj))))) && (((~~((noun == player))))))) { say__p=1;ParaContent();  print (PrintText) SC_253; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_230;  .L_Say336; .L_SayX331;  }
      ! phrase 4
      ! [4: otherwise say ~There's no one here but you.~ instead]
       else { say__p=1;ParaContent();  print (PrintText) SC_519;  new_line; .L_Say337; .L_SayX332;  rtrue; }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_972, 972, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Hailing (B461_carry_out_hailing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out hailing ( this is the standard hailing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework" by Eric Eve
! Carry out hailing ( this is the standard hailing rule ):
[ R_973 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_973, 973);
      ! phrase 1
      ! [1: try saying hello to the noun]
       TryAction(0, player, ##A109_saying_hello_to, noun, 0);; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_973, 973, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Leavetaking (B463_check_leavetaking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check leavetaking when the current interlocutor is not a visible person ( this is the don't allow saying goodbye to no-one rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework" by Eric Eve
! Check leavetaking when the current interlocutor is not a visible person ( this is the don't allow saying goodbye to no-one rule ):
[ R_979 ;
   if (actor == player) {
   if ((((((~~(((Global_Vars-->36) ofclass K8_person) && ((Adj_3_t1_v9((Global_Vars-->36))))))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_979, 979);
      ! phrase 1
      ! [1: say ~You're not talking to anyone.~ instead]
      say__p=1;ParaContent();  print (PrintText) SC_254;  new_line; rtrue; .L_Say338; .L_SayX333; rtrue;
   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_979, 979, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Leavetaking (B464_carry_out_leavetaking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out someone trying leavetaking ( this is the convert npc leavetaking to player leavetaking rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/2 ! Carry out leavetaking ( this is the standard leavetaking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework" by Eric Eve
! Carry out someone trying leavetaking ( this is the convert npc leavetaking to player leavetaking rule ):
[ R_982 ;
   if ( (actor~=player) && (act_requester==nothing) && ((actor ofclass K8_person))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_982, 982);
      ! phrase 1
      ! [1: try saying goodbye to the person asked]
       TryAction(0, player, ##A112_saying_goodbye_to, actor, 0);; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_982, 982, true);
   rfalse;
];
! No specific request
! From "Conversation Framework" by Eric Eve
! Carry out leavetaking ( this is the standard leavetaking rule ):
[ R_980 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_980, 980);
      ! phrase 1
      ! [1: try saying goodbye to the current interlocutor]
       TryAction(0, player, ##A112_saying_goodbye_to, (Global_Vars-->36), 0);; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_980, 980, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Saying goodbye to (B466_check_saying_goodbye_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check saying goodbye to something when the noun is not the current interlocutor ( this is the can't say goodbye to someone you're not talking to rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework" by Eric Eve
! Check saying goodbye to something when the noun is not the current interlocutor ( this is the can't say goodbye to someone you're not talking to rule ):
[ R_977 ;
   if ( (actor==player) && ((noun ofclass K2_thing)) && (self=actor,true) && (((~~((noun == (Global_Vars-->36))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_977, 977);
      ! phrase 1
      ! [1: say ~You're not talking to [the noun].~ instead]
      say__p=1;ParaContent();  print (PrintText) SC_520; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_201;  new_line; rtrue; .L_Say339; .L_SayX334; rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_977, 977, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Saying goodbye to (B467_carry_out_saying_goodby)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out saying goodbye to something ( this is the reset interlocutor on saying goodbye rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework" by Eric Eve
! Carry out saying goodbye to something ( this is the reset interlocutor on saying goodbye rule ):
[ R_978 ;
   if ( (actor==player) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_978, 978);
      ! phrase 1
      ! [1: reset the interlocutor]
      (PHR_976_r3 ());
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_978, 978, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Saying goodbye to (B468_report_saying_goodbye_t)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report saying goodbye to someone when the farewell type is explicit ( this is the default saying goodbye rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Conversation Framework" by Eric Eve
! Report saying goodbye to someone when the farewell type is explicit ( this is the default saying goodbye rule ):
[ R_983 ;
   if ( (actor==player) && ((noun ofclass K8_person)) && (self=actor,true) && ((((Global_Vars-->38) == I112_explicit)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_983, 983);
      ! phrase 1
      ! [1: say ~You say goodbye to [the noun].~]
      say__p=1;ParaContent();  print (PrintText) SC_521; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say340; .L_SayX335;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_983, 983, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: glulx timed activity (B469_glulx_timed_activity)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! A glulx timed activity rule ( this is the redirect from timer rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Real-Time Delays" by Erik Temple
! A glulx timed activity rule ( this is the redirect from timer rule ):
[ R_1017 ;
      ! phrase 1
      ! [1: now the waiting flag is false]
       wait_flag = 0; 
      ! phrase 2
      ! [2: stop the timer]
       if (glk_gestalt(gestalt_Timer, 0)) glk_request_timer_events(0); 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: command-counting (B482_command_counting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! A command-counting rule ( this is the ordinary checking for content rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Glulx Entry Points" by Emily Short
! A command-counting rule ( this is the ordinary checking for content rule ):
[ R_1009 ;
      ! phrase 1
      ! [1: if the number of characters in the glulx replacement command is 0 , rule fails]
       if ((( IT_BlobAccess((Global_Vars-->41), CHR_BLOB)  == 0))) {  RulebookFails(); rtrue;   }
      ! phrase 2
      ! [2: rule succeeds]
       RulebookSucceeds(); rtrue; 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: input-cancelling (B483_input_cancelling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! An input-cancelling rule ( this is the cancelling input in the main window rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Glulx Entry Points" by Emily Short
! An input-cancelling rule ( this is the cancelling input in the main window rule ):
[ R_1010 ;
      ! phrase 1
      ! [1: cancel line input in the main window]
       glk_cancel_line_event(gg_mainwin, GLK_NULL); 
      ! phrase 2
      ! [2: cancel character input in the main window]
       glk_cancel_char_event(gg_mainwin); 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: command-showing (B484_command_showing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! A command-showing rule ( this is the print text to the input prompt rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Glulx Entry Points" by Emily Short
! A command-showing rule ( this is the print text to the input prompt rule ):
[ R_1013 ;
      ! phrase 1
      ! [1: say input-style-for-glulx]
      say__p=1;ParaContent();  glk_set_style(style_Input);  .L_Say341; .L_SayX336;
      ! phrase 2
      ! [2: say glulx replacement command]
      say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->41);  .L_Say342; .L_SayX337;
      ! phrase 3
      ! [3: say roman type]
      say__p=1;ParaContent();  style roman;  .L_Say343; .L_SayX338;
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: command-pasting (B485_command_pasting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! A command-pasting rule ( this is the glue replacement command into parse buffer rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Glulx Entry Points" by Emily Short
! A command-pasting rule ( this is the glue replacement command into parse buffer rule ):
[ R_1015 ;
      ! phrase 1
      ! [1: change the text of the player's command to the glulx replacement command]
       SetPlayersCommand((Global_Vars-->41)); 
      ! phrase 2
      ! [2: rule succeeds]
       RulebookSucceeds(); rtrue; 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Dialling it on (B486_check_dialling_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check dialling it on ( this is the can't dial on something that is not a telephone rule ):
!   === which is equally specific with ===
! Rule 2/4 ! Check dialling it on ( this is the can't dial the calling number rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Check dialling it on ( this is the can't dial an emergency number rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Check dialling it on ( this is the can't dial an invalid numer rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Telephones" by George Tryfonas
! Check dialling it on ( this is the can't dial on something that is not a telephone rule ):
[ R_1023 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1023, 1023);
      ! phrase 1
      ! [1: if the second noun is not a telephone , say ~Don't be silly.~ instead]
       if (((~~((second ofclass K29_telephone))))) { say__p=1;ParaContent();  print (PrintText) SC_522;  new_line; .L_Say344; .L_SayX339;  rtrue; }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1023, 1023, true);
   rfalse;
];
! No specific request
! From "Telephones" by George Tryfonas
! Check dialling it on ( this is the can't dial the calling number rule ):
[ R_1024 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1024, 1024);
      ! phrase 1
      ! [1: if the number understood is the calling number of the second noun , say ~You get a busy signal.~ instead]
       if (((parsed_number == GProperty(OBJECT_TY, second,p14_calling_number)))) { say__p=1;ParaContent();  print (PrintText) SC_523;  new_line; .L_Say345; .L_SayX340;  rtrue; }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1024, 1024, true);
   rfalse;
];
! No specific request
! From "Telephones" by George Tryfonas
! Check dialling it on ( this is the can't dial an emergency number rule ):
[ R_1025 
    ct_0 ct_1 ! Used for table searches
    ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1025, 1025);
      ! phrase 1
      ! [1: if the number understood is a number listed in the table of misdialled numbers , say ~[the retort corresponding to a number of the number understood in the Table of Misdialled Numbers]~ instead]
       if (((true) && ((ct_1=ExistsTableRowCorr(ct_0=T11_misdialled_numbers,111,parsed_number))))) { say__p=1;ParaContent();  print (PrintText) TableLookUpCorr(T11_misdialled_numbers,118,111,parsed_number);  .L_Say346; .L_SayX341;  rtrue; }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1025, 1025, true);
   rfalse;
];
! No specific request
! From "Telephones" by George Tryfonas
! Check dialling it on ( this is the can't dial an invalid numer rule ):
[ R_1026 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1026, 1026);
      ! phrase 1
      ! [1: if the line dialled is nothing , say ~The phone rings but there is no reply.~ instead]
       if ((((MStack-->MstVO(20113,0)) == nothing))) { say__p=1;ParaContent();  print (PrintText) SC_524;  new_line; .L_Say347; .L_SayX342;  rtrue; }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1026, 1026, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Dialling it on (B487_carry_out_dialling_it_o)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out dialling it on ( this is the standard dialling rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Telephones" by George Tryfonas
! Carry out dialling it on ( this is the standard dialling rule ):
[ R_1027 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1027, 1027);
      ! phrase 1
      ! [1: now the second noun is inuse]
       (Adj_89_t2_v9(second)); 
      ! phrase 2
      ! [2: now the player reaches the owner of the line dialled]
       Relation_NowS1to1(GProperty(OBJECT_TY, (MStack-->MstVO(20113,0)),p15_owner),p72_other_party,player); 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1027, 1027, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Dialling it on (B488_report_dialling_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report dialling it on ( this is the standard report dialling rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Telephones" by George Tryfonas
! Report dialling it on ( this is the standard report dialling rule ):
[ R_1028 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1028, 1028);
      ! phrase 1
      ! [1: say ~'Hello?' says [the other party of the player] on the other side of the line.~]
      say__p=1;ParaContent();  print (PrintText) SC_525; ParaContent(); @push self;  print (the) GProperty(9, self=player,p72_other_party); @pull self; ParaContent();  print (PrintText) SC_526;  new_line; .L_Say348; .L_SayX343;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1028, 1028, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Hanging up (B489_check_hanging_up)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check hanging up ( this is the can't hang up while not on the line rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Telephones" by George Tryfonas
! Check hanging up ( this is the can't hang up while not on the line rule ):
[ R_1036 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1036, 1036);
      ! phrase 1
      ! [1: if the player does not reach someone , say ~You're not on the line with anyone.~ instead]
       if ((Prop_74())) { say__p=1;ParaContent();  print (PrintText) SC_527;  new_line; .L_Say349; .L_SayX344;  rtrue; }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1036, 1036, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Hanging up (B490_carry_out_hanging_up)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out hanging up ( this is the standard hanging up rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Telephones" by George Tryfonas
! Carry out hanging up ( this is the standard hanging up rule ):
[ R_1037 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1037, 1037);
      ! phrase 1
      ! [1: now the phone hanged up is not inuse]
       (Adj_89_t3_v9((MStack-->MstVO(20114,0)))); 
      ! phrase 2
      ! [2: now the player does not reach anyone]
       Prop_75(); 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1037, 1037, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Hanging up (B491_report_hanging_up)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report hanging up ( this is the standard report hanging up rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Telephones" by George Tryfonas
! Report hanging up ( this is the standard report hanging up rule ):
[ R_1038 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1038, 1038);
      ! phrase 1
      ! [1: say ~You put down [the phone hanged up], cutting the connection.~]
      say__p=1;ParaContent();  print (PrintText) SC_528; ParaContent();  print (the) (MStack-->MstVO(20114,0)); ParaContent();  print (PrintText) SC_529;  new_line; .L_Say350; .L_SayX345;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1038, 1038, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Sitting on (B493_carry_out_sitting_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor sitting on ( this is the standard carry out sitting on rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Postures" by Emily Short
! Carry out an actor sitting on ( this is the standard carry out sitting on rule ):
[ R_1042 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1042, 1042);
      ! phrase 1
      ! [1: if the holder of the actor is not the noun , silently try the actor entering the noun]
       if (((~~(( (HolderOf(actor))  == noun))))) {  @push keep_silent; keep_silent=1; TryAction(0, actor, ##Enter, noun, 0);; @pull keep_silent;   }
      ! phrase 2
      ! [2: if the holder of the actor is the noun begin]
       if ((( (HolderOf(actor))  == noun)))  {
         ! phrase 3
         ! [3: if the actor is not seated , try the actor taking position seated]
          if (((~~((actor.p73_posture == I115_seated))))) {  TryAction(0, actor, ##A121_taking_position, I115_seated, 0);;   }
         ! phrase 4
         ! [4: otherwise follow the report taking position rules]
          else {  FollowRulebook(512);   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1042, 1042, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Lying on (B496_carry_out_lying_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor lying on ( this is the standard carry out lying on rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Postures" by Emily Short
! Carry out an actor lying on ( this is the standard carry out lying on rule ):
[ R_1043 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1043, 1043);
      ! phrase 1
      ! [1: if the holder of the actor is not the noun , silently try the actor entering the noun]
       if (((~~(( (HolderOf(actor))  == noun))))) {  @push keep_silent; keep_silent=1; TryAction(0, actor, ##Enter, noun, 0);; @pull keep_silent;   }
      ! phrase 2
      ! [2: if the holder of the actor is the noun begin]
       if ((( (HolderOf(actor))  == noun)))  {
         ! phrase 3
         ! [3: if the actor is not reclining , try the actor taking position reclining]
          if (((~~((actor.p73_posture == I117_reclining))))) {  TryAction(0, actor, ##A121_taking_position, I117_reclining, 0);;   }
         ! phrase 4
         ! [4: otherwise follow the report taking position rules]
          else {  FollowRulebook(512);   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1043, 1043, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Standing up on (B499_carry_out_standing_up_o)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor standing up on ( this is the standard carry out standing up on rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Postures" by Emily Short
! Carry out an actor standing up on ( this is the standard carry out standing up on rule ):
[ R_1044 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1044, 1044);
      ! phrase 1
      ! [1: if the holder of the actor is not the noun , silently try the actor entering the noun]
       if (((~~(( (HolderOf(actor))  == noun))))) {  @push keep_silent; keep_silent=1; TryAction(0, actor, ##Enter, noun, 0);; @pull keep_silent;   }
      ! phrase 2
      ! [2: if the holder of the actor is the noun begin]
       if ((( (HolderOf(actor))  == noun)))  {
         ! phrase 3
         ! [3: if the actor is not standing , try the actor taking position standing]
          if (((~~((actor.p73_posture == I116_standing))))) {  TryAction(0, actor, ##A121_taking_position, I116_standing, 0);;   }
         ! phrase 4
         ! [4: otherwise follow the report taking position rules]
          else {  FollowRulebook(512);   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1044, 1044, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Taking position (B510_check_taking_position)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor taking position ( this is the can't use inappropriate postures rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor taking position ( this is the can't use already used posture rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Postures" by Emily Short
! Check an actor taking position ( this is the can't use inappropriate postures rule ):
[ R_1056 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1056, 1056);
      ! phrase 1
      ! [1: if the holder of the actor is not a room and the holder of the actor does not allow the posture understood begin]
       if ((((~~(( (HolderOf(actor))  ofclass K1_room))))) && (((~~(((Relation_TestVtoV( (HolderOf(actor)) ,Rel_Record_71,parsed_number,false))))))))  {
         ! phrase 2
         ! [2: if the actor is the player begin]
          if (((actor == player)))  {
            ! phrase 3
            ! [3: say ~You can't take that position [in-on the holder of the actor].~]
            say__p=1;ParaContent();  print (PrintText) SC_530; ParaContent(); (Resolver_9( (HolderOf(actor)) ,"source", 166));ParaContent();  print (PrintText) SC_201;  new_line; .L_Say351; .L_SayX346;
            ! phrase 4
            ! [4: otherwise if the actor is visible]
             } else if ((((Adj_3_t1_v9(actor))))) { 
            ! phrase 5
            ! [5: say ~[The actor] can't take that position.~]
            say__p=1;ParaContent();  print (The) actor; ParaContent();  print (PrintText) SC_531;  new_line; .L_Say352; .L_SayX347;
            ! phrase 6
            ! [6: end if]
            }

         ! phrase 7
         ! [7: stop the action]
          rtrue; 
         ! phrase 8
         ! [8: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1056, 1056, true);
   rfalse;
];
! No specific request
! From "Postures" by Emily Short
! Check an actor taking position ( this is the can't use already used posture rule ):
[ R_1057 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1057, 1057);
      ! phrase 1
      ! [1: if the posture understood is the posture of the actor begin]
       if (((parsed_number == GProperty(9, actor,p73_posture))))  {
         ! phrase 2
         ! [2: if the actor is the player begin]
          if (((actor == player)))  {
            ! phrase 3
            ! [3: say ~You are already [the posture understood].~]
            say__p=1;ParaContent();  print (PrintText) SC_532; ParaContent();  print (T74) parsed_number; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say353; .L_SayX348;
            ! phrase 4
            ! [4: otherwise]
            } else {

            ! phrase 5
            ! [5: if the actor is visible , say ~[The actor] is already [the posture understood].~]
             if ((((Adj_3_t1_v9(actor))))) { say__p=1;ParaContent();  print (The) actor; ParaContent();  print (PrintText) SC_533; ParaContent();  print (T74) parsed_number; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say354; .L_SayX349;  }
            ! phrase 6
            ! [6: end if]
            }

         ! phrase 7
         ! [7: stop the action]
          rtrue; 
         ! phrase 8
         ! [8: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1057, 1057, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Taking position (B511_carry_out_taking_positi)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor taking position ( this is the standard taking position rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Postures" by Emily Short
! Carry out an actor taking position ( this is the standard taking position rule ):
[ R_1058 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1058, 1058);
      ! phrase 1
      ! [1: now the posture of the actor is the posture understood]
       WriteGProperty(9, actor,p73_posture,parsed_number); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1058, 1058, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Taking position (B512_report_taking_position)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report someone taking position ( this is the stranger position report rule rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/2 ! Report taking position ( this is the standard position report rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Postures" by Emily Short
! Report someone taking position ( this is the stranger position report rule rule ):
[ R_1059 ;
   if ( (actor~=player) && (act_requester==nothing) && ((actor ofclass K8_person))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1059, 1059);
      ! phrase 1
      ! [1: say ~[The actor] is now [the posture of the actor][if the holder of the actor is not the location of the actor] [in-on the holder of the actor][end if].~]
      say__p=1;ParaContent();  print (The) actor; ParaContent();  print (PrintText) SC_534; ParaContent(); @push self;  print (T74) GProperty(9, self=actor,p73_posture); @pull self; 
	if (~~((((~~(( (HolderOf(actor))  ==  LocationOf(actor) ))))))) jump L_Say355;
		ParaContent();  print (PrintText) SC_88; ParaContent(); (Resolver_9( (HolderOf(actor)) ,"source", 183));
	.L_Say355; .L_SayX350;
		ParaContent();  print (PrintText) SC_201;  new_line; .L_Say356; .L_SayX351;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1059, 1059, true);
   rfalse;
];
! No specific request
! From "Postures" by Emily Short
! Report taking position ( this is the standard position report rule ):
[ R_1060 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1060, 1060);
      ! phrase 1
      ! [1: say ~You are now [the posture of the player][if the holder of the player is not the location] [in-on the holder of the player][end if].~]
      say__p=1;ParaContent();  print (PrintText) SC_370; ParaContent(); @push self;  print (T74) GProperty(9, self=player,p73_posture); @pull self; 
	if (~~((((~~(( (HolderOf(player))  == real_location))))))) jump L_Say357;
		ParaContent();  print (PrintText) SC_88; ParaContent(); (Resolver_9( (HolderOf(player)) ,"source", 186));
	.L_Say357; .L_SayX352;
		ParaContent();  print (PrintText) SC_201;  new_line; .L_Say358; .L_SayX353;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1060, 1060, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: after not (B513_after_not)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! after not unlocking car with something:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 2/2 ! after not opening car:
! ----------------------------------------------------------------------------------------------------
! No specific request
! after not unlocking car with something:
[ R_1148 ;
   if ((action ==##Unlock) &&  (actor==player) && ((noun == I233_car) && (true)) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1148, 1148);
      ! phrase 1
      ! [1: say ~Hmm... I think the car keys are in my suitcase.~]
      say__p=1;ParaContent();  print (PrintText) SC_535;  new_line; .L_Say359; .L_SayX354;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1148, 1148, true);
   rfalse;
];
! No specific request
! after not opening car:
[ R_1147 ;
   if ((action ==##Open) &&  (actor==player) && ((noun == I233_car) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1147, 1147);
      ! phrase 1
      ! [1: say ~Hmm... I think the car keys are in my suitcase.~]
      say__p=1;ParaContent();  print (PrintText) SC_535;  new_line; .L_Say360; .L_SayX355;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1147, 1147, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out asking for hints (B515_carry_out_asking_for_hi)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! carry out asking for hints:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Hpmenu for chapter 1" by Orion Zymaris
! carry out asking for hints:
[ R_1092 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1092, 1092);
      ! phrase 1
      ! [1: say ~Type in a word to look for related hints. You can name an item, to find all hints relating to it, a person, or a room. Type 'all' to find a list of all hints. Warning: hints do not include easter eggs. Find those on your own.~]
      say__p=1;ParaContent();  print (PrintText) SC_536;  new_line; .L_Say361; .L_SayX356;
      ! phrase 2
      ! [2: now the command prompt is ~Search:  ~]
       (Global_Vars-->1) = SC_400; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1092, 1092, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check carjacking (B522_check_carjacking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! check carjacking a vehicle:
! ----------------------------------------------------------------------------------------------------
! No specific request
! check carjacking a vehicle:
[ R_1171 ;
   if ( (actor==player) && ((noun ofclass K14_vehicle))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1171, 1171);
      ! phrase 1
      ! [1: if a random chance of 1 in 2 succeeds begin]
       if (( (GenerateRandomNumber(1, 2) <= 1) ))  {
         ! phrase 2
         ! [2: say ~As you break into the car, the alarm goes off. Now the police will be after you.~]
         say__p=1;ParaContent();  print (PrintText) SC_537;  new_line; .L_Say362; .L_SayX357;
         ! phrase 3
         ! [3: now in_trouble is ~in trouble~]
          (Global_Vars-->69) = SC_188; 
         ! phrase 4
         ! [4: now the noun is open]
          (Adj_65_t2_v9(noun)); 
         ! phrase 5
         ! [5: now the description of the noun is ~a smashed and battered car.~]
          WriteGProperty(OBJECT_TY, noun,description,SC_191); 
         ! phrase 6
         ! [6: otherwise if the description of the noun is not ~a smashed and battered car.~]
          } else if (((~~((GProperty(OBJECT_TY, noun,description) == SC_191))))) { 
         ! phrase 7
         ! [7: say ~You smash open the windows with a satisfying, and very loud, noise of breaking glass.~]
         say__p=1;ParaContent();  print (PrintText) SC_538;  new_line; .L_Say363; .L_SayX358;
         ! phrase 8
         ! [8: now the description is ~a smashed and battered car.~]
          WriteGProperty(OBJECT_TY, self,description,SC_191); 
         ! phrase 9
         ! [9: otherwise if the description of the noun is ~a smashed and battered car.~]
          } else if (((GProperty(OBJECT_TY, noun,description) == SC_191))) { 
         ! phrase 10
         ! [10: say ~That one's already broken.~]
         say__p=1;ParaContent();  print (PrintText) SC_539;  new_line; .L_Say364; .L_SayX359;
         ! phrase 11
         ! [11: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1171, 1171, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out using (B526_carry_out_using)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! carry out using phone for the first time:
! ----------------------------------------------------------------------------------------------------
! No specific request
! carry out using phone for the first time:
[ R_1183 ;
   if ((PAPR_6() && (((TimesActionHasHappened-->6) == 1) && (ActionCurrentlyHappeningFlag->6)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1183, 1183);
      ! phrase 1
      ! [1: say ~As you go to pick up the phone, it rings. You pick it up.~]
      say__p=1;ParaContent();  print (PrintText) SC_271;  new_line; .L_Say365; .L_SayX360;
      ! phrase 2
      ! [2: try dialling 893 on office phone]
       TryAction(0, player, ##A113_dialling_it_on, 893, I258_office_phone);; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1183, 1183, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report using (B527_report_using)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! report using toilet1:
!   === which is equally specific with ===
! Rule 2/5 ! report using sink1:
!   === which is equally specific with ===
! Rule 3/5 ! report using toilet2:
!   === which is equally specific with ===
! Rule 4/5 ! report using sink2:
!   >>> I - Number of aspects constrained >>>
! Rule 5/5 ! report using:
! ----------------------------------------------------------------------------------------------------
! No specific request
! report using toilet1:
[ R_1100 ;
   if ( (actor==player) && ((noun == I142_toilet1) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1100, 1100);
      ! phrase 1
      ! [1: say ~That isn't vital right now.~ instead]
      say__p=1;ParaContent();  print (PrintText) SC_540;  new_line; rtrue; .L_Say366; .L_SayX361; rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1100, 1100, true);
   rfalse;
];
! No specific request
! report using sink1:
[ R_1101 ;
   if ( (actor==player) && ((noun == I143_sink1) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1101, 1101);
      ! phrase 1
      ! [1: say ~You turn on the tap, rub some soap into your hands, and scrub them thoroughly.~ instead]
      say__p=1;ParaContent();  print (PrintText) SC_541;  new_line; rtrue; .L_Say367; .L_SayX362; rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1101, 1101, true);
   rfalse;
];
! No specific request
! report using toilet2:
[ R_1329 ;
   if ( (actor==player) && ((noun == I352_toilet2) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1329, 1329);
      ! phrase 1
      ! [1: say ~That isn't vital right now.~ instead]
      say__p=1;ParaContent();  print (PrintText) SC_540;  new_line; rtrue; .L_Say368; .L_SayX363; rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1329, 1329, true);
   rfalse;
];
! No specific request
! report using sink2:
[ R_1330 ;
   if ( (actor==player) && ((noun == I353_sink2) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1330, 1330);
      ! phrase 1
      ! [1: say ~You turn on the tap, rub some soap into your hands, and scrub them thoroughly.~ instead]
      say__p=1;ParaContent();  print (PrintText) SC_541;  new_line; rtrue; .L_Say369; .L_SayX364; rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1330, 1330, true);
   rfalse;
];
! No specific request
! report using:
[ R_1181 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1181, 1181);
      ! phrase 1
      ! [1: say ~What exactly do you want to use it for?~]
      say__p=1;ParaContent();  print (PrintText) SC_542;  new_line; .L_Say370; .L_SayX365;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1181, 1181, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out responding to customer (B531_carry_out_responding_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! carry out responding to customer when lexicon is table 5:
!   === which is equally specific with ===
! Rule 2/2 ! carry out responding to customer when lexicon is table 9:
! ----------------------------------------------------------------------------------------------------
! No specific request
! carry out responding to customer when lexicon is table 5:
[ R_1197 ;
   if (actor == player) {
   if (((((((Global_Vars-->72) == T17_second_half_customer_res)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1197, 1197);
      ! phrase 1
      ! [1: if the player's command includes ~HAL~ begin]
       if (( (matched_text=SnippetIncludes(Consult_Grammar_321,players_command)) ))  {
         ! phrase 2
         ! [2: if the player's command includes ~6502~ begin]
          if (( (matched_text=SnippetIncludes(Consult_Grammar_322,players_command)) ))  {
            ! phrase 3
            ! [3: try asking the customer about ~ask them for the hal 6502~]
             TryAction(32, player, ##Ask, I259_customer, SC_249);; 
            ! phrase 4
            ! [4: end if]
            }

         ! phrase 5
         ! [5: otherwise if the player's command includes ~Bk~]
          } else if (( (matched_text=SnippetIncludes(Consult_Grammar_323,players_command)) )) { 
         ! phrase 6
         ! [6: if the player's command includes ~44~ begin]
          if (( (matched_text=SnippetIncludes(Consult_Grammar_324,players_command)) ))  {
            ! phrase 7
            ! [7: try asking the customer about ~ask them for the hal 6502~]
             TryAction(32, player, ##Ask, I259_customer, SC_249);; 
            ! phrase 8
            ! [8: end if]
            }

         ! phrase 9
         ! [9: otherwise if the player's command includes ~Qz~]
          } else if (( (matched_text=SnippetIncludes(Consult_Grammar_325,players_command)) )) { 
         ! phrase 10
         ! [10: if the player's command includes ~77~ begin]
          if (( (matched_text=SnippetIncludes(Consult_Grammar_326,players_command)) ))  {
            ! phrase 11
            ! [11: try asking the customer about ~ask them for the hal 6502~]
             TryAction(32, player, ##Ask, I259_customer, SC_249);; 
            ! phrase 12
            ! [12: end if]
            }

         ! phrase 13
         ! [13: otherwise if the player's command includes ~T1000~]
          } else if (( (matched_text=SnippetIncludes(Consult_Grammar_327,players_command)) )) { 
         ! phrase 14
         ! [14: try asking the customer about ~ask them for the hal 6502~]
          TryAction(32, player, ##Ask, I259_customer, SC_249);; 
         ! phrase 15
         ! [15: otherwise]
         } else {

         ! phrase 16
         ! [16: continue the action]
          rfalse; 
         ! phrase 17
         ! [17: end if]
         }

   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1197, 1197, true);
   rfalse;
];
! No specific request
! carry out responding to customer when lexicon is table 9:
[ R_1231 ;
   if (actor == player) {
   if (((((((Global_Vars-->72) == T21_drill_order_part_of_mrma)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1231, 1231);
      ! phrase 1
      ! [1: if first digit is 3 begin]
       if ((((Global_Vars-->28) == 3)))  {
         ! phrase 2
         ! [2: if the player's command includes ~HAL 6502~ begin]
          if (( (matched_text=SnippetIncludes(Consult_Grammar_328,players_command)) ))  {
            ! phrase 3
            ! [3: try responding to customer ~Xc912~]
             TryAction(16, player, ##A126_responding_to_customer, SC_543, 0);; 
            ! phrase 4
            ! [4: end if]
            }

         ! phrase 5
         ! [5: otherwise if first digit is 4]
          } else if ((((Global_Vars-->28) == 4))) { 
         ! phrase 6
         ! [6: if the player's command includes ~HAL 6502~ begin]
          if (( (matched_text=SnippetIncludes(Consult_Grammar_329,players_command)) ))  {
            ! phrase 7
            ! [7: try responding to customer ~Xc912~]
             TryAction(16, player, ##A126_responding_to_customer, SC_543, 0);; 
            ! phrase 8
            ! [8: end if]
            }

         ! phrase 9
         ! [9: otherwise if first digit is 1]
          } else if ((((Global_Vars-->28) == 1))) { 
         ! phrase 10
         ! [10: if the player's command includes ~T1000~ begin]
          if (( (matched_text=SnippetIncludes(Consult_Grammar_330,players_command)) ))  {
            ! phrase 11
            ! [11: try responding to customer ~Xc912~]
             TryAction(16, player, ##A126_responding_to_customer, SC_543, 0);; 
            ! phrase 12
            ! [12: end if]
            }

         ! phrase 13
         ! [13: otherwise if first digit is 2]
          } else if ((((Global_Vars-->28) == 2))) { 
         ! phrase 14
         ! [14: if the player's command includes ~T1000~ begin]
          if (( (matched_text=SnippetIncludes(Consult_Grammar_331,players_command)) ))  {
            ! phrase 15
            ! [15: try responding to customer ~Xc912~]
             TryAction(16, player, ##A126_responding_to_customer, SC_543, 0);; 
            ! phrase 16
            ! [16: end if]
            }

         ! phrase 17
         ! [17: otherwise if first digit is 5]
          } else if ((((Global_Vars-->28) == 5))) { 
         ! phrase 18
         ! [18: if the player's command includes ~Bk 44~ begin]
          if (( (matched_text=SnippetIncludes(Consult_Grammar_332,players_command)) ))  {
            ! phrase 19
            ! [19: try responding to customer ~Xc912~]
             TryAction(16, player, ##A126_responding_to_customer, SC_543, 0);; 
            ! phrase 20
            ! [20: end if]
            }

         ! phrase 21
         ! [21: otherwise if first digit is 6]
          } else if ((((Global_Vars-->28) == 6))) { 
         ! phrase 22
         ! [22: if the player's command includes ~Bk 44~ begin]
          if (( (matched_text=SnippetIncludes(Consult_Grammar_333,players_command)) ))  {
            ! phrase 23
            ! [23: try responding to customer ~Xc912~]
             TryAction(16, player, ##A126_responding_to_customer, SC_543, 0);; 
            ! phrase 24
            ! [24: end if]
            }

         ! phrase 25
         ! [25: otherwise if the player's command includes ~Qz 77~]
          } else if (( (matched_text=SnippetIncludes(Consult_Grammar_334,players_command)) )) { 
         ! phrase 26
         ! [26: try responding to customer ~Xc912~]
          TryAction(16, player, ##A126_responding_to_customer, SC_543, 0);; 
         ! phrase 27
         ! [27: end if]
         }

   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1231, 1231, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report responding to customer (B532_report_responding_to_cu)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! report responding to customer when lexicon is table 9:
! ----------------------------------------------------------------------------------------------------
! No specific request
! report responding to customer when lexicon is table 9:
[ R_1232 ;
   if (actor == player) {
   if (((((((Global_Vars-->72) == T21_drill_order_part_of_mrma)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1232, 1232);
      ! phrase 1
      ! [1: unless responding to customer ~xc912~ begin]
       if (~~((action ==##A126_responding_to_customer) &&  (actor==player) && (Consult_Grammar_335(consult_from, consult_words)~=GPR_FAIL)))  {
         ! phrase 2
         ! [2: say ~'That doesn't sound right... I think that range is suited for something else.'[line break]~]
         say__p=1;ParaContent();  print (PrintText) SC_544; ParaContent();  new_line;  .L_Say371; .L_SayX366;
         ! phrase 3
         ! [3: end unless]
         }

   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1232, 1232, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out saying (B534_carry_out_saying)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! carry out saying:
! ----------------------------------------------------------------------------------------------------
! No specific request
! carry out saying:
[ R_1208 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1208, 1208);
      ! phrase 1
      ! [1: try asking the customer about it]
       TryAction(0, player, ##Ask, I259_customer, 0);; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1208, 1208, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out flipping (B537_carry_out_flipping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! carry out flipping for the first time:
!   >>> III.5.1 - Action/When/Duration >>>
! Rule 2/2 ! carry out flipping for at least the second time:
! ----------------------------------------------------------------------------------------------------
! No specific request
! carry out flipping for the first time:
[ R_1216 ;
   if ((PAPR_7() && (((TimesActionHasHappened-->7) == 1) && (ActionCurrentlyHappeningFlag->7)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1216, 1216);
      ! phrase 1
      ! [1: say ~you flip the rollerdex to a random page.~]
      say__p=1;ParaContent();  print (PrintText) SC_545;  new_line; .L_Say372; .L_SayX367;
      ! phrase 2
      ! [2: now the description of rollerdex is ~[rollentrypermanent]~]
       WriteGProperty(9, I273_rollerdex,description,text_routine_124); 
      ! phrase 3
      ! [3: now rollentrypermanent is ~[rollerdexentry]~ instead]
       BlkValueCast((Global_Vars-->73), INDEXED_TEXT_TY, TEXT_TY, (text_routine_125));  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1216, 1216, true);
   rfalse;
];
! No specific request
! carry out flipping for at least the second time:
[ R_1217 ;
   if ((PAPR_8() && (((TimesActionHasHappened-->8) >= 2) && (ActionCurrentlyHappeningFlag->8)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1217, 1217);
      ! phrase 1
      ! [1: if a random chance of 3 in 4 succeeds begin]
       if (( (GenerateRandomNumber(1, 4) <= 3) ))  {
         ! phrase 2
         ! [2: say ~you flip the rollerdex to a random page.~]
         say__p=1;ParaContent();  print (PrintText) SC_545;  new_line; .L_Say373; .L_SayX368;
         ! phrase 3
         ! [3: now the description of rollerdex is ~[rollentrypermanent]~]
          WriteGProperty(9, I273_rollerdex,description,text_routine_126); 
         ! phrase 4
         ! [4: now rollentrypermanent is ~[rollerdexentry]~ instead]
          BlkValueCast((Global_Vars-->73), INDEXED_TEXT_TY, TEXT_TY, (text_routine_127));  rtrue;
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: say ~you flip the rollerdex back to today's page.~]
         say__p=1;ParaContent();  print (PrintText) SC_546;  new_line; .L_Say374; .L_SayX369;
         ! phrase 7
         ! [7: now the description of rollerdex is ~Tuesday[paragraph break]Work for today:[paragraph break]Answer two customer phone calls:[line break]First call[if the venture of customercall is success]: [bold type]achieved[roman type][otherwise if the venture of customercall is failure]: [bold type]failed[roman type][otherwise].[end if][line break]Second call[if the venture of mrmason call is success]:[bold type]	achieved[roman type][otherwise if the venture of mrmason call is failure]:[bold type]	failed[roman type][otherwise if the venture of mrmason call is pending]:[bold type]	pending[roman type][otherwise].[end if]~]
          WriteGProperty(9, I273_rollerdex,description,text_routine_128); 
         ! phrase 8
         ! [8: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1217, 1217, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out writing intro (B542_carry_out_writing_intro)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! carry out writing intro:
! ----------------------------------------------------------------------------------------------------
! No specific request
! carry out writing intro:
[ R_1238 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1238, 1238);
      ! phrase 1
      ! [1: if the noun is a writeable begin]
       if (((noun ofclass K50_writeable)))  {
         ! phrase 2
         ! [2: say ~[no line break]~]
         say__p=1;ParaContent(); (PHR_335_r7 ()); .L_Say375; .L_SayX370;
         ! phrase 3
         ! [3: now the command prompt is ~What do you want to write: ~]
          (Global_Vars-->1) = SC_255; 
         ! phrase 4
         ! [4: otherwise]
         } else {

         ! phrase 5
         ! [5: say ~You can't write on that.~]
         say__p=1;ParaContent();  print (PrintText) SC_547;  new_line; .L_Say376; .L_SayX371;
         ! phrase 6
         ! [6: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1238, 1238, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out writing on (B545_carry_out_writing_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! carry out writing on when the command prompt is ~What do you want to write: ~:
! ----------------------------------------------------------------------------------------------------
! No specific request
! carry out writing on when the command prompt is ~What do you want to write: ~:
[ R_1239 ;
   if (actor == player) {
   if (((((((Global_Vars-->1) == SC_255)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1239, 1239);
      ! phrase 1
      ! [1: say ~You write '[the player's command]'.[line break]~]
      say__p=1;ParaContent();  print (PrintText) SC_256; ParaContent();  print (PrintSnippet) players_command; ParaContent();  print (PrintText) SC_257; ParaContent();  new_line;  .L_Say377; .L_SayX372;
      ! phrase 2
      ! [2: now notepad desc is the player's command instead]
       BlkValueCast((Global_Vars-->74), INDEXED_TEXT_TY, SNIPPET_TY, players_command);  rtrue;
   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1239, 1239, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out clearing the screen (B548_carry_out_clearing_the_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! carry out clearing the screen:
! ----------------------------------------------------------------------------------------------------
! No specific request
! carry out clearing the screen:
[ R_1245 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1245, 1245);
      ! phrase 1
      ! [1: clear the screen]
       VM_ClearScreen(0); 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1245, 1245, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report playing (B555_report_playing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! report playing piano:
!   >>> I - Number of aspects constrained >>>
! Rule 2/2 ! report playing:
! ----------------------------------------------------------------------------------------------------
! No specific request
! report playing piano:
[ R_1287 ;
   if ( (actor==player) && ((noun == I319_piano) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1287, 1287);
      ! phrase 1
      ! [1: say ~You sit down, and bash out something reminiscent of an old Beatles song.~ instead]
      say__p=1;ParaContent();  print (PrintText) SC_548;  new_line; rtrue; .L_Say378; .L_SayX373; rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1287, 1287, true);
   rfalse;
];
! No specific request
! report playing:
[ R_1286 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1286, 1286);
      ! phrase 1
      ! [1: say ~You attempt to play [noun], but to no avail.~]
      say__p=1;ParaContent();  print (PrintText) SC_549; ParaContent();  print (PrintShortName) noun; ParaContent();  print (PrintText) SC_550;  new_line; .L_Say379; .L_SayX374;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1286, 1286, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out thanking (B557_carry_out_thanking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! carry out thanking:
! ----------------------------------------------------------------------------------------------------
! No specific request
! carry out thanking:
[ R_1312 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1312, 1312);
      ! phrase 1
      ! [1: say ~[noun] accepts your thanks.~]
      say__p=1;ParaContent();  print (PrintShortName) noun; ParaContent();  print (PrintText) SC_551;  new_line; .L_Say380; .L_SayX375;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1312, 1312, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Living-room cut scene begins (B562_when_living_room_cut_sc)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! when living-room cut scene begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! when living-room cut scene begins:
[ R_1315 ;
      ! phrase 1
      ! [1: say ~'Funny stuff on the news. Owls... shooting stars...[wait 2000 ms]And there were a lot of funny-looking people in town today...'[wait 3000 ms][paragraph break]'So?' Snapped Petunia.[wait 3000 ms][paragraph break]'Well, I just thought... maybe... it was something to do with... you know... [italic type]her lot.'[roman type][wait 1000 ms][line break]You gulp down some Tea.[wait 2000 ms][line break]'Their son - he'd be about Dudley's age now, wouldn't he?'[wait 3000 ms][paragraph break]'I Suppose so.'[wait 2000 ms][line break]'What's his name again? Howard, isn't it?'[wait 3000 ms][paragraph break]'Harry. Nasty, common name, if you ask me.'[wait 3000 ms][paragraph break]'Oh, yes. Yes, I quite agree...'[wait 2000 ms][line break]Without another word, you and Petunia both go upstairs to bed.~]
      say__p=1;ParaContent();  print (PrintText) SC_552;  new_line;ParaContent(); (PHR_892_r21 (2000));ParaContent();  print (PrintText) SC_553;  new_line;ParaContent(); (PHR_892_r21 (3000));ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_554;  new_line;ParaContent(); (PHR_892_r21 (3000));ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_555; ParaContent();  style underline; ParaContent();  print (PrintText) SC_556; ParaContent();  style roman; ParaContent(); (PHR_892_r21 (1000));ParaContent();  new_line; ParaContent();  print (PrintText) SC_557;  new_line;ParaContent(); (PHR_892_r21 (2000));ParaContent();  new_line; ParaContent();  print (PrintText) SC_558;  new_line;ParaContent(); (PHR_892_r21 (3000));ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_559;  new_line;ParaContent(); (PHR_892_r21 (2000));ParaContent();  new_line; ParaContent();  print (PrintText) SC_560;  new_line;ParaContent(); (PHR_892_r21 (3000));ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_561;  new_line;ParaContent(); (PHR_892_r21 (3000));ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_562;  new_line;ParaContent(); (PHR_892_r21 (2000));ParaContent();  new_line; ParaContent();  print (PrintText) SC_563;  new_line; .L_Say381; .L_SayX376;
      ! phrase 2
      ! [2: say ~[line break]~]
      say__p=1;ParaContent();  new_line;  .L_Say382; .L_SayX377;
      ! phrase 3
      ! [3: now dursley is in dursley's bedroom]
       MoveObject(I97_dursley,I118_dursley_s_bedroom); 
      ! phrase 4
      ! [4: now petunia is in dursley's bedroom]
       MoveObject(I202_petunia,I118_dursley_s_bedroom); 
      ! phrase 5
      ! [5: now the description of bedroomwindow is ~[one of]As you look out the window, you see the cat from this morning, as well as a tall, thin man, who silently walks from the corner of the street. He holds up a small object, and suddenly, all the lamps in the street go out.[or]It is pitch black.[stopping]~]
       WriteGProperty(9, I119_bedroomwindow,description,text_routine_129); 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out dursley's spellcasting (B565_carry_out_dursley_s_spe)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! carry out dursley's spellcasting when magic wand is not carried:
!   >>> II - When/while requirement >>>
! Rule 2/2 ! carry out dursley's spellcasting when magic wand is carried:
! ----------------------------------------------------------------------------------------------------
! No specific request
! carry out dursley's spellcasting when magic wand is not carried:
[ R_1328 ;
   if (actor == player) {
   if ((((((~~(((Adj_1_t1_v9(I342_magic_wand)))))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1328, 1328);
      ! phrase 1
      ! [1: say ~What, is that a shakespearian play or something?~]
      say__p=1;ParaContent();  print (PrintText) SC_564;  new_line; .L_Say383; .L_SayX378;
   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1328, 1328, true);
   rfalse;
];
! No specific request
! carry out dursley's spellcasting when magic wand is carried:
[ R_1325 ;
   if (actor == player) {
   if (((((((Adj_1_t1_v9(I342_magic_wand)))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1325, 1325);
      ! phrase 1
      ! [1: say ~you wave the wand and shout [the player's command]!, and [spark colours] flies from the tip, causing [result of spell]~]
      say__p=1;ParaContent();  print (PrintText) SC_565; ParaContent();  print (PrintSnippet) players_command; ParaContent();  print (PrintText) SC_566; ParaContent(); (PHR_1326_r22 ());ParaContent();  print (PrintText) SC_567; ParaContent(); (PHR_1327_r23 ()); .L_Say384; .L_SayX379;
   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1325, 1325, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out jumping out of (B568_carry_out_jumping_out_o)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! carry out jumping out of bedroomwindow:
!   === which is equally specific with ===
! Rule 2/2 ! carry out jumping out of window:
! ----------------------------------------------------------------------------------------------------
! No specific request
! carry out jumping out of bedroomwindow:
[ R_1334 ;
   if ( (actor==player) && ((noun == I119_bedroomwindow) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1334, 1334);
      ! phrase 1
      ! [1: now the player is in privet drive]
       MoveObject(player,I355_privet_drive); 
      ! phrase 2
      ! [2: say ~you jump out of the window.~]
      say__p=1;ParaContent();  print (PrintText) SC_568;  new_line; .L_Say385; .L_SayX380;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1334, 1334, true);
   rfalse;
];
! No specific request
! carry out jumping out of window:
[ R_1335 ;
   if ( (actor==player) && ((noun == I229_window) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1335, 1335);
      ! phrase 1
      ! [1: now the player is in the garden]
       MoveObject(player,I200_garden); 
      ! phrase 2
      ! [2: say ~you jump out of the window.~]
      say__p=1;ParaContent();  print (PrintText) SC_568;  new_line; .L_Say386; .L_SayX381;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1335, 1335, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out timing (B571_carry_out_timing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! carry out timing:
! ----------------------------------------------------------------------------------------------------
! No specific request
! carry out timing:
[ R_1337 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1337, 1337);
      ! phrase 1
      ! [1: say ~the time is [time of day].~]
      say__p=1;ParaContent();  print (PrintText) SC_569; ParaContent();  print (PrintTimeOfDay) the_time; ParaContent();  print (PrintText) SC_201;  new_line; .L_Say387; .L_SayX382;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1337, 1337, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------
! Definitions of displaced and unbooked rules

! No specific request
! From the Standard Rules
! Check an actor going when the actor is on a supporter ( called the chaise ) ( this is the stand up before going rule ):
[ R_138 
    t_0 ! Local variable e.g. 'chaise' = supporter
    ;
   if ((act_requester==nothing) && (self=actor,true) && (((SupporterOf(actor) ofclass K6_supporter) && (t_0=(SupporterOf(actor)), true)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_138, 138);
      ! phrase 1
      ! [1: issue library message going action number 27 for the chaise]
       GL__M(##Go,27,t_0); 
      ! phrase 2
      ! [2: silently try the actor exiting]
       @push keep_silent; keep_silent=1; TryAction(0, actor, ##Exit, 0, 0);; @pull keep_silent; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_138, 138, true);
   rfalse;
];
! No specific request
! From "Menus" by Emily Short
! This is the quit rule:
[ R_862 ;
      ! phrase 1
      ! [1: decrease the menu depth by 1]
       (Global_Vars-->18) = (Global_Vars-->18) - 1; 
      ! phrase 2
      ! [2: rule succeeds]
       RulebookSucceeds(); rtrue; 
   rfalse;
];
! No specific request
! From "Menus" by Emily Short
! This is the move down rule:
[ R_863 ;
      ! phrase 1
      ! [1: if current menu selection is less than the number of filled rows in the current menu , increase current menu selection by 1]
       if ((((Global_Vars-->22) <  TableFilledRows((Global_Vars-->21)) ))) {  (Global_Vars-->22) = (Global_Vars-->22) + 1;   }
      ! phrase 2
      ! [2: reprint the current menu]
      (PHR_867_r24 ((Global_Vars-->21)));
      ! phrase 3
      ! [3: make no decision]
       rfalse; 
   rfalse;
];
! No specific request
! From "Menus" by Emily Short
! This is the move up rule:
[ R_864 ;
      ! phrase 1
      ! [1: if current menu selection is greater than 1 , decrease current menu selection by 1]
       if ((((Global_Vars-->22) > 1))) {  (Global_Vars-->22) = (Global_Vars-->22) - 1;   }
      ! phrase 2
      ! [2: reprint the current menu]
      (PHR_867_r24 ((Global_Vars-->21)));
      ! phrase 3
      ! [3: make no decision]
       rfalse; 
   rfalse;
];
! No specific request
! From "Menus" by Emily Short
! This is the select rule:
[ R_865 
    t_0 ! Local variable e.g. '?-1,-1?' = text
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: choose row current menu selection in the current menu]
       ct_0 = (Global_Vars-->21); ct_1 = (Global_Vars-->22); 
      ! phrase 2
      ! [2: if there is a toggle entry begin]
       if (( (ExistsTableLookUpEntry(ct_0,110,ct_1)) ))  {
         ! phrase 3
         ! [3: follow the toggle entry]
          FollowRulebook(TableLookUpEntry(ct_0,110,ct_1)); 
         ! phrase 4
         ! [4: reprint the current menu]
         (PHR_867_r24 ((Global_Vars-->21)));
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: if there is a subtable entry begin]
          if (( (ExistsTableLookUpEntry(ct_0,108,ct_1)) ))  {
            ! phrase 7
            ! [7: now the current menu title is title entry]
             (Global_Vars-->20) = TableLookUpEntry(ct_0,107,ct_1); 
            ! phrase 8
            ! [8: now the current menu selection is 1]
             (Global_Vars-->22) = 1; 
            ! phrase 9
            ! [9: now the current menu is subtable entry]
             (Global_Vars-->21) = TableLookUpEntry(ct_0,108,ct_1); 
            ! phrase 10
            ! [10: show menu contents]
            (PHR_868_r19 ());
            ! phrase 11
            ! [11: otherwise]
            } else {

            ! phrase 12
            ! [12: let the temporary title be the current menu title]
             t_0 = (Global_Vars-->20); 
            ! phrase 13
            ! [13: now the current menu title is title entry]
             (Global_Vars-->20) = TableLookUpEntry(ct_0,107,ct_1); 
            ! phrase 14
            ! [14: now the endnode flag is 1]
             (Global_Vars-->19) = 1; 
            ! phrase 15
            ! [15: redraw status line]
             DrawStatusLine(); 
            ! phrase 16
            ! [16: now the endnode flag is 0]
             (Global_Vars-->19) = 0; 
            ! phrase 17
            ! [17: clear only the main screen]
             VM_ClearScreen(2); 
            ! phrase 18
            ! [18: say ~[variable letter spacing][description entry][paragraph	 break]~]
            say__p=1;ParaContent();  font on; ParaContent();  print (PrintText) TableLookUpEntry(ct_0,109,ct_1); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say388; .L_SayX383;
            ! phrase 19
            ! [19: pause the game]
            (PHR_1072_r25 ());
            ! phrase 20
            ! [20: now the current menu title is temporary title]
             (Global_Vars-->20) = t_0; 
            ! phrase 21
            ! [21: reprint the current menu]
            (PHR_867_r24 ((Global_Vars-->21)));
            ! phrase 22
            ! [22: end if]
            }

         ! phrase 23
         ! [23: end if]
         }

   rfalse;
];
! No specific request
! From "Menus" by Emily Short
! This is the hint toggle rule:
[ R_873 
    t_0 ! Local variable e.g. 'temporary title' = text
    t_1 ! Local variable e.g. '__index' = number
    t_2 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: choose row current menu selection in the current menu]
       ct_0 = (Global_Vars-->21); ct_1 = (Global_Vars-->22); 
      ! phrase 2
      ! [2: let the temporary title be the current menu title]
       t_0 = (Global_Vars-->20); 
      ! phrase 3
      ! [3: now the current menu title is title entry]
       (Global_Vars-->20) = TableLookUpEntry(ct_0,107,ct_1); 
      ! phrase 4
      ! [4: now the endnode flag is 1]
       (Global_Vars-->19) = 1; 
      ! phrase 5
      ! [5: redraw status line]
       DrawStatusLine(); 
      ! phrase 6
      ! [6: now the endnode flag is 0]
       (Global_Vars-->19) = 0; 
      ! phrase 7
      ! [7: say known hints from the subtable entry]
      say__p=1;ParaContent(); (PHR_871_r26 (TableLookUpEntry(ct_0,108,ct_1))); .L_Say389; .L_SayX384;
      ! phrase 8
      ! [8: let __index be 0]
       t_1 = 0; 
      ! phrase 9
      ! [9: while __index < 1 begin]
       while (((t_1 < 1)))  {
         ! phrase 10
         ! [10: let __x be the chosen letter]
          t_2 =  GetKey() ; 
         ! phrase 11
         ! [11: if __x is 13 or __x is 31 or __x is 32 , let __index be 1]
          if ((((t_2 == 13))) || ((((t_2 == 31))) || (((t_2 == 32))))) {  t_1 = 1;   }
         ! phrase 12
         ! [12: if __x is 72 or __x is 104 , say hints from the subtable entry]
          if ((((t_2 == 72))) || (((t_2 == 104)))) { say__p=1;ParaContent(); (PHR_872_r27 (TableLookUpEntry(ct_0,108,ct_1))); .L_Say390; .L_SayX385;  }
         ! phrase 13
         ! [13: end while]
         }

      ! phrase 14
      ! [14: now the current menu title is temporary title]
       (Global_Vars-->20) = t_0; 
   rfalse;
];
! No specific request
! From "HPMenu" by Orion Zymaris
! this is the donotdelay rule:
[ R_891 ;
      ! phrase 1
      ! [1: if donotdelay is 0 begin]
       if ((((Global_Vars-->23) == 0)))  {
         ! phrase 2
         ! [2: now donotdelay is 1]
          (Global_Vars-->23) = 1; 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: now donotdelay is 0]
          (Global_Vars-->23) = 0; 
         ! phrase 5
         ! [5: end if]
         }

   rfalse;
];
! Definitions of adjectives

! No specific request
! From the Standard Rules
! Definition:
[ R_0 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_1 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_2 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_3 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_4 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_5 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_6 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_7 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_37 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_38 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_39 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_40 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_41 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_42 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_43 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_44 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_45 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_46 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_47 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_48 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_49 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_50 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_51 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_52 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_53 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_54 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_55 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_56 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_84 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Definition:
[ R_842 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From "Epistemology" by Eric eve
! Definition:
[ R_948 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From "Epistemology" by Eric eve
! Definition:
[ R_949 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! definition:
[ R_1122 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! Definition:
[ R_1149 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
[ Adj_0_t1_v9 ! meaning of "worn"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((((player == WearerOf(t_0)))));
    rfalse;
];

[ Adj_1_t1_v9 ! meaning of "carried"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((((player == CarrierOf(t_0)))));
    rfalse;
];

[ Adj_2_t1_v9 ! meaning of "held"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((((player == HolderOf(t_0)))));
    rfalse;
];

[ Adj_3_t1_v9 ! meaning of "visible"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((((TestVisibility(player,t_0)))));
    rfalse;
];

[ Adj_4_t1_v9 ! meaning of "invisible"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return (~~(((((TestVisibility(player,t_0)))))));
    rfalse;
];

[ Adj_5_t1_v9 ! meaning of "touchable"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((((TestTouchability(player,t_0)))));
    rfalse;
];

[ Adj_6_t1_v9 ! meaning of "untouchable"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return (~~(((((TestTouchability(player,t_0)))))));
    rfalse;
];

[ Adj_7_t1_v9 ! meaning of "concealed"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((((TestConcealment( (HolderOf(t_0)) ,t_0)))));
    rfalse;
];

[ Adj_8_t1_v9 ! meaning of "unconcealed"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return (~~(((((TestConcealment( (HolderOf(t_0)) ,t_0)))))));
    rfalse;
];

[ Adj_9_t1_v9 ! meaning of "on-stage"

    t_0 ! Call parameter 'it' = number
    ;
  if (t_0 ofclass K2_thing) return ((OnStage(t_0, -1)));
    rfalse;
];

[ Adj_10_t1_v9 ! meaning of "off-stage"

    t_0 ! Call parameter 'it' = number
    ;
  if (t_0 ofclass K2_thing) return (~~(((OnStage(t_0, -1)))));
    rfalse;
];

[ Adj_11_t1_v9 ! meaning of "adjacent"

    t_0 ! Call parameter 'it' = room
    ;
  if (t_0 ofclass K1_room) return ((((TestAdjacency(real_location,t_0)))));
    rfalse;
];

[ Adj_12_t1_v10 ! meaning of "even"

    t_0 ! Call parameter 'it' = number
    ;
return (((( (IntegerRemainder(t_0,2))  == 0))));
    rfalse;
];

[ Adj_13_t1_v10 ! meaning of "odd"

    t_0 ! Call parameter 'it' = number
    ;
return (~~((((( (IntegerRemainder(t_0,2))  == 0))))));
    rfalse;
];

[ Adj_14_t1_v10 ! meaning of "positive"

    t_0 ! Call parameter 'it' = number
    ;
return ((((t_0 > 0))));
    rfalse;
];

[ Adj_15_t1_v10 ! meaning of "negative"

    t_0 ! Call parameter 'it' = number
    ;
return ((((t_0 < 0))));
    rfalse;
];

[ Adj_16_t1_v12 ! meaning of "empty"

    t_0 ! Call parameter 'it' = text
    ;
return ((((t_0 == EMPTY_TEXT_VALUE))));
    rfalse;
];

[ Adj_16_t1_v13 ! meaning of "empty"

    t_0 ! Call parameter 'it' = number
    ;
return ((INDEXED_TEXT_TY_Empty(t_0)));
    rfalse;
];

[ Adj_16_t1_v17 ! meaning of "empty"

    t_0 ! Call parameter 'it' = table name
    ;
return (((( TableFilledRows(t_0)  == 0))));
    rfalse;
];

[ Adj_16_t1_v28 ! meaning of "empty"

    t_0 ! Call parameter 'it' = number
    ;
return ((RulebookEmpty(t_0)));
    rfalse;
];

[ Adj_16_t1_v29 ! meaning of "empty"

    t_0 ! Call parameter 'it' = number
    ;
return ((ActivityEmpty(t_0)));
    rfalse;
];

[ Adj_16_t1_v30 ! meaning of "empty"

    t_0 ! Call parameter 'it' = number
    ;
return ((LIST_OF_TY_Empty(t_0)));
    rfalse;
];

[ Adj_16_t1_v26 ! meaning of "empty"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_Empty(t_0, -1)));
    rfalse;
];

[ Adj_17_t1_v12 ! meaning of "non-empty"

    t_0 ! Call parameter 'it' = text
    ;
return (~~(((((t_0 == EMPTY_TEXT_VALUE))))));
    rfalse;
];

[ Adj_17_t1_v13 ! meaning of "non-empty"

    t_0 ! Call parameter 'it' = number
    ;
return (~~(((INDEXED_TEXT_TY_Empty(t_0)))));
    rfalse;
];

[ Adj_17_t1_v17 ! meaning of "non-empty"

    t_0 ! Call parameter 'it' = table name
    ;
return (~~((((( TableFilledRows(t_0)  == 0))))));
    rfalse;
];

[ Adj_17_t1_v28 ! meaning of "non-empty"

    t_0 ! Call parameter 'it' = number
    ;
return (~~(((RulebookEmpty(t_0)))));
    rfalse;
];

[ Adj_17_t1_v29 ! meaning of "non-empty"

    t_0 ! Call parameter 'it' = number
    ;
return (~~(((ActivityEmpty(t_0)))));
    rfalse;
];

[ Adj_17_t1_v30 ! meaning of "non-empty"

    t_0 ! Call parameter 'it' = number
    ;
return (~~(((LIST_OF_TY_Empty(t_0)))));
    rfalse;
];

[ Adj_17_t1_v26 ! meaning of "non-empty"

    t_0 ! Call parameter 'it' = number
    ;
return (~~(((RELATION_TY_Empty(t_0, -1)))));
    rfalse;
];

[ Adj_18_t1_v39 ! meaning of "happening"

    t_0 ! Call parameter 'it' = scene
    ;
return ((scene_status-->(t_0-1)==1));
    rfalse;
];

[ Adj_19_t1_v17 ! meaning of "full"

    t_0 ! Call parameter 'it' = table name
    ;
return (((( TableBlankRows(t_0)  == 0))));
    rfalse;
];

[ Adj_20_t1_v17 ! meaning of "non-full"

    t_0 ! Call parameter 'it' = table name
    ;
return (~~((((( TableBlankRows(t_0)  == 0))))));
    rfalse;
];

[ Adj_21_t1_v29 ! meaning of "going on"

    t_0 ! Call parameter 'it' = number
    ;
return ((TestActivity(t_0)));
    rfalse;
];

[ Adj_22_t1_v15 ! meaning of "active"

    t_0 ! Call parameter 'it' = number
    ;
return ((TestUseOption(t_0)));
    rfalse;
];

[ Adj_23_t1_v15 ! meaning of "inactive"

    t_0 ! Call parameter 'it' = number
    ;
return (~~(((TestUseOption(t_0)))));
    rfalse;
];

[ Adj_24_t1_v26 ! meaning of "equivalence"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_EquivalenceAdjective(t_0, -1)));
    rfalse;
];

[ Adj_25_t1_v26 ! meaning of "symmetric"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_SymmetricAdjective(t_0, -1)));
    rfalse;
];

[ Adj_26_t1_v26 ! meaning of "one-to-one"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_OToOAdjective(t_0, -1)));
    rfalse;
];

[ Adj_27_t1_v26 ! meaning of "one-to-various"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_OToVAdjective(t_0, -1)));
    rfalse;
];

[ Adj_28_t1_v26 ! meaning of "various-to-one"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_VToOAdjective(t_0, -1)));
    rfalse;
];

[ Adj_29_t1_v26 ! meaning of "various-to-various"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_VToVAdjective(t_0, -1)));
    rfalse;
];

[ Adj_30_t1_v9 ! meaning of "locale-supportable"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return (((((~~(((Adj_52_t1_v9(t_0))))))) && ((((~~(((Adj_60_t1_v9(t_0))))))) && (((~~(((Adj_57_t1_v9(t_0))))))))));
    rfalse;
];

[ Adj_31_t1_v9 ! meaning of "vehicular"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return (((((t_0 ofclass K14_vehicle))) || ((((t_0 ofclass K21_rideable_animal))) || (((t_0 ofclass K22_rideable_vehicle))))));
    rfalse;
];

[ Adj_32_t1_v9 ! meaning of "known"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((((((Adj_87_t1_v9(t_0))))) || ((((Adj_85_t1_v9(t_0)))))));
    rfalse;
];

[ Adj_33_t1_v9 ! meaning of "unknown"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((((~~(((Adj_32_t1_v9(t_0))))))));
    rfalse;
];

[ Adj_34_t1_v9 ! meaning of "occupied"

    t_0 ! Call parameter 'it' = broom
    ;
  if (t_0 ofclass K40_broom) return (((Prop_76(,t_0))));
      if (t_0) return (GetEitherOrProperty(t_0, p77_occupied));
    rfalse;
];

[ Adj_35_t1_v9 ! meaning of "offroad"

    t_0 ! Call parameter 'it' = room
    ;
  if (t_0 ofclass K1_room) return ((((~~((t_0 ofclass K43_road))))));
    rfalse;
];

[ Adj_36_t1_v9 ! meaning of "plural-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, pluralname));
    rfalse;
];

[ Adj_37_t1_v9 ! meaning of "singular-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, pluralname) == false);
    rfalse;
];

[ Adj_38_t1_v9 ! meaning of "proper-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, proper));
    rfalse;
];

[ Adj_39_t1_v9 ! meaning of "improper-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, proper) == false);
    rfalse;
];

[ Adj_40_t1_v9 ! meaning of "privately-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, privately_named));
    rfalse;
];

[ Adj_41_t1_v9 ! meaning of "publically-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, privately_named) == false);
    rfalse;
];

[ Adj_42_t1_v9 ! meaning of "lighted"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, light));
    rfalse;
];

[ Adj_43_t1_v9 ! meaning of "dark"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, light) == false);
    rfalse;
];

[ Adj_44_t1_v9 ! meaning of "visited"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, visited));
    rfalse;
];

[ Adj_45_t1_v9 ! meaning of "unvisited"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, visited) == false);
    rfalse;
];

[ Adj_46_t1_v9 ! meaning of "lit"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, light));
    rfalse;
];

[ Adj_47_t1_v9 ! meaning of "unlit"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, light) == false);
    rfalse;
];

[ Adj_48_t1_v9 ! meaning of "edible"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, edible));
    rfalse;
];

[ Adj_49_t1_v9 ! meaning of "inedible"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, edible) == false);
    rfalse;
];

[ Adj_50_t1_v9 ! meaning of "fixed in place"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, static));
    rfalse;
];

[ Adj_51_t1_v9 ! meaning of "portable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, static) == false);
    rfalse;
];

[ Adj_52_t1_v9 ! meaning of "scenery"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, scenery));
    rfalse;
];

[ Adj_53_t1_v9 ! meaning of "wearable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, clothing));
    rfalse;
];

[ Adj_54_t1_v9 ! meaning of "pushable between rooms"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, pushable));
    rfalse;
];

[ Adj_55_t1_v9 ! meaning of "handled"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, moved));
    rfalse;
];

[ Adj_56_t1_v9 ! meaning of "described"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, concealed) == false);
    rfalse;
];

[ Adj_57_t1_v9 ! meaning of "undescribed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, concealed));
    rfalse;
];

[ Adj_58_t1_v9 ! meaning of "marked for listing"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, workflag));
    rfalse;
];

[ Adj_59_t1_v9 ! meaning of "unmarked for listing"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, workflag) == false);
    rfalse;
];

[ Adj_60_t1_v9 ! meaning of "mentioned"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, mentioned));
    rfalse;
];

[ Adj_61_t1_v9 ! meaning of "unmentioned"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, mentioned) == false);
    rfalse;
];

[ Adj_62_t1_v9 ! meaning of "enterable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, enterable));
    rfalse;
];

[ Adj_63_t1_v9 ! meaning of "opaque"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, transparent) == false);
    rfalse;
];

[ Adj_64_t1_v9 ! meaning of "transparent"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, transparent));
    rfalse;
];

[ Adj_65_t1_v9 ! meaning of "open"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, open));
    rfalse;
];

[ Adj_66_t1_v9 ! meaning of "closed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, open) == false);
    rfalse;
];

[ Adj_67_t1_v9 ! meaning of "openable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, openable));
    rfalse;
];

[ Adj_68_t1_v9 ! meaning of "unopenable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, openable) == false);
    rfalse;
];

[ Adj_69_t1_v9 ! meaning of "lockable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, lockable));
    rfalse;
];

[ Adj_70_t1_v9 ! meaning of "locked"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, locked));
    rfalse;
];

[ Adj_71_t1_v9 ! meaning of "unlocked"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, locked) == false);
    rfalse;
];

[ Adj_72_t1_v9 ! meaning of "female"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, female));
    rfalse;
];

[ Adj_73_t1_v9 ! meaning of "male"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, female) == false);
    rfalse;
];

[ Adj_74_t1_v9 ! meaning of "neuter"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, neuter));
    rfalse;
];

[ Adj_75_t1_v9 ! meaning of "switched on"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, on));
    rfalse;
];

[ Adj_76_t1_v9 ! meaning of "switched off"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, on) == false);
    rfalse;
];

[ Adj_77_t1_v39 ! meaning of "recurring"

    t_0 ! Call parameter 'it' = scene
    ;
return (GProperty(SCENE_TY, t_0, p57_recurring));
    rfalse;
];

[ Adj_78_t1_v39 ! meaning of "non-recurring"

    t_0 ! Call parameter 'it' = scene
    ;
return (GProperty(SCENE_TY, t_0, p57_recurring) == false);
    rfalse;
];

[ Adj_79_t1_v9 ! meaning of "large"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p60_large));
    rfalse;
];

[ Adj_80_t1_v9 ! meaning of "small"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p61_small));
    rfalse;
];

[ Adj_81_t1_v9 ! meaning of "medium"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p62_medium));
    rfalse;
];

[ Adj_82_t1_v9 ! meaning of "huge"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p63_huge));
    rfalse;
];

[ Adj_83_t1_v9 ! meaning of "ambiguously plural"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p64_ambiguously_plural));
    rfalse;
];

[ Adj_84_t1_v9 ! meaning of "ordinarily enumerated"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p64_ambiguously_plural) == false);
    rfalse;
];

[ Adj_85_t1_v9 ! meaning of "seen"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p67_seen));
    rfalse;
];

[ Adj_86_t1_v9 ! meaning of "unseen"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p67_seen) == false);
    rfalse;
];

[ Adj_87_t1_v9 ! meaning of "familiar"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p69_familiar));
    rfalse;
];

[ Adj_88_t1_v9 ! meaning of "unfamiliar"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p69_familiar) == false);
    rfalse;
];

[ Adj_89_t1_v9 ! meaning of "inuse"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p71_inuse));
    rfalse;
];

[ Adj_90_t1_v9 ! meaning of "seated"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GProperty(9, t_0, p73_posture) == 1);
      if (t_0) return (GProperty(9, t_0, p73_posture) == 1);
      if (t_0) return (GProperty(9, t_0, p73_posture) == 1);
      if (t_0) return (GProperty(9, t_0, p73_posture) == 1);
      if (t_0) return (GProperty(9, t_0, p73_posture) == 1);
      if (t_0) return (GProperty(9, t_0, p73_posture) == 1);
    rfalse;
];

[ Adj_91_t1_v9 ! meaning of "standing"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GProperty(9, t_0, p73_posture) == 2);
      if (t_0) return (GProperty(9, t_0, p73_posture) == 2);
      if (t_0) return (GProperty(9, t_0, p73_posture) == 2);
      if (t_0) return (GProperty(9, t_0, p73_posture) == 2);
      if (t_0) return (GProperty(9, t_0, p73_posture) == 2);
      if (t_0) return (GProperty(9, t_0, p73_posture) == 2);
    rfalse;
];

[ Adj_92_t1_v9 ! meaning of "reclining"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GProperty(9, t_0, p73_posture) == 3);
      if (t_0) return (GProperty(9, t_0, p73_posture) == 3);
      if (t_0) return (GProperty(9, t_0, p73_posture) == 3);
      if (t_0) return (GProperty(9, t_0, p73_posture) == 3);
      if (t_0) return (GProperty(9, t_0, p73_posture) == 3);
      if (t_0) return (GProperty(9, t_0, p73_posture) == 3);
    rfalse;
];

[ Adj_93_t1_v9 ! meaning of "posture-friendly"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p75_posture_friendly));
    rfalse;
];

[ Adj_94_t1_v9 ! meaning of "posture-unfriendly"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p75_posture_friendly) == false);
    rfalse;
];

[ Adj_95_t1_v9 ! meaning of "uneaten"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GProperty(9, t_0, p78_foodlevel) == 1);
    rfalse;
];

[ Adj_96_t1_v9 ! meaning of "half-eaten"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GProperty(9, t_0, p78_foodlevel) == 2);
    rfalse;
];

[ Adj_97_t1_v9 ! meaning of "eaten"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GProperty(9, t_0, p78_foodlevel) == 3);
    rfalse;
];

[ Adj_98_t1_v9 ! meaning of "overflowing"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GProperty(9, t_0, p79_drinklevel) == 1);
    rfalse;
];

[ Adj_99_t1_v9 ! meaning of "half-empty"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GProperty(9, t_0, p79_drinklevel) == 2);
    rfalse;
];

[ Adj_100_t1_v9 ! meaning of "droplets"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GProperty(9, t_0, p79_drinklevel) == 3);
    rfalse;
];

[ Adj_101_t1_v39 ! meaning of "success"

    t_0 ! Call parameter 'it' = scene
    ;
return (GProperty(SCENE_TY, t_0, p80_venture) == 1);
    rfalse;
];

[ Adj_102_t1_v39 ! meaning of "failure"

    t_0 ! Call parameter 'it' = scene
    ;
return (GProperty(SCENE_TY, t_0, p80_venture) == 2);
    rfalse;
];

[ Adj_103_t1_v39 ! meaning of "incomplete"

    t_0 ! Call parameter 'it' = scene
    ;
return (GProperty(SCENE_TY, t_0, p80_venture) == 3);
    rfalse;
];

[ Adj_104_t1_v39 ! meaning of "pending"

    t_0 ! Call parameter 'it' = scene
    ;
return (GProperty(SCENE_TY, t_0, p80_venture) == 4);
    rfalse;
];

[ Adj_105_t1_v39 ! meaning of "half-complete"

    t_0 ! Call parameter 'it' = scene
    ;
return (GProperty(SCENE_TY, t_0, p80_venture) == 5);
    rfalse;
];

[ Adj_106_t1_v9 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, worn));
    rfalse;
];

[ Adj_107_t1_v9 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, absent));
    rfalse;
];

[ Adj_108_t1_v9 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, mark_as_room));
    rfalse;
];

[ Adj_109_t1_v9 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, mark_as_thing));
    rfalse;
];

[ Adj_9_t2_v9 ! meaning of "on-stage"

    t_0 ! Call parameter 'it' = number
    ;
  if (t_0 ofclass K2_thing) return ((OnStage(t_0, true)));
    rfalse;
];

[ Adj_10_t2_v9 ! meaning of "off-stage"

    t_0 ! Call parameter 'it' = number
    ;
  if (t_0 ofclass K2_thing) return ((OnStage(t_0, false)));
    rfalse;
];

[ Adj_16_t2_v26 ! meaning of "empty"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_Empty(t_0, true)));
    rfalse;
];

[ Adj_17_t2_v26 ! meaning of "non-empty"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_Empty(t_0, false)));
    rfalse;
];

[ Adj_24_t2_v26 ! meaning of "equivalence"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_EquivalenceAdjective(t_0, true)));
    rfalse;
];

[ Adj_25_t2_v26 ! meaning of "symmetric"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_SymmetricAdjective(t_0, true)));
    rfalse;
];

[ Adj_26_t2_v26 ! meaning of "one-to-one"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_OToOAdjective(t_0, true)));
    rfalse;
];

[ Adj_27_t2_v26 ! meaning of "one-to-various"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_OToVAdjective(t_0, true)));
    rfalse;
];

[ Adj_28_t2_v26 ! meaning of "various-to-one"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_VToOAdjective(t_0, true)));
    rfalse;
];

[ Adj_29_t2_v26 ! meaning of "various-to-various"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_VToVAdjective(t_0, true)));
    rfalse;
];

[ Adj_34_t2_v9 ! meaning of "occupied"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p77_occupied));
    rfalse;
];

[ Adj_36_t2_v9 ! meaning of "plural-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, pluralname));
    rfalse;
];

[ Adj_37_t2_v9 ! meaning of "singular-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, pluralname, true));
    rfalse;
];

[ Adj_38_t2_v9 ! meaning of "proper-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, proper));
    rfalse;
];

[ Adj_39_t2_v9 ! meaning of "improper-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, proper, true));
    rfalse;
];

[ Adj_40_t2_v9 ! meaning of "privately-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, privately_named));
    rfalse;
];

[ Adj_41_t2_v9 ! meaning of "publically-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, privately_named, true));
    rfalse;
];

[ Adj_42_t2_v9 ! meaning of "lighted"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, light));
    rfalse;
];

[ Adj_43_t2_v9 ! meaning of "dark"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, light, true));
    rfalse;
];

[ Adj_44_t2_v9 ! meaning of "visited"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, visited));
    rfalse;
];

[ Adj_45_t2_v9 ! meaning of "unvisited"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, visited, true));
    rfalse;
];

[ Adj_46_t2_v9 ! meaning of "lit"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, light));
    rfalse;
];

[ Adj_47_t2_v9 ! meaning of "unlit"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, light, true));
    rfalse;
];

[ Adj_48_t2_v9 ! meaning of "edible"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, edible));
    rfalse;
];

[ Adj_49_t2_v9 ! meaning of "inedible"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, edible, true));
    rfalse;
];

[ Adj_50_t2_v9 ! meaning of "fixed in place"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, static));
    rfalse;
];

[ Adj_51_t2_v9 ! meaning of "portable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, static, true));
    rfalse;
];

[ Adj_52_t2_v9 ! meaning of "scenery"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, scenery));
    rfalse;
];

[ Adj_53_t2_v9 ! meaning of "wearable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, clothing));
    rfalse;
];

[ Adj_54_t2_v9 ! meaning of "pushable between rooms"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, pushable));
    rfalse;
];

[ Adj_55_t2_v9 ! meaning of "handled"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, moved));
    rfalse;
];

[ Adj_56_t2_v9 ! meaning of "described"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, concealed, true));
    rfalse;
];

[ Adj_57_t2_v9 ! meaning of "undescribed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, concealed));
    rfalse;
];

[ Adj_58_t2_v9 ! meaning of "marked for listing"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, workflag));
    rfalse;
];

[ Adj_59_t2_v9 ! meaning of "unmarked for listing"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, workflag, true));
    rfalse;
];

[ Adj_60_t2_v9 ! meaning of "mentioned"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, mentioned));
    rfalse;
];

[ Adj_61_t2_v9 ! meaning of "unmentioned"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, mentioned, true));
    rfalse;
];

[ Adj_62_t2_v9 ! meaning of "enterable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, enterable));
    rfalse;
];

[ Adj_63_t2_v9 ! meaning of "opaque"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, transparent, true));
    rfalse;
];

[ Adj_64_t2_v9 ! meaning of "transparent"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, transparent));
    rfalse;
];

[ Adj_65_t2_v9 ! meaning of "open"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, open));
    rfalse;
];

[ Adj_66_t2_v9 ! meaning of "closed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, open, true));
    rfalse;
];

[ Adj_67_t2_v9 ! meaning of "openable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, openable));
    rfalse;
];

[ Adj_68_t2_v9 ! meaning of "unopenable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, openable, true));
    rfalse;
];

[ Adj_69_t2_v9 ! meaning of "lockable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, lockable));
    rfalse;
];

[ Adj_70_t2_v9 ! meaning of "locked"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, locked));
    rfalse;
];

[ Adj_71_t2_v9 ! meaning of "unlocked"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, locked, true));
    rfalse;
];

[ Adj_72_t2_v9 ! meaning of "female"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, female));
    rfalse;
];

[ Adj_73_t2_v9 ! meaning of "male"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, female, true));
    rfalse;
];

[ Adj_74_t2_v9 ! meaning of "neuter"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, neuter));
    rfalse;
];

[ Adj_75_t2_v9 ! meaning of "switched on"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, on));
    rfalse;
];

[ Adj_76_t2_v9 ! meaning of "switched off"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, on, true));
    rfalse;
];

[ Adj_77_t2_v39 ! meaning of "recurring"

    t_0 ! Call parameter 'it' = scene
    ;
return (WriteGProperty(SCENE_TY, t_0, p57_recurring, true));
    rfalse;
];

[ Adj_78_t2_v39 ! meaning of "non-recurring"

    t_0 ! Call parameter 'it' = scene
    ;
return (WriteGProperty(SCENE_TY, t_0, p57_recurring));
    rfalse;
];

[ Adj_79_t2_v9 ! meaning of "large"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p60_large));
    rfalse;
];

[ Adj_80_t2_v9 ! meaning of "small"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p61_small));
    rfalse;
];

[ Adj_81_t2_v9 ! meaning of "medium"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p62_medium));
    rfalse;
];

[ Adj_82_t2_v9 ! meaning of "huge"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p63_huge));
    rfalse;
];

[ Adj_83_t2_v9 ! meaning of "ambiguously plural"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p64_ambiguously_plural));
    rfalse;
];

[ Adj_84_t2_v9 ! meaning of "ordinarily enumerated"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p64_ambiguously_plural, true));
    rfalse;
];

[ Adj_85_t2_v9 ! meaning of "seen"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p67_seen));
    rfalse;
];

[ Adj_86_t2_v9 ! meaning of "unseen"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p67_seen, true));
    rfalse;
];

[ Adj_87_t2_v9 ! meaning of "familiar"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p69_familiar));
    rfalse;
];

[ Adj_88_t2_v9 ! meaning of "unfamiliar"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p69_familiar, true));
    rfalse;
];

[ Adj_89_t2_v9 ! meaning of "inuse"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p71_inuse));
    rfalse;
];

[ Adj_90_t2_v9 ! meaning of "seated"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (WriteGProperty(9, t_0, p73_posture, 1));
      if (t_0) return (WriteGProperty(9, t_0, p73_posture, 1));
      if (t_0) return (WriteGProperty(9, t_0, p73_posture, 1));
      if (t_0) return (WriteGProperty(9, t_0, p73_posture, 1));
      if (t_0) return (WriteGProperty(9, t_0, p73_posture, 1));
      if (t_0) return (WriteGProperty(9, t_0, p73_posture, 1));
    rfalse;
];

[ Adj_91_t2_v9 ! meaning of "standing"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (WriteGProperty(9, t_0, p73_posture, 2));
      if (t_0) return (WriteGProperty(9, t_0, p73_posture, 2));
      if (t_0) return (WriteGProperty(9, t_0, p73_posture, 2));
      if (t_0) return (WriteGProperty(9, t_0, p73_posture, 2));
      if (t_0) return (WriteGProperty(9, t_0, p73_posture, 2));
      if (t_0) return (WriteGProperty(9, t_0, p73_posture, 2));
    rfalse;
];

[ Adj_92_t2_v9 ! meaning of "reclining"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (WriteGProperty(9, t_0, p73_posture, 3));
      if (t_0) return (WriteGProperty(9, t_0, p73_posture, 3));
      if (t_0) return (WriteGProperty(9, t_0, p73_posture, 3));
      if (t_0) return (WriteGProperty(9, t_0, p73_posture, 3));
      if (t_0) return (WriteGProperty(9, t_0, p73_posture, 3));
      if (t_0) return (WriteGProperty(9, t_0, p73_posture, 3));
    rfalse;
];

[ Adj_93_t2_v9 ! meaning of "posture-friendly"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p75_posture_friendly));
    rfalse;
];

[ Adj_94_t2_v9 ! meaning of "posture-unfriendly"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p75_posture_friendly, true));
    rfalse;
];

[ Adj_95_t2_v9 ! meaning of "uneaten"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (WriteGProperty(9, t_0, p78_foodlevel, 1));
    rfalse;
];

[ Adj_96_t2_v9 ! meaning of "half-eaten"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (WriteGProperty(9, t_0, p78_foodlevel, 2));
    rfalse;
];

[ Adj_97_t2_v9 ! meaning of "eaten"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (WriteGProperty(9, t_0, p78_foodlevel, 3));
    rfalse;
];

[ Adj_98_t2_v9 ! meaning of "overflowing"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (WriteGProperty(9, t_0, p79_drinklevel, 1));
    rfalse;
];

[ Adj_99_t2_v9 ! meaning of "half-empty"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (WriteGProperty(9, t_0, p79_drinklevel, 2));
    rfalse;
];

[ Adj_100_t2_v9 ! meaning of "droplets"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (WriteGProperty(9, t_0, p79_drinklevel, 3));
    rfalse;
];

[ Adj_101_t2_v39 ! meaning of "success"

    t_0 ! Call parameter 'it' = scene
    ;
return (WriteGProperty(SCENE_TY, t_0, p80_venture, 1));
    rfalse;
];

[ Adj_102_t2_v39 ! meaning of "failure"

    t_0 ! Call parameter 'it' = scene
    ;
return (WriteGProperty(SCENE_TY, t_0, p80_venture, 2));
    rfalse;
];

[ Adj_103_t2_v39 ! meaning of "incomplete"

    t_0 ! Call parameter 'it' = scene
    ;
return (WriteGProperty(SCENE_TY, t_0, p80_venture, 3));
    rfalse;
];

[ Adj_104_t2_v39 ! meaning of "pending"

    t_0 ! Call parameter 'it' = scene
    ;
return (WriteGProperty(SCENE_TY, t_0, p80_venture, 4));
    rfalse;
];

[ Adj_105_t2_v39 ! meaning of "half-complete"

    t_0 ! Call parameter 'it' = scene
    ;
return (WriteGProperty(SCENE_TY, t_0, p80_venture, 5));
    rfalse;
];

[ Adj_106_t2_v9 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, worn));
    rfalse;
];

[ Adj_107_t2_v9 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, absent));
    rfalse;
];

[ Adj_108_t2_v9 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, mark_as_room));
    rfalse;
];

[ Adj_109_t2_v9 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, mark_as_thing));
    rfalse;
];

[ Adj_9_t3_v9 ! meaning of "on-stage"

    t_0 ! Call parameter 'it' = number
    ;
  if (t_0 ofclass K2_thing) return ((OnStage(t_0, false)));
    rfalse;
];

[ Adj_10_t3_v9 ! meaning of "off-stage"

    t_0 ! Call parameter 'it' = number
    ;
  if (t_0 ofclass K2_thing) return ((OnStage(t_0, true)));
    rfalse;
];

[ Adj_16_t3_v26 ! meaning of "empty"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_Empty(t_0, false)));
    rfalse;
];

[ Adj_17_t3_v26 ! meaning of "non-empty"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_Empty(t_0, true)));
    rfalse;
];

[ Adj_24_t3_v26 ! meaning of "equivalence"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_EquivalenceAdjective(t_0, false)));
    rfalse;
];

[ Adj_25_t3_v26 ! meaning of "symmetric"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_SymmetricAdjective(t_0, false)));
    rfalse;
];

[ Adj_26_t3_v26 ! meaning of "one-to-one"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_OToOAdjective(t_0, false)));
    rfalse;
];

[ Adj_27_t3_v26 ! meaning of "one-to-various"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_OToVAdjective(t_0, false)));
    rfalse;
];

[ Adj_28_t3_v26 ! meaning of "various-to-one"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_VToOAdjective(t_0, false)));
    rfalse;
];

[ Adj_29_t3_v26 ! meaning of "various-to-various"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_VToVAdjective(t_0, false)));
    rfalse;
];

[ Adj_34_t3_v9 ! meaning of "occupied"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p77_occupied, true));
    rfalse;
];

[ Adj_36_t3_v9 ! meaning of "plural-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, pluralname, true));
    rfalse;
];

[ Adj_37_t3_v9 ! meaning of "singular-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, pluralname));
    rfalse;
];

[ Adj_38_t3_v9 ! meaning of "proper-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, proper, true));
    rfalse;
];

[ Adj_39_t3_v9 ! meaning of "improper-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, proper));
    rfalse;
];

[ Adj_40_t3_v9 ! meaning of "privately-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, privately_named, true));
    rfalse;
];

[ Adj_41_t3_v9 ! meaning of "publically-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, privately_named));
    rfalse;
];

[ Adj_42_t3_v9 ! meaning of "lighted"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, light, true));
    rfalse;
];

[ Adj_43_t3_v9 ! meaning of "dark"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, light));
    rfalse;
];

[ Adj_44_t3_v9 ! meaning of "visited"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, visited, true));
    rfalse;
];

[ Adj_45_t3_v9 ! meaning of "unvisited"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, visited));
    rfalse;
];

[ Adj_46_t3_v9 ! meaning of "lit"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, light, true));
    rfalse;
];

[ Adj_47_t3_v9 ! meaning of "unlit"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, light));
    rfalse;
];

[ Adj_48_t3_v9 ! meaning of "edible"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, edible, true));
    rfalse;
];

[ Adj_49_t3_v9 ! meaning of "inedible"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, edible));
    rfalse;
];

[ Adj_50_t3_v9 ! meaning of "fixed in place"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, static, true));
    rfalse;
];

[ Adj_51_t3_v9 ! meaning of "portable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, static));
    rfalse;
];

[ Adj_52_t3_v9 ! meaning of "scenery"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, scenery, true));
    rfalse;
];

[ Adj_53_t3_v9 ! meaning of "wearable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, clothing, true));
    rfalse;
];

[ Adj_54_t3_v9 ! meaning of "pushable between rooms"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, pushable, true));
    rfalse;
];

[ Adj_55_t3_v9 ! meaning of "handled"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, moved, true));
    rfalse;
];

[ Adj_56_t3_v9 ! meaning of "described"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, concealed));
    rfalse;
];

[ Adj_57_t3_v9 ! meaning of "undescribed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, concealed, true));
    rfalse;
];

[ Adj_58_t3_v9 ! meaning of "marked for listing"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, workflag, true));
    rfalse;
];

[ Adj_59_t3_v9 ! meaning of "unmarked for listing"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, workflag));
    rfalse;
];

[ Adj_60_t3_v9 ! meaning of "mentioned"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, mentioned, true));
    rfalse;
];

[ Adj_61_t3_v9 ! meaning of "unmentioned"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, mentioned));
    rfalse;
];

[ Adj_62_t3_v9 ! meaning of "enterable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, enterable, true));
    rfalse;
];

[ Adj_63_t3_v9 ! meaning of "opaque"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, transparent));
    rfalse;
];

[ Adj_64_t3_v9 ! meaning of "transparent"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, transparent, true));
    rfalse;
];

[ Adj_65_t3_v9 ! meaning of "open"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, open, true));
    rfalse;
];

[ Adj_66_t3_v9 ! meaning of "closed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, open));
    rfalse;
];

[ Adj_67_t3_v9 ! meaning of "openable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, openable, true));
    rfalse;
];

[ Adj_68_t3_v9 ! meaning of "unopenable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, openable));
    rfalse;
];

[ Adj_69_t3_v9 ! meaning of "lockable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, lockable, true));
    rfalse;
];

[ Adj_70_t3_v9 ! meaning of "locked"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, locked, true));
    rfalse;
];

[ Adj_71_t3_v9 ! meaning of "unlocked"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, locked));
    rfalse;
];

[ Adj_72_t3_v9 ! meaning of "female"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, female, true));
    rfalse;
];

[ Adj_73_t3_v9 ! meaning of "male"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, female));
    rfalse;
];

[ Adj_74_t3_v9 ! meaning of "neuter"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, neuter, true));
    rfalse;
];

[ Adj_75_t3_v9 ! meaning of "switched on"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, on, true));
    rfalse;
];

[ Adj_76_t3_v9 ! meaning of "switched off"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, on));
    rfalse;
];

[ Adj_77_t3_v39 ! meaning of "recurring"

    t_0 ! Call parameter 'it' = scene
    ;
return (WriteGProperty(SCENE_TY, t_0, p57_recurring));
    rfalse;
];

[ Adj_78_t3_v39 ! meaning of "non-recurring"

    t_0 ! Call parameter 'it' = scene
    ;
return (WriteGProperty(SCENE_TY, t_0, p57_recurring, true));
    rfalse;
];

[ Adj_79_t3_v9 ! meaning of "large"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p60_large, true));
    rfalse;
];

[ Adj_80_t3_v9 ! meaning of "small"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p61_small, true));
    rfalse;
];

[ Adj_81_t3_v9 ! meaning of "medium"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p62_medium, true));
    rfalse;
];

[ Adj_82_t3_v9 ! meaning of "huge"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p63_huge, true));
    rfalse;
];

[ Adj_83_t3_v9 ! meaning of "ambiguously plural"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p64_ambiguously_plural, true));
    rfalse;
];

[ Adj_84_t3_v9 ! meaning of "ordinarily enumerated"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p64_ambiguously_plural));
    rfalse;
];

[ Adj_85_t3_v9 ! meaning of "seen"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p67_seen, true));
    rfalse;
];

[ Adj_86_t3_v9 ! meaning of "unseen"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p67_seen));
    rfalse;
];

[ Adj_87_t3_v9 ! meaning of "familiar"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p69_familiar, true));
    rfalse;
];

[ Adj_88_t3_v9 ! meaning of "unfamiliar"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p69_familiar));
    rfalse;
];

[ Adj_89_t3_v9 ! meaning of "inuse"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p71_inuse, true));
    rfalse;
];

[ Adj_93_t3_v9 ! meaning of "posture-friendly"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p75_posture_friendly, true));
    rfalse;
];

[ Adj_94_t3_v9 ! meaning of "posture-unfriendly"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p75_posture_friendly));
    rfalse;
];

[ Adj_106_t3_v9 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, worn, true));
    rfalse;
];

[ Adj_107_t3_v9 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, absent, true));
    rfalse;
];

[ Adj_108_t3_v9 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, mark_as_room, true));
    rfalse;
];

[ Adj_109_t3_v9 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, mark_as_thing, true));
    rfalse;
];



Array TimedEventsTable table 0 0;

Array TimedEventTimesTable table 0 0;



Array rulebooks_array --> B0_procedural B1_startup B2_turn_sequence B3_shutdown B4_scene_changing B5_when_play_begins B6_when_play_ends B7_when_scene_begins B8_when_scene_ends B9_every_turn B10_action_processing B11_setting_action_variables B12_specific_action_processi B13_player_s_action_awarenes B14_accessibility B15_reaching_inside B16_reaching_outside B17_visibility B18_persuasion B19_unsuccessful_attempt_by B20_before B21_instead B22_check B23_carry_out B24_after B25_report B26_does_the_player_mean B27_when_entire_game_begins B28_when_entire_game_ends B29_before_printing_the_name B30_for_printing_the_name B31_after_printing_the_name B32_before_printing_the_plur B33_for_printing_the_plural_ B34_after_printing_the_plura B35_before_printing_a_number B36_for_printing_a_number B37_after_printing_a_number B38_before_printing_room_des B39_for_printing_room_descri B40_after_printing_room_desc B41_before_listing_contents B42_for_listing_contents B43_after_listing_contents B44_before_grouping_together B45_for_grouping_together B46_after_grouping_together B47_before_writing_a_paragra B48_for_writing_a_paragraph_ B49_after_writing_a_paragrap B50_before_listing_nondescri B51_for_listing_nondescript_ B52_after_listing_nondescrip B53_before_printing_the_name B54_for_printing_the_name_of B55_after_printing_the_name_ B56_before_printing_the_desc B57_for_printing_the_descrip B58_after_printing_the_descr B59_before_printing_the_anno B60_for_printing_the_announc B61_after_printing_the_annou B62_before_printing_the_anno B63_for_printing_the_announc B64_after_printing_the_annou B65_before_printing_a_refusa B66_for_printing_a_refusal_t B67_after_printing_a_refusal B68_before_constructing_the_ B69_for_constructing_the_sta B70_after_constructing_the_s B71_before_printing_the_bann B72_for_printing_the_banner_ B73_after_printing_the_banne B74_before_reading_a_command B75_for_reading_a_command B76_after_reading_a_command B77_before_deciding_the_scop B78_for_deciding_the_scope B79_after_deciding_the_scope B80_before_deciding_the_conc B81_for_deciding_the_conceal B82_after_deciding_the_conce B83_before_deciding_whether_ B84_for_deciding_whether_all B85_after_deciding_whether_a B86_before_clarifying_the_pa B87_for_clarifying_the_parse B88_after_clarifying_the_par B89_before_asking_which_do_y B90_for_asking_which_do_you_ B91_after_asking_which_do_yo B92_before_printing_a_parser B93_for_printing_a_parser_er B94_after_printing_a_parser_ B95_before_supplying_a_missi B96_for_supplying_a_missing_ B97_after_supplying_a_missin B98_before_supplying_a_missi B99_for_supplying_a_missing_ B100_after_supplying_a_missi B101_before_implicitly_takin B102_for_implicitly_taking B103_after_implicitly_taking B104_before_starting_the_vir B105_for_starting_the_virtua B106_after_starting_the_virt B107_before_amusing_a_victor B108_for_amusing_a_victoriou B109_after_amusing_a_victori B110_before_printing_the_pla B111_for_printing_the_player B112_after_printing_the_play B113_before_handling_the_fin B114_for_handling_the_final_ B115_after_handling_the_fina B116_before_printing_the_loc B117_for_printing_the_locale B118_after_printing_the_loca B119_before_choosing_notable B120_for_choosing_notable_lo B121_after_choosing_notable_ B122_before_printing_a_local B123_for_printing_a_locale_p B124_after_printing_a_locale B125_check_taking_inventory B126_carry_out_taking_invent B127_report_taking_inventory B128_check_taking B129_carry_out_taking B130_report_taking B131_check_removing_it_from B132_carry_out_removing_it_f B133_report_removing_it_from B134_check_dropping B135_carry_out_dropping B136_report_dropping B137_check_putting_it_on B138_carry_out_putting_it_on B139_report_putting_it_on B140_check_inserting_it_into B141_carry_out_inserting_it_ B142_report_inserting_it_int B143_check_eating B144_carry_out_eating B145_report_eating B146_check_going B147_carry_out_going B148_report_going B149_check_entering B150_carry_out_entering B151_report_entering B152_check_exiting B153_carry_out_exiting B154_report_exiting B155_check_getting_off B156_carry_out_getting_off B157_report_getting_off B158_check_looking B159_carry_out_looking B160_report_looking B161_check_examining B162_carry_out_examining B163_report_examining B164_check_looking_under B165_carry_out_looking_under B166_report_looking_under B167_check_searching B168_carry_out_searching B169_report_searching B170_check_consulting_it_abo B171_carry_out_consulting_it B172_report_consulting_it_ab B173_check_locking_it_with B174_carry_out_locking_it_wi B175_report_locking_it_with B176_check_unlocking_it_with B177_carry_out_unlocking_it_ B178_report_unlocking_it_wit B179_check_switching_on B180_carry_out_switching_on B181_report_switching_on B182_check_switching_off B183_carry_out_switching_off B184_report_switching_off B185_check_opening B186_carry_out_opening B187_report_opening B188_check_closing B189_carry_out_closing B190_report_closing B191_check_wearing B192_carry_out_wearing B193_report_wearing B194_check_taking_off B195_carry_out_taking_off B196_report_taking_off B197_check_giving_it_to B198_carry_out_giving_it_to B199_report_giving_it_to B200_check_showing_it_to B201_carry_out_showing_it_to B202_report_showing_it_to B203_check_waking B204_carry_out_waking B205_report_waking B206_check_throwing_it_at B207_carry_out_throwing_it_a B208_report_throwing_it_at B209_check_attacking B210_carry_out_attacking B211_report_attacking B212_check_kissing B213_carry_out_kissing B214_report_kissing B215_check_answering_it_that B216_carry_out_answering_it_ B217_report_answering_it_tha B218_check_telling_it_about B219_carry_out_telling_it_ab B220_report_telling_it_about B221_check_asking_it_about B222_carry_out_asking_it_abo B223_report_asking_it_about B224_check_asking_it_for B225_carry_out_asking_it_for B226_report_asking_it_for B227_check_waiting B228_carry_out_waiting B229_report_waiting B230_check_touching B231_carry_out_touching B232_report_touching B233_check_waving B234_carry_out_waving B235_report_waving B236_check_pulling B237_carry_out_pulling B238_report_pulling B239_check_pushing B240_carry_out_pushing B241_report_pushing B242_check_turning B243_carry_out_turning B244_report_turning B245_check_pushing_it_to B246_carry_out_pushing_it_to B247_report_pushing_it_to B248_check_squeezing B249_carry_out_squeezing B250_report_squeezing B251_check_saying_yes B252_carry_out_saying_yes B253_report_saying_yes B254_check_saying_no B255_carry_out_saying_no B256_report_saying_no B257_check_burning B258_carry_out_burning B259_report_burning B260_check_waking_up B261_carry_out_waking_up B262_report_waking_up B263_check_thinking B264_carry_out_thinking B265_report_thinking B266_check_smelling B267_carry_out_smelling B268_report_smelling B269_check_listening_to B270_carry_out_listening_to B271_report_listening_to B272_check_tasting B273_carry_out_tasting B274_report_tasting B275_check_cutting B276_carry_out_cutting B277_report_cutting B278_check_jumping B279_carry_out_jumping B280_report_jumping B281_check_tying_it_to B282_carry_out_tying_it_to B283_report_tying_it_to B284_check_drinking B285_carry_out_drinking B286_report_drinking B287_check_saying_sorry B288_carry_out_saying_sorry B289_report_saying_sorry B290_check_swearing_obscenel B291_carry_out_swearing_obsc B292_report_swearing_obscene B293_check_swearing_mildly B294_carry_out_swearing_mild B295_report_swearing_mildly B296_check_swinging B297_carry_out_swinging B298_report_swinging B299_check_rubbing B300_carry_out_rubbing B301_report_rubbing B302_check_setting_it_to B303_carry_out_setting_it_to B304_report_setting_it_to B305_check_waving_hands B306_carry_out_waving_hands B307_report_waving_hands B308_check_buying B309_carry_out_buying B310_report_buying B311_check_singing B312_carry_out_singing B313_report_singing B314_check_climbing B315_carry_out_climbing B316_report_climbing B317_check_sleeping B318_carry_out_sleeping B319_report_sleeping B320_check_quitting_the_game B321_carry_out_quitting_the_ B322_report_quitting_the_gam B323_check_saving_the_game B324_carry_out_saving_the_ga B325_report_saving_the_game B326_check_restoring_the_gam B327_carry_out_restoring_the B328_report_restoring_the_ga B329_check_restarting_the_ga B330_carry_out_restarting_th B331_report_restarting_the_g B332_check_verifying_the_sto B333_carry_out_verifying_the B334_report_verifying_the_st B335_check_switching_the_sto B336_carry_out_switching_the B337_report_switching_the_st B338_check_switching_the_sto B339_carry_out_switching_the B340_report_switching_the_st B341_check_requesting_the_st B342_carry_out_requesting_th B343_report_requesting_the_s B344_check_requesting_the_sc B345_carry_out_requesting_th B346_report_requesting_the_s B347_check_preferring_abbrev B348_carry_out_preferring_ab B349_report_preferring_abbre B350_check_preferring_unabbr B351_carry_out_preferring_un B352_report_preferring_unabb B353_check_preferring_someti B354_carry_out_preferring_so B355_report_preferring_somet B356_check_switching_score_n B357_carry_out_switching_sco B358_report_switching_score_ B359_check_switching_score_n B360_carry_out_switching_sco B361_report_switching_score_ B362_check_requesting_the_pr B363_carry_out_requesting_th B364_report_requesting_the_p B365_when_uncle_vernon_s_sce B366_when_uncle_vernon_s_sce B367_check_putting_it_under B368_carry_out_putting_it_un B369_report_putting_it_under B370_check_getting_under B371_carry_out_getting_under B372_report_getting_under B373_check_going_under B374_carry_out_going_under B375_report_going_under B376_check_getting_out_from_ B377_carry_out_getting_out_f B378_report_getting_out_from B379_check_mounting B380_carry_out_mounting B381_report_mounting B382_check_dismounting B383_carry_out_dismounting B384_report_dismounting B385_before_displaying B386_for_displaying B387_after_displaying B388_check_asking_for_help B389_carry_out_asking_for_he B390_report_asking_for_help B391_check_switching_cheats_ B392_carry_out_switching_che B393_report_switching_cheats B394_check_switching_cheats_ B395_carry_out_switching_che B396_report_switching_cheats B397_check_teleporting_to B398_carry_out_teleporting_t B399_report_teleporting_to B400_check_moving_to B401_carry_out_moving_to B402_report_moving_to B403_check_putting_back B404_carry_out_putting_back B405_report_putting_back B406_check_universal_opening B407_carry_out_universal_ope B408_report_universal_openin B409_check_changing_player B410_carry_out_changing_play B411_report_changing_player B412_check_point_increasing B413_carry_out_point_increas B414_report_point_increasing B415_check_restoring_score B416_carry_out_restoring_sco B417_report_restoring_score B418_check_removing B419_carry_out_removing B420_report_removing B421_check_paying_wizard_mon B422_carry_out_paying_wizard B423_report_paying_wizard_mo B424_check_inputting B425_carry_out_inputting B426_report_inputting B427_check_requesting_it_for B428_carry_out_requesting_it B429_report_requesting_it_fo B430_check_imploring_it_for B431_carry_out_imploring_it_ B432_report_imploring_it_for B433_check_quizzing_it_about B434_carry_out_quizzing_it_a B435_report_quizzing_it_abou B436_check_informing_it_abou B437_carry_out_informing_it_ B438_report_informing_it_abo B439_check_implicit_asking B440_carry_out_implicit_aski B441_report_implicit_asking B442_check_implicit_telling B443_carry_out_implicit_tell B444_report_implicit_telling B445_check_implicit_quizzing B446_carry_out_implicit_quiz B447_report_implicit_quizzin B448_check_implicit_informin B449_carry_out_implicit_info B450_report_implicit_informi B451_check_implicit_requesti B452_carry_out_implicit_requ B453_report_implicit_request B454_check_implicit_implorin B455_carry_out_implicit_impl B456_report_implicit_implori B457_check_saying_hello_to B458_carry_out_saying_hello_ B459_report_saying_hello_to B460_check_hailing B461_carry_out_hailing B462_report_hailing B463_check_leavetaking B464_carry_out_leavetaking B465_report_leavetaking B466_check_saying_goodbye_to B467_carry_out_saying_goodby B468_report_saying_goodbye_t B469_glulx_timed_activity B470_glulx_redrawing B471_glulx_arranging B472_glulx_sound_notificatio B473_glulx_mouse_input B474_glulx_character_input B475_glulx_line_input B476_glulx_hyperlink B477_glulx_zeroing_reference B478_glulx_resetting_windows B479_glulx_resetting_streams B480_glulx_resetting_fileref B481_glulx_object_updating B482_command_counting B483_input_cancelling B484_command_showing B485_command_pasting B486_check_dialling_it_on B487_carry_out_dialling_it_o B488_report_dialling_it_on B489_check_hanging_up B490_carry_out_hanging_up B491_report_hanging_up B492_check_sitting_on B493_carry_out_sitting_on B494_report_sitting_on B495_check_lying_on B496_carry_out_lying_on B497_report_lying_on B498_check_standing_up_on B499_carry_out_standing_up_o B500_report_standing_up_on B501_check_lying_down B502_carry_out_lying_down B503_report_lying_down B504_check_sitting_down B505_carry_out_sitting_down B506_report_sitting_down B507_check_standing_up B508_carry_out_standing_up B509_report_standing_up B510_check_taking_position B511_carry_out_taking_positi B512_report_taking_position B513_after_not B514_check_asking_for_hints B515_carry_out_asking_for_hi B516_report_asking_for_hints B517_check_getting_out B518_carry_out_getting_out B519_report_getting_out B520_when_work_begins B521_when_work_ends B522_check_carjacking B523_carry_out_carjacking B524_report_carjacking B525_check_using B526_carry_out_using B527_report_using B528_when_customercall_begin B529_when_customercall_ends B530_check_responding_to_cus B531_carry_out_responding_to B532_report_responding_to_cu B533_check_saying B534_carry_out_saying B535_report_saying B536_check_flipping B537_carry_out_flipping B538_report_flipping B539_when_mrmason_call_begin B540_when_mrmason_call_ends B541_check_writing_intro B542_carry_out_writing_intro B543_report_writing_intro B544_check_writing_on B545_carry_out_writing_on B546_report_writing_on B547_check_clearing_the_scre B548_carry_out_clearing_the_ B549_report_clearing_the_scr B550_check_wanting B551_carry_out_wanting B552_report_wanting B553_check_playing B554_carry_out_playing B555_report_playing B556_check_thanking B557_carry_out_thanking B558_report_thanking B559_check_thanking_with_no_ B560_carry_out_thanking_with B561_report_thanking_with_no B562_when_living_room_cut_sc B563_when_living_room_cut_sc B564_check_dursley_s_spellca B565_carry_out_dursley_s_spe B566_report_dursley_s_spellc B567_check_jumping_out_of B568_carry_out_jumping_out_o B569_report_jumping_out_of B570_check_timing B571_carry_out_timing B572_report_timing 0;

Array B0_procedural --> R_1135 R_899 R_913 R_914 R_915 R_916 R_917 R_918 R_1094 R_1107 R_1120 R_1127 R_1270 R_1293 R_1294 R_1307 NULL; ! 16 rule(s)
Array B1_startup --> INITIALISE_MEMORY_R VIRTUAL_MACHINE_STARTUP_R SEED_RANDOM_NUMBER_GENERATOR_R UPDATE_CHRONOLOGICAL_RECORDS_R POSITION_PLAYER_IN_MODEL_R R_8 R_9 R_10 R_11 R_12 NULL; ! 10 rule(s)
Array B2_turn_sequence --> PARSE_COMMAND_R GENERATE_ACTION_R R_14 R_13 TIMED_EVENTS_R ADVANCE_TIME_R UPDATE_CHRONOLOGICAL_RECORDS_R R_15 ADJUST_LIGHT_R NOTE_OBJECT_ACQUISITIONS_R R_16 NULL; ! 11 rule(s)
Array B3_shutdown --> R_17 RESURRECT_PLAYER_IF_ASKED_R R_18 ASK_FINAL_QUESTION_R NULL; ! 4 rule(s)
Array B4_scene_changing --> DetectSceneChange NULL; ! 1 rule(s)
Array B5_when_play_begins --> R_754 R_755 R_935 R_936 R_937 R_975 R_1218 R_1262 NULL; ! 8 rule(s)
Constant B6_when_play_ends = EMPTY_RULEBOOK;
Array B7_when_scene_begins --> R_57 NULL; ! 1 rule(s)
Constant B8_when_scene_ends = EMPTY_RULEBOOK;
Array B9_every_turn --> (-2) (-2) 23 R_1155 R_1186 R_1196 R_1299 R_768 R_1156 R_1157 R_1163 R_1165 R_1172 R_1173 R_1306 R_1112 R_1117 R_1158 R_1178 R_1179 R_1187 R_1188 R_1189 R_1244 R_1298 R_985 NULL; ! 23 rule(s)
Array B10_action_processing --> R_20 R_19 R_21 R_837 BASIC_VISIBILITY_R BASIC_ACCESSIBILITY_R CARRYING_REQUIREMENTS_R R_22 REQUESTED_ACTIONS_REQUIRE_R CARRY_OUT_REQUESTED_ACTIONS_R DESCEND_TO_SPECIFIC_ACTION_R R_23 NULL; ! 12 rule(s)
Array B11_setting_action_variables --> R_137 R_171 R_843 R_1022 R_1035 R_159 R_756 NULL; ! 7 rule(s)
Array B12_specific_action_processi --> WORK_OUT_DETAILS_OF_SPECIFIC_R R_24 R_25 R_26 R_27 R_28 R_29 R_30 NULL; ! 8 rule(s)
Array B13_player_s_action_awarenes --> R_31 R_32 R_33 R_34 NULL; ! 4 rule(s)
Array B14_accessibility --> ACCESS_THROUGH_BARRIERS_R NULL; ! 1 rule(s)
Array B15_reaching_inside --> CANT_REACH_INSIDE_ROOMS_R CANT_REACH_INSIDE_CLOSED_R NULL; ! 2 rule(s)
Array B16_reaching_outside --> CANT_REACH_OUTSIDE_CLOSED_R NULL; ! 1 rule(s)
Array B17_visibility --> R_35 NULL; ! 1 rule(s)
Array B18_persuasion --> R_1267 R_974 R_981 R_898 NULL; ! 4 rule(s)
Array B19_unsuccessful_attempt_by --> R_856 R_860 NULL; ! 2 rule(s)
Array B20_before --> (-2) ##Go R_1166 ##A113_dialling_it_on R_1206 ##Ask 4 R_1199 R_1203 R_1204 R_1205 ##Give R_1261 ##Ask R_1209 ##Show R_963 ##Give R_964 ##Go 2 R_1180 R_1273 (-2) 2 R_1214 R_1215 ##A126_responding_to_customer R_1233 ##Take R_762 ##Listen R_1031 ##Eat R_1126 ##Buy R_1263 ##A110_hailing R_971 (-2) R_965 ##Go 2 R_1039 R_920 ##Unlock R_1144 ##Give R_1260 ##Answer 3 R_989 R_990 R_991 ##Open 2 R_1095 R_1096 ##Take R_1115 ##Examine R_1119 ##Drink R_1133 ##Eat R_1141 ##Open R_1222 ##Examine R_1223 ##Go R_861 ##Enter R_844 ##A84_mounting R_1110 ##Enter R_845 ##GetOff 2 R_846 R_847 ##Wear 2 R_1098 R_1099 ##A82_going_under R_761 ##Take R_919 ##A94_point_increasing R_928 ##Yes R_986 ##No R_987 ##Sorry R_988 ##A113_dialling_it_on R_1034 ##A85_dismounting R_1111 ##A114_hanging_up R_1192 ##A126_responding_to_customer R_1235 ##Yes R_1200 ##No R_1202 ##Yes R_1230 (-2) 6 R_1198 R_1234 R_955 R_962 R_954 R_1240 ##A90_moving_to R_759 ##A80_putting_it_under R_760 ##A89_teleporting_to R_763 ##Exit R_848 ##A89_teleporting_to R_902 ##A91_putting_back R_923 ##A97_paying_wizard_money R_934 ##A90_moving_to R_1118 ##Go 2 R_1161 R_1162 ##A129_writing_intro R_1241 ##A132_wanting R_1264 ##A135_thanking_with_no_noun R_1314 (-2) 2 R_764 R_771 NULL; ! 78 rule(s)
Array B21_instead --> (-2) ##Go 2 R_1151 R_1150 ##A113_dialling_it_on 2 R_1225 R_1226 ##Take R_1182 ##A109_saying_hello_to R_1212 ##Examine R_1290 ##Listen R_1030 ##Eat R_1125 ##Examine R_1284 ##Exit 2 R_1159 R_1160 ##Ask 2 R_952 R_953 ##Tell R_1211 ##A99_requesting_it_for R_1266 ##Turn R_1102 ##SwitchOn R_1103 ##A125_using R_1104 ##Open R_1114 ##Eat 2 R_1121 R_1134 ##A124_carjacking 2 R_1169 R_1170 ##Answer R_1210 ##Open R_1224 ##Enter R_1318 ##Open R_1319 ##Search R_1320 ##Turn R_1331 ##SwitchOn R_1332 ##A125_using R_1333 ##Drink R_1128 ##A124_carjacking R_1168 ##Examine R_895 ##A94_point_increasing R_929 ##Take 2 R_1113 R_1285 (-2) R_1265 ##A114_hanging_up R_1184 ##A80_putting_it_under R_757 ##Exit R_766 ##A89_teleporting_to R_901 ##A90_moving_to R_904 ##Look R_1268 ##Take R_1336 (-2) 2 R_1190 R_1237 ##A118_lying_down R_1046 ##A119_sitting_down R_1048 ##A120_standing_up R_1049 ##A103_implicit_asking R_956 ##A104_implicit_telling R_957 ##A105_implicit_quizzing R_958 ##A106_implicit_informing R_959 ##A107_implicit_requesting R_960 ##A108_implicit_imploring R_961 ##Inv R_1097 NULL; ! 58 rule(s)
Constant B22_check = EMPTY_RULEBOOK;
Constant B23_carry_out = EMPTY_RULEBOOK;
Array B24_after --> (-2) ##Go 4 R_1251 R_1167 R_1274 R_1279 ##Take R_769 ##A109_saying_hello_to R_1123 ##SwitchOn 2 R_1176 R_1177 ##Go R_1269 ##Enter R_1316 ##Go 2 R_1289 R_1323 ##Exit R_1275 ##A113_dialling_it_on R_1191 ##A109_saying_hello_to R_1124 ##Examine R_1220 ##A109_saying_hello_to R_1221 ##Examine R_1228 ##A109_saying_hello_to R_1229 ##Examine 2 R_1252 R_1253 ##Enter R_1278 ##Drink R_1313 ##Take R_751 ##A89_teleporting_to 2 R_903 R_1194 ##Open 3 R_1105 R_896 R_897 ##Take R_933 ##A84_mounting R_1108 ##Take R_749 ##Look R_1040 ##Exit R_1193 ##A80_putting_it_under R_747 ##A93_changing_player R_927 ##A85_dismounting R_1109 ##A90_moving_to R_1195 NULL; ! 38 rule(s)
Constant B25_report = EMPTY_RULEBOOK;
Array B26_does_the_player_mean --> R_1053 R_1054 R_1055 R_1050 R_1051 R_1052 R_1175 R_1277 R_1243 R_1276 R_36 R_910 R_1213 NULL; ! 13 rule(s)
Constant B27_when_entire_game_begins = EMPTY_RULEBOOK;
Constant B28_when_entire_game_ends = EMPTY_RULEBOOK;
Array B29_before_printing_the_name --> R_58 NULL; ! 1 rule(s)
Array B30_for_printing_the_name --> (-2) (-2) 28 R_1131 R_1132 R_1137 R_1138 R_1142 R_1185 R_1249 R_1250 R_1254 R_1255 R_1256 R_1257 R_1258 R_1259 R_1300 R_1301 R_1302 R_1303 R_1304 R_1305 R_1317 R_1321 R_1322 R_1281 R_1282 R_1116 R_1136 STANDARD_NAME_PRINTING_R NULL; ! 28 rule(s)
Array B31_after_printing_the_name --> R_838 R_894 R_772 R_758 NULL; ! 4 rule(s)
Constant B32_before_printing_the_plur = EMPTY_RULEBOOK;
Array B33_for_printing_the_plural_ --> R_59 NULL; ! 1 rule(s)
Constant B34_after_printing_the_plura = EMPTY_RULEBOOK;
Constant B35_before_printing_a_number = EMPTY_RULEBOOK;
Array B36_for_printing_a_number --> R_60 NULL; ! 1 rule(s)
Constant B37_after_printing_a_number = EMPTY_RULEBOOK;
Constant B38_before_printing_room_des = EMPTY_RULEBOOK;
Constant B39_for_printing_room_descri = EMPTY_RULEBOOK;
Constant B40_after_printing_room_desc = EMPTY_RULEBOOK;
Constant B41_before_listing_contents = EMPTY_RULEBOOK;
Array B42_for_listing_contents --> STANDARD_CONTENTS_LISTING_R NULL; ! 1 rule(s)
Constant B43_after_listing_contents = EMPTY_RULEBOOK;
Constant B44_before_grouping_together = EMPTY_RULEBOOK;
Constant B45_for_grouping_together = EMPTY_RULEBOOK;
Constant B46_after_grouping_together = EMPTY_RULEBOOK;
Constant B47_before_writing_a_paragra = EMPTY_RULEBOOK;
Constant B48_for_writing_a_paragraph_ = EMPTY_RULEBOOK;
Constant B49_after_writing_a_paragrap = EMPTY_RULEBOOK;
Constant B50_before_listing_nondescri = EMPTY_RULEBOOK;
Constant B51_for_listing_nondescript_ = EMPTY_RULEBOOK;
Constant B52_after_listing_nondescrip = EMPTY_RULEBOOK;
Constant B53_before_printing_the_name = EMPTY_RULEBOOK;
Constant B54_for_printing_the_name_of = EMPTY_RULEBOOK;
Constant B55_after_printing_the_name_ = EMPTY_RULEBOOK;
Constant B56_before_printing_the_desc = EMPTY_RULEBOOK;
Constant B57_for_printing_the_descrip = EMPTY_RULEBOOK;
Constant B58_after_printing_the_descr = EMPTY_RULEBOOK;
Constant B59_before_printing_the_anno = EMPTY_RULEBOOK;
Constant B60_for_printing_the_announc = EMPTY_RULEBOOK;
Constant B61_after_printing_the_annou = EMPTY_RULEBOOK;
Constant B62_before_printing_the_anno = EMPTY_RULEBOOK;
Array B63_for_printing_the_announc --> R_61 NULL; ! 1 rule(s)
Constant B64_after_printing_the_annou = EMPTY_RULEBOOK;
Constant B65_before_printing_a_refusa = EMPTY_RULEBOOK;
Constant B66_for_printing_a_refusal_t = EMPTY_RULEBOOK;
Constant B67_after_printing_a_refusal = EMPTY_RULEBOOK;
Constant B68_before_constructing_the_ = EMPTY_RULEBOOK;
Array B69_for_constructing_the_sta --> R_870 NULL; ! 1 rule(s)
Constant B70_after_constructing_the_s = EMPTY_RULEBOOK;
Array B71_before_printing_the_bann --> R_744 NULL; ! 1 rule(s)
Constant B72_for_printing_the_banner_ = EMPTY_RULEBOOK;
Constant B73_after_printing_the_banne = EMPTY_RULEBOOK;
Constant B74_before_reading_a_command = EMPTY_RULEBOOK;
Constant B75_for_reading_a_command = EMPTY_RULEBOOK;
Array B76_after_reading_a_command --> R_932 R_1093 R_1174 R_1236 R_1242 R_1283 R_1288 R_1143 R_1227 R_1246 R_1247 R_1248 R_1271 R_1324 NULL; ! 14 rule(s)
Constant B77_before_deciding_the_scop = EMPTY_RULEBOOK;
Constant B78_for_deciding_the_scope = EMPTY_RULEBOOK;
Array B79_after_deciding_the_scope --> R_1029 NULL; ! 1 rule(s)
Constant B80_before_deciding_the_conc = EMPTY_RULEBOOK;
Constant B81_for_deciding_the_conceal = EMPTY_RULEBOOK;
Constant B82_after_deciding_the_conce = EMPTY_RULEBOOK;
Constant B83_before_deciding_whether_ = EMPTY_RULEBOOK;
Array B84_for_deciding_whether_all --> R_62 R_64 R_63 NULL; ! 3 rule(s)
Constant B85_after_deciding_whether_a = EMPTY_RULEBOOK;
Constant B86_before_clarifying_the_pa = EMPTY_RULEBOOK;
Constant B87_for_clarifying_the_parse = EMPTY_RULEBOOK;
Constant B88_after_clarifying_the_par = EMPTY_RULEBOOK;
Constant B89_before_asking_which_do_y = EMPTY_RULEBOOK;
Constant B90_for_asking_which_do_you_ = EMPTY_RULEBOOK;
Constant B91_after_asking_which_do_yo = EMPTY_RULEBOOK;
Constant B92_before_printing_a_parser = EMPTY_RULEBOOK;
Array B93_for_printing_a_parser_er --> R_1207 NULL; ! 1 rule(s)
Constant B94_after_printing_a_parser_ = EMPTY_RULEBOOK;
Constant B95_before_supplying_a_missi = EMPTY_RULEBOOK;
Array B96_for_supplying_a_missing_ --> R_65 R_66 R_67 R_148 NULL; ! 4 rule(s)
Constant B97_after_supplying_a_missin = EMPTY_RULEBOOK;
Constant B98_before_supplying_a_missi = EMPTY_RULEBOOK;
Array B99_for_supplying_a_missing_ --> R_1032 NULL; ! 1 rule(s)
Constant B100_after_supplying_a_missi = EMPTY_RULEBOOK;
Constant B101_before_implicitly_takin = EMPTY_RULEBOOK;
Constant B102_for_implicitly_taking = EMPTY_RULEBOOK;
Constant B103_after_implicitly_taking = EMPTY_RULEBOOK;
Constant B104_before_starting_the_vir = EMPTY_RULEBOOK;
Array B105_for_starting_the_virtua --> ENABLE_GLULX_ACCEL_R NULL; ! 1 rule(s)
Constant B106_after_starting_the_virt = EMPTY_RULEBOOK;
Constant B107_before_amusing_a_victor = EMPTY_RULEBOOK;
Constant B108_for_amusing_a_victoriou = EMPTY_RULEBOOK;
Constant B109_after_amusing_a_victori = EMPTY_RULEBOOK;
Constant B110_before_printing_the_pla = EMPTY_RULEBOOK;
Array B111_for_printing_the_player --> PRINT_OBITUARY_HEADLINE_R PRINT_FINAL_SCORE_R DISPLAY_FINAL_STATUS_LINE_R NULL; ! 3 rule(s)
Constant B112_after_printing_the_play = EMPTY_RULEBOOK;
Array B113_before_handling_the_fin --> R_69 R_68 READ_FINAL_ANSWER_R NULL; ! 3 rule(s)
Array B114_for_handling_the_final_ --> R_70 NULL; ! 1 rule(s)
Constant B115_after_handling_the_fina = EMPTY_RULEBOOK;
Array B116_before_printing_the_loc --> R_73 R_74 NULL; ! 2 rule(s)
Array B117_for_printing_the_locale --> R_75 R_76 NULL; ! 2 rule(s)
Constant B118_after_printing_the_loca = EMPTY_RULEBOOK;
Constant B119_before_choosing_notable = EMPTY_RULEBOOK;
Array B120_for_choosing_notable_lo --> R_77 NULL; ! 1 rule(s)
Constant B121_after_choosing_notable_ = EMPTY_RULEBOOK;
Constant B122_before_printing_a_local = EMPTY_RULEBOOK;
Array B123_for_printing_a_locale_p --> R_78 R_79 R_80 R_81 R_82 R_83 R_85 NULL; ! 7 rule(s)
Constant B124_after_printing_a_locale = EMPTY_RULEBOOK;
Constant B125_check_taking_inventory = EMPTY_RULEBOOK;
Array B126_carry_out_taking_invent --> R_86 R_87 NULL; ! 2 rule(s)
Array B127_report_taking_inventory --> R_88 NULL; ! 1 rule(s)
Array B128_check_taking --> R_89 R_90 R_91 R_92 R_93 R_94 R_95 R_96 R_97 R_98 R_99 R_100 NULL; ! 12 rule(s)
Array B129_carry_out_taking --> R_101 NULL; ! 1 rule(s)
Array B130_report_taking --> R_1145 R_770 R_102 NULL; ! 3 rule(s)
Array B131_check_removing_it_from --> R_91 R_103 R_104 R_105 NULL; ! 4 rule(s)
Constant B132_carry_out_removing_it_f = EMPTY_RULEBOOK;
Constant B133_report_removing_it_from = EMPTY_RULEBOOK;
Array B134_check_dropping --> R_106 R_107 R_108 R_109 R_110 NULL; ! 5 rule(s)
Array B135_carry_out_dropping --> R_111 NULL; ! 1 rule(s)
Array B136_report_dropping --> R_112 NULL; ! 1 rule(s)
Array B137_check_putting_it_on --> R_113 R_114 R_115 R_116 R_117 R_118 R_119 NULL; ! 7 rule(s)
Array B138_carry_out_putting_it_on --> R_120 NULL; ! 1 rule(s)
Array B139_report_putting_it_on --> R_121 R_122 NULL; ! 2 rule(s)
Array B140_check_inserting_it_into --> R_123 R_124 R_125 R_126 R_127 R_128 R_129 NULL; ! 7 rule(s)
Array B141_carry_out_inserting_it_ --> R_130 NULL; ! 1 rule(s)
Array B142_report_inserting_it_int --> R_131 R_132 NULL; ! 2 rule(s)
Array B143_check_eating --> R_133 R_134 NULL; ! 2 rule(s)
Array B144_carry_out_eating --> R_135 NULL; ! 1 rule(s)
Array B145_report_eating --> R_136 NULL; ! 1 rule(s)
Array B146_check_going --> R_1064 R_139 R_140 R_141 R_142 R_143 NULL; ! 6 rule(s)
Array B147_carry_out_going --> R_984 R_144 R_145 R_146 NULL; ! 4 rule(s)
Array B148_report_going --> R_147 NULL; ! 1 rule(s)
Array B149_check_entering --> R_149 R_150 R_151 R_152 R_153 R_154 R_155 NULL; ! 7 rule(s)
Array B150_carry_out_entering --> R_156 R_1063 NULL; ! 2 rule(s)
Array B151_report_entering --> R_157 R_158 NULL; ! 2 rule(s)
Array B152_check_exiting --> R_1065 R_160 R_161 R_162 R_163 NULL; ! 5 rule(s)
Array B153_carry_out_exiting --> R_164 R_1062 NULL; ! 2 rule(s)
Array B154_report_exiting --> R_165 R_166 NULL; ! 2 rule(s)
Array B155_check_getting_off --> R_167 NULL; ! 1 rule(s)
Array B156_carry_out_getting_off --> R_168 R_1062 NULL; ! 2 rule(s)
Array B157_report_getting_off --> R_169 R_170 NULL; ! 2 rule(s)
Constant B158_check_looking = EMPTY_RULEBOOK;
Array B159_carry_out_looking --> R_172 R_173 R_174 R_175 R_945 NULL; ! 5 rule(s)
Array B160_report_looking --> R_176 NULL; ! 1 rule(s)
Constant B161_check_examining = EMPTY_RULEBOOK;
Array B162_carry_out_examining --> R_947 R_177 R_178 R_179 R_180 R_181 R_182 NULL; ! 7 rule(s)
Array B163_report_examining --> R_183 NULL; ! 1 rule(s)
Constant B164_check_looking_under = EMPTY_RULEBOOK;
Array B165_carry_out_looking_under --> R_750 R_184 NULL; ! 2 rule(s)
Array B166_report_looking_under --> R_185 NULL; ! 1 rule(s)
Array B167_check_searching --> R_186 R_187 NULL; ! 2 rule(s)
Constant B168_carry_out_searching = EMPTY_RULEBOOK;
Array B169_report_searching --> R_188 R_189 R_190 NULL; ! 3 rule(s)
Constant B170_check_consulting_it_abo = EMPTY_RULEBOOK;
Constant B171_carry_out_consulting_it = EMPTY_RULEBOOK;
Array B172_report_consulting_it_ab --> R_191 NULL; ! 1 rule(s)
Array B173_check_locking_it_with --> R_192 R_193 R_194 R_195 NULL; ! 4 rule(s)
Array B174_carry_out_locking_it_wi --> R_196 NULL; ! 1 rule(s)
Array B175_report_locking_it_with --> R_197 NULL; ! 1 rule(s)
Array B176_check_unlocking_it_with --> R_1146 R_198 R_199 R_200 NULL; ! 4 rule(s)
Array B177_carry_out_unlocking_it_ --> R_201 NULL; ! 1 rule(s)
Array B178_report_unlocking_it_wit --> R_202 NULL; ! 1 rule(s)
Array B179_check_switching_on --> R_203 R_204 NULL; ! 2 rule(s)
Array B180_carry_out_switching_on --> R_205 NULL; ! 1 rule(s)
Array B181_report_switching_on --> R_1292 R_1291 R_1164 R_206 NULL; ! 4 rule(s)
Array B182_check_switching_off --> R_207 R_208 NULL; ! 2 rule(s)
Array B183_carry_out_switching_off --> R_209 NULL; ! 1 rule(s)
Array B184_report_switching_off --> R_210 NULL; ! 1 rule(s)
Array B185_check_opening --> R_211 R_212 R_213 NULL; ! 3 rule(s)
Array B186_carry_out_opening --> R_214 R_946 NULL; ! 2 rule(s)
Array B187_report_opening --> R_215 R_216 NULL; ! 2 rule(s)
Array B188_check_closing --> R_217 R_218 NULL; ! 2 rule(s)
Array B189_carry_out_closing --> R_219 NULL; ! 1 rule(s)
Array B190_report_closing --> R_220 NULL; ! 1 rule(s)
Array B191_check_wearing --> R_221 R_222 R_223 NULL; ! 3 rule(s)
Array B192_carry_out_wearing --> R_224 NULL; ! 1 rule(s)
Array B193_report_wearing --> R_225 NULL; ! 1 rule(s)
Array B194_check_taking_off --> R_226 NULL; ! 1 rule(s)
Array B195_carry_out_taking_off --> R_227 NULL; ! 1 rule(s)
Array B196_report_taking_off --> R_228 NULL; ! 1 rule(s)
Array B197_check_giving_it_to --> R_229 R_230 R_231 R_232 R_233 NULL; ! 5 rule(s)
Array B198_carry_out_giving_it_to --> R_234 NULL; ! 1 rule(s)
Array B199_report_giving_it_to --> R_235 NULL; ! 1 rule(s)
Array B200_check_showing_it_to --> R_236 R_237 R_238 NULL; ! 3 rule(s)
Constant B201_carry_out_showing_it_to = EMPTY_RULEBOOK;
Constant B202_report_showing_it_to = EMPTY_RULEBOOK;
Array B203_check_waking --> R_239 NULL; ! 1 rule(s)
Constant B204_carry_out_waking = EMPTY_RULEBOOK;
Constant B205_report_waking = EMPTY_RULEBOOK;
Array B206_check_throwing_it_at --> R_240 R_241 R_242 NULL; ! 3 rule(s)
Constant B207_carry_out_throwing_it_a = EMPTY_RULEBOOK;
Constant B208_report_throwing_it_at = EMPTY_RULEBOOK;
Array B209_check_attacking --> R_243 NULL; ! 1 rule(s)
Array B210_carry_out_attacking --> R_900 NULL; ! 1 rule(s)
Constant B211_report_attacking = EMPTY_RULEBOOK;
Array B212_check_kissing --> R_244 R_245 NULL; ! 2 rule(s)
Constant B213_carry_out_kissing = EMPTY_RULEBOOK;
Constant B214_report_kissing = EMPTY_RULEBOOK;
Constant B215_check_answering_it_that = EMPTY_RULEBOOK;
Array B216_carry_out_answering_it_ --> R_1310 NULL; ! 1 rule(s)
Array B217_report_answering_it_tha --> R_246 NULL; ! 1 rule(s)
Array B218_check_telling_it_about --> R_247 NULL; ! 1 rule(s)
Array B219_carry_out_telling_it_ab --> R_1311 NULL; ! 1 rule(s)
Array B220_report_telling_it_about --> R_248 NULL; ! 1 rule(s)
Constant B221_check_asking_it_about = EMPTY_RULEBOOK;
Array B222_carry_out_asking_it_abo --> R_1308 NULL; ! 1 rule(s)
Array B223_report_asking_it_about --> R_249 NULL; ! 1 rule(s)
Array B224_check_asking_it_for --> R_250 R_251 NULL; ! 2 rule(s)
Constant B225_carry_out_asking_it_for = EMPTY_RULEBOOK;
Constant B226_report_asking_it_for = EMPTY_RULEBOOK;
Constant B227_check_waiting = EMPTY_RULEBOOK;
Constant B228_carry_out_waiting = EMPTY_RULEBOOK;
Array B229_report_waiting --> R_252 NULL; ! 1 rule(s)
Constant B230_check_touching = EMPTY_RULEBOOK;
Constant B231_carry_out_touching = EMPTY_RULEBOOK;
Array B232_report_touching --> R_253 R_254 R_255 NULL; ! 3 rule(s)
Array B233_check_waving --> R_256 NULL; ! 1 rule(s)
Constant B234_carry_out_waving = EMPTY_RULEBOOK;
Array B235_report_waving --> R_257 NULL; ! 1 rule(s)
Array B236_check_pulling --> R_258 R_259 R_260 NULL; ! 3 rule(s)
Constant B237_carry_out_pulling = EMPTY_RULEBOOK;
Array B238_report_pulling --> R_261 NULL; ! 1 rule(s)
Array B239_check_pushing --> R_262 R_263 R_264 NULL; ! 3 rule(s)
Constant B240_carry_out_pushing = EMPTY_RULEBOOK;
Array B241_report_pushing --> R_265 NULL; ! 1 rule(s)
Array B242_check_turning --> R_266 R_267 R_268 NULL; ! 3 rule(s)
Constant B243_carry_out_turning = EMPTY_RULEBOOK;
Array B244_report_turning --> R_269 NULL; ! 1 rule(s)
Array B245_check_pushing_it_to --> R_270 R_271 R_272 R_273 R_274 NULL; ! 5 rule(s)
Constant B246_carry_out_pushing_it_to = EMPTY_RULEBOOK;
Constant B247_report_pushing_it_to = EMPTY_RULEBOOK;
Array B248_check_squeezing --> R_275 NULL; ! 1 rule(s)
Constant B249_carry_out_squeezing = EMPTY_RULEBOOK;
Array B250_report_squeezing --> R_276 NULL; ! 1 rule(s)
Array B251_check_saying_yes --> R_277 NULL; ! 1 rule(s)
Constant B252_carry_out_saying_yes = EMPTY_RULEBOOK;
Constant B253_report_saying_yes = EMPTY_RULEBOOK;
Array B254_check_saying_no --> R_278 NULL; ! 1 rule(s)
Constant B255_carry_out_saying_no = EMPTY_RULEBOOK;
Constant B256_report_saying_no = EMPTY_RULEBOOK;
Array B257_check_burning --> R_279 NULL; ! 1 rule(s)
Constant B258_carry_out_burning = EMPTY_RULEBOOK;
Constant B259_report_burning = EMPTY_RULEBOOK;
Array B260_check_waking_up --> R_280 NULL; ! 1 rule(s)
Constant B261_carry_out_waking_up = EMPTY_RULEBOOK;
Constant B262_report_waking_up = EMPTY_RULEBOOK;
Array B263_check_thinking --> R_281 NULL; ! 1 rule(s)
Constant B264_carry_out_thinking = EMPTY_RULEBOOK;
Array B265_report_thinking --> R_1296 R_1297 R_1295 NULL; ! 3 rule(s)
Array B266_check_smelling --> R_282 NULL; ! 1 rule(s)
Constant B267_carry_out_smelling = EMPTY_RULEBOOK;
Constant B268_report_smelling = EMPTY_RULEBOOK;
Array B269_check_listening_to --> R_283 NULL; ! 1 rule(s)
Array B270_carry_out_listening_to --> R_1272 NULL; ! 1 rule(s)
Constant B271_report_listening_to = EMPTY_RULEBOOK;
Array B272_check_tasting --> R_284 NULL; ! 1 rule(s)
Constant B273_carry_out_tasting = EMPTY_RULEBOOK;
Constant B274_report_tasting = EMPTY_RULEBOOK;
Array B275_check_cutting --> R_285 NULL; ! 1 rule(s)
Constant B276_carry_out_cutting = EMPTY_RULEBOOK;
Constant B277_report_cutting = EMPTY_RULEBOOK;
Array B278_check_jumping --> R_286 NULL; ! 1 rule(s)
Constant B279_carry_out_jumping = EMPTY_RULEBOOK;
Constant B280_report_jumping = EMPTY_RULEBOOK;
Array B281_check_tying_it_to --> R_287 NULL; ! 1 rule(s)
Constant B282_carry_out_tying_it_to = EMPTY_RULEBOOK;
Constant B283_report_tying_it_to = EMPTY_RULEBOOK;
Array B284_check_drinking --> R_288 R_1130 NULL; ! 2 rule(s)
Constant B285_carry_out_drinking = EMPTY_RULEBOOK;
Array B286_report_drinking --> R_1129 NULL; ! 1 rule(s)
Array B287_check_saying_sorry --> R_289 NULL; ! 1 rule(s)
Constant B288_carry_out_saying_sorry = EMPTY_RULEBOOK;
Constant B289_report_saying_sorry = EMPTY_RULEBOOK;
Array B290_check_swearing_obscenel --> R_290 NULL; ! 1 rule(s)
Constant B291_carry_out_swearing_obsc = EMPTY_RULEBOOK;
Constant B292_report_swearing_obscene = EMPTY_RULEBOOK;
Array B293_check_swearing_mildly --> R_291 NULL; ! 1 rule(s)
Constant B294_carry_out_swearing_mild = EMPTY_RULEBOOK;
Constant B295_report_swearing_mildly = EMPTY_RULEBOOK;
Array B296_check_swinging --> R_292 NULL; ! 1 rule(s)
Constant B297_carry_out_swinging = EMPTY_RULEBOOK;
Constant B298_report_swinging = EMPTY_RULEBOOK;
Array B299_check_rubbing --> R_1139 R_1140 R_293 NULL; ! 3 rule(s)
Constant B300_carry_out_rubbing = EMPTY_RULEBOOK;
Constant B301_report_rubbing = EMPTY_RULEBOOK;
Array B302_check_setting_it_to --> R_294 NULL; ! 1 rule(s)
Constant B303_carry_out_setting_it_to = EMPTY_RULEBOOK;
Constant B304_report_setting_it_to = EMPTY_RULEBOOK;
Array B305_check_waving_hands --> R_295 NULL; ! 1 rule(s)
Constant B306_carry_out_waving_hands = EMPTY_RULEBOOK;
Constant B307_report_waving_hands = EMPTY_RULEBOOK;
Array B308_check_buying --> R_296 NULL; ! 1 rule(s)
Constant B309_carry_out_buying = EMPTY_RULEBOOK;
Constant B310_report_buying = EMPTY_RULEBOOK;
Array B311_check_singing --> R_297 NULL; ! 1 rule(s)
Constant B312_carry_out_singing = EMPTY_RULEBOOK;
Constant B313_report_singing = EMPTY_RULEBOOK;
Array B314_check_climbing --> R_298 NULL; ! 1 rule(s)
Array B315_carry_out_climbing --> R_1106 NULL; ! 1 rule(s)
Constant B316_report_climbing = EMPTY_RULEBOOK;
Array B317_check_sleeping --> R_299 NULL; ! 1 rule(s)
Constant B318_carry_out_sleeping = EMPTY_RULEBOOK;
Constant B319_report_sleeping = EMPTY_RULEBOOK;
Array B320_check_quitting_the_game --> R_752 NULL; ! 1 rule(s)
Array B321_carry_out_quitting_the_ --> QUIT_THE_GAME_R NULL; ! 1 rule(s)
Constant B322_report_quitting_the_gam = EMPTY_RULEBOOK;
Constant B323_check_saving_the_game = EMPTY_RULEBOOK;
Array B324_carry_out_saving_the_ga --> SAVE_THE_GAME_R NULL; ! 1 rule(s)
Constant B325_report_saving_the_game = EMPTY_RULEBOOK;
Constant B326_check_restoring_the_gam = EMPTY_RULEBOOK;
Array B327_carry_out_restoring_the --> RESTORE_THE_GAME_R NULL; ! 1 rule(s)
Constant B328_report_restoring_the_ga = EMPTY_RULEBOOK;
Array B329_check_restarting_the_ga --> R_753 NULL; ! 1 rule(s)
Array B330_carry_out_restarting_th --> RESTART_THE_GAME_R NULL; ! 1 rule(s)
Constant B331_report_restarting_the_g = EMPTY_RULEBOOK;
Constant B332_check_verifying_the_sto = EMPTY_RULEBOOK;
Array B333_carry_out_verifying_the --> VERIFY_THE_STORY_FILE_R NULL; ! 1 rule(s)
Constant B334_report_verifying_the_st = EMPTY_RULEBOOK;
Constant B335_check_switching_the_sto = EMPTY_RULEBOOK;
Array B336_carry_out_switching_the --> SWITCH_TRANSCRIPT_ON_R NULL; ! 1 rule(s)
Constant B337_report_switching_the_st = EMPTY_RULEBOOK;
Constant B338_check_switching_the_sto = EMPTY_RULEBOOK;
Array B339_carry_out_switching_the --> SWITCH_TRANSCRIPT_OFF_R NULL; ! 1 rule(s)
Constant B340_report_switching_the_st = EMPTY_RULEBOOK;
Constant B341_check_requesting_the_st = EMPTY_RULEBOOK;
Array B342_carry_out_requesting_th --> ANNOUNCE_STORY_FILE_VERSION_R NULL; ! 1 rule(s)
Constant B343_report_requesting_the_s = EMPTY_RULEBOOK;
Constant B344_check_requesting_the_sc = EMPTY_RULEBOOK;
Array B345_carry_out_requesting_th --> ANNOUNCE_SCORE_R NULL; ! 1 rule(s)
Constant B346_report_requesting_the_s = EMPTY_RULEBOOK;
Constant B347_check_preferring_abbrev = EMPTY_RULEBOOK;
Array B348_carry_out_preferring_ab --> PREFER_ABBREVIATED_R NULL; ! 1 rule(s)
Array B349_report_preferring_abbre --> REP_PREFER_ABBREVIATED_R NULL; ! 1 rule(s)
Constant B350_check_preferring_unabbr = EMPTY_RULEBOOK;
Array B351_carry_out_preferring_un --> PREFER_UNABBREVIATED_R NULL; ! 1 rule(s)
Array B352_report_preferring_unabb --> REP_PREFER_UNABBREVIATED_R NULL; ! 1 rule(s)
Constant B353_check_preferring_someti = EMPTY_RULEBOOK;
Array B354_carry_out_preferring_so --> PREFER_SOMETIMES_ABBREVIATED_R NULL; ! 1 rule(s)
Array B355_report_preferring_somet --> REP_PREFER_SOMETIMES_ABBR_R NULL; ! 1 rule(s)
Constant B356_check_switching_score_n = EMPTY_RULEBOOK;
Array B357_carry_out_switching_sco --> SWITCH_SCORE_NOTIFY_ON_R NULL; ! 1 rule(s)
Array B358_report_switching_score_ --> REP_SWITCH_NOTIFY_ON_R NULL; ! 1 rule(s)
Constant B359_check_switching_score_n = EMPTY_RULEBOOK;
Array B360_carry_out_switching_sco --> SWITCH_SCORE_NOTIFY_OFF_R NULL; ! 1 rule(s)
Array B361_report_switching_score_ --> REP_SWITCH_NOTIFY_OFF_R NULL; ! 1 rule(s)
Constant B362_check_requesting_the_pr = EMPTY_RULEBOOK;
Array B363_carry_out_requesting_th --> ANNOUNCE_PRONOUN_MEANINGS_R NULL; ! 1 rule(s)
Constant B364_report_requesting_the_p = EMPTY_RULEBOOK;
Constant B365_when_uncle_vernon_s_sce = EMPTY_RULEBOOK;
Constant B366_when_uncle_vernon_s_sce = EMPTY_RULEBOOK;
Array B367_check_putting_it_under --> R_745 NULL; ! 1 rule(s)
Array B368_carry_out_putting_it_un --> R_746 NULL; ! 1 rule(s)
Array B369_report_putting_it_under --> R_748 NULL; ! 1 rule(s)
Constant B370_check_getting_under = EMPTY_RULEBOOK;
Constant B371_carry_out_getting_under = EMPTY_RULEBOOK;
Constant B372_report_getting_under = EMPTY_RULEBOOK;
Constant B373_check_going_under = EMPTY_RULEBOOK;
Array B374_carry_out_going_under --> R_765 NULL; ! 1 rule(s)
Constant B375_report_going_under = EMPTY_RULEBOOK;
Constant B376_check_getting_out_from_ = EMPTY_RULEBOOK;
Array B377_carry_out_getting_out_f --> R_767 NULL; ! 1 rule(s)
Constant B378_report_getting_out_from = EMPTY_RULEBOOK;
Array B379_check_mounting --> R_849 R_850 R_851 R_852 R_853 NULL; ! 5 rule(s)
Array B380_carry_out_mounting --> R_854 NULL; ! 1 rule(s)
Array B381_report_mounting --> R_855 NULL; ! 1 rule(s)
Array B382_check_dismounting --> R_857 NULL; ! 1 rule(s)
Array B383_carry_out_dismounting --> R_858 NULL; ! 1 rule(s)
Array B384_report_dismounting --> R_859 NULL; ! 1 rule(s)
Constant B385_before_displaying = EMPTY_RULEBOOK;
Array B386_for_displaying --> R_869 NULL; ! 1 rule(s)
Constant B387_after_displaying = EMPTY_RULEBOOK;
Constant B388_check_asking_for_help = EMPTY_RULEBOOK;
Array B389_carry_out_asking_for_he --> R_893 NULL; ! 1 rule(s)
Constant B390_report_asking_for_help = EMPTY_RULEBOOK;
Array B391_check_switching_cheats_ --> R_911 NULL; ! 1 rule(s)
Constant B392_carry_out_switching_che = EMPTY_RULEBOOK;
Constant B393_report_switching_cheats = EMPTY_RULEBOOK;
Array B394_check_switching_cheats_ --> R_912 NULL; ! 1 rule(s)
Constant B395_carry_out_switching_che = EMPTY_RULEBOOK;
Constant B396_report_switching_cheats = EMPTY_RULEBOOK;
Constant B397_check_teleporting_to = EMPTY_RULEBOOK;
Constant B398_carry_out_teleporting_t = EMPTY_RULEBOOK;
Constant B399_report_teleporting_to = EMPTY_RULEBOOK;
Array B400_check_moving_to --> R_905 R_906 R_907 R_908 NULL; ! 4 rule(s)
Array B401_carry_out_moving_to --> R_909 NULL; ! 1 rule(s)
Constant B402_report_moving_to = EMPTY_RULEBOOK;
Array B403_check_putting_back --> R_922 NULL; ! 1 rule(s)
Array B404_carry_out_putting_back --> R_921 NULL; ! 1 rule(s)
Constant B405_report_putting_back = EMPTY_RULEBOOK;
Constant B406_check_universal_opening = EMPTY_RULEBOOK;
Array B407_carry_out_universal_ope --> R_924 NULL; ! 1 rule(s)
Array B408_report_universal_openin --> R_925 NULL; ! 1 rule(s)
Constant B409_check_changing_player = EMPTY_RULEBOOK;
Constant B410_carry_out_changing_play = EMPTY_RULEBOOK;
Array B411_report_changing_player --> R_926 NULL; ! 1 rule(s)
Constant B412_check_point_increasing = EMPTY_RULEBOOK;
Constant B413_carry_out_point_increas = EMPTY_RULEBOOK;
Constant B414_report_point_increasing = EMPTY_RULEBOOK;
Constant B415_check_restoring_score = EMPTY_RULEBOOK;
Array B416_carry_out_restoring_sco --> R_930 NULL; ! 1 rule(s)
Constant B417_report_restoring_score = EMPTY_RULEBOOK;
Constant B418_check_removing = EMPTY_RULEBOOK;
Array B419_carry_out_removing --> R_931 NULL; ! 1 rule(s)
Constant B420_report_removing = EMPTY_RULEBOOK;
Constant B421_check_paying_wizard_mon = EMPTY_RULEBOOK;
Constant B422_carry_out_paying_wizard = EMPTY_RULEBOOK;
Constant B423_report_paying_wizard_mo = EMPTY_RULEBOOK;
Constant B424_check_inputting = EMPTY_RULEBOOK;
Array B425_carry_out_inputting --> R_940 R_941 R_942 R_943 NULL; ! 4 rule(s)
Array B426_report_inputting --> R_944 NULL; ! 1 rule(s)
Constant B427_check_requesting_it_for = EMPTY_RULEBOOK;
Constant B428_carry_out_requesting_it = EMPTY_RULEBOOK;
Constant B429_report_requesting_it_fo = EMPTY_RULEBOOK;
Constant B430_check_imploring_it_for = EMPTY_RULEBOOK;
Array B431_carry_out_imploring_it_ --> R_1309 NULL; ! 1 rule(s)
Constant B432_report_imploring_it_for = EMPTY_RULEBOOK;
Array B433_check_quizzing_it_about --> R_992 NULL; ! 1 rule(s)
Constant B434_carry_out_quizzing_it_a = EMPTY_RULEBOOK;
Array B435_report_quizzing_it_abou --> R_951 NULL; ! 1 rule(s)
Array B436_check_informing_it_abou --> R_993 NULL; ! 1 rule(s)
Constant B437_carry_out_informing_it_ = EMPTY_RULEBOOK;
Array B438_report_informing_it_abo --> R_950 NULL; ! 1 rule(s)
Constant B439_check_implicit_asking = EMPTY_RULEBOOK;
Constant B440_carry_out_implicit_aski = EMPTY_RULEBOOK;
Constant B441_report_implicit_asking = EMPTY_RULEBOOK;
Constant B442_check_implicit_telling = EMPTY_RULEBOOK;
Constant B443_carry_out_implicit_tell = EMPTY_RULEBOOK;
Constant B444_report_implicit_telling = EMPTY_RULEBOOK;
Constant B445_check_implicit_quizzing = EMPTY_RULEBOOK;
Constant B446_carry_out_implicit_quiz = EMPTY_RULEBOOK;
Constant B447_report_implicit_quizzin = EMPTY_RULEBOOK;
Constant B448_check_implicit_informin = EMPTY_RULEBOOK;
Constant B449_carry_out_implicit_info = EMPTY_RULEBOOK;
Constant B450_report_implicit_informi = EMPTY_RULEBOOK;
Constant B451_check_implicit_requesti = EMPTY_RULEBOOK;
Constant B452_carry_out_implicit_requ = EMPTY_RULEBOOK;
Constant B453_report_implicit_request = EMPTY_RULEBOOK;
Constant B454_check_implicit_implorin = EMPTY_RULEBOOK;
Constant B455_carry_out_implicit_impl = EMPTY_RULEBOOK;
Constant B456_report_implicit_implori = EMPTY_RULEBOOK;
Array B457_check_saying_hello_to --> R_967 NULL; ! 1 rule(s)
Array B458_carry_out_saying_hello_ --> R_1280 R_968 NULL; ! 2 rule(s)
Array B459_report_saying_hello_to --> R_970 R_969 NULL; ! 2 rule(s)
Array B460_check_hailing --> R_972 NULL; ! 1 rule(s)
Array B461_carry_out_hailing --> R_973 NULL; ! 1 rule(s)
Constant B462_report_hailing = EMPTY_RULEBOOK;
Array B463_check_leavetaking --> R_979 NULL; ! 1 rule(s)
Array B464_carry_out_leavetaking --> R_982 R_980 NULL; ! 2 rule(s)
Constant B465_report_leavetaking = EMPTY_RULEBOOK;
Array B466_check_saying_goodbye_to --> R_977 NULL; ! 1 rule(s)
Array B467_carry_out_saying_goodby --> R_978 NULL; ! 1 rule(s)
Array B468_report_saying_goodbye_t --> R_983 NULL; ! 1 rule(s)
Array B469_glulx_timed_activity --> R_1017 NULL; ! 1 rule(s)
Constant B470_glulx_redrawing = EMPTY_RULEBOOK;
Constant B471_glulx_arranging = EMPTY_RULEBOOK;
Constant B472_glulx_sound_notificatio = EMPTY_RULEBOOK;
Constant B473_glulx_mouse_input = EMPTY_RULEBOOK;
Constant B474_glulx_character_input = EMPTY_RULEBOOK;
Constant B475_glulx_line_input = EMPTY_RULEBOOK;
Constant B476_glulx_hyperlink = EMPTY_RULEBOOK;
Constant B477_glulx_zeroing_reference = EMPTY_RULEBOOK;
Constant B478_glulx_resetting_windows = EMPTY_RULEBOOK;
Constant B479_glulx_resetting_streams = EMPTY_RULEBOOK;
Constant B480_glulx_resetting_fileref = EMPTY_RULEBOOK;
Constant B481_glulx_object_updating = EMPTY_RULEBOOK;
Array B482_command_counting --> R_1009 NULL; ! 1 rule(s)
Array B483_input_cancelling --> R_1010 NULL; ! 1 rule(s)
Array B484_command_showing --> R_1013 NULL; ! 1 rule(s)
Array B485_command_pasting --> R_1015 NULL; ! 1 rule(s)
Array B486_check_dialling_it_on --> R_1023 R_1024 R_1025 R_1026 NULL; ! 4 rule(s)
Array B487_carry_out_dialling_it_o --> R_1027 NULL; ! 1 rule(s)
Array B488_report_dialling_it_on --> R_1028 NULL; ! 1 rule(s)
Array B489_check_hanging_up --> R_1036 NULL; ! 1 rule(s)
Array B490_carry_out_hanging_up --> R_1037 NULL; ! 1 rule(s)
Array B491_report_hanging_up --> R_1038 NULL; ! 1 rule(s)
Constant B492_check_sitting_on = EMPTY_RULEBOOK;
Array B493_carry_out_sitting_on --> R_1042 NULL; ! 1 rule(s)
Constant B494_report_sitting_on = EMPTY_RULEBOOK;
Constant B495_check_lying_on = EMPTY_RULEBOOK;
Array B496_carry_out_lying_on --> R_1043 NULL; ! 1 rule(s)
Constant B497_report_lying_on = EMPTY_RULEBOOK;
Constant B498_check_standing_up_on = EMPTY_RULEBOOK;
Array B499_carry_out_standing_up_o --> R_1044 NULL; ! 1 rule(s)
Constant B500_report_standing_up_on = EMPTY_RULEBOOK;
Constant B501_check_lying_down = EMPTY_RULEBOOK;
Constant B502_carry_out_lying_down = EMPTY_RULEBOOK;
Constant B503_report_lying_down = EMPTY_RULEBOOK;
Constant B504_check_sitting_down = EMPTY_RULEBOOK;
Constant B505_carry_out_sitting_down = EMPTY_RULEBOOK;
Constant B506_report_sitting_down = EMPTY_RULEBOOK;
Constant B507_check_standing_up = EMPTY_RULEBOOK;
Constant B508_carry_out_standing_up = EMPTY_RULEBOOK;
Constant B509_report_standing_up = EMPTY_RULEBOOK;
Array B510_check_taking_position --> R_1056 R_1057 NULL; ! 2 rule(s)
Array B511_carry_out_taking_positi --> R_1058 NULL; ! 1 rule(s)
Array B512_report_taking_position --> R_1059 R_1060 NULL; ! 2 rule(s)
Array B513_after_not --> R_1148 R_1147 NULL; ! 2 rule(s)
Constant B514_check_asking_for_hints = EMPTY_RULEBOOK;
Array B515_carry_out_asking_for_hi --> R_1092 NULL; ! 1 rule(s)
Constant B516_report_asking_for_hints = EMPTY_RULEBOOK;
Constant B517_check_getting_out = EMPTY_RULEBOOK;
Constant B518_carry_out_getting_out = EMPTY_RULEBOOK;
Constant B519_report_getting_out = EMPTY_RULEBOOK;
Constant B520_when_work_begins = EMPTY_RULEBOOK;
Constant B521_when_work_ends = EMPTY_RULEBOOK;
Array B522_check_carjacking --> R_1171 NULL; ! 1 rule(s)
Constant B523_carry_out_carjacking = EMPTY_RULEBOOK;
Constant B524_report_carjacking = EMPTY_RULEBOOK;
Constant B525_check_using = EMPTY_RULEBOOK;
Array B526_carry_out_using --> R_1183 NULL; ! 1 rule(s)
Array B527_report_using --> R_1100 R_1101 R_1329 R_1330 R_1181 NULL; ! 5 rule(s)
Constant B528_when_customercall_begin = EMPTY_RULEBOOK;
Constant B529_when_customercall_ends = EMPTY_RULEBOOK;
Constant B530_check_responding_to_cus = EMPTY_RULEBOOK;
Array B531_carry_out_responding_to --> R_1197 R_1231 NULL; ! 2 rule(s)
Array B532_report_responding_to_cu --> R_1232 NULL; ! 1 rule(s)
Constant B533_check_saying = EMPTY_RULEBOOK;
Array B534_carry_out_saying --> R_1208 NULL; ! 1 rule(s)
Constant B535_report_saying = EMPTY_RULEBOOK;
Constant B536_check_flipping = EMPTY_RULEBOOK;
Array B537_carry_out_flipping --> R_1216 R_1217 NULL; ! 2 rule(s)
Constant B538_report_flipping = EMPTY_RULEBOOK;
Constant B539_when_mrmason_call_begin = EMPTY_RULEBOOK;
Constant B540_when_mrmason_call_ends = EMPTY_RULEBOOK;
Constant B541_check_writing_intro = EMPTY_RULEBOOK;
Array B542_carry_out_writing_intro --> R_1238 NULL; ! 1 rule(s)
Constant B543_report_writing_intro = EMPTY_RULEBOOK;
Constant B544_check_writing_on = EMPTY_RULEBOOK;
Array B545_carry_out_writing_on --> R_1239 NULL; ! 1 rule(s)
Constant B546_report_writing_on = EMPTY_RULEBOOK;
Constant B547_check_clearing_the_scre = EMPTY_RULEBOOK;
Array B548_carry_out_clearing_the_ --> R_1245 NULL; ! 1 rule(s)
Constant B549_report_clearing_the_scr = EMPTY_RULEBOOK;
Constant B550_check_wanting = EMPTY_RULEBOOK;
Constant B551_carry_out_wanting = EMPTY_RULEBOOK;
Constant B552_report_wanting = EMPTY_RULEBOOK;
Constant B553_check_playing = EMPTY_RULEBOOK;
Constant B554_carry_out_playing = EMPTY_RULEBOOK;
Array B555_report_playing --> R_1287 R_1286 NULL; ! 2 rule(s)
Constant B556_check_thanking = EMPTY_RULEBOOK;
Array B557_carry_out_thanking --> R_1312 NULL; ! 1 rule(s)
Constant B558_report_thanking = EMPTY_RULEBOOK;
Constant B559_check_thanking_with_no_ = EMPTY_RULEBOOK;
Constant B560_carry_out_thanking_with = EMPTY_RULEBOOK;
Constant B561_report_thanking_with_no = EMPTY_RULEBOOK;
Array B562_when_living_room_cut_sc --> R_1315 NULL; ! 1 rule(s)
Constant B563_when_living_room_cut_sc = EMPTY_RULEBOOK;
Constant B564_check_dursley_s_spellca = EMPTY_RULEBOOK;
Array B565_carry_out_dursley_s_spe --> R_1328 R_1325 NULL; ! 2 rule(s)
Constant B566_report_dursley_s_spellc = EMPTY_RULEBOOK;
Constant B567_check_jumping_out_of = EMPTY_RULEBOOK;
Array B568_carry_out_jumping_out_o --> R_1334 R_1335 NULL; ! 2 rule(s)
Constant B569_report_jumping_out_of = EMPTY_RULEBOOK;
Constant B570_check_timing = EMPTY_RULEBOOK;
Array B571_carry_out_timing --> R_1337 NULL; ! 1 rule(s)
Constant B572_report_timing = EMPTY_RULEBOOK;

Constant BR_0 = R_8;
Constant BR_1 = R_9;
Constant BR_2 = R_10;
Constant BR_3 = R_11;
Constant BR_4 = R_12;
Constant BR_5 = R_13;
Constant BR_6 = R_16;
Constant BR_7 = R_17;
Constant BR_8 = R_18;
Constant BR_9 = R_19;
Constant BR_10 = R_20;
Constant BR_11 = R_21;
Constant BR_12 = R_22;
Constant BR_13 = R_23;
Constant BR_14 = R_24;
Constant BR_15 = R_25;
Constant BR_16 = R_26;
Constant BR_17 = R_27;
Constant BR_18 = R_28;
Constant BR_19 = R_29;
Constant BR_20 = R_31;
Constant BR_21 = R_32;
Constant BR_22 = R_33;
Constant BR_23 = R_34;
Constant BR_24 = R_35;
Constant BR_25 = R_36;
Constant BR_26 = R_57;
Constant BR_27 = R_58;
Constant BR_28 = R_59;
Constant BR_29 = R_60;
Constant BR_30 = R_61;
Constant BR_31 = R_62;
Constant BR_32 = R_63;
Constant BR_33 = R_64;
Constant BR_34 = R_65;
Constant BR_35 = R_66;
Constant BR_36 = R_67;
Constant BR_37 = R_68;
Constant BR_38 = R_69;
Constant BR_39 = R_70;
Constant BR_40 = R_73;
Constant BR_41 = R_74;
Constant BR_42 = R_75;
Constant BR_43 = R_76;
Constant BR_44 = R_77;
Constant BR_45 = R_78;
Constant BR_46 = R_79;
Constant BR_47 = R_80;
Constant BR_48 = R_81;
Constant BR_49 = R_82;
Constant BR_50 = R_83;
Constant BR_51 = R_85;
Constant BR_52 = R_86;
Constant BR_53 = R_87;
Constant BR_54 = R_88;
Constant BR_55 = R_89;
Constant BR_56 = R_90;
Constant BR_57 = R_91;
Constant BR_58 = R_92;
Constant BR_59 = R_93;
Constant BR_60 = R_94;
Constant BR_61 = R_95;
Constant BR_62 = R_96;
Constant BR_63 = R_97;
Constant BR_64 = R_98;
Constant BR_65 = R_99;
Constant BR_66 = R_100;
Constant BR_67 = R_101;
Constant BR_68 = R_102;
Constant BR_69 = R_103;
Constant BR_70 = R_104;
Constant BR_71 = R_105;
Constant BR_72 = R_106;
Constant BR_73 = R_107;
Constant BR_74 = R_108;
Constant BR_75 = R_109;
Constant BR_76 = R_110;
Constant BR_77 = R_111;
Constant BR_78 = R_112;
Constant BR_79 = R_113;
Constant BR_80 = R_114;
Constant BR_81 = R_115;
Constant BR_82 = R_116;
Constant BR_83 = R_117;
Constant BR_84 = R_118;
Constant BR_85 = R_119;
Constant BR_86 = R_120;
Constant BR_87 = R_121;
Constant BR_88 = R_122;
Constant BR_89 = R_123;
Constant BR_90 = R_124;
Constant BR_91 = R_125;
Constant BR_92 = R_126;
Constant BR_93 = R_127;
Constant BR_94 = R_128;
Constant BR_95 = R_129;
Constant BR_96 = R_130;
Constant BR_97 = R_131;
Constant BR_98 = R_132;
Constant BR_99 = R_133;
Constant BR_100 = R_134;
Constant BR_101 = R_135;
Constant BR_102 = R_136;
Constant BR_103 = R_137;
Constant BR_104 = R_138;
Constant BR_105 = R_139;
Constant BR_106 = R_140;
Constant BR_107 = R_141;
Constant BR_108 = R_142;
Constant BR_109 = R_143;
Constant BR_110 = R_144;
Constant BR_111 = R_145;
Constant BR_112 = R_146;
Constant BR_113 = R_147;
Constant BR_114 = R_148;
Constant BR_115 = R_149;
Constant BR_116 = R_150;
Constant BR_117 = R_151;
Constant BR_118 = R_152;
Constant BR_119 = R_153;
Constant BR_120 = R_154;
Constant BR_121 = R_155;
Constant BR_122 = R_156;
Constant BR_123 = R_157;
Constant BR_124 = R_158;
Constant BR_125 = R_160;
Constant BR_126 = R_161;
Constant BR_127 = R_162;
Constant BR_128 = R_163;
Constant BR_129 = R_164;
Constant BR_130 = R_165;
Constant BR_131 = R_166;
Constant BR_132 = R_167;
Constant BR_133 = R_168;
Constant BR_134 = R_169;
Constant BR_135 = R_170;
Constant BR_136 = R_171;
Constant BR_137 = R_172;
Constant BR_138 = R_173;
Constant BR_139 = R_174;
Constant BR_140 = R_175;
Constant BR_141 = R_176;
Constant BR_142 = R_177;
Constant BR_143 = R_178;
Constant BR_144 = R_179;
Constant BR_145 = R_180;
Constant BR_146 = R_181;
Constant BR_147 = R_182;
Constant BR_148 = R_183;
Constant BR_149 = R_184;
Constant BR_150 = R_185;
Constant BR_151 = R_186;
Constant BR_152 = R_187;
Constant BR_153 = R_188;
Constant BR_154 = R_189;
Constant BR_155 = R_190;
Constant BR_156 = R_191;
Constant BR_157 = R_192;
Constant BR_158 = R_193;
Constant BR_159 = R_194;
Constant BR_160 = R_195;
Constant BR_161 = R_196;
Constant BR_162 = R_197;
Constant BR_163 = R_198;
Constant BR_164 = R_199;
Constant BR_165 = R_200;
Constant BR_166 = R_201;
Constant BR_167 = R_202;
Constant BR_168 = R_203;
Constant BR_169 = R_204;
Constant BR_170 = R_205;
Constant BR_171 = R_206;
Constant BR_172 = R_207;
Constant BR_173 = R_208;
Constant BR_174 = R_209;
Constant BR_175 = R_210;
Constant BR_176 = R_211;
Constant BR_177 = R_212;
Constant BR_178 = R_213;
Constant BR_179 = R_214;
Constant BR_180 = R_215;
Constant BR_181 = R_216;
Constant BR_182 = R_217;
Constant BR_183 = R_218;
Constant BR_184 = R_219;
Constant BR_185 = R_220;
Constant BR_186 = R_221;
Constant BR_187 = R_222;
Constant BR_188 = R_223;
Constant BR_189 = R_224;
Constant BR_190 = R_225;
Constant BR_191 = R_226;
Constant BR_192 = R_227;
Constant BR_193 = R_228;
Constant BR_194 = R_229;
Constant BR_195 = R_230;
Constant BR_196 = R_231;
Constant BR_197 = R_232;
Constant BR_198 = R_233;
Constant BR_199 = R_234;
Constant BR_200 = R_235;
Constant BR_201 = R_236;
Constant BR_202 = R_237;
Constant BR_203 = R_238;
Constant BR_204 = R_239;
Constant BR_205 = R_240;
Constant BR_206 = R_241;
Constant BR_207 = R_242;
Constant BR_208 = R_243;
Constant BR_209 = R_244;
Constant BR_210 = R_245;
Constant BR_211 = R_246;
Constant BR_212 = R_247;
Constant BR_213 = R_248;
Constant BR_214 = R_249;
Constant BR_215 = R_250;
Constant BR_216 = R_251;
Constant BR_217 = R_252;
Constant BR_218 = R_253;
Constant BR_219 = R_254;
Constant BR_220 = R_255;
Constant BR_221 = R_256;
Constant BR_222 = R_257;
Constant BR_223 = R_258;
Constant BR_224 = R_259;
Constant BR_225 = R_260;
Constant BR_226 = R_261;
Constant BR_227 = R_262;
Constant BR_228 = R_263;
Constant BR_229 = R_264;
Constant BR_230 = R_265;
Constant BR_231 = R_266;
Constant BR_232 = R_267;
Constant BR_233 = R_268;
Constant BR_234 = R_269;
Constant BR_235 = R_270;
Constant BR_236 = R_271;
Constant BR_237 = R_272;
Constant BR_238 = R_273;
Constant BR_239 = R_274;
Constant BR_240 = R_275;
Constant BR_241 = R_276;
Constant BR_242 = R_277;
Constant BR_243 = R_278;
Constant BR_244 = R_279;
Constant BR_245 = R_280;
Constant BR_246 = R_281;
Constant BR_247 = R_282;
Constant BR_248 = R_283;
Constant BR_249 = R_284;
Constant BR_250 = R_285;
Constant BR_251 = R_286;
Constant BR_252 = R_287;
Constant BR_253 = R_288;
Constant BR_254 = R_289;
Constant BR_255 = R_290;
Constant BR_256 = R_291;
Constant BR_257 = R_292;
Constant BR_258 = R_293;
Constant BR_259 = R_294;
Constant BR_260 = R_295;
Constant BR_261 = R_296;
Constant BR_262 = R_297;
Constant BR_263 = R_298;
Constant BR_264 = R_299;
Constant BR_265 = R_772;
Constant BR_266 = R_837;
Constant BR_267 = R_838;
Constant BR_268 = R_843;
Constant BR_269 = R_849;
Constant BR_270 = R_850;
Constant BR_271 = R_851;
Constant BR_272 = R_852;
Constant BR_273 = R_853;
Constant BR_274 = R_854;
Constant BR_275 = R_855;
Constant BR_276 = R_856;
Constant BR_277 = R_857;
Constant BR_278 = R_858;
Constant BR_279 = R_859;
Constant BR_280 = R_860;
Constant BR_281 = R_862;
Constant BR_282 = R_863;
Constant BR_283 = R_864;
Constant BR_284 = R_865;
Constant BR_285 = R_869;
Constant BR_286 = R_870;
Constant BR_287 = R_873;
Constant BR_288 = R_891;
Constant BR_289 = R_945;
Constant BR_290 = R_946;
Constant BR_291 = R_947;
Constant BR_292 = R_950;
Constant BR_293 = R_951;
Constant BR_294 = R_952;
Constant BR_295 = R_953;
Constant BR_296 = R_954;
Constant BR_297 = R_955;
Constant BR_298 = R_962;
Constant BR_299 = R_963;
Constant BR_300 = R_964;
Constant BR_301 = R_965;
Constant BR_302 = R_967;
Constant BR_303 = R_968;
Constant BR_304 = R_969;
Constant BR_305 = R_970;
Constant BR_306 = R_971;
Constant BR_307 = R_972;
Constant BR_308 = R_973;
Constant BR_309 = R_974;
Constant BR_310 = R_977;
Constant BR_311 = R_978;
Constant BR_312 = R_979;
Constant BR_313 = R_980;
Constant BR_314 = R_981;
Constant BR_315 = R_982;
Constant BR_316 = R_983;
Constant BR_317 = R_984;
Constant BR_318 = R_985;
Constant BR_319 = R_986;
Constant BR_320 = R_987;
Constant BR_321 = R_988;
Constant BR_322 = R_989;
Constant BR_323 = R_990;
Constant BR_324 = R_991;
Constant BR_325 = R_992;
Constant BR_326 = R_993;
Constant BR_327 = R_1009;
Constant BR_328 = R_1010;
Constant BR_329 = R_1013;
Constant BR_330 = R_1015;
Constant BR_331 = R_1017;
Constant BR_332 = R_1022;
Constant BR_333 = R_1023;
Constant BR_334 = R_1024;
Constant BR_335 = R_1025;
Constant BR_336 = R_1026;
Constant BR_337 = R_1027;
Constant BR_338 = R_1028;
Constant BR_339 = R_1029;
Constant BR_340 = R_1030;
Constant BR_341 = R_1031;
Constant BR_342 = R_1034;
Constant BR_343 = R_1035;
Constant BR_344 = R_1036;
Constant BR_345 = R_1037;
Constant BR_346 = R_1038;
Constant BR_347 = R_1039;
Constant BR_348 = R_1040;
Constant BR_349 = R_1042;
Constant BR_350 = R_1043;
Constant BR_351 = R_1044;
Constant BR_352 = R_1046;
Constant BR_353 = R_1048;
Constant BR_354 = R_1049;
Constant BR_355 = R_1050;
Constant BR_356 = R_1051;
Constant BR_357 = R_1052;
Constant BR_358 = R_1053;
Constant BR_359 = R_1054;
Constant BR_360 = R_1055;
Constant BR_361 = R_1056;
Constant BR_362 = R_1057;
Constant BR_363 = R_1058;
Constant BR_364 = R_1059;
Constant BR_365 = R_1060;
Constant BR_366 = R_1062;
Constant BR_367 = R_1063;
Constant BR_368 = R_1064;
Constant BR_369 = R_1065;
Constant BR_1333 = R_8;
Constant BR_1339 = R_9;
Constant BR_1340 = R_10;
Constant BR_1341 = R_11;
Constant BR_1342 = R_12;
Constant BR_1350 = R_16;
Constant BR_1351 = R_17;
Constant BR_1353 = R_18;
Constant BR_1356 = R_21;
Constant BR_1357 = R_19;
Constant BR_1358 = R_20;
Constant BR_1362 = R_22;
Constant BR_1366 = R_23;
Constant BR_1372 = R_35;
Constant BR_1374 = R_59;
Constant BR_1375 = R_60;
Constant BR_1377 = R_61;
Constant BR_1382 = R_69;
Constant BR_1383 = R_68;
Constant BR_1385 = R_70;
Constant BR_1386 = R_91;
Constant BR_1387 = R_148;
Constant BR_1408 = R_837;
Constant BR_1409 = R_946;
Constant BR_1410 = R_971;
Constant BR_1411 = R_984;
Constant BR_1412 = R_1062;
Constant BR_1413 = R_1062;
Constant BR_1414 = R_1063;



[ DetectSceneChange 
    chs sc ch ! Used for scene searches
    ;
if (scene_status-->0 == 1) {
        if ((( (deadflag~=0) ))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Entire Game' ends]^";
            if (GProperty(39, 1, p57_recurring)) scene_status-->0 = 0; else scene_status-->0 = 2; ProcessRulebook(WHEN_SCENE_ENDS_RB, 1);
            ProcessRulebook(28);
            scene_ended-->0 = the_time;
            scene_endings-->0 = (scene_endings-->0)|2;
            scene_latest_ending-->0 = 1;
            jump CScene;
        }
    }
    if (scene_status-->0 == 0) {
        if ((( (deadflag==0) ))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Entire Game' begins]^";
            scene_status-->0 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 1);
            ProcessRulebook(27);
            scene_started-->0 = the_time;
            scene_endings-->0 = (scene_endings-->0)|1;
            scene_latest_ending-->0 = 0;
            jump CScene;
        }
    }
    if (scene_status-->1 == 1) {
        if ((((GProperty(SCENE_TY, I92_uncle_vernon_s_scene,p80_venture) == I266_success)))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Uncle Vernon's Scene' ends]^";
            if (GProperty(39, 2, p57_recurring)) scene_status-->1 = 0; else scene_status-->1 = 2; ProcessRulebook(WHEN_SCENE_ENDS_RB, 2);
            ProcessRulebook(366);
            scene_ended-->1 = the_time;
            scene_endings-->1 = (scene_endings-->1)|2;
            scene_latest_ending-->1 = 1;
            jump CScene;
        }
    }
    if (scene_status-->1 == 0) {
        if (((scene_endings-->1) & 1) == 0) {
            if (debug_scenes) print "[Scene 'Uncle Vernon's Scene' begins]^";
            scene_status-->1 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 2);
            ProcessRulebook(365);
            scene_started-->1 = the_time;
            scene_endings-->1 = (scene_endings-->1)|1;
            scene_latest_ending-->1 = 0;
        }
    }
    if (scene_status-->2 == 1) {
        if ((((GProperty(SCENE_TY, I238_work,p80_venture) == I266_success)))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Work' ends]^";
            if (GProperty(39, 3, p57_recurring)) scene_status-->2 = 0; else scene_status-->2 = 2; ProcessRulebook(WHEN_SCENE_ENDS_RB, 3);
            ProcessRulebook(521);
            scene_ended-->2 = the_time;
            scene_endings-->2 = (scene_endings-->2)|2;
            scene_latest_ending-->2 = 1;
            jump CScene;
        }
    }
    if (scene_status-->2 == 0) {
        if ((((~~((TestRegionalContainment(player,I99_dursley_s_house))))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Work' begins]^";
            scene_status-->2 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 3);
            ProcessRulebook(520);
            scene_started-->2 = the_time;
            scene_endings-->2 = (scene_endings-->2)|1;
            scene_latest_ending-->2 = 0;
            jump CScene;
        }
    }
    if (scene_status-->3 == 1) {
        if ((((~~((GProperty(SCENE_TY, I264_customercall,p80_venture) == I268_incomplete)))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'customercall' ends]^";
            if (GProperty(39, 4, p57_recurring)) scene_status-->3 = 0; else scene_status-->3 = 2; ProcessRulebook(WHEN_SCENE_ENDS_RB, 4);
            ProcessRulebook(529);
            scene_ended-->3 = the_time;
            scene_endings-->3 = (scene_endings-->3)|2;
            scene_latest_ending-->3 = 1;
            jump CScene;
        }
    }
    if (scene_status-->3 == 0) {
        if (((((Global_Vars-->71) == 1)))) {
            ch = true;
            if (debug_scenes) print "[Scene 'customercall' begins]^";
            scene_status-->3 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 4);
            ProcessRulebook(528);
            scene_started-->3 = the_time;
            scene_endings-->3 = (scene_endings-->3)|1;
            scene_latest_ending-->3 = 0;
            jump CScene;
        }
    }
    if (scene_status-->4 == 1) {
        if ((((~~((GProperty(SCENE_TY, I276_mrmason_call,p80_venture) == I268_incomplete)))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Mrmason call' ends]^";
            if (GProperty(39, 5, p57_recurring)) scene_status-->4 = 0; else scene_status-->4 = 2; ProcessRulebook(WHEN_SCENE_ENDS_RB, 5);
            ProcessRulebook(540);
            scene_ended-->4 = the_time;
            scene_endings-->4 = (scene_endings-->4)|2;
            scene_latest_ending-->4 = 1;
            jump CScene;
        }
    }
    if (scene_status-->4 == 0) {
        if (((((Adj_89_t1_v9(I258_office_phone)))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Mrmason call' begins]^";
            scene_status-->4 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 5);
            ProcessRulebook(539);
            scene_started-->4 = the_time;
            scene_endings-->4 = (scene_endings-->4)|1;
            scene_latest_ending-->4 = 0;
            jump CScene;
        }
    }
    if (scene_status-->5 == 1) {
        if ((((GProperty(SCENE_TY, I328_living_room_cut_scene,p80_venture) == I266_success)))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Living-room cut scene' ends]^";
            if (GProperty(39, 6, p57_recurring)) scene_status-->5 = 0; else scene_status-->5 = 2; ProcessRulebook(WHEN_SCENE_ENDS_RB, 6);
            ProcessRulebook(563);
            scene_ended-->5 = the_time;
            scene_endings-->5 = (scene_endings-->5)|2;
            scene_latest_ending-->5 = 1;
            jump CScene;
        }
    }
    if (scene_status-->5 == 0) {
        if ((((GProperty(SCENE_TY, I328_living_room_cut_scene,p80_venture) == I270_half_complete)))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Living-room cut scene' begins]^";
            scene_status-->5 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 6);
            ProcessRulebook(562);
            scene_started-->5 = the_time;
            scene_endings-->5 = (scene_endings-->5)|1;
            scene_latest_ending-->5 = 0;
            jump CScene;
        }
    }
    .CScene;
    if (chs>20) ">--> The scene change machinery is stuck.";

    if (ch>0) DetectSceneChange(++chs);

    rfalse;
];

#IFDEF DEBUG;
[ ShowSceneStatus chs sc ch;
    if (scene_status-->0 == 1) {
        print "Scene 'Entire Game' playing (for ", the_time-(scene_started-->0), " mins now)^";
    } else {
        if (scene_latest_ending-->0 > 0) {
            print "Scene 'Entire Game' ended";
            print "^";
        }
    }
    if (scene_status-->1 == 1) {
        print "Scene 'Uncle Vernon's Scene' playing (for ", the_time-(scene_started-->1), " mins now)^";
    } else {
        if (scene_latest_ending-->1 > 0) {
            print "Scene 'Uncle Vernon's Scene' ended";
            print "^";
        }
    }
    if (scene_status-->2 == 1) {
        print "Scene 'Work' playing (for ", the_time-(scene_started-->2), " mins now)^";
    } else {
        if (scene_latest_ending-->2 > 0) {
            print "Scene 'Work' ended";
            print "^";
        }
    }
    if (scene_status-->3 == 1) {
        print "Scene 'customercall' playing (for ", the_time-(scene_started-->3), " mins now)^";
    } else {
        if (scene_latest_ending-->3 > 0) {
            print "Scene 'customercall' ended";
            print "^";
        }
    }
    if (scene_status-->4 == 1) {
        print "Scene 'Mrmason call' playing (for ", the_time-(scene_started-->4), " mins now)^";
    } else {
        if (scene_latest_ending-->4 > 0) {
            print "Scene 'Mrmason call' ended";
            print "^";
        }
    }
    if (scene_status-->5 == 1) {
        print "Scene 'Living-room cut scene' playing (for ", the_time-(scene_started-->5), " mins now)^";
    } else {
        if (scene_latest_ending-->5 > 0) {
            print "Scene 'Living-room cut scene' ended";
            print "^";
        }
    }
];


#ENDIF;



Constant AD_ACTION = 0; ! The I6 action number (0 to 4095)
Constant AD_REQUIREMENTS = 1; ! Such as requiring light; a bitmap, see below
Constant AD_NOUN_KOV = 2; ! Kind of value of the first noun
Constant AD_SECOND_KOV = 3; ! Kind of value of the second noun
Constant AD_VARIABLES_CREATOR = 4; ! Routine to initialise variables owned
Constant AD_VARIABLES_ID = 5; ! Frame ID for variables owned by action

Constant AD_RECORD_SIZE = 6;

[ FindAction fa t;
	if (fa == -1) fa = action;
	t = 1;
	while (t <= ActionData-->0) {
		if (fa == ActionData-->t) return t;
		t = t + AD_RECORD_SIZE;
	}
	rfalse;
];

[ ActionNumberIndexed i;
	if ((i>=0) && (i < AD_RECORDS)) return ActionData-->(i*AD_RECORD_SIZE + AD_ACTION + 1);
	return 0;
];

Constant TOUCH_NOUN_ABIT   = $$00000001;
Constant TOUCH_SECOND_ABIT = $$00000010;
Constant LIGHT_ABIT        = $$00000100;
Constant NEED_NOUN_ABIT    = $$00001000;
Constant NEED_SECOND_ABIT  = $$00010000;
Constant OUT_OF_WORLD_ABIT = $$00100000;
Constant CARRY_NOUN_ABIT   = $$01000000;
Constant CARRY_SECOND_ABIT = $$10000000;

[ NeedToCarryNoun;       return TestActionMask(CARRY_NOUN_ABIT); ];
[ NeedToCarrySecondNoun; return TestActionMask(CARRY_SECOND_ABIT); ];
[ NeedToTouchNoun;       return TestActionMask(TOUCH_NOUN_ABIT); ];
[ NeedToTouchSecondNoun; return TestActionMask(TOUCH_SECOND_ABIT); ];
[ NeedLightForAction;    return TestActionMask(LIGHT_ABIT); ];

[ TestActionMask match mask at; 
	at = FindAction(-1); 
	if (at == 0) rfalse; 
	mask = ActionData-->(at+AD_REQUIREMENTS); 
	if (mask & match) rtrue; 
	rfalse; 
];

[ TryAction req by ac n s stora smeta tbits saved_command text_of_command;
	if (stora) return STORED_ACTION_TY_New(ac, n, s, by, req, stora);
	tbits = req & (16+32);
	req = req & 1;
	@push actor; @push act_requester; @push inp1; @push inp2;
	@push parsed_number; smeta = meta;
	actor = by; if (req) act_requester = player; else act_requester = 0;

	by = FindAction(ac);
	if (by) {
		if (ActionData-->(by+AD_NOUN_KOV) == OBJECT_TY) inp1 = n;
		else { inp1 = 1; parsed_number = n; }
		if (ActionData-->(by+AD_SECOND_KOV) == OBJECT_TY) inp2 = s;
		else { inp2 = 1; parsed_number = s; }
		if (((ActionData-->(by+AD_NOUN_KOV) == UNDERSTANDING_TY) ||
			(ActionData-->(by+AD_SECOND_KOV) == UNDERSTANDING_TY)) && (tbits)) {
			saved_command = INDEXED_TEXT_TY_Create();
			INDEXED_TEXT_TY_Cast(players_command, SNIPPET_TY, saved_command);
			text_of_command = INDEXED_TEXT_TY_Create();
			INDEXED_TEXT_TY_Cast(parsed_number, TEXT_TY, text_of_command);
			SetPlayersCommand(text_of_command);
			if (tbits == 16) {
				n = players_command; inp1 = 1; parsed_number = players_command;
			} else {
				s = players_command; inp2 = 1; parsed_number = players_command;
			}
			BlkFree(text_of_command);
			@push consult_from; @push consult_words;
			consult_from = 1; consult_words = parsed_number - 100;
		}
	}

	BeginAction(ac, n, s, 0, true);

	if (saved_command) {
		@pull consult_words; @pull consult_from;
		SetPlayersCommand(saved_command);
		BlkFree(saved_command);
	}

	meta = smeta; @pull parsed_number;
	@pull inp2; @pull inp1; @pull act_requester; @pull actor;
	TrackActions(true, smeta);
];

[ R_Process a i j;
	@push inp1; @push inp2;
    inp1 = i; inp2 = j; BeginAction(a, i, j);
    @pull inp2; @pull inp1;
];

Global converted_action_outcome = -1;
[ GVS_Convert ac n s;
	converted_action_outcome = BeginAction(ac, n, s);
	rtrue;
];

[ ConvertToGoingWithPush i oldrm newrm infl;
	i=noun;
	if (IndirectlyContains(noun, actor) == false) { move i to actor; infl = true; }
	move_pushing = i;
	oldrm = LocationOf(noun);
	BeginAction(##Go, second);
	newrm = LocationOf(actor);
	move_pushing = nothing; move i to newrm;
	if (newrm ~= oldrm) {
		if (IndirectlyContains(i, player)) TryAction(0, player, ##Look, 0, 0);
		RulebookSucceeds();
	} else RulebookFails();
];

[ ImplicitTake obj ks;
	if (actor == player) L__M(##Miscellany, 69, obj);
	else L__M(##Miscellany, 68, obj);
	ClearParagraphing();
	@push keep_silent; keep_silent = true;
	if (act_requester) TryAction(true, actor, ##Take, obj, nothing);
	else TryAction(false, actor, ##Take, obj, nothing);
	@pull keep_silent;
	if (obj in actor) rtrue;
	rfalse;
];

[ LookAfterGoing;
	GoingLookBreak();
	AbbreviatedRoomDescription();
];

[ AbbreviatedRoomDescription  prior_action pos frame_id;
	prior_action = action; 

	action = ##Look;
	pos = FindAction(##Look);
	if ((pos) && (ActionData-->(pos+AD_VARIABLES_CREATOR))) {
		frame_id = ActionData-->(pos+AD_VARIABLES_ID);
		Mstack_Create_Frame(ActionData-->(pos+AD_VARIABLES_CREATOR), frame_id);
		ProcessRulebook(SETTING_ACTION_VARIABLES_RB);
		(MStack-->MstVO(frame_id, 0)) = prior_action; ! "room-describing action"
		(MStack-->MstVO(frame_id, 1)) = true; ! "abbreviated form allowed"
	}
	LookSub(); ! The I6 verb routine for "looking"
	if (frame_id) Mstack_Destroy_Frame(ActionData-->(pos+AD_VARIABLES_CREATOR), frame_id);

	action = prior_action;
];

 [ ActionPrimitive  rv p1 p2 p3 p4 p5 frame_id;
	MStack_CreateRBVars(ACTION_PROCESSING_RB);

	if ((keep_silent == false) && (multiflag == false)) DivideParagraphPoint();
	reason_the_action_failed = 0;

	frame_id = -1;
	p1 = FindAction(action);
	if ((p1) && (ActionData-->(p1+AD_VARIABLES_CREATOR))) {
		frame_id = ActionData-->(p1+AD_VARIABLES_ID);
		Mstack_Create_Frame(ActionData-->(p1+AD_VARIABLES_CREATOR), frame_id);
	}
	if (ActionVariablesNotTypeSafe()) {
		if (frame_id ~= -1)
			Mstack_Destroy_Frame(ActionData-->(p1+AD_VARIABLES_CREATOR), frame_id);
		MStack_DestroyRBVars(ACTION_PROCESSING_RB);
		return;
	}

	ProcessRulebook(SETTING_ACTION_VARIABLES_RB);

	#IFDEF DEBUG;
	if ((trace_actions) && (FindAction(-1))) {
		print "["; p1=actor; p2=act_requester; p3=action; p4=noun; p5=second;
		DB_Action(p1,p2,p3,p4,p5);
		print "]^"; ClearParagraphing();
	}
	++debug_rule_nesting;
	#ENDIF;
	TrackActions(false, meta);
	BeginFollowRulebook();
	if ((meta) && (actor ~= player)) { L__M(##Miscellany, 74, actor); rv = RS_FAILS; }
	else if (meta) { DESCEND_TO_SPECIFIC_ACTION_R(); rv = RulebookOutcome(); }
	else { ProcessRulebook(ACTION_PROCESSING_RB); rv = RulebookOutcome(); }
	#IFDEF DEBUG;
	--debug_rule_nesting;
	if ((trace_actions) && (FindAction(-1))) {
		print "["; DB_Action(p1,p2,p3,p4,p5); print " - ";
		switch (rv) {
			RS_SUCCEEDS: print "succeeded";
			RS_FAILS: print "failed";
				#IFNDEF MEMORY_ECONOMY;
				if (reason_the_action_failed)
					print " the ",
						(RulePrintingRule) reason_the_action_failed;
			    #ENDIF;
			default: print "ended without result";
		}
		print "]^"; say__p = 1;
		SetRulebookOutcome(rv); ! In case disturbed by printing activities
	}
	#ENDIF;
	if (rv == RS_SUCCEEDS) UpdateActionBitmap();
	EndFollowRulebook();
	if (frame_id ~= -1) {
		p1 = FindAction(action);
		Mstack_Destroy_Frame(ActionData-->(p1+AD_VARIABLES_CREATOR), frame_id);
	}
	MStack_DestroyRBVars(ACTION_PROCESSING_RB);
	if ((keep_silent == false) && (multiflag == false)) DivideParagraphPoint();
	if (rv == RS_SUCCEEDS) rtrue;
	rfalse;
];

[ ActionVariablesNotTypeSafe mask noun_kova second_kova at;
	at = FindAction(-1); if (at == 0) rfalse; ! For any I6-defined actions

	noun_kova = ActionData-->(at+AD_NOUN_KOV);
	second_kova = ActionData-->(at+AD_SECOND_KOV);

	!print "at = ", at, " nst = ", noun_kova, "^";
	!print "consult_from = ", consult_from, " consult_words = ", consult_from, "^";
	!print "inp1 = ", inp1, " noun = ", noun, "^";
	!print "inp2 = ", inp2, " second = ", second, "^";
	!print "sst = ", second_kova, "^";

	if (noun_kova == SNIPPET_TY or UNDERSTANDING_TY) {
	    if (inp1 ~= 1) { inp2 = inp1; second = noun; }
	    parsed_number = 100*consult_from + consult_words;
	    inp1 = 1; noun = nothing; ! noun = parsed_number;
	}
	if (second_kova == SNIPPET_TY or UNDERSTANDING_TY) {
	    parsed_number = 100*consult_from + consult_words;
	    inp2 = 1; second = nothing; ! second = parsed_number;
	}

	mask = ActionData-->(at+AD_REQUIREMENTS);
	if (mask & OUT_OF_WORLD_ABIT) { meta = 1; rfalse; }

	if (inp1 == 1) {
	    if (noun_kova == OBJECT_TY) {
	        return L__M(##Miscellany, 61); }
	} else {
	    if (noun_kova ~= OBJECT_TY) {
	        return L__M(##Miscellany, 62); }
	    if ((mask & NEED_NOUN_ABIT) && (noun == nothing)) {
	    	@push act_requester; act_requester = nothing;
	        CarryOutActivity(SUPPLYING_A_MISSING_NOUN_ACT);
	        @pull act_requester;
	        if (noun == nothing) {
	        	if (say__p) rtrue;
	        	return L__M(##Miscellany, 59);
	    	}
	    }
	    if (((mask & NEED_NOUN_ABIT) == 0) && (noun ~= nothing)) {
	        return L__M(##Miscellany, 60); }
	}

	if (inp2 == 1) {
	    if (second_kova == OBJECT_TY) {
	        return L__M(##Miscellany, 63); }
	} else {
	    if (second_kova ~= OBJECT_TY) {
	        return L__M(##Miscellany, 64); }
	    if ((mask & NEED_SECOND_ABIT) && (second == nothing)) {
	        @push act_requester; act_requester = nothing;
	        CarryOutActivity(SUPPLYING_A_MISSING_SECOND_ACT);
	        @pull act_requester;
	        if (second == nothing) {
	        	if (say__p) rtrue;
	        	return L__M(##Miscellany, 65);
	        }
	    }
	    if (((mask & NEED_SECOND_ABIT) == 0) && (second ~= nothing)) {
	        return L__M(##Miscellany, 66); }
	}

	rfalse;
];

[ BASIC_VISIBILITY_R;
	if (act_requester) rfalse;
	if ((NeedLightForAction()) &&
		(actor == player) &&
		(ProcessRulebook(VISIBLE_RB)) &&
		(RulebookSucceeded())) {
		BeginActivity(REFUSAL_TO_ACT_IN_DARK_ACT);
		if (ForActivity(REFUSAL_TO_ACT_IN_DARK_ACT)==false) L__M(##Miscellany, 17);
		EndActivity(REFUSAL_TO_ACT_IN_DARK_ACT);
		reason_the_action_failed = BASIC_VISIBILITY_R;
		RulebookFails();
		rtrue;
	}
	rfalse;
];

[ BASIC_ACCESSIBILITY_R mask at;
	if (act_requester) rfalse;
	at = FindAction(-1);
	if (at == 0) rfalse;
	mask = ActionData-->(at+AD_REQUIREMENTS);

	if ((mask & TOUCH_NOUN_ABIT) && noun && (inp1 ~= 1)) {
		if (noun ofclass K3_direction) {
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R; 
			if (actor~=player) rtrue;
			return L__M(##Miscellany, 67);
		}
		if (ObjectIsUntouchable(noun, (actor~=player), FALSE, actor)) {
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R;
			rtrue;
		}
	}

	if ((mask & TOUCH_SECOND_ABIT) && second && (inp2 ~= 1)) {
		if (second ofclass K3_direction) {
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R;
			if (actor~=player) rtrue;
			return L__M(##Miscellany, 67);
		}
		if (ObjectIsUntouchable(second, (actor~=player), FALSE, actor)) {
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R;
			rtrue;
		}
	}
	rfalse;
];

[ CARRYING_REQUIREMENTS_R mask at;
	
	at = FindAction(-1);
	if (at == 0) rfalse;
	mask = ActionData-->(at+AD_REQUIREMENTS);

	if ((mask & TOUCH_NOUN_ABIT) && noun && (inp1 ~= 1)) {
		if ((mask & CARRY_NOUN_ABIT) && (noun notin actor)) {
			BeginActivity(IMPLICITLY_TAKING_ACT, noun);
            if (ForActivity(IMPLICITLY_TAKING_ACT, noun)==false)
            	ImplicitTake(noun);
            EndActivity(IMPLICITLY_TAKING_ACT, noun);
            !if (act_requester) rfalse;
			if (noun notin actor) {
				RulebookFails();
				reason_the_action_failed = CARRYING_REQUIREMENTS_R;
				rtrue;
			}
		}
	}

	if ((mask & TOUCH_SECOND_ABIT) && second && (inp2 ~= 1)) {
		if ((mask & CARRY_SECOND_ABIT) && (second notin actor)) {
			BeginActivity(IMPLICITLY_TAKING_ACT, second);
            if (ForActivity(IMPLICITLY_TAKING_ACT, second)==false)
            	ImplicitTake(second);
            EndActivity(IMPLICITLY_TAKING_ACT, second);
            !if (act_requester) rfalse;
			if (second notin actor) {
				RulebookFails();
				reason_the_action_failed = CARRYING_REQUIREMENTS_R;
				rtrue;
			}
		}
	}
	rfalse;
];

[ REQUESTED_ACTIONS_REQUIRE_R rv;
	if ((actor ~= player) && (act_requester)) {
		@push say__p;
		say__p = 0;
		rv = ProcessRulebook(PERSUADE_RB);
		if (RulebookSucceeded() == false) {
			if ((deadflag == false) && (say__p == FALSE)) L__M(##Miscellany, 72, actor);
			ActRulebookFails(rv); rtrue;
		}
		@pull say__p;
	}
	rfalse;
];

[ CARRY_OUT_REQUESTED_ACTIONS_R rv;
	if ((actor ~= player) && (act_requester)) {
		@push act_requester; act_requester = nothing;
		rv = BeginAction(action, noun, second);
		if (((meta) || (rv == false)) && (deadflag == false)) {
			if (ProcessRulebook(UNSUCCESSFUL_ATTEMPT_RB) == false) L__M(##Miscellany, 58);
		}
		@pull act_requester;
		ActRulebookSucceeds();
		rtrue;
	}
	rfalse;
];

Array Details_of_Specific_Action-->5;

[ GenericVerbSub ch co re vis rv;
	@push converted_action_outcome;
	converted_action_outcome = -1;

	Details_of_Specific_Action-->0 = true;
	if (meta) Details_of_Specific_Action-->0 = false;
	Details_of_Specific_Action-->1 = keep_silent;
	Details_of_Specific_Action-->2 = ch; ! Check rules for the action
	Details_of_Specific_Action-->3 = co; ! Carry out rules for the action
	Details_of_Specific_Action-->4 = re; ! Report rules for the action

	ProcessRulebook(SPECIFIC_ACTION_PROCESSING_RB, 0, true);
	if ((RulebookFailed()) && (converted_action_outcome == 1)) ActRulebookSucceeds();

	@pull converted_action_outcome;
	rtrue;
];

[ WORK_OUT_DETAILS_OF_SPECIFIC_R;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 0) = Details_of_Specific_Action-->0;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 1) = Details_of_Specific_Action-->1;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 2) = Details_of_Specific_Action-->2;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 3) = Details_of_Specific_Action-->3;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 4) = Details_of_Specific_Action-->4;
	rfalse;
];

[ TestActionBitmap obj act i j k bitmap;
	if (obj == nothing) bitmap = ActionHappened;
	else {
		if (~~(obj provides action_bitmap)) rfalse;
		bitmap = obj.&action_bitmap;
	}
	if (act == -1) return (((bitmap->0) & 1) ~= 0); 
	for (i=0, k=2; i<ActionCount; i++) {
		if (act == ActionCoding-->i) {
			return (((bitmap->j) & k) ~= 0);
		}
		k = k*2; if (k == 256) { k = 1; j++; }
	}
	rfalse;
];

[ UpdateActionBitmap;
	SetActionBitmap(noun, action);
	if (action == ##Go) SetActionBitmap(location, ##Enter);
];

[ SetActionBitmap obj act i j k bitmap;
	for (i=0, k=2; i<ActionCount; i++) {
		if (act == ActionCoding-->i) {
			if (obj provides action_bitmap) {
				bitmap = obj.&action_bitmap;
				bitmap->0 = (bitmap->0) | 1;
				bitmap->j = (bitmap->j) | k;
			}
			ActionHappened->0 = (ActionHappened->0) | 1;
			ActionHappened->j = (ActionHappened->j) | k;
		}
		k = k*2; if (k == 256) { k = 1; j++; }
	}
];

[ SayActionName act; DB_Action(0, 0, act, 0, 0, 2); ];

[ DA_Name n; if (n ofclass K3_direction) print (name) n; else print (the) n; ];
[ DA_Topic x a b c d i cf cw;
	cw = x%100; cf = x/100;
	print "~";
	for (a=cf:d<cw:d++,a++) {
		wn = a; b = WordAddress(a); c = WordLength(a);
		for (i=b:i<b+c:i++) {
			print (char) 0->i;
		}
		if (d<cw-1) print " ";
	}
	print "~";
];
[ DA_Number n; print n; ];
[ DA_TruthState n; if (n==0) print "false"; else print "true"; ];
[ DB_Action ac acr act n s for_say t at l j v c clc;
	if ((for_say == 0) && (debug_rule_nesting > 0))
		print "(", debug_rule_nesting, ") ";
	if ((ac ~= player) && (for_say ~= 2)) {
		if (acr) print "asking ", (the) ac, " to try ";
		else print (the) ac, " ";
	}
	DB_Action_Details(act, n, s, for_say);
	if ((keep_silent) && (for_say == 0)) print " - silently";
];

Constant MAX_NESTED_ACTIVITIES = 20;
Global activities_sp = 0;
Array activities_stack --> MAX_NESTED_ACTIVITIES;
Array activity_parameters_stack --> MAX_NESTED_ACTIVITIES;

Global inhibit_flag = 0;
Global saved_debug_rules = 0;
[ FixInhibitFlag n act inhibit_rule_debugging;
	for (n=0:n<activities_sp:n++) {
		act = activities_stack-->n;
		if (act == PRINTING_THE_NAME_ACT or PRINTING_THE_PLURAL_NAME_ACT or
			PRINTING_ROOM_DESC_DETAILS_ACT or LISTING_CONTENTS_ACT or
			GROUPING_TOGETHER_ACT) inhibit_rule_debugging = true;
	}
	if ((inhibit_flag == false) && (inhibit_rule_debugging)) {
		saved_debug_rules = debug_rules;
		debug_rules = 0;
	}
	if ((inhibit_flag) && (inhibit_rule_debugging == false)) {
		debug_rules = saved_debug_rules;
	}
	inhibit_flag = inhibit_rule_debugging;
];

[ TestActivity A desc val i;
	for (i=0:i<activities_sp:i++)
		if (activities_stack-->i == A) {
			if (desc) {
				if ((desc)(activity_parameters_stack-->i)) rtrue;
			} else if (val) {
				if (val == activity_parameters_stack-->i) rtrue;
			} else rtrue;
		}
	rfalse;
];

[ ActivityEmpty A x;
	x = Activity_before_rulebooks-->A;
	if (((rulebooks_array-->x)-->0) ~= NULL) rfalse;
	x = Activity_for_rulebooks-->A;
	if (((rulebooks_array-->x)-->0) ~= NULL) rfalse;
	x = Activity_after_rulebooks-->A;
	if (((rulebooks_array-->x)-->0) ~= NULL) rfalse;
	rtrue;
];

[ RulebookEmpty rb;
	if (((rulebooks_array-->rb)-->0) ~= NULL) rfalse;
	rtrue;
];

[ ProcessActivityRulebook rulebook parameter  rv;
	@push self;
	if (parameter) self = parameter;
	rv = ProcessRulebook(rulebook, parameter, true);
	@pull self;
	if (rv) rtrue;
	rfalse;
];

[ CarryOutActivity A o rv;
	BeginActivity(A, o);
	rv = ForActivity(A, o);
	EndActivity(A, o);
	return rv;
];

[ BeginActivity A o x;
	if (activities_sp == MAX_NESTED_ACTIVITIES) return RunTimeProblem(RTP_TOOMANYACTS);
	activity_parameters_stack-->activities_sp = o;
	activities_stack-->(activities_sp++) = A;
	FixInhibitFlag();
	MStack_CreateAVVars(A);
	if (Activity_atb_rulebooks->A) { x = action; action = action_to_be; }
	o = ProcessActivityRulebook(Activity_before_rulebooks-->A, o);
	if (Activity_atb_rulebooks->A) action = x;
	return o;
];

[ ForActivity A o x;
	if (Activity_atb_rulebooks->A) { x = action; action = action_to_be; }
	o = ProcessActivityRulebook(Activity_for_rulebooks-->A, o);
	if (Activity_atb_rulebooks->A) action = x;
	return o;
];

[ EndActivity A o rv x;
	if ((activities_sp > 0) && (activities_stack-->(activities_sp-1) == A)) {
		if (Activity_atb_rulebooks->A) { x = action; action = action_to_be; }
		rv = ProcessActivityRulebook(Activity_after_rulebooks-->A, o);
		if (Activity_atb_rulebooks->A) action = x;
		activities_sp--; FixInhibitFlag();
		MStack_DestroyAVVars(A);
		return rv;
	}
	return RunTimeProblem(RTP_CANTABANDON);
];

[ AbandonActivity A o;
	if ((activities_sp > 0) && (activities_stack-->(activities_sp-1) == A)) {
		activities_sp--; FixInhibitFlag();
		MStack_DestroyAVVars(A);
		return;
	}
	return RunTimeProblem(RTP_CANTEND);
];

Array ResourceUsageFlags ->
	(1+4+5);

[ DisplayFigure resource_ID one_time;
	if ((one_time) && (ResourceUsageFlags->resource_ID)) return;
	ResourceUsageFlags->resource_ID = true;
	print "^"; VM_Picture(resource_ID); print "^";
];

[ PlaySound resource_ID one_time;
	if (resource_ID == 0) return; ! The "silence" non-sound effect
	if ((one_time) && (ResourceUsageFlags->resource_ID)) return;
	ResourceUsageFlags->resource_ID = true;
	VM_SoundEffect(resource_ID);
];

#IFDEF PLUGIN_FILES;

Constant AUXF_MAGIC = 0; ! First word holds a safety constant
Constant AUXF_MAGIC_VALUE = 16339; ! Should be first word of any valid file structure
Constant AUXF_STATUS = 1; ! One of the following:
	Constant AUXF_STATUS_IS_CLOSED = 1; ! Currently closed, or perhaps doesn't exist
	Constant AUXF_STATUS_IS_OPEN_FOR_READ = 2;
	Constant AUXF_STATUS_IS_OPEN_FOR_WRITE = 3;
	Constant AUXF_STATUS_IS_OPEN_FOR_APPEND = 4;
Constant AUXF_BINARY = 2; ! False for text files (I7 default), true for binary
Constant AUXF_STREAM = 3; ! Stream for an open file (meaningless otherwise)
Constant AUXF_FILENAME = 4; ! Packed address of constant string
Constant AUXF_IFID_OF_OWNER = 5; ! UUID_ARRAY if owned by this project, or
	! string array of IFID of owner wrapped in //...//, or NULL to leave open

Constant NO_EXTERNAL_FILES 0;
Array TableOfExternalFiles --> 0 0;


[ FileIO_Error extf err_text  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) {
		print "^*** Error on unknown file: ", (string) err_text, " ***^";
	} else {
		struc = TableOfExternalFiles-->extf;
		print "^*** Error on file '",
			(string) struc-->AUXF_FILENAME, "': ",
			(string) err_text, " ***^";
	}
	RunTimeProblem(RTP_FILEIOERROR);
	return 0;
];

#IFDEF TARGET_GLULX;

[ FileIO_Exists extf  fref struc rv usage;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) rfalse;
	struc = TableOfExternalFiles-->extf;
	if ((struc == 0) || (struc-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;
	if (struc-->AUXF_BINARY) usage = fileusage_BinaryMode;
	else usage = fileusage_TextMode;
	fref = glk_fileref_create_by_name(fileusage_Data + usage,
		Glulx_ChangeAnyToCString(struc-->AUXF_FILENAME), 0);
	rv = glk_fileref_does_file_exist(fref);
	glk_fileref_destroy(fref);
	return rv;
];

[ FileIO_Ready extf  struc fref usage str ch;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) rfalse;
	struc = TableOfExternalFiles-->extf;
	if ((struc == 0) || (struc-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;
	if (struc-->AUXF_BINARY) usage = fileusage_BinaryMode;
	else usage = fileusage_TextMode;
	fref = glk_fileref_create_by_name(fileusage_Data + usage,
		Glulx_ChangeAnyToCString(struc-->AUXF_FILENAME), 0);
	if (glk_fileref_does_file_exist(fref) == false) {
		glk_fileref_destroy(fref);
		rfalse;
	}
	str = glk_stream_open_file(fref, filemode_Read, 0);
	ch = glk_get_char_stream(str);
	glk_stream_close(str, 0);
	glk_fileref_destroy(fref);
	if (ch ~= '*') rfalse;
	rtrue;
];

[ FileIO_MarkReady extf readiness  struc fref str ch usage;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to open a non-file");
	struc = TableOfExternalFiles-->extf;
	if ((struc == 0) || (struc-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;
	if (struc-->AUXF_BINARY) usage = fileusage_BinaryMode;
	else usage = fileusage_TextMode;
	fref = glk_fileref_create_by_name(fileusage_Data + usage,
		Glulx_ChangeAnyToCString(struc-->AUXF_FILENAME), 0);
	if (glk_fileref_does_file_exist(fref) == false) {
		glk_fileref_destroy(fref);
		return FileIO_Error(extf, "only existing files can be marked");
	}
	if (struc-->AUXF_STATUS ~= AUXF_STATUS_IS_CLOSED) {
		glk_fileref_destroy(fref);
		return FileIO_Error(extf, "only closed files can be marked");
	}
	str = glk_stream_open_file(fref, filemode_ReadWrite, 0);
	glk_stream_set_position(str, 0, 0); ! seek start
	if (readiness) ch = '*'; else ch = '-';
	glk_put_char_stream(str, ch); ! mark as complete
	glk_stream_close(str, 0);
	glk_fileref_destroy(fref);
];

[ FileIO_Open extf write_flag append_flag
	struc fref str mode ix ch not_this_ifid owner force_header usage;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to open a non-file");
	struc = TableOfExternalFiles-->extf;
	if ((struc == 0) || (struc-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;
	if (struc-->AUXF_STATUS ~= AUXF_STATUS_IS_CLOSED)
		return FileIO_Error(extf, "tried to open a file already open");
	if (struc-->AUXF_BINARY) usage = fileusage_BinaryMode;
	else usage = fileusage_TextMode;
	fref = glk_fileref_create_by_name(fileusage_Data + usage,
		Glulx_ChangeAnyToCString(struc-->AUXF_FILENAME), 0);
	if (write_flag) {
		if (append_flag) {
			mode = filemode_WriteAppend;
			if (glk_fileref_does_file_exist(fref) == false)
				force_header = true;
		}
		else mode = filemode_Write;
	} else {
		mode = filemode_Read;
		if (glk_fileref_does_file_exist(fref) == false) {
			glk_fileref_destroy(fref);
			return FileIO_Error(extf, "tried to open a file which does not exist");
		}
	}
	str = glk_stream_open_file(fref, mode, 0);
	glk_fileref_destroy(fref);
	if (str == 0) return FileIO_Error(extf, "tried to open a file but failed");
	struc-->AUXF_STREAM = str;
	if (write_flag) {
		if (append_flag)
			struc-->AUXF_STATUS = AUXF_STATUS_IS_OPEN_FOR_APPEND;
		else
			struc-->AUXF_STATUS = AUXF_STATUS_IS_OPEN_FOR_WRITE;
		glk_stream_set_current(str);
		if ((append_flag == FALSE) || (force_header)) {
			print "- ";
			for (ix=6: ix <= UUID_ARRAY->0: ix++) print (char) UUID_ARRAY->ix;
			print " ", (string) struc-->AUXF_FILENAME, "^";
		}
	} else {
		struc-->AUXF_STATUS = AUXF_STATUS_IS_OPEN_FOR_READ;
		ch = FileIO_GetC(extf);
		if (ch ~= '-' or '*') { jump BadFile; }
		if (ch == '-')
			return FileIO_Error(extf, "tried to open a file which was incomplete");
		ch = FileIO_GetC(extf);
		if (ch ~= ' ') { jump BadFile; }
		ch = FileIO_GetC(extf);
		if (ch ~= '/') { jump BadFile; }
		ch = FileIO_GetC(extf);
		if (ch ~= '/') { jump BadFile; }
		owner = struc-->AUXF_IFID_OF_OWNER;
		ix = 3;
		if (owner == UUID_ARRAY) ix = 8;
		if (owner ~= NULL) {
			for (: ix <= owner->0: ix++) {
				ch = FileIO_GetC(extf);
				if (ch == -1) { jump BadFile; }
				if (ch ~= owner->ix) not_this_ifid = true;
				if (ch == ' ') break;
			}
			if (not_this_ifid == false) {
				ch = FileIO_GetC(extf);
				if (ch ~= ' ') { jump BadFile; }
			}
		}
		while (ch ~= -1) {
			ch = FileIO_GetC(extf);
			if (ch == 10 or 13) break;
		}
		if (not_this_ifid) {
			struc-->AUXF_STATUS = AUXF_STATUS_IS_CLOSED;
			glk_stream_close(str, 0);
			return FileIO_Error(extf,
				"tried to open a file owned by another project");
		}
	}
	return struc-->AUXF_STREAM;
	.BadFile;
	struc-->AUXF_STATUS = AUXF_STATUS_IS_CLOSED;
	glk_stream_close(str, 0);
	return FileIO_Error(extf, "tried to open a file which seems to be malformed");
];

[ FileIO_Close extf  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to open a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_STATUS ~=
		AUXF_STATUS_IS_OPEN_FOR_READ or
		AUXF_STATUS_IS_OPEN_FOR_WRITE or
		AUXF_STATUS_IS_OPEN_FOR_APPEND)
		return FileIO_Error(extf, "tried to close a file which is not open");
	if ((struc-->AUXF_BINARY == false) &&
		(struc-->AUXF_STATUS ==
		AUXF_STATUS_IS_OPEN_FOR_WRITE or
		AUXF_STATUS_IS_OPEN_FOR_APPEND)) {
		glk_set_window(gg_mainwin);
	}
	if (struc-->AUXF_STATUS ==
		AUXF_STATUS_IS_OPEN_FOR_WRITE or
		AUXF_STATUS_IS_OPEN_FOR_APPEND) {
		glk_stream_set_position(struc-->AUXF_STREAM, 0, 0); ! seek start
		glk_put_char_stream(struc-->AUXF_STREAM, '*'); ! mark as complete
	}
	glk_stream_close(struc-->AUXF_STREAM, 0);
	struc-->AUXF_STATUS = AUXF_STATUS_IS_CLOSED;
];

[ FileIO_GetC extf  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) return -1;
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_STATUS ~= AUXF_STATUS_IS_OPEN_FOR_READ) return -1;
	return glk_get_char_stream(struc-->AUXF_STREAM);
];

[ FileIO_PutC extf char  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) return -1;
		return FileIO_Error(extf, "tried to write to a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_STATUS ~=
		AUXF_STATUS_IS_OPEN_FOR_WRITE or
		AUXF_STATUS_IS_OPEN_FOR_APPEND)
		return FileIO_Error(extf,
			"tried to write to a file which is not open for writing");
	return glk_put_char_stream(struc-->AUXF_STREAM, char);
];

[ FileIO_PrintLine extf ch  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to write to a non-file");
	struc = TableOfExternalFiles-->extf;
	for (::) {
		ch = FileIO_GetC(extf);
		if (ch == -1) rfalse;
		if (ch == 10 or 13) { print "^"; rtrue; }
		print (char) ch;
	}
];

[ FileIO_PrintContents extf tab  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to access a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_BINARY)
		return FileIO_Error(extf, "printing text will not work with binary files");
	if (FileIO_Open(extf, false) == 0) rfalse;
	while (FileIO_PrintLine(extf)) ;
	FileIO_Close(extf);
	rtrue;
];

[ FileIO_PutContents extf text append_flag  struc str ch;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to access a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_BINARY)
		return FileIO_Error(extf, "writing text will not work with binary files");
	str = FileIO_Open(extf, true, append_flag);
	if (str == 0) rfalse;
	@push say__p; @push say__pc;
	ClearParagraphing();
	PrintText(text);
	FileIO_Close(extf);
	@pull say__pc; @pull say__p;
	rfalse;
];

[ FileIO_PutTable extf tab rv  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to write table to a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_BINARY)
		return FileIO_Error(extf, "writing a table will not work with binary files");
	if (FileIO_Open(extf, true) == 0) rfalse;
	rv = TablePrint(tab);
	FileIO_Close(extf);
	if (rv) return RunTimeProblem(RTP_TABLE_CANTSAVE, tab);
	rtrue;
];

[ FileIO_GetTable extf tab  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to read table from a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_BINARY)
		return FileIO_Error(extf, "reading a table will not work with binary files");
	if (FileIO_Open(extf, false) == 0) rfalse;
	TableRead(tab, extf);
	FileIO_Close(extf);
	rtrue;
];

#IFNOT; ! TARGET_GLULX
[ FileIO_Exists extf; rfalse; ];
[ FileIO_Ready extf; rfalse; ];
[ FileIO_GetC extf; return -1; ];
[ FileIO_PutTable extf tab;
	return FileIO_Error(extf, "external files can only be used under Glulx");
];
[ FileIO_MarkReady extf status; FileIO_PutTable(extf); ];
[ FileIO_GetTable extf tab; FileIO_PutTable(extf); ];
[ FileIO_PrintContents extf; FileIO_PutTable(extf); ];
[ FileIO_PutContents extf; FileIO_PutTable(extf); ];
#ENDIF; ! TARGET_GLULX

#IFNOT; ! PLUGIN_FILES
[ FileIO_GetC extf; return -1; ];
#ENDIF; ! PLUGIN_FILES

Constant MAX_MSTACK_FRAME = 2 + 6;
Constant MSTACK_CAPACITY = 20;
Constant MSTACK_SIZE = MSTACK_CAPACITY*MAX_MSTACK_FRAME;

Array MStack --> MSTACK_SIZE;
Global MStack_Top = 0; ! Topmost word currently used

[ Mstack_Create_Frame creator id extent;
	if (creator == 0) rfalse;
	extent = creator.call(MStack_Top+2, 1);
	if (extent == 0) rfalse;
	if (MStack_Top + MAX_MSTACK_FRAME >= MSTACK_SIZE + 2) {
		RunTimeProblem(RTP_MSTACKMEMORY, MSTACK_SIZE);
		Mstack_Backtrace();
		rfalse;
	}
	MStack_Top++;
	MStack-->MStack_Top = id;
	MStack_Top++;
	MStack_Top = MStack_Top + extent;
	MStack-->MStack_Top = -(extent+2);
	rtrue;
];

[ Mstack_Destroy_Frame creator id pos;
	pos = Mstack_Seek_Frame(id);
	if (pos == 0) rfalse; ! Not found: do nothing
	MStack_Top = pos - 2; ! Clear mstack down to just below this frame
	if (creator) creator.call(pos, -1);
	rtrue;
];

Global MStack_Frame_Extent = 0;

[ Mstack_Seek_Frame id pos;
	pos = MStack_Top;
	while ((pos > 0) && (MStack-->pos ~= 0)) {
		MStack_Frame_Extent = MStack-->pos;
		pos = pos + MStack_Frame_Extent;
		MStack_Frame_Extent = (-2) - MStack_Frame_Extent;
		if (MStack-->(pos+1) == id) return pos+2;
	}
	MStack_Frame_Extent = 0;
	return 0; ! Not found
];

[ Mstack_Backtrace pos k;
	print "Mstack backtrace: size ", MStack_Top+1, " words^";
	pos = MStack_Top;
	while (MStack-->pos ~= 0) {
		MStack_Frame_Extent = MStack-->pos;
		pos = pos + MStack_Frame_Extent;
		MStack_Frame_Extent = (-2) - MStack_Frame_Extent;
		print "Block at ", pos+2,
			" owner ID ", MStack-->(pos+1), " size ", MStack_Frame_Extent, "^";
		for (k=0: k<MStack_Frame_Extent: k++) print MStack-->(pos+2+k), " ";
		print "^";
	}
];

[ MstVO id off pos;
	pos = Mstack_Seek_Frame(id);
	if (pos == 0) {
		print "Variable unavailable for this action, activity or rulebook: ",
			"internal ID number ",
			id, "/", off, "^";
		rfalse;
	}
	if ((off<0) || (off >= MStack_Frame_Extent)) {
		print "Variable stack offset wrong: ", id, "/", off, " at ", pos, "^";
		rfalse;
	}
	return pos+off;
];

[ MstVON id off pos;
	pos = Mstack_Seek_Frame(id);
	if (pos == 0) {
		return 0; ! word position 0 on the M-stack
	}
	if ((off<0) || (off >= MStack_Frame_Extent)) {
		print "Variable stack offset wrong: ", id, "/", off, " at ", pos, "^";
		rfalse;
	}
	return pos+off;
];

#IFNDEF MEMORY_ECONOMY;
Array rulebook_var_creators --> 0 0 0 0 0 0 0 0 0 0 RBSTVC_10 0 RBSTVC_12 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
#ENDIF;
[  RBSTVC_10 pos state;
    if (state == 1) {
        MStack-->pos = selfobj; pos++;
    } else {
        pos++;
    }
    return 1;
];
[  RBSTVC_12 pos state;
    if (state == 1) {
        MStack-->pos = false; pos++;
        MStack-->pos = false; pos++;
        MStack-->pos = 0; pos++;
        MStack-->pos = 0; pos++;
        MStack-->pos = 0; pos++;
        MStack-->pos = false; pos++;
    } else {
        pos++;
        pos++;
        pos++;
        pos++;
        pos++;
        pos++;
    }
    return 6;
];


[ MStack_CreateRBVars rb cr;
#IFDEF MEMORY_ECONOMY;
switch (rb) {
10: cr = RBSTVC_10;
12: cr = RBSTVC_12;
}
#IFNOT;
cr = rulebook_var_creators-->rb;
#ENDIF;

	if (cr == 0) return;
	Mstack_Create_Frame(cr, rb);
];

[ MStack_DestroyRBVars rb cr;
#IFDEF MEMORY_ECONOMY;
switch (rb) {
10: cr = RBSTVC_10;
12: cr = RBSTVC_12;
}
#IFNOT;
cr = rulebook_var_creators-->rb;
#ENDIF;

	if (cr == 0) return;
	Mstack_Destroy_Frame(cr, rb);
];

Array activity_var_creators --> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;


[ MStack_CreateAVVars av cr;
	cr = activity_var_creators-->av;
	if (cr == 0) return;
	Mstack_Create_Frame(cr, av + 10000);
];

[ MStack_DestroyAVVars av cr;
	cr = activity_var_creators-->av;
	if (cr == 0) return;
	Mstack_Destroy_Frame(cr, av + 10000);
];

[ Perform_Undo;
	#ifdef PREVENT_UNDO; L__M(##Miscellany, 70); return; #endif;
	if (turns == 1) { L__M(##Miscellany, 11); return; }
	if (undo_flag == 0) { L__M(##Miscellany, 6); return; }
	if (undo_flag == 1) { L__M(##Miscellany, 7); return; }
	if (VM_Undo() == 0) L__M(##Miscellany, 7);
];

[ ANNOUNCE_SCORE_R;
	if (actor ~= player) rfalse;
	#ifdef NO_SCORING; L__M(##Score, 2);
	#ifnot; GL__M(##Score); PrintRank();
	#endif;
];

[ SWITCH_SCORE_NOTIFY_ON_R;
	if (actor ~= player) rfalse;
	#ifdef NO_SCORING; ANNOUNCE_SCORE_R();
	#ifnot; notify_mode=1; #endif;
];

[ REP_SWITCH_NOTIFY_ON_R;
	if (actor ~= player) rfalse;
	#ifndef NO_SCORING; GL__M(##NotifyOn); #endif;
];

[ SWITCH_SCORE_NOTIFY_OFF_R;
	if (actor ~= player) rfalse;
	#ifdef NO_SCORING; ANNOUNCE_SCORE_R();
	#ifnot; notify_mode=0; #endif;
];

[ REP_SWITCH_NOTIFY_OFF_R;
	if (actor ~= player) rfalse;
	#ifndef NO_SCORING; GL__M(##NotifyOff); #endif;
];

[ PREFER_SOMETIMES_ABBREVIATED_R;
	if (actor ~= player) rfalse;
	lookmode=1;
]; ! Brief

[ REP_PREFER_SOMETIMES_ABBR_R;
	if (actor ~= player) rfalse;
	print (string) Story; GL__M(##LMode1);
]; ! Brief

[ PREFER_UNABBREVIATED_R;
	if (actor ~= player) rfalse;
	lookmode=2;
]; ! Verbose

[ REP_PREFER_UNABBREVIATED_R;
	if (actor ~= player) rfalse;
	print (string) Story; GL__M(##LMode2);
]; ! Verbose

[ PREFER_ABBREVIATED_R;
	if (actor ~= player) rfalse;
	lookmode=3;
]; ! Superbrief

[ REP_PREFER_ABBREVIATED_R;
	if (actor ~= player) rfalse;
	print (string) Story; GL__M(##LMode3);
]; ! Superbrief

[ ANNOUNCE_PRONOUN_MEANINGS_R x y c d;
	if (actor ~= player) rfalse;
	GL__M(##Pronouns, 1);

	c = (LanguagePronouns-->0)/3;
	if (player ~= selfobj) c++;

	if (c==0) return GL__M(##Pronouns, 4);

	for (x = 1, d = 0 : x <= LanguagePronouns-->0: x = x+3) {
		print "~", (address) LanguagePronouns-->x, "~ ";
		y = LanguagePronouns-->(x+2);
		if (y == NULL) GL__M(##Pronouns, 3);
		else { GL__M(##Pronouns, 2); print (the) y; }
		d++;
		if (d < c-1) print ", ";
		if (d == c-1) print (string) LISTAND__TX;
	}
	if (player ~= selfobj) {
		print "~", (address) ME1__WD, "~ "; GL__M(##Pronouns, 2);
		c = player; player = selfobj;
		print (the) c; player = c;
	}
	".";
];

!Constant TRACE_I7_SPACING;

[ ClearParagraphing;
	say__p = 0; say__pc = 0;
];

[ DivideParagraphPoint;
	#ifdef TRACE_I7_SPACING; print "[DPP", say__p, say__pc, "]"; #endif;
	if (say__p) {
		new_line; say__p = 0; say__pc = say__pc | PARA_COMPLETED;
		if (say__pc & PARA_PROMPTSKIP) say__pc = say__pc - PARA_PROMPTSKIP;
		if (say__pc & PARA_SUPPRESSPROMPTSKIP) say__pc = say__pc - PARA_SUPPRESSPROMPTSKIP;
	}
	#ifdef TRACE_I7_SPACING; print "[-->", say__p, say__pc, "]"; #endif;
	say__pc = say__pc | PARA_CONTENTEXPECTED;
];

[ ParaContent;
	if (say__pc & PARA_CONTENTEXPECTED) {
		say__pc = say__pc - PARA_CONTENTEXPECTED;
		say__p = 1;
	}
];

[ GoingLookBreak;
	if (say__pc & PARA_COMPLETED == 0) new_line;
	ClearParagraphing();
];

[ CommandClarificationBreak;
	new_line;
	ClearParagraphing();
];

[ RunParagraphOn;
	#ifdef TRACE_I7_SPACING; print "[RPO", say__p, say__pc, "]"; #endif;
	say__p = 0;
	say__pc = say__pc | PARA_PROMPTSKIP;
	say__pc = say__pc | PARA_SUPPRESSPROMPTSKIP;
];

[ SpecialLookSpacingBreak;
	#ifdef TRACE_I7_SPACING; print "[SLS", say__p, say__pc, "]"; #endif;
	say__p = 0;
	say__pc = say__pc | PARA_PROMPTSKIP;
];

[ EnsureBreakBeforePrompt;
	if ((say__p) ||
		((say__pc & PARA_PROMPTSKIP) && ((say__pc & PARA_SUPPRESSPROMPTSKIP)==0)))
		new_line;
	ClearParagraphing();
];

[ PrintSingleParagraph matter;
	say__p = 1;
	say__pc = say__pc | PARA_NORULEBOOKBREAKS;
	PrintText(matter);
	DivideParagraphPoint();
	say__pc = 0;
];

[ STextSubstitution;
	if (say__n ~= 1) print "s";
];

[ PrintPrompt i;
	style roman;
	EnsureBreakBeforePrompt();
	PrintText( (Global_Vars-->1) );
	ClearBoxedText();
	ClearParagraphing();
	enable_rte = true;
];

Global pending_boxed_quotation; ! a routine to overlay the quotation on screen

[ DisplayBoxedQuotation Q;
	pending_boxed_quotation = Q;
];

[ ClearBoxedText i;
	if (pending_boxed_quotation) {
		for (i=0: Runtime_Quotations_Displayed-->i: i++)
			if (Runtime_Quotations_Displayed-->i == pending_boxed_quotation) {
				pending_boxed_quotation = 0;
				return;
			}
		Runtime_Quotations_Displayed-->i = pending_boxed_quotation;

		ClearParagraphing();
		pending_boxed_quotation();
		ClearParagraphing();

		pending_boxed_quotation = 0;
	}
];

[ NotifyTheScore;
#Ifndef NO_SCORING;
	if (notify_mode == 1) {
		DivideParagraphPoint();
		VM_Style(NOTE_VMSTY);
		print "["; L__M(##Miscellany, 50, score-last_score); print ".]^";
		VM_Style(NORMAL_VMSTY);
	}
#Endif;
];

#Ifdef TARGET_ZCODE;
#Iftrue (#version_number == 6);
[ DrawStatusLine; Z6_DrawStatusLine(); ];
#Endif;
#Endif;

#Ifndef DrawStatusLine;
[ DrawStatusLine width posb;
	@push say__p; @push say__pc;
	BeginActivity(CONSTRUCTING_STATUS_LINE_ACT);
	VM_StatusLineHeight(1); VM_MoveCursorInStatusLine(1, 1); 
	if (statuswin_current) {
		width = VM_ScreenWidth(); posb = width-15;
		spaces width;
		ClearParagraphing();
		if (ForActivity(CONSTRUCTING_STATUS_LINE_ACT) == false) {
			VM_MoveCursorInStatusLine(1, 2);
			switch(metaclass(left_hand_status_line)) {
				String: print (string) left_hand_status_line;
				Routine: left_hand_status_line();
			}
			VM_MoveCursorInStatusLine(1, posb);
			switch(metaclass(right_hand_status_line)) {
				String: print (string) right_hand_status_line;
				Routine: right_hand_status_line();
			}
		}
		VM_MoveCursorInStatusLine(1, 1); VM_MainWindow();
	}
	ClearParagraphing();
	EndActivity(CONSTRUCTING_STATUS_LINE_ACT);
	@pull say__pc; @pull say__p;
];
#Endif;

[ SL_Score_Moves;
	if (not_yet_in_play) return;
	#ifdef NO_SCORING; print sline2; #ifnot; print sline1, "/", sline2; #endif;
];

[ SL_Location;
	if (not_yet_in_play) return;
	if (location == thedark) {
		BeginActivity(PRINTING_NAME_OF_DARK_ROOM_ACT);
		if (ForActivity(PRINTING_NAME_OF_DARK_ROOM_ACT) == false)
 			L__M(##Miscellany, 71);
		EndActivity(PRINTING_NAME_OF_DARK_ROOM_ACT);
	} else {
		FindVisibilityLevels();
		if (visibility_ceiling == location) print (name) location;
		else print (The) visibility_ceiling;
	}
];

[ Banner;
   BeginActivity(PRINTING_BANNER_TEXT_ACT);
   if (ForActivity(PRINTING_BANNER_TEXT_ACT) == false) {
	   	VM_Style(HEADER_VMSTY);
		print (string) Story;
		VM_Style(NORMAL_VMSTY);
		new_line;
		print (string) Headline;
		#ifdef Story_Author;
		print " by ", (string) Story_Author;
		#endif; ! Story_Author
		new_line;
		VM_Describe_Release();
		print " / Inform 7 build ", (string) NI_BUILD_COUNT, " ";
		print "(I6/v"; inversion;
		print " lib ", (string) LibRelease, ") ";
		#Ifdef STRICT_MODE;
		print "S";
		#Endif; ! STRICT_MODE
		#Ifdef DEBUG;
		print "D";
		#Endif; ! DEBUG
		new_line;
    }
    EndActivity(PRINTING_BANNER_TEXT_ACT);
];

[ DecimalNumber num; print num; ];

[ EnglishNumber n; LanguageNumber(n); ];

[ PrintText x;
	if (x ofclass String) print (string) x;
	if (x ofclass Routine) (x)();
];
[ I7_String x; PrintText(x); ]; ! An alternative name now used only by extensions

[ PrintOrRun obj prop no_break  routine_return_value;
	!print "(", obj, ".", prop, ";", say__p, say__pc, ")";
	if (prop == 0) {
		print (name) prop; routine_return_value = true;
	} else {
		switch (metaclass(obj.prop)) {
			nothing:
				routine_return_value = false;
			String:
				if (obj.prop == EMPTY_TEXT_VALUE) break;
				print (string) obj.prop; !if (no_break == false) new_line;
				routine_return_value = true;
			Routine:
				routine_return_value = RunRoutines(obj, prop);
				!print "[", routine_return_value, "]";
		}
	}
	
	if (routine_return_value) {
		say__p = 1;
		if (no_break == false) {
			new_line;
			!print "(DP->", say__p, say__pc, ")";
			DivideParagraphPoint();
			!print "(to", say__p, say__pc, ")";
		}
	}

	!print "(-->", say__p, say__pc, ")";
	return routine_return_value;
];

Array StorageForShortName buffer 250;

[ CPrintOrRun obj prop  v length i;
    if ((obj ofclass String or Routine) || (prop == 0))
        VM_PrintToBuffer (StorageForShortName, 160, obj);
    else {
    	if (obj.prop == NULL) rfalse;
        if (metaclass(obj.prop) == Routine or String)
            VM_PrintToBuffer(StorageForShortName, 160, obj, prop);
        else return RunTimeError(2, obj, prop);
	}

    length = StorageForShortName-->0;

    StorageForShortName->WORDSIZE = VM_LowerToUpperCase(StorageForShortName->WORDSIZE);
    for (i=WORDSIZE: i<length+WORDSIZE: i++) print (char) StorageForShortName->i;
    if (i>WORDSIZE) say__p = 1;

    return;
];

[ Cap str nocaps;
    if (nocaps) print (string) str;
    else CPrintOrRun(str, 0);
];

[ PSN__ o;
    if (o == 0) { print (string) NOTHING__TX; rtrue; }
    switch (metaclass(o)) {
		Routine:  print "<routine ", o, ">"; rtrue;
		String:   print "<string ~", (string) o, "~>"; rtrue;
		nothing:  print "<illegal object number ", o, ">"; rtrue;
    }
    CarryOutActivity(PRINTING_THE_NAME_ACT, o);
];

Global caps_mode = false;

[ STANDARD_NAME_PRINTING_R obj;
	obj = parameter_object;
    if (obj == 0) {
    	print (string) NOTHING__TX; return;
    }
    switch (metaclass(obj)) {
		Routine:  print "<routine ", obj, ">"; return;
		String:   print "<string ~", (string) obj, "~>"; return;
		nothing:  print "<illegal object number ", obj, ">"; return;
    }
    if (obj == player) { 
   	    if (indef_mode == NULL && caps_mode) print (string) YOU__TX;
   	    else print (string) YOURSELF__TX;
   	    return;
   	}
    #Ifdef LanguagePrintShortName;
    if (LanguagePrintShortName(obj)) return;
    #Endif; ! LanguagePrintShortName
    if (indef_mode && obj.&short_name_indef ~= 0 &&
    	PrintOrRun(obj, short_name_indef, true) ~= 0) return;
    if (caps_mode &&
    	obj.&cap_short_name ~= 0 && PrintOrRun(obj, cap_short_name, true) ~= 0) {
    	caps_mode = false;
    	return;
    }
    if (obj.&short_name ~= 0 && PrintOrRun(obj, short_name, true) ~= 0) return;
    print (object) obj;
];

Global short_name_case;

[ PrefaceByArticle obj acode pluralise capitalise  i artform findout artval;
    if (obj provides articles) {
        artval=(obj.&articles)-->(acode+short_name_case*LanguageCases);
        if (capitalise)
            print (Cap) artval, " ";
        else
            print (string) artval, " ";
        if (pluralise) return;
        print (PSN__) obj; return;
    }

    i = GetGNAOfObject(obj);
    if (pluralise) {
        if (i < 3 || (i >= 6 && i < 9)) i = i + 3;
    }
    i = LanguageGNAsToArticles-->i;

    artform = LanguageArticles
        + 3*WORDSIZE*LanguageContractionForms*(short_name_case + i*LanguageCases);

    #Iftrue (LanguageContractionForms == 2);
    if (artform-->acode ~= artform-->(acode+3)) findout = true;
    #Endif; ! LanguageContractionForms
    #Iftrue (LanguageContractionForms == 3);
    if (artform-->acode ~= artform-->(acode+3)) findout = true;
    if (artform-->(acode+3) ~= artform-->(acode+6)) findout = true;
    #Endif; ! LanguageContractionForms
    #Iftrue (LanguageContractionForms == 4);
    if (artform-->acode ~= artform-->(acode+3)) findout = true;
    if (artform-->(acode+3) ~= artform-->(acode+6)) findout = true;
    if (artform-->(acode+6) ~= artform-->(acode+9)) findout = true;
    #Endif; ! LanguageContractionForms
    #Iftrue (LanguageContractionForms > 4);
    findout = true;
    #Endif; ! LanguageContractionForms

    #Ifdef TARGET_ZCODE;
    if (standard_interpreter ~= 0 && findout) {
        StorageForShortName-->0 = 160;
        @output_stream 3 StorageForShortName;
        if (pluralise) print (number) pluralise; else print (PSN__) obj;
        @output_stream -3;
        acode = acode + 3*LanguageContraction(StorageForShortName + 2);
    }
    #Ifnot; ! TARGET_GLULX
    if (findout) {
        if (pluralise)
            Glulx_PrintAnyToArray(StorageForShortName, 160, EnglishNumber, pluralise);
        else
            Glulx_PrintAnyToArray(StorageForShortName, 160, PSN__, obj);
        acode = acode + 3*LanguageContraction(StorageForShortName);
    }
    #Endif; ! TARGET_

    Cap (artform-->acode, ~~capitalise); ! print article
    if (pluralise) return;
    print (PSN__) obj;
];

[ IndefArt obj i;
	if (obj == 0) { print (string) NOTHING__TX; rtrue; }
    i = indef_mode; indef_mode = true;
    if (obj has proper) { indef_mode = NULL; print (PSN__) obj; indef_mode = i; return; }
    if ((obj provides article) && (obj.article ~= EMPTY_TEXT_VALUE)) {
        PrintOrRun(obj, article, true); print " ", (PSN__) obj; indef_mode = i;
        return;
    }
    PrefaceByArticle(obj, 2); indef_mode = i;
];

[ CIndefArt obj i;
	if (obj == 0) { CPrintOrRun(NOTHING__TX, 0); rtrue; }
    i = indef_mode; indef_mode = true;
    if (obj has proper) {
    	indef_mode = NULL;
		caps_mode = true;
    	print (PSN__) obj;
    	indef_mode = i;
    	caps_mode = false;
    	return;
    }
    if ((obj provides article) && (obj.article ~= EMPTY_TEXT_VALUE)) {
        CPrintOrRun(obj, article); print " ", (PSN__) obj; indef_mode = i;
        return;
    }
    PrefaceByArticle(obj, 2, 0, 1); indef_mode = i;
];

[ DefArt obj i;
    i = indef_mode; indef_mode = false;
    if ((~~obj ofclass Object) || obj has proper) {
        indef_mode = NULL; print (PSN__) obj; indef_mode = i;
        return;
    }
    PrefaceByArticle(obj, 1); indef_mode = i;
];

[ CDefArt obj i;
    i = indef_mode; indef_mode = false;
    if ((obj ofclass Object) && (obj has proper || obj == player)) {
    	indef_mode = NULL;
    	caps_mode = true;
    	print (PSN__) obj;
    	indef_mode = i;
    	caps_mode = false;
    	return;
    }
    if ((~~obj ofclass Object) || obj has proper) {
        indef_mode = NULL; print (PSN__) obj; indef_mode = i;
        return;
    }
    PrefaceByArticle(obj, 0); indef_mode = i;
];

[ PrintShortName obj i;
    i = indef_mode; indef_mode = NULL;
    PSN__(obj); indef_mode = i;
];

[ I7_SOO_PAR oldval count; if (count <= 1) return count; return random(count); ];
[ I7_SOO_RAN oldval count v; if (count <= 1) return count;
	v = oldval; while (v == oldval) v = random(count); return v; ];
[ I7_SOO_STI oldval count v; if (oldval) return oldval; return I7_SOO_PAR(oldval, count); ];
[ I7_SOO_CYC oldval count; oldval++; if (oldval > count) oldval = 1; return oldval; ];
[ I7_SOO_STOP oldval count; oldval++; if (oldval > count) oldval = count; return oldval; ];
[ I7_SOO_TAP oldval count tn rn c; if (count <= 1) return count; tn = count*(count+1)/2;
	rn = random(tn); for (c=1:c<=count:c++) { rn = rn - c; if (rn<=0) return (count-c+1); } ];
[ I7_SOO_TRAN oldval count; if (oldval<count) return oldval+1; 
	return count + 1 + I7_SOO_RAN(oldval%(count+1), count); ];
[ I7_SOO_TPAR oldval count; if (oldval<count) return oldval+1; 
	return count + 1 + I7_SOO_PAR(oldval%(count+1), count); ];

Array I7_SOO_SHUF->32;

[ I7_SOO_SHU oldval count sd ct v i j s ssd scope cc base;
	base = count+1;
	v = oldval%base; oldval = oldval/base; ct = oldval%base; sd = oldval/base;
	if (count > 32) return I7_SOO_PAR(oldval, count);
	if (count <= 1) v = count;
	else {
		!print "^In v=", v, " ct=", ct, " sd=", sd, "^";
		cc = base*base;
		scope = (MAX_POSITIVE_NUMBER-1)/cc;
		!print "Scope = ", scope, "^";
		if (sd == 0) { sd = random(scope); ct=0; }
		for (i=0:i<count:i++) I7_SOO_SHUF->i = i;
		ssd = sd;
		for (i=0:i<count-1:i++) {
			j = (sd)%(count-i)+i; sd = (sd*31973)+17; if (sd<0) sd=-sd;
			s = I7_SOO_SHUF->j; I7_SOO_SHUF->j = I7_SOO_SHUF->i; I7_SOO_SHUF->i = s;
		}
		!for (i=0:i<count:i++) print I7_SOO_SHUF->i, " "; print "^";
		v = (I7_SOO_SHUF->ct)+1;
		ct++; if (ct >= count) { ct = 0; ssd = 0; }
	}
	!print "Out v=", v, " ct=", ct, " ssd=", sd, "^";
	!print "Return ", v + ct*base + ssd*base*base, "^";
	return v + ct*base + ssd*base*base;
];

Constant RR_NAME     		4;
Constant RR_PERMISSIONS		5;
Constant RR_STORAGE			6;
Constant RR_KIND			7;
Constant RR_HANDLER			8;
Constant RR_DESCRIPTION		9;

Constant VALENCY_MASK = RELS_EQUIVALENCE+RELS_SYMMETRIC+RELS_X_UNIQUE+RELS_Y_UNIQUE;
[ RELATION_TY_EquivalenceAdjective rel set  perms state handler;
	perms = rel-->RR_PERMISSIONS;
	if (perms & RELS_EQUIVALENCE) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		perms = perms + RELS_EQUIVALENCE;
		if (perms & RELS_SYMMETRIC == 0) perms = perms + RELS_SYMMETRIC;
	}
	if ((set == false) && (state)) {
		perms = perms - RELS_EQUIVALENCE;
		if (perms & RELS_SYMMETRIC) perms = perms - RELS_SYMMETRIC;
	}
	rel-->RR_PERMISSIONS = perms;
	handler = rel-->RR_HANDLER;
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to an equivalence relation ***";		
];

[ RELATION_TY_SymmetricAdjective rel set  perms state handler;
	perms = rel-->RR_PERMISSIONS;
	if (perms & RELS_SYMMETRIC) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) perms = perms + RELS_SYMMETRIC;
	if ((set == false) && (state)) perms = perms - RELS_SYMMETRIC;
	rel-->RR_PERMISSIONS = perms;
	handler = rel-->RR_HANDLER;
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a symmetric relation ***";		
];

[ RELATION_TY_OToOAdjective rel set  perms state handler;
	perms = rel-->RR_PERMISSIONS;
	if (perms & (RELS_X_UNIQUE+RELS_Y_UNIQUE) == RELS_X_UNIQUE+RELS_Y_UNIQUE) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		if (perms & RELS_X_UNIQUE == 0) perms = perms + RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE == 0) perms = perms + RELS_Y_UNIQUE;
		if (perms & RELS_EQUIVALENCE) perms = perms - RELS_EQUIVALENCE;
	}
	if ((set == false) && (state)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
	}
	rel-->RR_PERMISSIONS = perms;
	handler = rel-->RR_HANDLER;
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a one-to-one relation ***";		
];

[ RELATION_TY_OToVAdjective rel set  perms state handler;
	perms = rel-->RR_PERMISSIONS;
	if (perms & (RELS_X_UNIQUE+RELS_Y_UNIQUE) == RELS_X_UNIQUE) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		if (perms & RELS_X_UNIQUE == 0) perms = perms + RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
		if (perms & RELS_SYMMETRIC) perms = perms - RELS_SYMMETRIC;
		if (perms & RELS_EQUIVALENCE) perms = perms - RELS_EQUIVALENCE;
	}
	if ((set == false) && (state)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
	}
	rel-->RR_PERMISSIONS = perms;
	handler = rel-->RR_HANDLER;
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a one-to-various relation ***";		
];

[ RELATION_TY_VToOAdjective rel set  perms state handler;
	perms = rel-->RR_PERMISSIONS;
	if (perms & (RELS_X_UNIQUE+RELS_Y_UNIQUE) == RELS_Y_UNIQUE) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE == 0) perms = perms + RELS_Y_UNIQUE;
		if (perms & RELS_SYMMETRIC) perms = perms - RELS_SYMMETRIC;
		if (perms & RELS_EQUIVALENCE) perms = perms - RELS_EQUIVALENCE;
	}
	if ((set == false) && (state)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
	}
	rel-->RR_PERMISSIONS = perms;
	handler = rel-->RR_HANDLER;
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a various-to-one relation ***";		
];

[ RELATION_TY_VToVAdjective rel set  perms state handler;
	perms = rel-->RR_PERMISSIONS;
	if (perms & (RELS_X_UNIQUE+RELS_Y_UNIQUE) == 0) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
	}
	if ((set == false) && (state)) {
		if (perms & RELS_X_UNIQUE == 0) perms = perms + RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE == 0) perms = perms + RELS_Y_UNIQUE;
	}
	rel-->RR_PERMISSIONS = perms;
	handler = rel-->RR_HANDLER;
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a various-to-various relation ***";		
];

[ Relation_Now1to1 obj1 relation_property obj2 ol; ! Assert 1-1 true
	if (obj2) objectloop (ol provides relation_property)
		if (ol.relation_property == obj2) ol.relation_property = nothing;
	if (obj1) obj1.relation_property = obj2;
];

[ Relation_NowN1toV obj1 relation_property obj2; ! Assert 1-1 false
	if ((obj1) && (obj1.relation_property == obj2)) obj1.relation_property = nothing;
];

[ Relation_Now1to1V obj1 obj2 KOV relation_property ol N; ! Assert 1-1 true
	if (obj2) {
		N = KOVDomainSize(KOV);
		for (ol=1: ol<=N: ol++)
			if (GProperty(KOV, ol, relation_property) == obj2)
				WriteGProperty(KOV, ol, relation_property, 0);
	}
	if (obj1) WriteGProperty(KOV, obj1, relation_property, obj2);
];

[ Relation_NowN1toVV obj1 obj2 KOV relation_property; ! Assert 1-1 false
	if ((obj1) && (GProperty(KOV, obj1, relation_property) == obj2))
		WriteGProperty(KOV, obj1, relation_property, 0);
];

[ Relation_NowS1to1 obj1 relation_property obj2; ! Assert symmetric 1-1 true
	if ((obj1 ofclass Object) && (obj1 provides relation_property) &&
		(obj2 ofclass Object) && (obj2 provides relation_property)) {
		if (obj1.relation_property) { (obj1.relation_property).relation_property = 0; }
		if (obj2.relation_property) { (obj2.relation_property).relation_property = 0; }
		obj1.relation_property = obj2; obj2.relation_property = obj1;
	}
];

[ Relation_NowSN1to1 obj1 relation_property obj2; ! Assert symmetric 1-1 false
	if ((obj1 ofclass Object) && (obj1 provides relation_property) &&
		(obj2 ofclass Object) && (obj2 provides relation_property) &&
		(obj1.relation_property == obj2)) {
		obj1.relation_property = 0; obj2.relation_property = 0;
	}
];

[ Relation_NowS1to1V obj1 obj2 KOV relation_property; ! Assert symmetric 1-1 true
	if (GProperty(KOV, obj1, relation_property))
		WriteGProperty(KOV, GProperty(KOV, obj1, relation_property), relation_property, 0);
	if (GProperty(KOV, obj2, relation_property)) 
		WriteGProperty(KOV, GProperty(KOV, obj2, relation_property), relation_property, 0);
	WriteGProperty(KOV, obj1, relation_property, obj2);
	WriteGProperty(KOV, obj2, relation_property, obj1);
];

[ Relation_NowSN1to1V obj1 obj2 KOV relation_property; ! Assert symmetric 1-1 false
	if (GProperty(KOV, obj1, relation_property) == obj2) {
		WriteGProperty(KOV, obj1, relation_property, 0);
		WriteGProperty(KOV, obj2, relation_property, 0);
	}
];

Constant VTOVS_LEFT_INDEX_PROP = 0;
Constant VTOVS_RIGHT_INDEX_PROP = 1;
Constant VTOVS_LEFT_DOMAIN_SIZE = 2;
Constant VTOVS_RIGHT_DOMAIN_SIZE = 3;
Constant VTOVS_LEFT_PRINTING_ROUTINE = 4;
Constant VTOVS_RIGHT_PRINTING_ROUTINE = 5;
Constant VTOVS_CACHE_BROKEN = 6;
Constant VTOVS_CACHE = 7;

[ Relation_NowVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
	if (sym && (obj2 ~= obj1)) { Relation_NowVtoV(obj2, relation, obj1, false); }
	vtov_structure = relation-->RR_STORAGE;
	pr = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	vtov_structure-->VTOVS_CACHE_BROKEN = true; ! Mark any cache as broken
	if (pr) {
		if ((obj1 ofclass Object) && (obj1 provides pr)) i1 = obj1.pr;
		else return RunTimeProblem(RTP_IMPREL, obj1, relation);
	} else i1 = obj1-1;
	if (pr2) {
		if ((obj2 ofclass Object) && (obj2 provides pr2)) i2 = obj2.pr2;
		else return RunTimeProblem(RTP_IMPREL, obj2, relation);
	} else i2 = obj2-1;
	pr = i1*(vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE) + i2;
	i1 = IncreasingPowersOfTwo_TB-->(pr%16);
	pr = pr/16 + 8;
	vtov_structure-->pr = (vtov_structure-->pr) | i1;
];

[ Relation_NowNVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
	if (sym && (obj2 ~= obj1)) { Relation_NowNVtoV(obj2, relation, obj1, false); }
	vtov_structure = relation-->RR_STORAGE;
	pr = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	vtov_structure-->VTOVS_CACHE_BROKEN = true; ! Mark any cache as broken
	if (pr) {
		if ((obj1 ofclass Object) && (obj1 provides pr)) i1 = obj1.pr;
		else return RunTimeProblem(RTP_IMPREL, obj1, relation);
	} else i1 = obj1-1;
	if (pr2) {
		if ((obj2 ofclass Object) && (obj2 provides pr2)) i2 = obj2.pr2;
		else return RunTimeProblem(RTP_IMPREL, obj2, relation);
	} else i2 = obj2-1;
	pr = i1*(vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE) + i2;
	i1 = IncreasingPowersOfTwo_TB-->(pr%16);
	pr = pr/16 + 8;
	if ((vtov_structure-->pr) & i1) vtov_structure-->pr = vtov_structure-->pr - i1;
];

[ Relation_TestVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
	vtov_structure = relation-->RR_STORAGE;
	pr = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	if (sym && (obj2 > obj1)) { sym = obj1; obj1 = obj2; obj2 = sym; }
	if (pr) {
		if ((obj1 ofclass Object) && (obj1 provides pr)) i1 = obj1.pr;
		else { RunTimeProblem(RTP_IMPREL, obj1, relation); rfalse; }
	} else i1 = obj1-1;
	if (pr2) {
		if ((obj2 ofclass Object) && (obj2 provides pr2)) i2 = obj2.pr2;
		else { RunTimeProblem(RTP_IMPREL, obj2, relation); rfalse; }
	} else i2 = obj2-1;
	pr = i1*(vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE) + i2;
	i1 = IncreasingPowersOfTwo_TB-->(pr%16);
	pr = pr/16 + 8;
	if ((vtov_structure-->pr) & i1) rtrue; rfalse;
];

[ Relation_NowEquiv obj1 relation_property obj2 big little;
	big = obj1.relation_property; little = obj2.relation_property;
	if (big == little) return;
	if (big < little) { little = obj1.relation_property; big = obj2.relation_property; }
	objectloop (obj1 provides relation_property)
		if (obj1.relation_property == big) obj1.relation_property = little;
];

[ Relation_NowNEquiv obj1 relation_property obj2 old new;
	old = obj1.relation_property; new = obj2.relation_property;
	if (old ~= new) return;
	new = 0;
	objectloop (obj2 provides relation_property)
		if (obj2.relation_property > new) new = obj2.relation_property;
	new++;
	obj1.relation_property = new;
];

[ Relation_NowEquivV obj1 obj2 KOV relation_property n big little i;
	big = GProperty(KOV, obj1, relation_property);
	little = GProperty(KOV, obj2, relation_property);
	if (big == little) return;
	if (big < little) {
		little = GProperty(KOV, obj1, relation_property);
		big = GProperty(KOV, obj2, relation_property);
	}
	n = KOVDomainSize(KOV);
	for (i=1: i<=n: i++)
		if (GProperty(KOV, i, relation_property) == big)
			WriteGProperty(KOV, i, relation_property, little);
];

[ Relation_NowNEquivV obj1 obj2 KOV relation_property n old new i;
	old = GProperty(KOV, obj1, relation_property); 
	new = GProperty(KOV, obj2, relation_property);
	if (old ~= new) return;
	new = 0;
	n = KOVDomainSize(KOV);
	for (i=1: i<=n: i++)
		if (GProperty(KOV, i, relation_property) > new)
			new = GProperty(KOV, i, relation_property);
	new++;
	WriteGProperty(KOV, obj1, relation_property, new);
];

[ Relation_ShowVtoV relation sym x obj1 obj2 pr pr2 proutine1 proutine2 vtov_structure;
	vtov_structure = relation-->RR_STORAGE;
	pr = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	proutine1 = vtov_structure-->VTOVS_LEFT_PRINTING_ROUTINE;
	proutine2 = vtov_structure-->VTOVS_RIGHT_PRINTING_ROUTINE;
 
	if (pr && pr2) {
		objectloop (obj1 provides pr)
		  objectloop (obj2 provides pr2) {
				if (sym && obj2 > obj1) continue;
				if (Relation_TestVtoV(obj1, relation, obj2)) {
					if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
					print "  ", (The) obj1;
					if (sym) print "  <=>  "; else print "  >=>  ";
					print (the) obj2, "^";
				}
		  }
		return;
	}
	if (pr && (pr2==0)) {
		objectloop (obj1 provides pr)
		  for (obj2=1:obj2<=vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE:obj2++) {
				if (Relation_TestVtoV(obj1, relation, obj2)) {
					if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
					print "  ", (The) obj1, "  >=>  ";
					(proutine2).call(obj2);
					print "^";
				}
		  }
		return;
	}
	if ((pr==0) && (pr2)) {
		for (obj1=1:obj1<=vtov_structure-->2:obj1++)
		  objectloop (obj2 provides pr2) {
				if (Relation_TestVtoV(obj1, relation, obj2)) {
					if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
					print "  ";
					(proutine1).call(obj1);
					print "  >=>  ", (the) obj2, "^";
				}
		  }
		return;
	}
	for (obj1=1:obj1<=vtov_structure-->2:obj1++)
		  for (obj2=1:obj2<=vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE:obj2++)
			if (Relation_TestVtoV(obj1, relation, obj2)) {
				if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
				print "  ";
				(proutine1).call(obj1);
				print "  >=>  ";
				(proutine2).call(obj2);
				print "^";
		  }
];

[ Relation_ShowOtoO relation sym x relation_property t N obj1 obj2;
	relation_property = relation-->RR_STORAGE;
	t = KindBaseTerm(relation-->RR_KIND, 0); ! Kind of left term
	N = KOVDomainSize(t);
	if (t == OBJECT_TY) {
		objectloop (obj1 provides relation_property) {
			obj2 = obj1.relation_property;
			if (sym && obj2 < obj1) continue;
			if (obj2 == 0) continue;
			if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
			print "  ", (The) obj1;
			if (sym) print "  ==  "; else print "  >=>  ";
			print (the) obj2, "^";
		}
	} else {
		for (obj1=1: obj1<=N: obj1++) {
			obj2 = GProperty(t, obj1, relation_property);
			if (sym && obj2 < obj1) continue;
			if (obj2 == 0) continue;
			if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
			print "  ";
			PrintKindValuePair(t, obj1);
			if (sym) print "  ==  "; else print "  >=>  ";
			PrintKindValuePair(t, obj2);
			print "^";
		}
	}
];

[ Relation_RShowOtoO relation sym x relation_property obj1 obj2 t1 t2 N1 N2;
	relation_property = relation-->RR_STORAGE;
	t1 = KindBaseTerm(relation-->RR_KIND, 0); ! Kind of left term
	t2 = KindBaseTerm(relation-->RR_KIND, 1); ! Kind of right term
	if (t2 == OBJECT_TY) {
		if (t1 == OBJECT_TY) {
			objectloop (obj1) {
				objectloop (obj2 provides relation_property) {
					if (obj2.relation_property ~= obj1) continue;
					if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
					print "  ", (The) obj1;
					print "  >=>  ";
					print (the) obj2, "^";
				}
			}
		} else {
			N1 = KOVDomainSize(t1);
			for (obj1=1: obj1<=N1: obj1++) {
				objectloop (obj2 provides relation_property) {
					if (obj2.relation_property ~= obj1) continue;
					if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
					print "  "; PrintKindValuePair(t1, obj1);
					print "  >=>  ";
					print (the) obj2, "^";
				}
			}
		}
	} else {
		N2 = KOVDomainSize(t2);
		if (t1 == OBJECT_TY) {
			objectloop (obj1) {
				for (obj2=1: obj2<=N2: obj2++) {
					if (GProperty(t2, obj2, relation_property) ~= obj1) continue;
					if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
					print "  ", (The) obj1;
					print "  >=>  ";
					PrintKindValuePair(t2, obj2);
					print "^";
				}
			}
		} else {
			N1 = KOVDomainSize(t1);
			for (obj1=1: obj1<=N1: obj1++) {
				for (obj2=1: obj2<=N2: obj2++) {
					if (GProperty(t2, obj2, relation_property) ~= obj1) continue;
					if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
					print "  ";
					PrintKindValuePair(t1, obj1);
					print "  >=>  ";
					PrintKindValuePair(t2, obj2);
					print "^";
				}
			}
		}
	}
];

[ RSE_Flip KOV v relation_property x;
	x = GProperty(KOV, v, relation_property); x = -x;
	WriteGProperty(KOV, v, relation_property, x);
];
[ RSE_Set KOV v relation_property;
	if (GProperty(KOV, v, relation_property) < 0) rtrue; rfalse;
];
[ Relation_ShowEquiv relation relation_property obj1 obj2 v c d somegroups t N x;
	print (string) relation-->RR_DESCRIPTION, ":^";
	relation_property = relation-->RR_STORAGE;
	t = KindBaseTerm(relation-->RR_KIND, 0); ! Kind of left term
	N = KOVDomainSize(t);
	if (t == OBJECT_TY) {
		objectloop (obj1 provides relation_property)
			obj1.relation_property = -(obj1.relation_property);
		objectloop (obj1 provides relation_property) {
			if (obj1.relation_property < 0) {
				v = obj1.relation_property; c = 0;
				objectloop (obj2 has workflag2) give obj2 ~workflag2;
				objectloop (obj2 provides relation_property) {
					if (obj2.relation_property == v) {
						give obj2 workflag2;
						obj2.relation_property = -v;
						c++;
					}
				}
				if (c>1) {
					somegroups = true;
					print "  { ";
					WriteListOfMarkedObjects(ENGLISH_BIT);
					print " }^";
				} else obj1.relation_property = v;
			}
		}
		objectloop (obj2 has workflag2) give obj2 ~workflag2;
		c = 0; objectloop (obj1 provides relation_property)
			if (obj1.relation_property < 0) { c++; give obj1 workflag2; }
		if (c == 0) return;
		if (somegroups) print "  and "; else print "  ";
		if (c < 4) { WriteListOfMarkedObjects(ENGLISH_BIT); print " in"; }
		else print c;
		if (c == 1) print " a";
		print " single-member group";
		if (c > 1) print "s";
		print "^";
		objectloop (obj1 provides relation_property)
			if (obj1.relation_property < 0)
				obj1.relation_property = -(obj1.relation_property);
	} else {
		! A slower method, since we have less efficient storage:
		for (obj1 = 1: obj1 <= N: obj1++)
			RSE_Flip(t, obj1, relation_property);
		for (obj1 = 1: obj1 <= N: obj1++) {
			if (RSE_Set(t, obj1, relation_property)) {
				v = GProperty(t, obj1, relation_property);
				c = 0;
				for (obj2 = 1: obj2 <= N: obj2++)
					if (GProperty(t, obj2, relation_property) == v)
						c++;
				if (c>1) {
					somegroups = true;
					print "  {";
					d = 0;
					for (obj2 = 1: obj2 <= N: obj2++) {
						if (GProperty(t, obj2, relation_property) == v) {
							print " "; PrintKindValuePair(t, obj2);
							if (d < c-1) print ","; print " ";
							RSE_Flip(t, obj2, relation_property);
							d++;
						}
					}
					print "}^";
				} else WriteGProperty(t, obj1, relation_property, v);
			}
		}
		objectloop (obj2 has workflag2) give obj2 ~workflag2;
		c = 0;
		for (obj1 = 1: obj1 <= N: obj1++)
			if (RSE_Set(t, obj1, relation_property)) c++;
		if (c == 0) return;
		if (somegroups) print "  and "; else print "  ";
		if (c == 1) print "a"; else print c;
		print " single-member group";
		if (c > 1) print "s";
		print "^";
		for (obj1 = 1: obj1 <= N: obj1++)
			if (RSE_Set(t, obj1, relation_property))
				RSE_Flip(t, obj1, relation_property);
	}
];

#ifndef FAST_ROUTE_FINDING;
#ifndef SLOW_ROUTE_FINDING;
#ifdef TARGET_GLULX;
Constant FAST_ROUTE_FINDING;
#ifnot;
Constant SLOW_ROUTE_FINDING;
#endif;
#endif;
#endif;

Constant NUM_DOORS = 14;
Constant NUM_ROOMS = 21;

Array DoorRoutingViable -> NUM_DOORS+1;

Global map_has_changed = true;
Global last_filter; Global last_use_doors;

[ SignalMapChange; map_has_changed = true; ];

[ MapRouteTo from to filter use_doors count  oy oyi ds;
	if (from == nothing) return nothing;
	if (to == nothing) return nothing;
	if (from == to) return nothing;
	if ((filter) && (filter(from) == 0)) return nothing;
	if ((filter) && (filter(to) == 0)) return nothing;
	if ((last_filter ~= filter) || (last_use_doors ~= use_doors)) map_has_changed = true;
	oyi = 0;
	objectloop (oy has mark_as_room) {
		if ((filter == 0) || (filter(oy))) {
			if (oy.room_index == -1) map_has_changed = true;
			oy.room_index = oyi++;
		} else {
			if (oy.room_index >= 0) map_has_changed = true;
			oy.room_index = -1;
		}
	}
	oyi = 0;
	objectloop (oy ofclass K4_door) {
		ds = false;
		if ((use_doors & 2) ||
			(oy has open) || ((oy has openable) && (oy hasnt locked))) ds = true;
		if (DoorRoutingViable->oyi ~= ds) map_has_changed = true;
		DoorRoutingViable->oyi = ds;
		oyi++;
	}
	if (map_has_changed) {
		#ifdef FAST_ROUTE_FINDING; ComputeFWMatrix(filter, use_doors); #endif;
		map_has_changed = false; last_filter = filter; last_use_doors = use_doors;
	}
	#ifdef FAST_ROUTE_FINDING;
	if (count) return FastCountRouteTo(from, to, filter, use_doors);
	return FastRouteTo(from, to, filter, use_doors);
	#ifnot;
	if (count) return SlowCountRouteTo(from, to, filter, use_doors);
	return SlowRouteTo(from, to, filter, use_doors);
	#endif;
];

#ifdef FAST_ROUTE_FINDING;
Array FWMatrix --> NUM_ROOMS*NUM_ROOMS;

[ FastRouteTo from to filter use_doors diri i dir oy;
	if (from == to) return nothing;
	i = (FWMatrix-->(from.room_index*NUM_ROOMS + to.room_index))/No_Directions;
	if (i == 0) return nothing;
	diri = (FWMatrix-->(from.room_index*NUM_ROOMS + to.room_index))%No_Directions;
	i=0; objectloop (dir ofclass K3_direction) {
		if (i == diri) return dir;
		i++;
	}
	return nothing;
];

[ FastCountRouteTo from to filter use_doors  k;
	if (from == to) return 0;
	k = (FWMatrix-->(from.room_index*NUM_ROOMS + to.room_index))/No_Directions;
	if (k == 0) return -1;
	return k;
];

[ ComputeFWMatrix filter use_doors  oy ox oj axy ayj axj dir diri nd row;
	objectloop (oy has mark_as_room) if (oy.room_index >= 0)
		objectloop (ox has mark_as_room) if (ox.room_index >= 0)
			FWMatrix-->(oy.room_index*NUM_ROOMS + ox.room_index) = 0;

	objectloop (oy has mark_as_room) if (oy.room_index >= 0) {
		row = (oy.IK1_Count)*No_Directions;
		for (diri=0: diri<No_Directions: diri++) {
			ox = Map_Storage-->(row+diri);
			if ((ox) && (ox has mark_as_room) && (ox.room_index >= 0)) {
				FWMatrix-->(oy.room_index*NUM_ROOMS + ox.room_index) = No_Directions + diri;
				continue;
			}
			if (use_doors && (ox ofclass K4_door) &&
				((use_doors & 2) || (DoorRoutingViable->(ox.IK4_Count)))) {
				@push location; location = oy;
				ox = ox.door_to();
				@pull location;
				if ((ox) && (ox has mark_as_room) && (ox.room_index >= 0)) {
					FWMatrix-->(oy.room_index*NUM_ROOMS + ox.room_index) = No_Directions + diri;
					continue;
				}
			}
		}	
	}

	objectloop (oy has mark_as_room) if (oy.room_index >= 0)
		objectloop (ox has mark_as_room) if (ox.room_index >= 0) {
			axy = (FWMatrix-->(ox.room_index*NUM_ROOMS + oy.room_index))/No_Directions;
			if (axy > 0)
				objectloop (oj has mark_as_room) if (oj.room_index >= 0) {
					ayj = (FWMatrix-->(oy.room_index*NUM_ROOMS + oj.room_index))/No_Directions;
					if (ayj > 0) {
						!print "Is it faster to go from ", (name) ox, " to ",
						!   (name) oj, " via ", (name) oy, "?^";
						axj = (FWMatrix-->(ox.room_index*NUM_ROOMS + oj.room_index))/
							No_Directions;
						if ((axj == 0) || (axy + ayj < axj)) {
							!print "Yes^";
							FWMatrix-->(ox.room_index*NUM_ROOMS + oj.room_index) =
								(axy + ayj)*No_Directions +
								(FWMatrix-->(ox.room_index*NUM_ROOMS + oy.room_index))%
									No_Directions;
						}
					}
				}
		}
];
#ENDIF;

#ifndef FAST_ROUTE_FINDING;
[ SlowRouteTo from to filter use_doors  obj dir in_direction progressed sl through_door;
	if (from == nothing) return nothing;
	if (to == nothing) return nothing;
	if (from == to) return nothing;
	objectloop (obj has mark_as_room) obj.vector = 0;
	to.vector = 1;
	!print "Routing from ", (the) from, " to ", (the) to, "^";
	while (true) {
		progressed = false;
		!print "Pass begins^";
		objectloop (obj has mark_as_room)
			if ((filter == 0) || (filter(obj)))
				if (obj.vector == 0)
					objectloop (dir ofclass K3_direction) {
						in_direction = Map_Storage-->((obj.IK1_Count)*No_Directions + dir.IK3_Count);
						if (in_direction == nothing) continue;
						!print (the) obj, " > ", (the) dir, " > ", (the) in_direction, "^";
						if ((in_direction)
							&& (in_direction has mark_as_room)
							&& (in_direction.vector > 0)
							&& ((filter == 0) || (filter(in_direction)))) {
							obj.vector = dir | WORD_HIGHBIT;
							!print "* ", (the) obj, " vector is ", (the) dir, "^";
							progressed = true;
							continue;
						}
						if (use_doors && (in_direction ofclass K4_door) &&
							((use_doors & 2) ||
							 (in_direction has open) ||
							 ((in_direction has openable) && (in_direction hasnt locked)))) {
							sl = location; location = obj;
							through_door = in_direction.door_to();
							location = sl;
							!print "Through door is ", (the) through_door, "^";
							if ((through_door)
								&& (through_door has mark_as_room)
								&& (through_door.vector > 0)
								&& ((filter == 0) || (filter(through_door)))) {
								obj.vector = dir | WORD_HIGHBIT;
								!print "* ", (the) obj, " vector is ", (the) dir, "^";
								progressed = true;
								continue;
							}
						}
					}
		objectloop (obj has mark_as_room) obj.vector = obj.vector &~ WORD_HIGHBIT;
		if (from.vector) return from.vector;
		if (progressed == false) return from.vector;
	}
];

[ SlowCountRouteTo from to filter use_doors obj i;
	if (from == nothing) return -1;
	if (to == nothing) return -1;
	if (from == to) return 0;
	if (from has mark_as_room && to has mark_as_room) {
		obj = MapRouteTo(from,to,filter,use_doors);
		if (obj == nothing) return -1;
		i = 0; obj = from;
		while ((obj ~= to) && (i<NUM_ROOMS)) { i++; obj = MapConnection(obj,obj.vector); }
		return i;
	}
	return -1;
];
#ENDIF;

Constant MAX_ROUTE_LENGTH = 211 + 32;

[ RelationRouteTo relation from to count  handler;
	if (count) {
		if (from == nothing) return -1;
		if (to == nothing) return -1;
		if (relation == 0) return -1;
	} else {
		if (from == nothing) return nothing;
		if (to == nothing) return nothing;
		if (relation == 0) return nothing;
	}
	if (from == to) return nothing;
	if (((relation-->RR_PERMISSIONS) & RELS_ROUTE_FIND) == 0) {
		RunTimeProblem(RTP_ROUTELESS);
		return nothing;
	}
	if (relation-->RR_STORAGE == 0) return nothing;
	handler = relation-->RR_HANDLER;
	if (count) return handler(relation, RELS_ROUTE_FIND_COUNT, from, to);
	return handler(relation, RELS_ROUTE_FIND, from, to);
];

[ RelFollowVector rv from to  obj i;
	if (rv == nothing) return -1;
	i = 0; obj = from;
	while ((obj ~= to) && (i<=MAX_ROUTE_LENGTH)) { i++; obj = obj.vector; }
	return i;
];

[ OtoVRelRouteTo relation_property from to previous;
	while ((to) && (to provides relation_property) && (to.relation_property)) {
		previous = to.relation_property;
		previous.vector = to;
		if (previous == from) return to;
		to = previous;
	}
	return nothing;
];

[ VtoORelRouteTo relation_property from to next  start;
	start = from;
	while ((from) && (from provides relation_property) && (from.relation_property)) {
		next = from.relation_property;
		from.vector = next;
		if (from == to) return start.vector;
		from = next;
	}
	return nothing;
];

[ VtoVRelRouteTo relation from to count obj obj2 related progressed left_ix pr2 i vtov_structure;
	vtov_structure = relation-->RR_STORAGE;
	if (vtov_structure-->VTOVS_CACHE)
		return FastVtoVRelRouteTo(relation, from, to, count);
	left_ix = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	objectloop (obj ofclass Object && obj provides vector) obj.vector = 0;
	to.vector = 1;
	while (true) {
		progressed = false;
		objectloop (obj ofclass Object && obj provides left_ix)
			if (obj.vector == 0) {
				objectloop (obj2 ofclass Object && obj2 provides pr2 && obj2.vector > 0) {
					if (Relation_TestVtoV(obj, relation, obj2)) {
						obj.vector = obj2 | WORD_HIGHBIT;
						progressed = true;
						continue;
					}
				}
			}
		objectloop (obj ofclass Object && obj provides left_ix)
			obj.vector = obj.vector &~ WORD_HIGHBIT;
		if (from.vector) break;
		if (progressed == false) break;
	}
	if (count) {
		if (from.vector == nothing) return -1;
		i = 0; obj = from;
		while ((obj ~= to) && (i<=MAX_ROUTE_LENGTH)) { i++; obj = obj.vector; }
		return i;
	}
	return from.vector;
];

[ FastVtoVRelRouteTo relation from to count
	domainsize cache cache2 left_ix ox oy oj offset axy axj ayj;
	domainsize = relation-->RR_STORAGE-->2; ! Number of left instances
	left_ix = relation-->RR_STORAGE-->VTOVS_LEFT_INDEX_PROP;
	if ((from provides left_ix) && (to provides left_ix)) {
		if (domainsize < 256) {
			cache = relation-->RR_STORAGE-->VTOVS_CACHE;
			cache2 = cache + domainsize*domainsize;
			if (relation-->RR_STORAGE-->VTOVS_CACHE_BROKEN == true) {
				relation-->RR_STORAGE-->VTOVS_CACHE_BROKEN = false;
				objectloop (oy provides left_ix)
					objectloop (ox provides left_ix)
						if (Relation_TestVtoV(oy, relation, ox)) {
							offset = ((oy.left_ix)*domainsize + (ox.left_ix));
							cache->offset = 1;
							cache2->offset = ox.left_ix;
						} else {
							offset = ((oy.left_ix)*domainsize + (ox.left_ix));
							cache->offset = 0;
							cache2->offset = 255;
						}
				for (oy=0: oy<domainsize: oy++)
					for (ox=0: ox<domainsize: ox++) {
						axy = cache->(ox*domainsize + oy);
						if (axy > 0)
							for (oj=0: oj<domainsize: oj++) {
								ayj = cache->(oy*domainsize + oj);
								if (ayj > 0) {
									offset = ox*domainsize + oj;
									axj = cache->offset;
									if ((axj == 0) || (axy + ayj < axj)) {
										cache->offset = (axy + ayj);
										cache2->offset = cache2->(ox*domainsize + oy);
									}
								}
							}
					}
			}
			if (count) {
				count = cache->((from.left_ix)*domainsize + (to.left_ix));
				if (count == 0) return -1;
				return count;
			}
			oy = cache2->((from.left_ix)*domainsize + (to.left_ix));
			if (oy < 255)
				objectloop (ox provides left_ix)
					if (ox.left_ix == oy) return oy;
			return nothing;
		} else {
			cache = relation-->RR_STORAGE-->VTOVS_CACHE;
			cache2 = cache + WORDSIZE*domainsize*domainsize;
			if (relation-->RR_STORAGE-->VTOVS_CACHE_BROKEN == true) {
				relation-->RR_STORAGE-->VTOVS_CACHE_BROKEN = false;
				objectloop (oy provides left_ix)
					objectloop (ox provides left_ix)
						if (Relation_TestVtoV(oy, relation, ox)) {
							offset = ((oy.left_ix)*domainsize + (ox.left_ix));
							cache-->offset = 1;
							cache2-->offset = ox;
						} else {
							offset = ((oy.left_ix)*domainsize + (ox.left_ix));
							cache-->offset = 0;
							cache2-->offset = nothing;
						}
				for (oy=0: oy<domainsize: oy++)
					for (ox=0: ox<domainsize: ox++) {
						axy = cache-->(ox*domainsize + oy);
						if (axy > 0)
							for (oj=0: oj<domainsize: oj++) {
								ayj = cache-->(oy*domainsize + oj);
								if (ayj > 0) {
									offset = ox*domainsize + oj;
									axj = cache-->offset;
									if ((axj == 0) || (axy + ayj < axj)) {
										cache-->offset = (axy + ayj);
										cache2-->offset = cache2-->(ox*domainsize + oy);
									}
								}
							}
					}
			}
			if (count) {
				count = cache-->((from.left_ix)*domainsize + (to.left_ix));
				if (count == 0) return -1;
				return count;
			}
			return cache2-->((from.left_ix)*domainsize + (to.left_ix));
		}
	}
	if (count) return -1;
	return nothing;
];

[ IterateRelations callback;
	callback(Rel_Record_63);
    callback(Rel_Record_65);
    callback(Rel_Record_67);
    callback(Rel_Record_69);
    callback(Rel_Record_71);

];

[ RunTimeProblem n par1 par2 par3 ln   i c;
	if (enable_rte == false) return;
	enable_rte = false;
	print "^*** Run-time problem P", n;
	if (ln) print " (at paragraph ", ln, " in the source text)";
	print ": ";
	switch(n) {
		RTP_BACKDROP:
			print "Tried to move ", (the) par1, " (a backdrop) to ", (the) par2,
				", which is not a region.^";
		RTP_CANTCHANGE:
			print "Tried to change player to ", (the) par1, ", which is not a person.^";
		RTP_NOEXIT:
		    print "Tried to change ", (the) par2, " exit of ", (the) par1,
		    	", but it didn't seem to have such an exit to change.^";
		RTP_EXITDOOR:
		    print "Tried to change ", (the) par2, " exit of ", (the) par1,
		    	", but it led to a door, not a room.^";
		RTP_IMPREL:
			print "Tried to access an inappropriate relation for ", (the) par1,
				", violating '", (string) par2-->RR_DESCRIPTION, "'.^";
		RTP_RULESTACK:
			print "Too many procedural rules acting all at once.^";
		RTP_TOOMANYRULEBOOKS:
			print "Too many rulebooks in simultaneous use.^";
		RTP_TOOMANYEVENTS:
			print "Too many timed events are going on at once.^";
		RTP_BADPROPERTY:
			print "Tried to access non-existent property for ", (the) par1, ".^";
		RTP_UNPROVIDED:
			print "Since ", (the) par1, " is not allowed the property ~",
					(string) par2, "~, it is against the rules to try to use it.^";
		RTP_UNSET:
			print "Although ", (the) par1, " is allowed to have the property ~",
				(string) par2, "~, no value was ever given, so it can't now be used.^";
		RTP_TOOMANYACTS:
			print "Too many activities are going on at once.^";
		RTP_CANTABANDON:
			print "Tried to abandon an activity which wasn't going on.^";
		RTP_CANTEND:
			print "Tried to end an activity which wasn't going on.^";
		RTP_CANTMOVENOTHING:
			print "You can't move nothing.^";
		RTP_CANTREMOVENOTHING:
			print "You can't remove nothing from play.^";
		RTP_DIVZERO:
			print "You can't divide by zero.^";
		RTP_BADVALUEPROPERTY:
			print "Tried to access property for a value which didn't fit: ",
				"if this were a number it would be ", par1, ".^";
		RTP_NOTBACKDROP:
			print "Tried to move ", (the) par1, " (not a backdrop) to ", (the) par2,
				", which is a region.^";
		RTP_TABLE_NOCOL:
			print "Attempt to look up a non-existent column in the table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_NOCORR:
			print "Attempt to look up a non-existent correspondence in the table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_NOROW:
			print "Attempt to look up a non-existent row in the table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_NOENTRY:
			print "Attempt to look up a non-existent entry at column ", par2,
				", row ", par3, " of the table '", (PrintTableName) par1, "'.^";
		RTP_TABLE_NOTABLE:
			print "Attempt to blank out a row from a non-existent table (value ",
				par1, ").^";
		RTP_TABLE_NOMOREBLANKS:
			print "Attempt to choose a blank row in a table with none left: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_NOROWS:
			print "Attempt to choose a random row in an entirely blank table: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_CANTRUNTHROUGH:
			print "Attempt to repeat through a table in a tricky column order: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_CANTSORT:
			print "Attempt to sort a table whose ordering must remain fixed: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_CANTSAVE:
			print "Attempt to save a table to a file whose data is unstable: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_WONTFIT:
			print "File being read has too many rows or columns to fit into table: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_BADFILE:
			print "File being read is not a previously saved table: table '",
				(PrintTableName) par1, "'.^";
		RTP_NOTINAROOM:
			print "Attempt to test if the current location is '",
				(the) par1, "', which is not a room or region.^";
		RTP_BADTOPIC:
			print "Attempt to see if a snippet of text matches something which
				is not a topic.^";
		RTP_ROUTELESS:
			print "Attempt to find route or count steps through an implicit
				relation.^";
		RTP_PROPOFNOTHING:
			print "Attempt to use a property of the 'nothing' non-object: property ",
				(PrintPropertyName) par2, "^";
		RTP_DECIDEONWRONGKIND:
			print "Attempt to 'decide on V' where V is the wrong kind of object.^";
		RTP_DECIDEONNOTHING:
			print "Attempt to 'decide on nothing'.^";
		RTP_LOWLEVELERROR:
			print "Low level error.^";
		RTP_DONTIGNORETURNSEQUENCE:
			print "Attempt to ignore the turn sequence rules.^";
		RTP_SAYINVALIDSNIPPET:
			print "Attempt to say a snippet value which is currently invalid: words ",
				par1, " to ", par2, ".^";
		RTP_SPLICEINVALIDSNIPPET:
			print "Attempt to splice a snippet value which is currently invalid: words ",
				par1, " to ", par2, ".^";
		RTP_INCLUDEINVALIDSNIPPET:
			print "Attempt to match a snippet value which is currently invalid: words ",
				par1, " to ", par2, ".^";
		RTP_LISTWRITERMEMORY:
			print "The list-writer has run out of memory.^";
		RTP_CANTREMOVEPLAYER:
			print "Attempt to remove the player from play.^";
		RTP_CANTREMOVEDOORS:
			print "Attempt to remove a door from play.^";
		RTP_CANTCHANGEOFFSTAGE:
			print "Attempt to change the player to a person off-stage.^";
		RTP_MSTACKMEMORY:
			print "The memory stack is exhausted.^";
		RTP_TYPECHECK:
			print "Phrase applied to an incompatible kind of value.^";
		RTP_FILEIOERROR:
			print "Error handling external file.^";
		RTP_HEAPERROR:
			print "Memory allocation proved impossible.^";
		RTP_LISTRANGEERROR:
			print "Attempt to use list item which does not exist.^";
		RTP_REGEXPSYNTAXERROR:
			print "Syntax error in regular expression.^";
		RTP_NOGLULXUNICODE:
			print "This interpreter does not support Unicode.^";
		RTP_BACKDROPONLY:
			print "Only backdrops can be moved to multiple places.^";
		RTP_NOTBACKDROP:
			print "Tried to move ", (the) par1, " (not a thing) to ", (the) par2,
				", but only things can move around.^";
		RTP_SCENEHASNTSTARTED:
			print "The scene ", (PrintSceneName) par1,
				" hasn't started, so you can't ask when it did.^";
		RTP_SCENEHASNTENDED:
			print "The scene ", (PrintSceneName) par1,
				" hasn't ended, so you can't ask when it did.^";
		RTP_NEGATIVEROOT:
			print "You can't take the square root of a negative number.^";
		RTP_CANTITERATE:
			print "You can't implicitly repeat through the values of this kind: ",
				"a problem arising from a description which started out here - ~",
				(string) par1, "~.^";
		RTP_WRONGASSIGNEDKIND:
			print "Attempt to set a variable to the wrong kind of object: ",
				"you wrote '", (string) par2, "', which sets the value to ", (the) par1,
				" - but that doesn't have the kind '", (string) par3, "'.^";			
		}
	print "^";
];

Constant MAX_TIMERS = 0;
[ RunTimeError n p1 p2;
    #Ifdef DEBUG;
    print "** Library error ", n, " (", p1, ",", p2, ") **^** ";
    switch (n) {
      1:    print "preposition not found (this should not occur)";
      2:    print "Property value not routine or string: ~", (property) p2, "~ of ~", (name) p1,
                  "~ (", p1, ")";
      3:    print "Entry in property list not routine or string: ~", (property) p2, "~ list of ~",
                  (name) p1, "~ (", p1, ")";
      4:    print "Too many timers/daemons are active simultaneously.
                  The limit is the library constant MAX_TIMERS (currently ",
                  MAX_TIMERS, ") and should be increased";
      5:    print "Object ~", (name) p1, "~ has no ~time_left~ property";
      7:    print "The object ~", (name) p1, "~ can only be used as a player object if it has
                  the ~number~ property";
      8:    print "Attempt to take random entry from an empty table array";
      9:    print p1, " is not a valid direction property number";
      10:   print "The player-object is outside the object tree";
      11:   print "The room ~", (name) p1, "~ has no ~description~ property";
      12:   print "Tried to set a non-existent pronoun using SetPronoun";
      13:   print "A 'topic' token can only be followed by a preposition";
      default: print "(unexplained)";
    }
    print " **^";
    #Ifnot;
    print "** Library error ", n, " (", p1, ",", p2, ") **^";
    #Endif; ! DEBUG
    RunTimeProblem(RTP_LOWLEVELERROR);
];

[ ArgumentTypeFailed file line arg;
	RunTimeProblem(RTP_TYPECHECK, 0, 0, 0, line);
];

[ CheckKindReturned V K;
	if (V ofclass K) return V;
	if (v == nothing) RunTimeProblem(RTP_DECIDEONNOTHING);
	else RunTimeProblem(RTP_DECIDEONWRONGKIND);
	return V;
];

[ WhetherProvides obj either_or p issue_rtp  off i textual a l;
	if (metaclass(obj) ~= Object) rfalse;
	if (p<0) p = ~p;
	if (either_or) {
		if (p < FBNA_PROP_NUMBER) off = attributed_property_offsets-->p;
		else off = valued_property_offsets-->p;
	} else off = valued_property_offsets-->p;
	if (off<0) {
		if (issue_rtp) RunTimeProblem(RTP_BADPROPERTY, obj);
		rfalse;
	}
	textual = property_metadata-->off; off++;
	
	if (ScanPropertyMetadata(obj, off)) jump PermissionFound;
	if (obj provides KD_Count) {
		l = obj.KD_Count;
		while (l > 0) {
			a = l*2;
			if (ScanPropertyMetadata(KindHierarchy-->a, off)) jump PermissionFound;
			l = KindHierarchy-->(a+1);
		}
	}
	if (issue_rtp) RunTimeProblem(RTP_UNPROVIDED, obj, textual);
	rfalse;

	.PermissionFound;
		if (either_or) rtrue;
		if (obj provides p) rtrue;
		if (issue_rtp) RunTimeProblem(RTP_UNSET, obj, textual);
		rfalse;
];

[ PrintPropertyName  p  off textual;
	if (p<0) p = ~p;
	off = valued_property_offsets-->p;
	textual = property_metadata-->off;
	print (string) textual;
];

[ ScanPropertyMetadata obj off i;
	for (i=off: property_metadata-->i >= 0: i++)
		if (obj == property_metadata-->i) rtrue;
	rfalse;
];

[ GetEitherOrProperty o p;
	if (o == nothing) rfalse;
	if (p<0) p = ~p;
	if (WhetherProvides(o, true, p, false)) {
		if (p<FBNA_PROP_NUMBER) { if (o has p) rtrue; rfalse; }
		if ((o provides p) && (o.p)) rtrue;
	}
	rfalse;
];

[ SetEitherOrProperty o p negate adj;
	if (p<0) { p = ~p; negate = ~negate; }
	if (adj) {
		(adj)(o);
	} else if (WhetherProvides(o, true, p, true)) {
		if (negate) {
			if (p<FBNA_PROP_NUMBER) give o ~p; else o.p = false;
		} else {
			if (p<FBNA_PROP_NUMBER) give o p; else o.p = true;
		}
	}
];

[ GProperty K V pr obj;
	if (K == OBJECT_TY) obj = V; else obj = KOV_representatives-->K;
	if (obj == 0) { RunTimeProblem(RTP_PROPOFNOTHING, obj, pr); rfalse; }
	if (obj provides pr) {
		if (K == OBJECT_TY) {
			if (pr == door_to) return obj.pr();
			if (WhetherProvides(V, false, pr, true)) return obj.pr;
			rfalse;
		}
		if (obj ofclass K0_kind)
			WhetherProvides(V, false, pr, true); ! to force a run-time problem
		if ((V < 1) || (V > obj.value_range)) {
			RunTimeProblem(RTP_BADVALUEPROPERTY); return 0; }
		return (obj.pr)-->(V+COL_HSIZE);
	} else {
		if (obj ofclass K0_kind)
			WhetherProvides(V, false, pr, true); ! to force a run-time problem
	}
    rfalse;
];

[ WriteGProperty K V pr val obj;
	if (K == OBJECT_TY) obj = V; else obj = KOV_representatives-->K;
	if (obj == 0) { RunTimeProblem(RTP_PROPOFNOTHING, obj, pr); rfalse; }
	if (K == OBJECT_TY) {
		if (WhetherProvides(V, false, pr, true)) obj.pr = val;
	} else {
		if ((V < 1) || (V > obj.value_range))
			return RunTimeProblem(RTP_BADVALUEPROPERTY);
		if (obj provides pr) { (obj.pr)-->(V+COL_HSIZE) = val; }
	}
];

[ PROPERTY_TY_Say v;
	print "property ", v;
];

Constant RULECHANGE_STACK_SIZE = 501;
Global rulechange_sp = 0;
Array rulechange_stack --> RULECHANGE_STACK_SIZE;

[ PushRuleChange usage rule1 rule2;
	if (rulechange_sp >= RULECHANGE_STACK_SIZE) return RunTimeProblem(RTP_RULESTACK);
	if ((rulechange_stack-->rulechange_sp == RS_SUCCEEDS or RS_FAILS) &&
		(KOVIsBlockValue(rulechange_stack-->(rulechange_sp+1))))
		BlkValueDestroy(rulechange_stack-->(rulechange_sp+2));
	if ((usage == RS_SUCCEEDS or RS_FAILS) && (KOVIsBlockValue(rule1)))
		rule2 = BlkValueCopy(BlkValueCreate(rule1), rule2);
	rulechange_stack-->rulechange_sp++ = usage;
	rulechange_stack-->rulechange_sp++ = rule1;
	rulechange_stack-->rulechange_sp++ = rule2;
];

Constant RS_FRAME       = -1;

Constant RS_DONOTRUN	= 1;
Constant RS_RUN			= 2;
Constant RS_MOVEBEFORE	= 3;
Constant RS_MOVEAFTER	= 4;
Constant RS_DONOTUSE	= 5;
Constant RS_USE			= 6;
Constant RS_SUBSTITUTE	= 7;

Constant RS_SUCCEEDS	= 8;
Constant RS_FAILS		= 9;
Constant RS_NEITHER		= 10;

Global rule_frames = 0; ! Number of frames currently in force
Constant MAX_SIMULTANEOUS_FRAMES = 20;

[ FollowRulebook rulebook parameter no_paragraph_skips  rv;
	@push self;
	if ((Protect_I7_Arrays-->0 ~= 16339) || (Protect_I7_Arrays-->1 ~= 12345)) {
		print "^^*** Fatal programming error: I7 arrays corrupted ***^^";
		@quit;
	}
	if (parameter) self = parameter;
	if (rulebook ~= PROCEDURAL_RB) BeginFollowRulebook();
	rv = ProcessRulebook(rulebook, parameter, no_paragraph_skips);
	if (rulebook ~= PROCEDURAL_RB) EndFollowRulebook();
	@pull self;
	if (rv) rtrue;
	rfalse;
];

[ BeginFollowRulebook;
	PushRuleChange(RS_FRAME, RS_FRAME, RS_FRAME);
	rule_frames++;
	if (rule_frames == MAX_SIMULTANEOUS_FRAMES) {
		RunTimeProblem(RTP_TOOMANYRULEBOOKS);
		rule_frames = -1; ! For recovery: this terminates rulebook processing
		return;
	}
	ProcessRulebook(PROCEDURAL_RB, 0, true);
];

[ EndFollowRulebook r x y;
	if (rulechange_stack-->rulechange_sp == RS_SUCCEEDS) r = 1;
	else if (rulechange_stack-->rulechange_sp == RS_FAILS) r = 0;
	else r = -1;
	if (r ~= -1) {
		x = rulechange_stack-->(rulechange_sp+1);
		y = rulechange_stack-->(rulechange_sp+2);
	}
	rule_frames--;
	while (rulechange_sp > 0) {
		rulechange_sp = rulechange_sp - 3;
		if (rulechange_stack-->rulechange_sp == RS_FRAME) break;
	}
	if (rulechange_sp == 0) rule_frames = 0;
	if (r == 1) rulechange_stack-->rulechange_sp = RS_SUCCEEDS;
	else if (r == 0) rulechange_stack-->rulechange_sp = RS_FAILS;
	if (r ~= -1) {
		rulechange_stack-->(rulechange_sp+1) = x;
		rulechange_stack-->(rulechange_sp+2) = y;
	}
];

Constant RS_ACTIVE_BIT		= 1;
Constant RS_MOVED_BIT		= 2;
Constant RS_USERESULT_BIT	= 4;
Constant RS_ACTIVITY		= 8;
Constant RS_NOSKIPS			= 16;
Constant RS_AFFECTED_BIT	= 32;

Global process_rulebook_count; ! Depth of processing recursion
Global debugging_rules = false; ! Are we tracing rule invocations?

[ ProcessRulebook rulebook parameter bits rv
	x frame_base substituted_rule usage original_deadflag rbaddress ra acf gc ga;
	if (bits) bits = RS_ACTIVITY + RS_NOSKIPS;
	if (say__pc & PARA_NORULEBOOKBREAKS) bits = bits | RS_NOSKIPS;
	if (rule_frames<0) rfalse;
	if (parameter) parameter_object = parameter;
	for (x = rulechange_sp-3: x>=0: x = x - 3) {
		usage = rulechange_stack-->x;
		if (usage == RS_FRAME) { x=x+3; break; }
		if (rulechange_stack-->(x+1) == rulebook) {
			bits = bits | (RS_AFFECTED_BIT);
			if (usage == RS_MOVEBEFORE or RS_MOVEAFTER)
				bits = bits | (RS_MOVED_BIT);
		}
		if (rulechange_stack-->(x+2) == rulebook) {
			bits = bits | (RS_AFFECTED_BIT);
		}
	} if (x<0) x=0; frame_base = x;
	if ((bits & RS_MOVED_BIT) && (rv == false)) { rfalse; }
	! rv was a call parameter: it's no longer needed and is now reused
	bits = bits | (RS_ACTIVE_BIT + RS_USERESULT_BIT);
	substituted_rule = rulebook; rv = 0;
	if (bits & RS_AFFECTED_BIT)
		for (: x<rulechange_sp: x = x + 3) {
			usage = rulechange_stack-->x;
			if (rulechange_stack-->(x+1) == rulebook) {
				if (usage == RS_DONOTRUN) bits = bits & (~RS_ACTIVE_BIT);
				if (usage == RS_RUN) bits = bits | (RS_ACTIVE_BIT);
				if (usage == RS_DONOTUSE) bits = bits & (~RS_USERESULT_BIT);
				if (usage == RS_USE) bits = bits | (RS_USERESULT_BIT);
				if (usage == RS_SUBSTITUTE)
					substituted_rule = rulechange_stack-->(x+2);
			}
			if ((usage == RS_MOVEBEFORE) && (rulechange_stack-->(x+2) == rulebook)) {
				rv = ProcessRulebook(rulechange_stack-->(x+1),
					parameter, (bits & RS_ACTIVITY ~= 0), true);
				if (rv) return rv;
			}
		}
	if ((bits & RS_ACTIVE_BIT) == 0) rfalse;
	! We now reuse usage to keep the stack frame slimmer
	usage = debugging_rules;
	#ifndef MEMORY_ECONOMY;
	if (debugging_rules) DebugRulebooks(substituted_rule, parameter);
	#endif;
	! (A routine defined in the I7 code generator)
	process_rulebook_count = process_rulebook_count + debugging_rules;
	if ((substituted_rule >= 0) && (substituted_rule < NUMBER_RULEBOOKS_CREATED)) {
		rbaddress = rulebooks_array-->substituted_rule;
		ra = rbaddress-->0; x = 0; original_deadflag = deadflag;
		if (ra ~= NULL) {
			acf = (bits & RS_ACTIVITY ~= 0);
			if (substituted_rule ~= ACTION_PROCESSING_RB) MStack_CreateRBVars(substituted_rule);
			if (ra == (-2)) {
				for (x=1: original_deadflag == deadflag: x++) {
					ra = rbaddress-->x;
					if (ra == NULL) break;
					if (gc == 0) {
						ga = ra; x++; gc = rbaddress-->x;
						if ((gc<1) || (gc>31)) { gc = 1; x--; }
						x++; ra = rbaddress-->x;
					}
					gc--;
					if (ga ~= (-2) or action) continue;
					if ((rv = (ProcessRulebook(ra, parameter, acf)))
						&& (bits & RS_USERESULT_BIT)) jump NonNullResult;
				}
			} else {
				for (: original_deadflag == deadflag: x++) {
					ra = rbaddress-->x;
					if (ra == NULL) break;
					if ((rv = (ProcessRulebook(ra, parameter, acf)))
						&& (bits & RS_USERESULT_BIT)) jump NonNullResult;
				}
			}
			rv = 0;
			.NonNullResult;
			if (substituted_rule ~= ACTION_PROCESSING_RB) MStack_DestroyRBVars(substituted_rule);
		}
	} else {
		if ((say__p) && (bits & RS_NOSKIPS == 0)) DivideParagraphPoint();
		rv = indirect(substituted_rule);
		if (rv == 2) rv = reason_the_action_failed;
		else if (rv) rv = substituted_rule;
	}
	if (rv && (bits & RS_USERESULT_BIT)) {
		process_rulebook_count = process_rulebook_count - debugging_rules;
		if (process_rulebook_count < 0) process_rulebook_count = 0;
		#ifndef MEMORY_ECONOMY;
		if (debugging_rules) {
			spaces(2*process_rulebook_count);
	  	    if (rulechange_stack-->rulechange_sp == RS_SUCCEEDS)
	  			print "[stopped: success]^";
	  	    if (rulechange_stack-->rulechange_sp == RS_FAILS)
	  			print "[stopped: fail]^";
		}
		#endif;
		debugging_rules = usage;
		return rv;
	}
	if (bits & RS_AFFECTED_BIT)
		for (x=rulechange_sp-3: x>=frame_base: x = x-3) {
			if ((rulechange_stack-->x == RS_MOVEAFTER) &&
				(rulechange_stack-->(x+2) == rulebook)) {
				rv = ProcessRulebook(rulechange_stack-->(x+1),
					parameter, (bits & RS_ACTIVITY ~= 0), true);
				if (rv) {
					process_rulebook_count--;
					debugging_rules = usage;
					return rv;
				}
			}
		}
	process_rulebook_count = process_rulebook_count - debugging_rules;
	rulechange_stack-->rulechange_sp = 0;
	debugging_rules = usage;
	rfalse;
];

[ ActRulebookSucceeds rule_id;
	if (rule_id) reason_the_action_failed = rule_id;
	RulebookSucceeds();
];

[ ActRulebookFails rule_id;
	if (rule_id) reason_the_action_failed = rule_id;
	RulebookFails();
];

[ RulebookSucceeds weak_kind value;
	PushRuleChange(RS_SUCCEEDS, weak_kind, value);
	rulechange_sp = rulechange_sp - 3;
];

[ RulebookFails weak_kind value;
	PushRuleChange(RS_FAILS, weak_kind, value);
	rulechange_sp = rulechange_sp - 3;
];

[ RuleHasNoOutcome;
	PushRuleChange(RS_NEITHER, 0, 0);
	rulechange_sp = rulechange_sp - 3;
];

[ SetRulebookOutcome a;
	rulechange_stack-->rulechange_sp = a;
];

[ RulebookOutcome a;
	a = rulechange_stack-->rulechange_sp;
	if ((a == RS_FAILS) || (a == RS_SUCCEEDS)) return a;
	return RS_NEITHER;
];

[ RulebookFailed;
	if (rulechange_stack-->rulechange_sp == RS_FAILS) rtrue; rfalse;
];

[ RulebookSucceeded;
	if (rulechange_stack-->rulechange_sp == RS_SUCCEEDS) rtrue; rfalse;
];

[ ResultOfRule RB V F K a;
	if (RB) ProcessRulebook(RB, V, F);
	a = rulechange_stack-->rulechange_sp;
	if ((a == RS_FAILS) || (a == RS_SUCCEEDS)) {
		a = rulechange_stack-->(rulechange_sp + 1);
		if (a) return rulechange_stack-->(rulechange_sp + 2);
	}
	if (K) return DefaultValueOfKOV(K);
	return 0;
];

Global DITS_said = false;
[ SuppressRule rule;
	if (rule == TURN_SEQUENCE_RB) {
		if (DITS_said == false) RunTimeProblem(RTP_DONTIGNORETURNSEQUENCE);
		DITS_said = true;
	} else PushRuleChange(RS_DONOTRUN, rule, 0);
];
[ ReinstateRule rule; PushRuleChange(RS_RUN, rule, 0); ];
[ DonotuseRule rule; PushRuleChange(RS_DONOTUSE, rule, 0); ];
[ UseRule rule; PushRuleChange(RS_USE, rule, 0); ];
[ SubstituteRule rule1 rule2; PushRuleChange(RS_SUBSTITUTE, rule2, rule1); ];
[ MoveRuleBefore rule1 rule2; PushRuleChange(RS_MOVEBEFORE, rule1, rule2); ];
[ MoveRuleAfter rule1 rule2; PushRuleChange(RS_MOVEAFTER, rule1, rule2); ];

#IFNDEF MEMORY_ECONOMY;
Array RulebookNames -->
    "Procedural rulebook" ! 0
    "Startup rulebook" ! 1
    "Turn sequence rulebook" ! 2
    "Shutdown rulebook" ! 3
    "Scene changing rulebook" ! 4
    "When play begins rulebook" ! 5
    "When play ends rulebook" ! 6
    "When scene begins rulebook" ! 7
    "When scene ends rulebook" ! 8
    "Every turn rulebook" ! 9
    "Action-processing rulebook" ! 10
    "Setting action variables rulebook" ! 11
    "specific action-processing rulebook" ! 12
    "player's action awareness rulebook" ! 13
    "Accessibility rulebook" ! 14
    "Reaching inside rulebook" ! 15
    "Reaching outside rulebook" ! 16
    "Visibility rulebook" ! 17
    "Persuasion rulebook" ! 18
    "Unsuccessful attempt by rulebook" ! 19
    "Before rulebook" ! 20
    "Instead rulebook" ! 21
    "Check rulebook" ! 22
    "Carry out rulebook" ! 23
    "After rulebook" ! 24
    "Report rulebook" ! 25
    "does the player mean rulebook" ! 26
    "when Entire Game begins rulebook" ! 27
    "when Entire Game ends rulebook" ! 28
    "before Printing the name rulebook" ! 29
    "for Printing the name rulebook" ! 30
    "after Printing the name rulebook" ! 31
    "before Printing the plural name rulebook" ! 32
    "for Printing the plural name rulebook" ! 33
    "after Printing the plural name rulebook" ! 34
    "before Printing a number rulebook" ! 35
    "for Printing a number rulebook" ! 36
    "after Printing a number rulebook" ! 37
    "before Printing room description details rulebook" ! 38
    "for Printing room description details rulebook" ! 39
    "after Printing room description details rulebook" ! 40
    "before Listing contents rulebook" ! 41
    "for Listing contents rulebook" ! 42
    "after Listing contents rulebook" ! 43
    "before Grouping together rulebook" ! 44
    "for Grouping together rulebook" ! 45
    "after Grouping together rulebook" ! 46
    "before Writing a paragraph about rulebook" ! 47
    "for Writing a paragraph about rulebook" ! 48
    "after Writing a paragraph about rulebook" ! 49
    "before Listing nondescript items rulebook" ! 50
    "for Listing nondescript items rulebook" ! 51
    "after Listing nondescript items rulebook" ! 52
    "before Printing the name of a dark room rulebook" ! 53
    "for Printing the name of a dark room rulebook" ! 54
    "after Printing the name of a dark room rulebook" ! 55
    "before Printing the description of a dark room rulebook" ! 56
    "for Printing the description of a dark room rulebook" ! 57
    "after Printing the description of a dark room rulebook" ! 58
    "before Printing the announcement of darkness rulebook" ! 59
    "for Printing the announcement of darkness rulebook" ! 60
    "after Printing the announcement of darkness rulebook" ! 61
    "before Printing the announcement of light rulebook" ! 62
    "for Printing the announcement of light rulebook" ! 63
    "after Printing the announcement of light rulebook" ! 64
    "before Printing a refusal to act in the dark rulebook" ! 65
    "for Printing a refusal to act in the dark rulebook" ! 66
    "after Printing a refusal to act in the dark rulebook" ! 67
    "before Constructing the status line rulebook" ! 68
    "for Constructing the status line rulebook" ! 69
    "after Constructing the status line rulebook" ! 70
    "before Printing the banner text rulebook" ! 71
    "for Printing the banner text rulebook" ! 72
    "after Printing the banner text rulebook" ! 73
    "before Reading a command rulebook" ! 74
    "for Reading a command rulebook" ! 75
    "after Reading a command rulebook" ! 76
    "before Deciding the scope rulebook" ! 77
    "for Deciding the scope rulebook" ! 78
    "after Deciding the scope rulebook" ! 79
    "before Deciding the concealed possessions rulebook" ! 80
    "for Deciding the concealed possessions rulebook" ! 81
    "after Deciding the concealed possessions rulebook" ! 82
    "before Deciding whether all includes rulebook" ! 83
    "for Deciding whether all includes rulebook" ! 84
    "after Deciding whether all includes rulebook" ! 85
    "before Clarifying the parser's choice rulebook" ! 86
    "for Clarifying the parser's choice rulebook" ! 87
    "after Clarifying the parser's choice rulebook" ! 88
    "before Asking which do you mean rulebook" ! 89
    "for Asking which do you mean rulebook" ! 90
    "after Asking which do you mean rulebook" ! 91
    "before Printing a parser error rulebook" ! 92
    "for Printing a parser error rulebook" ! 93
    "after Printing a parser error rulebook" ! 94
    "before Supplying a missing noun rulebook" ! 95
    "for Supplying a missing noun rulebook" ! 96
    "after Supplying a missing noun rulebook" ! 97
    "before Supplying a missing second noun rulebook" ! 98
    "for Supplying a missing second noun rulebook" ! 99
    "after Supplying a missing second noun rulebook" ! 100
    "before Implicitly taking rulebook" ! 101
    "for Implicitly taking rulebook" ! 102
    "after Implicitly taking rulebook" ! 103
    "before Starting the virtual machine rulebook" ! 104
    "for Starting the virtual machine rulebook" ! 105
    "after Starting the virtual machine rulebook" ! 106
    "before Amusing a victorious player rulebook" ! 107
    "for Amusing a victorious player rulebook" ! 108
    "after Amusing a victorious player rulebook" ! 109
    "before Printing the player's obituary rulebook" ! 110
    "for Printing the player's obituary rulebook" ! 111
    "after Printing the player's obituary rulebook" ! 112
    "before Handling the final question rulebook" ! 113
    "for Handling the final question rulebook" ! 114
    "after Handling the final question rulebook" ! 115
    "before Printing the locale description rulebook" ! 116
    "for Printing the locale description rulebook" ! 117
    "after Printing the locale description rulebook" ! 118
    "before Choosing notable locale objects rulebook" ! 119
    "for Choosing notable locale objects rulebook" ! 120
    "after Choosing notable locale objects rulebook" ! 121
    "before Printing a locale paragraph about rulebook" ! 122
    "for Printing a locale paragraph about rulebook" ! 123
    "after Printing a locale paragraph about rulebook" ! 124
    "check Taking inventory rulebook" ! 125
    "carry out Taking inventory rulebook" ! 126
    "report Taking inventory rulebook" ! 127
    "check Taking rulebook" ! 128
    "carry out Taking rulebook" ! 129
    "report Taking rulebook" ! 130
    "check Removing it from rulebook" ! 131
    "carry out Removing it from rulebook" ! 132
    "report Removing it from rulebook" ! 133
    "check Dropping rulebook" ! 134
    "carry out Dropping rulebook" ! 135
    "report Dropping rulebook" ! 136
    "check Putting it on rulebook" ! 137
    "carry out Putting it on rulebook" ! 138
    "report Putting it on rulebook" ! 139
    "check Inserting it into rulebook" ! 140
    "carry out Inserting it into rulebook" ! 141
    "report Inserting it into rulebook" ! 142
    "check Eating rulebook" ! 143
    "carry out Eating rulebook" ! 144
    "report Eating rulebook" ! 145
    "check Going rulebook" ! 146
    "carry out Going rulebook" ! 147
    "report Going rulebook" ! 148
    "check Entering rulebook" ! 149
    "carry out Entering rulebook" ! 150
    "report Entering rulebook" ! 151
    "check Exiting rulebook" ! 152
    "carry out Exiting rulebook" ! 153
    "report Exiting rulebook" ! 154
    "check Getting off rulebook" ! 155
    "carry out Getting off rulebook" ! 156
    "report Getting off rulebook" ! 157
    "check Looking rulebook" ! 158
    "carry out Looking rulebook" ! 159
    "report Looking rulebook" ! 160
    "check Examining rulebook" ! 161
    "carry out Examining rulebook" ! 162
    "report Examining rulebook" ! 163
    "check Looking under rulebook" ! 164
    "carry out Looking under rulebook" ! 165
    "report Looking under rulebook" ! 166
    "check Searching rulebook" ! 167
    "carry out Searching rulebook" ! 168
    "report Searching rulebook" ! 169
    "check Consulting it about rulebook" ! 170
    "carry out Consulting it about rulebook" ! 171
    "report Consulting it about rulebook" ! 172
    "check Locking it with rulebook" ! 173
    "carry out Locking it with rulebook" ! 174
    "report Locking it with rulebook" ! 175
    "check Unlocking it with rulebook" ! 176
    "carry out Unlocking it with rulebook" ! 177
    "report Unlocking it with rulebook" ! 178
    "check Switching on rulebook" ! 179
    "carry out Switching on rulebook" ! 180
    "report Switching on rulebook" ! 181
    "check Switching off rulebook" ! 182
    "carry out Switching off rulebook" ! 183
    "report Switching off rulebook" ! 184
    "check Opening rulebook" ! 185
    "carry out Opening rulebook" ! 186
    "report Opening rulebook" ! 187
    "check Closing rulebook" ! 188
    "carry out Closing rulebook" ! 189
    "report Closing rulebook" ! 190
    "check Wearing rulebook" ! 191
    "carry out Wearing rulebook" ! 192
    "report Wearing rulebook" ! 193
    "check Taking off rulebook" ! 194
    "carry out Taking off rulebook" ! 195
    "report Taking off rulebook" ! 196
    "check Giving it to rulebook" ! 197
    "carry out Giving it to rulebook" ! 198
    "report Giving it to rulebook" ! 199
    "check Showing it to rulebook" ! 200
    "carry out Showing it to rulebook" ! 201
    "report Showing it to rulebook" ! 202
    "check Waking rulebook" ! 203
    "carry out Waking rulebook" ! 204
    "report Waking rulebook" ! 205
    "check Throwing it at rulebook" ! 206
    "carry out Throwing it at rulebook" ! 207
    "report Throwing it at rulebook" ! 208
    "check Attacking rulebook" ! 209
    "carry out Attacking rulebook" ! 210
    "report Attacking rulebook" ! 211
    "check Kissing rulebook" ! 212
    "carry out Kissing rulebook" ! 213
    "report Kissing rulebook" ! 214
    "check Answering it that rulebook" ! 215
    "carry out Answering it that rulebook" ! 216
    "report Answering it that rulebook" ! 217
    "check Telling it about rulebook" ! 218
    "carry out Telling it about rulebook" ! 219
    "report Telling it about rulebook" ! 220
    "check Asking it about rulebook" ! 221
    "carry out Asking it about rulebook" ! 222
    "report Asking it about rulebook" ! 223
    "check Asking it for rulebook" ! 224
    "carry out Asking it for rulebook" ! 225
    "report Asking it for rulebook" ! 226
    "check Waiting rulebook" ! 227
    "carry out Waiting rulebook" ! 228
    "report Waiting rulebook" ! 229
    "check Touching rulebook" ! 230
    "carry out Touching rulebook" ! 231
    "report Touching rulebook" ! 232
    "check Waving rulebook" ! 233
    "carry out Waving rulebook" ! 234
    "report Waving rulebook" ! 235
    "check Pulling rulebook" ! 236
    "carry out Pulling rulebook" ! 237
    "report Pulling rulebook" ! 238
    "check Pushing rulebook" ! 239
    "carry out Pushing rulebook" ! 240
    "report Pushing rulebook" ! 241
    "check Turning rulebook" ! 242
    "carry out Turning rulebook" ! 243
    "report Turning rulebook" ! 244
    "check Pushing it to rulebook" ! 245
    "carry out Pushing it to rulebook" ! 246
    "report Pushing it to rulebook" ! 247
    "check Squeezing rulebook" ! 248
    "carry out Squeezing rulebook" ! 249
    "report Squeezing rulebook" ! 250
    "check Saying yes rulebook" ! 251
    "carry out Saying yes rulebook" ! 252
    "report Saying yes rulebook" ! 253
    "check Saying no rulebook" ! 254
    "carry out Saying no rulebook" ! 255
    "report Saying no rulebook" ! 256
    "check Burning rulebook" ! 257
    "carry out Burning rulebook" ! 258
    "report Burning rulebook" ! 259
    "check Waking up rulebook" ! 260
    "carry out Waking up rulebook" ! 261
    "report Waking up rulebook" ! 262
    "check Thinking rulebook" ! 263
    "carry out Thinking rulebook" ! 264
    "report Thinking rulebook" ! 265
    "check Smelling rulebook" ! 266
    "carry out Smelling rulebook" ! 267
    "report Smelling rulebook" ! 268
    "check Listening to rulebook" ! 269
    "carry out Listening to rulebook" ! 270
    "report Listening to rulebook" ! 271
    "check Tasting rulebook" ! 272
    "carry out Tasting rulebook" ! 273
    "report Tasting rulebook" ! 274
    "check Cutting rulebook" ! 275
    "carry out Cutting rulebook" ! 276
    "report Cutting rulebook" ! 277
    "check Jumping rulebook" ! 278
    "carry out Jumping rulebook" ! 279
    "report Jumping rulebook" ! 280
    "check Tying it to rulebook" ! 281
    "carry out Tying it to rulebook" ! 282
    "report Tying it to rulebook" ! 283
    "check Drinking rulebook" ! 284
    "carry out Drinking rulebook" ! 285
    "report Drinking rulebook" ! 286
    "check Saying sorry rulebook" ! 287
    "carry out Saying sorry rulebook" ! 288
    "report Saying sorry rulebook" ! 289
    "check Swearing obscenely rulebook" ! 290
    "carry out Swearing obscenely rulebook" ! 291
    "report Swearing obscenely rulebook" ! 292
    "check Swearing mildly rulebook" ! 293
    "carry out Swearing mildly rulebook" ! 294
    "report Swearing mildly rulebook" ! 295
    "check Swinging rulebook" ! 296
    "carry out Swinging rulebook" ! 297
    "report Swinging rulebook" ! 298
    "check Rubbing rulebook" ! 299
    "carry out Rubbing rulebook" ! 300
    "report Rubbing rulebook" ! 301
    "check Setting it to rulebook" ! 302
    "carry out Setting it to rulebook" ! 303
    "report Setting it to rulebook" ! 304
    "check Waving hands rulebook" ! 305
    "carry out Waving hands rulebook" ! 306
    "report Waving hands rulebook" ! 307
    "check Buying rulebook" ! 308
    "carry out Buying rulebook" ! 309
    "report Buying rulebook" ! 310
    "check Singing rulebook" ! 311
    "carry out Singing rulebook" ! 312
    "report Singing rulebook" ! 313
    "check Climbing rulebook" ! 314
    "carry out Climbing rulebook" ! 315
    "report Climbing rulebook" ! 316
    "check Sleeping rulebook" ! 317
    "carry out Sleeping rulebook" ! 318
    "report Sleeping rulebook" ! 319
    "check Quitting the game rulebook" ! 320
    "carry out Quitting the game rulebook" ! 321
    "report Quitting the game rulebook" ! 322
    "check Saving the game rulebook" ! 323
    "carry out Saving the game rulebook" ! 324
    "report Saving the game rulebook" ! 325
    "check Restoring the game rulebook" ! 326
    "carry out Restoring the game rulebook" ! 327
    "report Restoring the game rulebook" ! 328
    "check Restarting the game rulebook" ! 329
    "carry out Restarting the game rulebook" ! 330
    "report Restarting the game rulebook" ! 331
    "check Verifying the story file rulebook" ! 332
    "carry out Verifying the story file rulebook" ! 333
    "report Verifying the story file rulebook" ! 334
    "check Switching the story transcript on rulebook" ! 335
    "carry out Switching the story transcript on rulebook" ! 336
    "report Switching the story transcript on rulebook" ! 337
    "check Switching the story transcript off rulebook" ! 338
    "carry out Switching the story transcript off rulebook" ! 339
    "report Switching the story transcript off rulebook" ! 340
    "check Requesting the story file version rulebook" ! 341
    "carry out Requesting the story file version rulebook" ! 342
    "report Requesting the story file version rulebook" ! 343
    "check Requesting the score rulebook" ! 344
    "carry out Requesting the score rulebook" ! 345
    "report Requesting the score rulebook" ! 346
    "check Preferring abbreviated room descriptions rulebook" ! 347
    "carry out Preferring abbreviated room descriptions rulebook" ! 348
    "report Preferring abbreviated room descriptions rulebook" ! 349
    "check Preferring unabbreviated room descriptions rulebook" ! 350
    "carry out Preferring unabbreviated room descriptions rulebook" ! 351
    "report Preferring unabbreviated room descriptions rulebook" ! 352
    "check Preferring sometimes abbreviated room descriptions rulebook" ! 353
    "carry out Preferring sometimes abbreviated room descriptions rulebook" ! 354
    "report Preferring sometimes abbreviated room descriptions rulebook" ! 355
    "check Switching score notification on rulebook" ! 356
    "carry out Switching score notification on rulebook" ! 357
    "report Switching score notification on rulebook" ! 358
    "check Switching score notification off rulebook" ! 359
    "carry out Switching score notification off rulebook" ! 360
    "report Switching score notification off rulebook" ! 361
    "check Requesting the pronoun meanings rulebook" ! 362
    "carry out Requesting the pronoun meanings rulebook" ! 363
    "report Requesting the pronoun meanings rulebook" ! 364
    "when Uncle Vernon's Scene begins rulebook" ! 365
    "when Uncle Vernon's Scene ends rulebook" ! 366
    "check putting it under rulebook" ! 367
    "carry out putting it under rulebook" ! 368
    "report putting it under rulebook" ! 369
    "check getting under rulebook" ! 370
    "carry out getting under rulebook" ! 371
    "report getting under rulebook" ! 372
    "check going under rulebook" ! 373
    "carry out going under rulebook" ! 374
    "report going under rulebook" ! 375
    "check getting out from under rulebook" ! 376
    "carry out getting out from under rulebook" ! 377
    "report getting out from under rulebook" ! 378
    "check Mounting rulebook" ! 379
    "carry out Mounting rulebook" ! 380
    "report Mounting rulebook" ! 381
    "check Dismounting rulebook" ! 382
    "carry out Dismounting rulebook" ! 383
    "report Dismounting rulebook" ! 384
    "before Displaying rulebook" ! 385
    "for Displaying rulebook" ! 386
    "after Displaying rulebook" ! 387
    "check Asking for help rulebook" ! 388
    "carry out Asking for help rulebook" ! 389
    "report Asking for help rulebook" ! 390
    "check switching cheats on rulebook" ! 391
    "carry out switching cheats on rulebook" ! 392
    "report switching cheats on rulebook" ! 393
    "check switching cheats off rulebook" ! 394
    "carry out switching cheats off rulebook" ! 395
    "report switching cheats off rulebook" ! 396
    "check Teleporting to rulebook" ! 397
    "carry out Teleporting to rulebook" ! 398
    "report Teleporting to rulebook" ! 399
    "check moving to rulebook" ! 400
    "carry out moving to rulebook" ! 401
    "report moving to rulebook" ! 402
    "check putting back rulebook" ! 403
    "carry out putting back rulebook" ! 404
    "report putting back rulebook" ! 405
    "check universal opening rulebook" ! 406
    "carry out universal opening rulebook" ! 407
    "report universal opening rulebook" ! 408
    "check Changing player rulebook" ! 409
    "carry out Changing player rulebook" ! 410
    "report Changing player rulebook" ! 411
    "check point increasing rulebook" ! 412
    "carry out point increasing rulebook" ! 413
    "report point increasing rulebook" ! 414
    "check restoring score rulebook" ! 415
    "carry out restoring score rulebook" ! 416
    "report restoring score rulebook" ! 417
    "check Removing rulebook" ! 418
    "carry out Removing rulebook" ! 419
    "report Removing rulebook" ! 420
    "check paying wizard money rulebook" ! 421
    "carry out paying wizard money rulebook" ! 422
    "report paying wizard money rulebook" ! 423
    "check Inputting rulebook" ! 424
    "carry out Inputting rulebook" ! 425
    "report Inputting rulebook" ! 426
    "check Requesting it for rulebook" ! 427
    "carry out Requesting it for rulebook" ! 428
    "report Requesting it for rulebook" ! 429
    "check Imploring it for rulebook" ! 430
    "carry out Imploring it for rulebook" ! 431
    "report Imploring it for rulebook" ! 432
    "check Quizzing it about rulebook" ! 433
    "carry out Quizzing it about rulebook" ! 434
    "report Quizzing it about rulebook" ! 435
    "check Informing it about rulebook" ! 436
    "carry out Informing it about rulebook" ! 437
    "report Informing it about rulebook" ! 438
    "check Implicit-asking rulebook" ! 439
    "carry out Implicit-asking rulebook" ! 440
    "report Implicit-asking rulebook" ! 441
    "check implicit-telling rulebook" ! 442
    "carry out implicit-telling rulebook" ! 443
    "report implicit-telling rulebook" ! 444
    "check implicit-quizzing rulebook" ! 445
    "carry out implicit-quizzing rulebook" ! 446
    "report implicit-quizzing rulebook" ! 447
    "check implicit-informing rulebook" ! 448
    "carry out implicit-informing rulebook" ! 449
    "report implicit-informing rulebook" ! 450
    "check implicit-requesting rulebook" ! 451
    "carry out implicit-requesting rulebook" ! 452
    "report implicit-requesting rulebook" ! 453
    "check implicit-imploring rulebook" ! 454
    "carry out implicit-imploring rulebook" ! 455
    "report implicit-imploring rulebook" ! 456
    "check Saying hello to rulebook" ! 457
    "carry out Saying hello to rulebook" ! 458
    "report Saying hello to rulebook" ! 459
    "check Hailing rulebook" ! 460
    "carry out Hailing rulebook" ! 461
    "report Hailing rulebook" ! 462
    "check Leavetaking rulebook" ! 463
    "carry out Leavetaking rulebook" ! 464
    "report Leavetaking rulebook" ! 465
    "check Saying goodbye to rulebook" ! 466
    "carry out Saying goodbye to rulebook" ! 467
    "report Saying goodbye to rulebook" ! 468
    "glulx timed activity rulebook" ! 469
    "glulx redrawing rulebook" ! 470
    "glulx arranging rulebook" ! 471
    "glulx sound notification rulebook" ! 472
    "glulx mouse input rulebook" ! 473
    "glulx character input rulebook" ! 474
    "glulx line input rulebook" ! 475
    "glulx hyperlink rulebook" ! 476
    "glulx zeroing-reference rulebook" ! 477
    "glulx resetting-windows rulebook" ! 478
    "glulx resetting-streams rulebook" ! 479
    "glulx resetting-filerefs rulebook" ! 480
    "glulx object-updating rulebook" ! 481
    "command-counting rulebook" ! 482
    "input-cancelling rulebook" ! 483
    "command-showing rulebook" ! 484
    "command-pasting rulebook" ! 485
    "check Dialling it on rulebook" ! 486
    "carry out Dialling it on rulebook" ! 487
    "report Dialling it on rulebook" ! 488
    "check Hanging up rulebook" ! 489
    "carry out Hanging up rulebook" ! 490
    "report Hanging up rulebook" ! 491
    "check Sitting on rulebook" ! 492
    "carry out Sitting on rulebook" ! 493
    "report Sitting on rulebook" ! 494
    "check Lying on rulebook" ! 495
    "carry out Lying on rulebook" ! 496
    "report Lying on rulebook" ! 497
    "check Standing up on rulebook" ! 498
    "carry out Standing up on rulebook" ! 499
    "report Standing up on rulebook" ! 500
    "check Lying down rulebook" ! 501
    "carry out Lying down rulebook" ! 502
    "report Lying down rulebook" ! 503
    "check Sitting down rulebook" ! 504
    "carry out Sitting down rulebook" ! 505
    "report Sitting down rulebook" ! 506
    "check Standing up rulebook" ! 507
    "carry out Standing up rulebook" ! 508
    "report Standing up rulebook" ! 509
    "check Taking position rulebook" ! 510
    "carry out Taking position rulebook" ! 511
    "report Taking position rulebook" ! 512
    "after not rulebook" ! 513
    "check asking for hints rulebook" ! 514
    "carry out asking for hints rulebook" ! 515
    "report asking for hints rulebook" ! 516
    "check getting out rulebook" ! 517
    "carry out getting out rulebook" ! 518
    "report getting out rulebook" ! 519
    "when Work begins rulebook" ! 520
    "when Work ends rulebook" ! 521
    "check carjacking rulebook" ! 522
    "carry out carjacking rulebook" ! 523
    "report carjacking rulebook" ! 524
    "check using rulebook" ! 525
    "carry out using rulebook" ! 526
    "report using rulebook" ! 527
    "when customercall begins rulebook" ! 528
    "when customercall ends rulebook" ! 529
    "check responding to customer rulebook" ! 530
    "carry out responding to customer rulebook" ! 531
    "report responding to customer rulebook" ! 532
    "check saying rulebook" ! 533
    "carry out saying rulebook" ! 534
    "report saying rulebook" ! 535
    "check flipping rulebook" ! 536
    "carry out flipping rulebook" ! 537
    "report flipping rulebook" ! 538
    "when Mrmason call begins rulebook" ! 539
    "when Mrmason call ends rulebook" ! 540
    "check writing intro rulebook" ! 541
    "carry out writing intro rulebook" ! 542
    "report writing intro rulebook" ! 543
    "check writing on rulebook" ! 544
    "carry out writing on rulebook" ! 545
    "report writing on rulebook" ! 546
    "check clearing the screen rulebook" ! 547
    "carry out clearing the screen rulebook" ! 548
    "report clearing the screen rulebook" ! 549
    "check wanting rulebook" ! 550
    "carry out wanting rulebook" ! 551
    "report wanting rulebook" ! 552
    "check playing rulebook" ! 553
    "carry out playing rulebook" ! 554
    "report playing rulebook" ! 555
    "check thanking rulebook" ! 556
    "carry out thanking rulebook" ! 557
    "report thanking rulebook" ! 558
    "check thanking with no noun rulebook" ! 559
    "carry out thanking with no noun rulebook" ! 560
    "report thanking with no noun rulebook" ! 561
    "when Living-room cut scene begins rulebook" ! 562
    "when Living-room cut scene ends rulebook" ! 563
    "check dursley's spellcasting rulebook" ! 564
    "carry out dursley's spellcasting rulebook" ! 565
    "report dursley's spellcasting rulebook" ! 566
    "check jumping out of rulebook" ! 567
    "carry out jumping out of rulebook" ! 568
    "report jumping out of rulebook" ! 569
    "check timing rulebook" ! 570
    "carry out timing rulebook" ! 571
    "report timing rulebook" ! 572
;


#ENDIF; ! MEMORY_ECONOMY

[ RulePrintingRule R p1;
#ifndef MEMORY_ECONOMY;
	if ((R>=0) && (R<NUMBER_RULEBOOKS_CREATED)) {
		print (string) (RulebookNames-->R);
	} else {
		if (R == R_8) { print "start in the correct scenes rule"; return; } ! 0, case 1
		if (R == R_9) { print "when play begins stage rule"; return; } ! 1, case 1
		if (R == R_10) { print "fix baseline scoring rule"; return; } ! 2, case 1
		if (R == R_11) { print "display banner rule"; return; } ! 3, case 1
		if (R == R_12) { print "initial room description rule"; return; } ! 4, case 1
		if (R == R_13) { print "every turn stage rule"; return; } ! 5, case 1
		if (R == R_16) { print "notify score changes rule"; return; } ! 6, case 1
		if (R == R_17) { print "when play ends stage rule"; return; } ! 7, case 1
		if (R == R_18) { print "print player's obituary rule"; return; } ! 8, case 1
		if (R == R_19) { print "set pronouns from items from multiple object lists rule"; return; } ! 9, case 1
		if (R == R_20) { print "announce items from multiple object lists rule"; return; } ! 10, case 1
		if (R == R_21) { print "before stage rule"; return; } ! 11, case 1
		if (R == R_22) { print "instead stage rule"; return; } ! 12, case 1
		if (R == R_23) { print "end action-processing in success rule"; return; } ! 13, case 1
		if (R == R_24) { print "investigate player's awareness before action rule"; return; } ! 14, case 1
		if (R == R_25) { print "check stage rule"; return; } ! 15, case 1
		if (R == R_26) { print "carry out stage rule"; return; } ! 16, case 1
		if (R == R_27) { print "after stage rule"; return; } ! 17, case 1
		if (R == R_28) { print "investigate player's awareness after action rule"; return; } ! 18, case 1
		if (R == R_29) { print "report stage rule"; return; } ! 19, case 1
		if (R == R_31) { print "player aware of his own actions rule"; return; } ! 20, case 1
		if (R == R_32) { print "player aware of actions by visible actors rule"; return; } ! 21, case 1
		if (R == R_33) { print "player aware of actions on visible nouns rule"; return; } ! 22, case 1
		if (R == R_34) { print "player aware of actions on visible second nouns rule"; return; } ! 23, case 1
		if (R == R_35) { print "can't act in the dark rule"; return; } ! 24, case 1
		if (R == R_36) { print "very unlikely to mean taking what's already carried rule"; return; } ! 25, case 1
		if (R == R_57) { print "scene description text rule"; return; } ! 26, case 1
		if (R == R_58) { print "make named things mentioned rule"; return; } ! 27, case 1
		if (R == R_59) { print "standard printing the plural name rule"; return; } ! 28, case 1
		if (R == R_60) { print "standard printing a number of something rule"; return; } ! 29, case 1
		if (R == R_61) { print "look around once light available rule"; return; } ! 30, case 1
		if (R == R_62) { print "exclude scenery from take all rule"; return; } ! 31, case 1
		if (R == R_63) { print "exclude people from take all rule"; return; } ! 32, case 1
		if (R == R_64) { print "exclude fixed in place things from take all rule"; return; } ! 33, case 1
		if (R == R_65) { print "ambient odour rule"; return; } ! 34, case 1
		if (R == R_66) { print "ambient sound rule"; return; } ! 35, case 1
		if (R == R_67) { print "block vaguely going rule"; return; } ! 36, case 1
		if (R == R_68) { print "print the final prompt rule"; return; } ! 37, case 1
		if (R == R_69) { print "print the final question rule"; return; } ! 38, case 1
		if (R == R_70) { print "standard respond to final question rule"; return; } ! 39, case 1
		if (R == R_73) { print "initialise locale description rule"; return; } ! 40, case 1
		if (R == R_74) { print "find notable locale objects rule"; return; } ! 41, case 1
		if (R == R_75) { print "interesting locale paragraphs rule"; return; } ! 42, case 1
		if (R == R_76) { print "you-can-also-see rule"; return; } ! 43, case 1
		if (R == R_77) { print "standard notable locale objects rule"; return; } ! 44, case 1
		if (R == R_78) { print "don't mention player's supporter in room descriptions rule"; return; } ! 45, case 1
		if (R == R_79) { print "don't mention scenery in room descriptions rule"; return; } ! 46, case 1
		if (R == R_80) { print "don't mention undescribed items in room descriptions rule"; return; } ! 47, case 1
		if (R == R_81) { print "set pronouns from items in room descriptions rule"; return; } ! 48, case 1
		if (R == R_82) { print "offer items to writing a paragraph about rule"; return; } ! 49, case 1
		if (R == R_83) { print "use initial appearance in room descriptions rule"; return; } ! 50, case 1
		if (R == R_85) { print "describe what's on scenery supporters in room descriptions rule"; return; } ! 51, case 1
		if (R == R_86) { print "print empty inventory rule"; return; } ! 52, case 1
		if (R == R_87) { print "print standard inventory rule"; return; } ! 53, case 1
		if (R == R_88) { print "report other people taking inventory rule"; return; } ! 54, case 1
		if (R == R_89) { print "can't take yourself rule"; return; } ! 55, case 1
		if (R == R_90) { print "can't take other people rule"; return; } ! 56, case 1
		if (R == R_91) { print "can't take component parts rule"; return; } ! 57, case 1
		if (R == R_92) { print "can't take people's possessions rule"; return; } ! 58, case 1
		if (R == R_93) { print "can't take items out of play rule"; return; } ! 59, case 1
		if (R == R_94) { print "can't take what you're inside rule"; return; } ! 60, case 1
		if (R == R_95) { print "can't take what's already taken rule"; return; } ! 61, case 1
		if (R == R_96) { print "can't take scenery rule"; return; } ! 62, case 1
		if (R == R_97) { print "can only take things rule"; return; } ! 63, case 1
		if (R == R_98) { print "can't take what's fixed in place rule"; return; } ! 64, case 1
		if (R == R_99) { print "use player's holdall to avoid exceeding carrying capacity rule"; return; } ! 65, case 1
		if (R == R_100) { print "can't exceed carrying capacity rule"; return; } ! 66, case 1
		if (R == R_101) { print "standard taking rule"; return; } ! 67, case 1
		if (R == R_102) { print "standard report taking rule"; return; } ! 68, case 1
		if (R == R_103) { print "can't remove what's not inside rule"; return; } ! 69, case 1
		if (R == R_104) { print "can't remove from people rule"; return; } ! 70, case 1
		if (R == R_105) { print "convert remove to take rule"; return; } ! 71, case 1
		if (R == R_106) { print "can't drop yourself rule"; return; } ! 72, case 1
		if (R == R_107) { print "can't drop what's already dropped rule"; return; } ! 73, case 1
		if (R == R_108) { print "can't drop what's not held rule"; return; } ! 74, case 1
		if (R == R_109) { print "can't drop clothes being worn rule"; return; } ! 75, case 1
		if (R == R_110) { print "can't drop if this exceeds carrying capacity rule"; return; } ! 76, case 1
		if (R == R_111) { print "standard dropping rule"; return; } ! 77, case 1
		if (R == R_112) { print "standard report dropping rule"; return; } ! 78, case 1
		if (R == R_113) { print "convert put to drop where possible rule"; return; } ! 79, case 1
		if (R == R_114) { print "can't put what's not held rule"; return; } ! 80, case 1
		if (R == R_115) { print "can't put something on itself rule"; return; } ! 81, case 1
		if (R == R_116) { print "can't put onto what's not a supporter rule"; return; } ! 82, case 1
		if (R == R_117) { print "can't put onto something being carried rule"; return; } ! 83, case 1
		if (R == R_118) { print "can't put clothes being worn rule"; return; } ! 84, case 1
		if (R == R_119) { print "can't put if this exceeds carrying capacity rule"; return; } ! 85, case 1
		if (R == R_120) { print "standard putting rule"; return; } ! 86, case 1
		if (R == R_121) { print "concise report putting rule"; return; } ! 87, case 1
		if (R == R_122) { print "standard report putting rule"; return; } ! 88, case 1
		if (R == R_123) { print "convert insert to drop where possible rule"; return; } ! 89, case 1
		if (R == R_124) { print "can't insert what's not held rule"; return; } ! 90, case 1
		if (R == R_125) { print "can't insert something into itself rule"; return; } ! 91, case 1
		if (R == R_126) { print "can't insert into closed containers rule"; return; } ! 92, case 1
		if (R == R_127) { print "can't insert into what's not a container rule"; return; } ! 93, case 1
		if (R == R_128) { print "can't insert clothes being worn rule"; return; } ! 94, case 1
		if (R == R_129) { print "can't insert if this exceeds carrying capacity rule"; return; } ! 95, case 1
		if (R == R_130) { print "standard inserting rule"; return; } ! 96, case 1
		if (R == R_131) { print "concise report inserting rule"; return; } ! 97, case 1
		if (R == R_132) { print "standard report inserting rule"; return; } ! 98, case 1
		if (R == R_133) { print "can't eat unless edible rule"; return; } ! 99, case 1
		if (R == R_134) { print "can't eat clothing without removing it first rule"; return; } ! 100, case 1
		if (R == R_135) { print "standard eating rule"; return; } ! 101, case 1
		if (R == R_136) { print "standard report eating rule"; return; } ! 102, case 1
		if (R == R_137) { print "standard set going variables rule"; return; } ! 103, case 1
		if (R == R_138) { print "stand up before going rule"; return; } ! 104, case 1
		if (R == R_139) { print "can't travel in what's not a vehicle rule"; return; } ! 105, case 1
		if (R == R_140) { print "can't go through undescribed doors rule"; return; } ! 106, case 1
		if (R == R_141) { print "can't go through closed doors rule"; return; } ! 107, case 1
		if (R == R_142) { print "determine map connection rule"; return; } ! 108, case 1
		if (R == R_143) { print "can't go that way rule"; return; } ! 109, case 1
		if (R == R_144) { print "move player and vehicle rule"; return; } ! 110, case 1
		if (R == R_145) { print "move floating objects rule"; return; } ! 111, case 1
		if (R == R_146) { print "check light in new location rule"; return; } ! 112, case 1
		if (R == R_147) { print "describe room gone into rule"; return; } ! 113, case 1
		if (R == R_148) { print "find what to enter rule"; return; } ! 114, case 1
		if (R == R_149) { print "convert enter door into go rule"; return; } ! 115, case 1
		if (R == R_150) { print "convert enter compass direction into go rule"; return; } ! 116, case 1
		if (R == R_151) { print "can't enter what's already entered rule"; return; } ! 117, case 1
		if (R == R_152) { print "can't enter what's not enterable rule"; return; } ! 118, case 1
		if (R == R_153) { print "can't enter closed containers rule"; return; } ! 119, case 1
		if (R == R_154) { print "can't enter something carried rule"; return; } ! 120, case 1
		if (R == R_155) { print "implicitly pass through other barriers rule"; return; } ! 121, case 1
		if (R == R_156) { print "standard entering rule"; return; } ! 122, case 1
		if (R == R_157) { print "standard report entering rule"; return; } ! 123, case 1
		if (R == R_158) { print "describe contents entered into rule"; return; } ! 124, case 1
		if (R == R_160) { print "convert exit into go out rule"; return; } ! 125, case 1
		if (R == R_161) { print "can't exit when not inside anything rule"; return; } ! 126, case 1
		if (R == R_162) { print "can't exit closed containers rule"; return; } ! 127, case 1
		if (R == R_163) { print "convert exit into get off rule"; return; } ! 128, case 1
		if (R == R_164) { print "standard exiting rule"; return; } ! 129, case 1
		if (R == R_165) { print "standard report exiting rule"; return; } ! 130, case 1
		if (R == R_166) { print "describe room emerged into rule"; return; } ! 131, case 1
		if (R == R_167) { print "can't get off things rule"; return; } ! 132, case 1
		if (R == R_168) { print "standard getting off rule"; return; } ! 133, case 1
		if (R == R_169) { print "standard report getting off rule"; return; } ! 134, case 1
		if (R == R_170) { print "describe room stood up into rule"; return; } ! 135, case 1
		if (R == R_171) { print "determine visibility ceiling rule"; return; } ! 136, case 1
		if (R == R_172) { print "room description heading rule"; return; } ! 137, case 1
		if (R == R_173) { print "room description body text rule"; return; } ! 138, case 1
		if (R == R_174) { print "room description paragraphs about objects rule"; return; } ! 139, case 1
		if (R == R_175) { print "check new arrival rule"; return; } ! 140, case 1
		if (R == R_176) { print "other people looking rule"; return; } ! 141, case 1
		if (R == R_177) { print "standard examining rule"; return; } ! 142, case 1
		if (R == R_178) { print "examine directions rule"; return; } ! 143, case 1
		if (R == R_179) { print "examine containers rule"; return; } ! 144, case 1
		if (R == R_180) { print "examine supporters rule"; return; } ! 145, case 1
		if (R == R_181) { print "examine devices rule"; return; } ! 146, case 1
		if (R == R_182) { print "examine undescribed things rule"; return; } ! 147, case 1
		if (R == R_183) { print "report other people examining rule"; return; } ! 148, case 1
		if (R == R_184) { print "standard looking under rule"; return; } ! 149, case 1
		if (R == R_185) { print "report other people looking under rule"; return; } ! 150, case 1
		if (R == R_186) { print "can't search unless container or supporter rule"; return; } ! 151, case 1
		if (R == R_187) { print "can't search closed opaque containers rule"; return; } ! 152, case 1
		if (R == R_188) { print "standard search containers rule"; return; } ! 153, case 1
		if (R == R_189) { print "standard search supporters rule"; return; } ! 154, case 1
		if (R == R_190) { print "report other people searching rule"; return; } ! 155, case 1
		if (R == R_191) { print "block consulting rule"; return; } ! 156, case 1
		if (R == R_192) { print "can't lock without a lock rule"; return; } ! 157, case 1
		if (R == R_193) { print "can't lock what's already locked rule"; return; } ! 158, case 1
		if (R == R_194) { print "can't lock what's open rule"; return; } ! 159, case 1
		if (R == R_195) { print "can't lock without the correct key rule"; return; } ! 160, case 1
		if (R == R_196) { print "standard locking rule"; return; } ! 161, case 1
		if (R == R_197) { print "standard report locking rule"; return; } ! 162, case 1
		if (R == R_198) { print "can't unlock without a lock rule"; return; } ! 163, case 1
		if (R == R_199) { print "can't unlock what's already unlocked rule"; return; } ! 164, case 1
		if (R == R_200) { print "can't unlock without the correct key rule"; return; } ! 165, case 1
		if (R == R_201) { print "standard unlocking rule"; return; } ! 166, case 1
		if (R == R_202) { print "standard report unlocking rule"; return; } ! 167, case 1
		if (R == R_203) { print "can't switch on unless switchable rule"; return; } ! 168, case 1
		if (R == R_204) { print "can't switch on what's already on rule"; return; } ! 169, case 1
		if (R == R_205) { print "standard switching on rule"; return; } ! 170, case 1
		if (R == R_206) { print "standard report switching on rule"; return; } ! 171, case 1
		if (R == R_207) { print "can't switch off unless switchable rule"; return; } ! 172, case 1
		if (R == R_208) { print "can't switch off what's already off rule"; return; } ! 173, case 1
		if (R == R_209) { print "standard switching off rule"; return; } ! 174, case 1
		if (R == R_210) { print "standard report switching off rule"; return; } ! 175, case 1
		if (R == R_211) { print "can't open unless openable rule"; return; } ! 176, case 1
		if (R == R_212) { print "can't open what's locked rule"; return; } ! 177, case 1
		if (R == R_213) { print "can't open what's already open rule"; return; } ! 178, case 1
		if (R == R_214) { print "standard opening rule"; return; } ! 179, case 1
		if (R == R_215) { print "reveal any newly visible interior rule"; return; } ! 180, case 1
		if (R == R_216) { print "standard report opening rule"; return; } ! 181, case 1
		if (R == R_217) { print "can't close unless openable rule"; return; } ! 182, case 1
		if (R == R_218) { print "can't close what's already closed rule"; return; } ! 183, case 1
		if (R == R_219) { print "standard closing rule"; return; } ! 184, case 1
		if (R == R_220) { print "standard report closing rule"; return; } ! 185, case 1
		if (R == R_221) { print "can't wear what's not clothing rule"; return; } ! 186, case 1
		if (R == R_222) { print "can't wear what's not held rule"; return; } ! 187, case 1
		if (R == R_223) { print "can't wear what's already worn rule"; return; } ! 188, case 1
		if (R == R_224) { print "standard wearing rule"; return; } ! 189, case 1
		if (R == R_225) { print "standard report wearing rule"; return; } ! 190, case 1
		if (R == R_226) { print "can't take off what's not worn rule"; return; } ! 191, case 1
		if (R == R_227) { print "standard taking off rule"; return; } ! 192, case 1
		if (R == R_228) { print "standard report taking off rule"; return; } ! 193, case 1
		if (R == R_229) { print "can't give what you haven't got rule"; return; } ! 194, case 1
		if (R == R_230) { print "can't give to yourself rule"; return; } ! 195, case 1
		if (R == R_231) { print "can't give to a non-person rule"; return; } ! 196, case 1
		if (R == R_232) { print "can't give clothes being worn rule"; return; } ! 197, case 1
		if (R == R_233) { print "block giving rule"; return; } ! 198, case 1
		if (R == R_234) { print "standard giving rule"; return; } ! 199, case 1
		if (R == R_235) { print "standard report giving rule"; return; } ! 200, case 1
		if (R == R_236) { print "can't show what you haven't got rule"; return; } ! 201, case 1
		if (R == R_237) { print "convert show to yourself to examine rule"; return; } ! 202, case 1
		if (R == R_238) { print "block showing rule"; return; } ! 203, case 1
		if (R == R_239) { print "block waking rule"; return; } ! 204, case 1
		if (R == R_240) { print "implicitly remove thrown clothing rule"; return; } ! 205, case 1
		if (R == R_241) { print "futile to throw things at inanimate objects rule"; return; } ! 206, case 1
		if (R == R_242) { print "block throwing at rule"; return; } ! 207, case 1
		if (R == R_243) { print "block attacking rule"; return; } ! 208, case 1
		if (R == R_244) { print "kissing yourself rule"; return; } ! 209, case 1
		if (R == R_245) { print "block kissing rule"; return; } ! 210, case 1
		if (R == R_246) { print "block answering rule"; return; } ! 211, case 1
		if (R == R_247) { print "telling yourself rule"; return; } ! 212, case 1
		if (R == R_248) { print "block telling rule"; return; } ! 213, case 1
		if (R == R_249) { print "block asking rule"; return; } ! 214, case 1
		if (R == R_250) { print "asking yourself for something rule"; return; } ! 215, case 1
		if (R == R_251) { print "translate asking for to giving rule"; return; } ! 216, case 1
		if (R == R_252) { print "standard report waiting rule"; return; } ! 217, case 1
		if (R == R_253) { print "report touching yourself rule"; return; } ! 218, case 1
		if (R == R_254) { print "report touching other people rule"; return; } ! 219, case 1
		if (R == R_255) { print "report touching things rule"; return; } ! 220, case 1
		if (R == R_256) { print "can't wave what's not held rule"; return; } ! 221, case 1
		if (R == R_257) { print "report waving things rule"; return; } ! 222, case 1
		if (R == R_258) { print "can't pull what's fixed in place rule"; return; } ! 223, case 1
		if (R == R_259) { print "can't pull scenery rule"; return; } ! 224, case 1
		if (R == R_260) { print "can't pull people rule"; return; } ! 225, case 1
		if (R == R_261) { print "report pulling rule"; return; } ! 226, case 1
		if (R == R_262) { print "can't push what's fixed in place rule"; return; } ! 227, case 1
		if (R == R_263) { print "can't push scenery rule"; return; } ! 228, case 1
		if (R == R_264) { print "can't push people rule"; return; } ! 229, case 1
		if (R == R_265) { print "report pushing rule"; return; } ! 230, case 1
		if (R == R_266) { print "can't turn what's fixed in place rule"; return; } ! 231, case 1
		if (R == R_267) { print "can't turn scenery rule"; return; } ! 232, case 1
		if (R == R_268) { print "can't turn people rule"; return; } ! 233, case 1
		if (R == R_269) { print "report turning rule"; return; } ! 234, case 1
		if (R == R_270) { print "can't push unpushable things rule"; return; } ! 235, case 1
		if (R == R_271) { print "can't push to non-directions rule"; return; } ! 236, case 1
		if (R == R_272) { print "can't push vertically rule"; return; } ! 237, case 1
		if (R == R_273) { print "standard pushing in directions rule"; return; } ! 238, case 1
		if (R == R_274) { print "block pushing in directions rule"; return; } ! 239, case 1
		if (R == R_275) { print "innuendo about squeezing people rule"; return; } ! 240, case 1
		if (R == R_276) { print "report squeezing rule"; return; } ! 241, case 1
		if (R == R_277) { print "block saying yes rule"; return; } ! 242, case 1
		if (R == R_278) { print "block saying no rule"; return; } ! 243, case 1
		if (R == R_279) { print "block burning rule"; return; } ! 244, case 1
		if (R == R_280) { print "block waking up rule"; return; } ! 245, case 1
		if (R == R_281) { print "block thinking rule"; return; } ! 246, case 1
		if (R == R_282) { print "block smelling rule"; return; } ! 247, case 1
		if (R == R_283) { print "block listening rule"; return; } ! 248, case 1
		if (R == R_284) { print "block tasting rule"; return; } ! 249, case 1
		if (R == R_285) { print "block cutting rule"; return; } ! 250, case 1
		if (R == R_286) { print "block jumping rule"; return; } ! 251, case 1
		if (R == R_287) { print "block tying rule"; return; } ! 252, case 1
		if (R == R_288) { print "block drinking rule"; return; } ! 253, case 1
		if (R == R_289) { print "block saying sorry rule"; return; } ! 254, case 1
		if (R == R_290) { print "block swearing obscenely rule"; return; } ! 255, case 1
		if (R == R_291) { print "block swearing mildly rule"; return; } ! 256, case 1
		if (R == R_292) { print "block swinging rule"; return; } ! 257, case 1
		if (R == R_293) { print "block rubbing rule"; return; } ! 258, case 1
		if (R == R_294) { print "block setting it to rule"; return; } ! 259, case 1
		if (R == R_295) { print "block waving hands rule"; return; } ! 260, case 1
		if (R == R_296) { print "block buying rule"; return; } ! 261, case 1
		if (R == R_297) { print "block singing rule"; return; } ! 262, case 1
		if (R == R_298) { print "block climbing rule"; return; } ! 263, case 1
		if (R == R_299) { print "block sleeping rule"; return; } ! 264, case 1
		if (R == R_772) { print "notice plurality of printed object rule"; return; } ! 265, case 1
		if (R == R_837) { print "update ambiguous pronouns for actions rule"; return; } ! 266, case 1
		if (R == R_838) { print "notice plurality of printed ambiguous object rule"; return; } ! 267, case 1
		if (R == R_843) { print "allow rideables to be going vehicles rule"; return; } ! 268, case 1
		if (R == R_849) { print "can't mount when mounted on an animal rule"; return; } ! 269, case 1
		if (R == R_850) { print "can't mount when mounted on a vehicle rule"; return; } ! 270, case 1
		if (R == R_851) { print "can't mount something unrideable rule"; return; } ! 271, case 1
		if (R == R_852) { print "can't mount something carried rule"; return; } ! 272, case 1
		if (R == R_853) { print "can't mount something unreachable rule"; return; } ! 273, case 1
		if (R == R_854) { print "standard mounting rule"; return; } ! 274, case 1
		if (R == R_855) { print "standard report mounting rule"; return; } ! 275, case 1
		if (R == R_856) { print "mounting excuses rule"; return; } ! 276, case 1
		if (R == R_857) { print "can't dismount when not mounted rule"; return; } ! 277, case 1
		if (R == R_858) { print "standard dismounting rule"; return; } ! 278, case 1
		if (R == R_859) { print "standard report dismounting rule"; return; } ! 279, case 1
		if (R == R_860) { print "dismounting excuses rule"; return; } ! 280, case 1
		if (R == R_862) { print "quit rule"; return; } ! 281, case 1
		if (R == R_863) { print "move down rule"; return; } ! 282, case 1
		if (R == R_864) { print "move up rule"; return; } ! 283, case 1
		if (R == R_865) { print "select rule"; return; } ! 284, case 1
		if (R == R_869) { print "basic menu contents rule"; return; } ! 285, case 1
		if (R == R_870) { print "constructing status line while displaying rule"; return; } ! 286, case 1
		if (R == R_873) { print "hint toggle rule"; return; } ! 287, case 1
		if (R == R_891) { print "donotdelay rule"; return; } ! 288, case 1
		if (R == R_945) { print "mark items as seen when looking rule"; return; } ! 289, case 1
		if (R == R_946) { print "mark items as seen on opening a container rule"; return; } ! 290, case 1
		if (R == R_947) { print "mark items as seen on examining rule"; return; } ! 291, case 1
		if (R == R_950) { print "block informing rule"; return; } ! 292, case 1
		if (R == R_951) { print "block quizzing rule"; return; } ! 293, case 1
		if (R == R_952) { print "asking a woman about herself rule"; return; } ! 294, case 1
		if (R == R_953) { print "asking a man about himself rule"; return; } ! 295, case 1
		if (R == R_954) { print "implicit-conversing needs current interlocutor rule"; return; } ! 296, case 1
		if (R == R_955) { print "can't converse with absent interlocutor rule"; return; } ! 297, case 1
		if (R == R_962) { print "greet a new interlocutor rule"; return; } ! 298, case 1
		if (R == R_963) { print "showing needs an interlocutor rule"; return; } ! 299, case 1
		if (R == R_964) { print "giving needs an interlocutor rule"; return; } ! 300, case 1
		if (R == R_965) { print "giving orders needs an interlocutor rule"; return; } ! 301, case 1
		if (R == R_967) { print "can't greet current interlocutor rule"; return; } ! 302, case 1
		if (R == R_968) { print "note current interlocutor when greeted rule"; return; } ! 303, case 1
		if (R == R_969) { print "can't greet inanimate objects rule"; return; } ! 304, case 1
		if (R == R_970) { print "default greeting rule"; return; } ! 305, case 1
		if (R == R_971) { print "change greeting command to greeting rule"; return; } ! 306, case 1
		if (R == R_972) { print "check what's being hailed rule"; return; } ! 307, case 1
		if (R == R_973) { print "standard hailing rule"; return; } ! 308, case 1
		if (R == R_974) { print "allow hailing rule"; return; } ! 309, case 1
		if (R == R_977) { print "can't say goodbye to someone you're not talking to rule"; return; } ! 310, case 1
		if (R == R_978) { print "reset interlocutor on saying goodbye rule"; return; } ! 311, case 1
		if (R == R_979) { print "don't allow saying goodbye to no-one rule"; return; } ! 312, case 1
		if (R == R_980) { print "standard leavetaking rule"; return; } ! 313, case 1
		if (R == R_981) { print "alllow leavetaking rule"; return; } ! 314, case 1
		if (R == R_982) { print "convert npc leavetaking to player leavetaking rule"; return; } ! 315, case 1
		if (R == R_983) { print "default saying goodbye rule"; return; } ! 316, case 1
		if (R == R_984) { print "say goodbye when moving rule"; return; } ! 317, case 1
		if (R == R_985) { print "reset protocol rule"; return; } ! 318, case 1
		if (R == R_986) { print "greet before saying yes rule"; return; } ! 319, case 1
		if (R == R_987) { print "greet before saying no rule"; return; } ! 320, case 1
		if (R == R_988) { print "greet before saying sorry rule"; return; } ! 321, case 1
		if (R == R_989) { print "change answering yes to saying yes rule"; return; } ! 322, case 1
		if (R == R_990) { print "change answering no to saying no rule"; return; } ! 323, case 1
		if (R == R_991) { print "change answering sorry to saying sorry rule"; return; } ! 324, case 1
		if (R == R_992) { print "block asking about something unknown rule"; return; } ! 325, case 1
		if (R == R_993) { print "block telling about something unknown rule"; return; } ! 326, case 1
		if (R == R_1009) { print "ordinary checking for content rule"; return; } ! 327, case 1
		if (R == R_1010) { print "cancelling input in the main window rule"; return; } ! 328, case 1
		if (R == R_1013) { print "print text to the input prompt rule"; return; } ! 329, case 1
		if (R == R_1015) { print "glue replacement command into parse buffer rule"; return; } ! 330, case 1
		if (R == R_1017) { print "redirect from timer rule"; return; } ! 331, case 1
		if (R == R_1022) { print "set up dialling rule"; return; } ! 332, case 1
		if (R == R_1023) { print "can't dial on something that is not a telephone rule"; return; } ! 333, case 1
		if (R == R_1024) { print "can't dial the calling number rule"; return; } ! 334, case 1
		if (R == R_1025) { print "can't dial an emergency number rule"; return; } ! 335, case 1
		if (R == R_1026) { print "can't dial an invalid numer rule"; return; } ! 336, case 1
		if (R == R_1027) { print "standard dialling rule"; return; } ! 337, case 1
		if (R == R_1028) { print "standard report dialling rule"; return; } ! 338, case 1
		if (R == R_1029) { print "establish connection rule"; return; } ! 339, case 1
		if (R == R_1030) { print "listening to a connected telephone rule"; return; } ! 340, case 1
		if (R == R_1031) { print "listening to a connected party rule"; return; } ! 341, case 1
		if (R == R_1034) { print "dialling a telephone while on the line rule"; return; } ! 342, case 1
		if (R == R_1035) { print "set up hanging up rule"; return; } ! 343, case 1
		if (R == R_1036) { print "can't hang up while not on the line rule"; return; } ! 344, case 1
		if (R == R_1037) { print "standard hanging up rule"; return; } ! 345, case 1
		if (R == R_1038) { print "standard report hanging up rule"; return; } ! 346, case 1
		if (R == R_1039) { print "go somewhere while on the line rule"; return; } ! 347, case 1
		if (R == R_1040) { print "look while on the line rule"; return; } ! 348, case 1
		if (R == R_1042) { print "standard carry out sitting on rule"; return; } ! 349, case 1
		if (R == R_1043) { print "standard carry out lying on rule"; return; } ! 350, case 1
		if (R == R_1044) { print "standard carry out standing up on rule"; return; } ! 351, case 1
		if (R == R_1046) { print "convert lying down rule"; return; } ! 352, case 1
		if (R == R_1048) { print "convert sitting down rule"; return; } ! 353, case 1
		if (R == R_1049) { print "convert standing up rule"; return; } ! 354, case 1
		if (R == R_1050) { print "prefer sitting on seating objects rule"; return; } ! 355, case 1
		if (R == R_1051) { print "prefer standing on standing objects rule"; return; } ! 356, case 1
		if (R == R_1052) { print "prefer lying on reclining objects rule"; return; } ! 357, case 1
		if (R == R_1053) { print "prefer request sitting on seating objects rule"; return; } ! 358, case 1
		if (R == R_1054) { print "prefer request standing on standing objects rule"; return; } ! 359, case 1
		if (R == R_1055) { print "prefer request lying on reclining objects rule"; return; } ! 360, case 1
		if (R == R_1056) { print "can't use inappropriate postures rule"; return; } ! 361, case 1
		if (R == R_1057) { print "can't use already used posture rule"; return; } ! 362, case 1
		if (R == R_1058) { print "standard taking position rule"; return; } ! 363, case 1
		if (R == R_1059) { print "stranger position report rule rule"; return; } ! 364, case 1
		if (R == R_1060) { print "standard position report rule"; return; } ! 365, case 1
		if (R == R_1062) { print "departure-posture rule"; return; } ! 366, case 1
		if (R == R_1063) { print "arrival-posture rule"; return; } ! 367, case 1
		if (R == R_1064) { print "can't go without standing rule"; return; } ! 368, case 1
		if (R == R_1065) { print "convert exits to standing rule"; return; } ! 369, case 1
		if (R == LITTLE_USED_DO_NOTHING_R) { print "little-used do nothing rule"; return; } ! 397, case 1
		if (R == VIRTUAL_MACHINE_STARTUP_R) { print "virtual machine startup rule"; return; } ! 398, case 1
		if (R == INITIALISE_MEMORY_R) { print "initialise memory rule"; return; } ! 399, case 1
		if (R == SEED_RANDOM_NUMBER_GENERATOR_R) { print "seed random number generator rule"; return; } ! 400, case 1
		if (R == UPDATE_CHRONOLOGICAL_RECORDS_R) { print "update chronological records rule"; return; } ! 401, case 1
		if (R == POSITION_PLAYER_IN_MODEL_R) { print "position player in model world rule"; return; } ! 402, case 1
		if (R == ADJUST_LIGHT_R) { print "adjust light rule"; return; } ! 403, case 1
		if (R == ADVANCE_TIME_R) { print "advance time rule"; return; } ! 404, case 1
		if (R == GENERATE_ACTION_R) { print "generate action rule"; return; } ! 405, case 1
		if (R == NOTE_OBJECT_ACQUISITIONS_R) { print "note object acquisitions rule"; return; } ! 406, case 1
		if (R == PARSE_COMMAND_R) { print "parse command rule"; return; } ! 407, case 1
		if (R == TIMED_EVENTS_R) { print "timed events rule"; return; } ! 408, case 1
		if (R == RESURRECT_PLAYER_IF_ASKED_R) { print "resurrect player if asked rule"; return; } ! 409, case 1
		if (R == ASK_FINAL_QUESTION_R) { print "ask the final question rule"; return; } ! 410, case 1
		if (R == DetectSceneChange) { print "scene change machinery rule"; return; } ! 411, case 1
		if (R == BASIC_ACCESSIBILITY_R) { print "basic accessibility rule"; return; } ! 414, case 1
		if (R == BASIC_VISIBILITY_R) { print "basic visibility rule"; return; } ! 415, case 1
		if (R == CARRYING_REQUIREMENTS_R) { print "carrying requirements rule"; return; } ! 416, case 1
		if (R == REQUESTED_ACTIONS_REQUIRE_R) { print "requested actions require persuasion rule"; return; } ! 417, case 1
		if (R == CARRY_OUT_REQUESTED_ACTIONS_R) { print "carry out requested actions rule"; return; } ! 418, case 1
		if (R == DESCEND_TO_SPECIFIC_ACTION_R) { print "descend to specific action-processing rule"; return; } ! 419, case 1
		if (R == WORK_OUT_DETAILS_OF_SPECIFIC_R) { print "work out details of specific action rule"; return; } ! 420, case 1
		if (R == ACCESS_THROUGH_BARRIERS_R) { print "access through barriers rule"; return; } ! 421, case 1
		if (R == CANT_REACH_INSIDE_CLOSED_R) { print "can't reach inside closed containers rule"; return; } ! 422, case 1
		if (R == CANT_REACH_INSIDE_ROOMS_R) { print "can't reach inside rooms rule"; return; } ! 423, case 1
		if (R == CANT_REACH_OUTSIDE_CLOSED_R) { print "can't reach outside closed containers rule"; return; } ! 424, case 1
		if (R == STANDARD_NAME_PRINTING_R) { print "standard name printing rule"; return; } ! 428, case 1
		if (R == STANDARD_CONTENTS_LISTING_R) { print "standard contents listing rule"; return; } ! 441, case 1
		if (R == ENABLE_GLULX_ACCEL_R) { print "enable Glulx acceleration rule"; return; } ! 505, case 1
		if (R == PRINT_OBITUARY_HEADLINE_R) { print "print obituary headline rule"; return; } ! 512, case 1
		if (R == PRINT_FINAL_SCORE_R) { print "print final score rule"; return; } ! 513, case 1
		if (R == DISPLAY_FINAL_STATUS_LINE_R) { print "display final status line rule"; return; } ! 514, case 1
		if (R == IMMEDIATELY_RESTART_VM_R) { print "immediately restart the VM rule"; return; } ! 518, case 1
		if (R == IMMEDIATELY_RESTORE_SAVED_R) { print "immediately restore saved game rule"; return; } ! 519, case 1
		if (R == IMMEDIATELY_QUIT_R) { print "immediately quit rule"; return; } ! 520, case 1
		if (R == IMMEDIATELY_UNDO_R) { print "immediately undo rule"; return; } ! 521, case 1
		if (R == READ_FINAL_ANSWER_R) { print "read the final answer rule"; return; } ! 522, case 1
		if (R == QUIT_THE_GAME_R) { print "quit the game rule"; return; } ! 730, case 1
		if (R == SAVE_THE_GAME_R) { print "save the game rule"; return; } ! 734, case 1
		if (R == RESTORE_THE_GAME_R) { print "restore the game rule"; return; } ! 738, case 1
		if (R == RESTART_THE_GAME_R) { print "restart the game rule"; return; } ! 742, case 1
		if (R == VERIFY_THE_STORY_FILE_R) { print "verify the story file rule"; return; } ! 746, case 1
		if (R == SWITCH_TRANSCRIPT_ON_R) { print "switch the story transcript on rule"; return; } ! 750, case 1
		if (R == SWITCH_TRANSCRIPT_OFF_R) { print "switch the story transcript off rule"; return; } ! 754, case 1
		if (R == ANNOUNCE_STORY_FILE_VERSION_R) { print "announce the story file version rule"; return; } ! 758, case 1
		if (R == ANNOUNCE_SCORE_R) { print "announce the score rule"; return; } ! 762, case 1
		if (R == PREFER_ABBREVIATED_R) { print "prefer abbreviated room descriptions rule"; return; } ! 766, case 1
		if (R == REP_PREFER_ABBREVIATED_R) { print "standard report preferring abbreviated room descriptions rule"; return; } ! 767, case 1
		if (R == PREFER_UNABBREVIATED_R) { print "prefer unabbreviated room descriptions rule"; return; } ! 771, case 1
		if (R == REP_PREFER_UNABBREVIATED_R) { print "standard report preferring unabbreviated room descriptions rule"; return; } ! 772, case 1
		if (R == PREFER_SOMETIMES_ABBREVIATED_R) { print "prefer sometimes abbreviated room descriptions rule"; return; } ! 776, case 1
		if (R == REP_PREFER_SOMETIMES_ABBR_R) { print "standard report preferring sometimes abbreviated room descriptions rule"; return; } ! 777, case 1
		if (R == SWITCH_SCORE_NOTIFY_ON_R) { print "switch score notification on rule"; return; } ! 781, case 1
		if (R == REP_SWITCH_NOTIFY_ON_R) { print "standard report switching score notification on rule"; return; } ! 782, case 1
		if (R == SWITCH_SCORE_NOTIFY_OFF_R) { print "switch score notification off rule"; return; } ! 786, case 1
		if (R == REP_SWITCH_NOTIFY_OFF_R) { print "standard report switching score notification off rule"; return; } ! 787, case 1
		if (R == ANNOUNCE_PRONOUN_MEANINGS_R) { print "announce the pronoun meanings rule"; return; } ! 791, case 1
		if (R == R_14) { print "A first turn sequence rule"; return; } ! 1000, case 2
		if (R == R_15) { print "A last turn sequence rule"; return; } ! 1001, case 2
		if (R == R_30) { print "last specific action-processing rule"; return; } ! 1002, case 2
		if (R == R_159) { print "Setting action variables for exiting"; return; } ! 1003, case 2
		if (R == R_744) { print "before printing the banner text when bannerprinted is 0"; return; } ! 1004, case 2
		if (R == R_745) { print "check putting it under"; return; } ! 1005, case 2
		if (R == R_746) { print "carry out putting under"; return; } ! 1006, case 2
		if (R == R_747) { print "after putting under"; return; } ! 1007, case 2
		if (R == R_748) { print "report putting under"; return; } ! 1008, case 2
		if (R == R_749) { print "after taking a thing"; return; } ! 1009, case 2
		if (R == R_750) { print "carry out looking under a noun"; return; } ! 1010, case 2
		if (R == R_751) { print "after taking a noun"; return; } ! 1011, case 2
		if (R == R_752) { print "check quitting the game"; return; } ! 1012, case 2
		if (R == R_753) { print "Check restarting the game"; return; } ! 1013, case 2
		if (R == R_754) { print "when play begins"; return; } ! 1014, case 2
		if (R == R_755) { print "When play begins"; return; } ! 1015, case 2
		if (R == R_756) { print "Setting action variables for taking"; return; } ! 1016, case 2
		if (R == R_757) { print "instead of putting under when player's command includes ~put me under [any thing]~"; return; } ! 1017, case 2
		if (R == R_758) { print "after printing the name of a room"; return; } ! 1018, case 2
		if (R == R_759) { print "before moving to"; return; } ! 1019, case 2
		if (R == R_760) { print "before putting under"; return; } ! 1020, case 2
		if (R == R_761) { print "before going under a thing"; return; } ! 1021, case 2
		if (R == R_762) { print "before taking a noun when the noun is overlaying something ( called the under-contents )"; return; } ! 1022, case 2
		if (R == R_763) { print "before teleporting to"; return; } ! 1023, case 2
		if (R == R_764) { print "before doing anything"; return; } ! 1024, case 2
		if (R == R_765) { print "carry out going under"; return; } ! 1025, case 2
		if (R == R_766) { print "instead of exiting when underly is 1"; return; } ! 1026, case 2
		if (R == R_767) { print "carry out getting out from under"; return; } ! 1027, case 2
		if (R == R_768) { print "every turn when already reported taking is 1"; return; } ! 1028, case 2
		if (R == R_769) { print "after taking something from the location when cheats_bin is 0"; return; } ! 1029, case 2
		if (R == R_770) { print "Report taking something"; return; } ! 1030, case 2
		if (R == R_771) { print "before doing anything"; return; } ! 1031, case 2
		if (R == R_844) { print "Before an actor entering a rideable animal ( called the steed )"; return; } ! 1032, case 2
		if (R == R_845) { print "Before an actor entering a rideable vehicle ( called the conveyance )"; return; } ! 1033, case 2
		if (R == R_846) { print "Before an actor getting off a rideable animal ( called the steed )"; return; } ! 1034, case 2
		if (R == R_847) { print "Before an actor getting off a rideable vehicle ( called the conveyance )"; return; } ! 1035, case 2
		if (R == R_848) { print "Before an actor exiting"; return; } ! 1036, case 2
		if (R == R_861) { print "Before asking a rideable animal ( called the mount ) to try going a direction ( called the way )"; return; } ! 1037, case 2
		if (R == R_893) { print "Carry out asking for help"; return; } ! 1038, case 2
		if (R == R_894) { print "After printing the name of a door"; return; } ! 1039, case 2
		if (R == R_895) { print "instead of examining a direction ( called direction )"; return; } ! 1040, case 2
		if (R == R_896) { print "After opening a door"; return; } ! 1041, case 2
		if (R == R_897) { print "after opening a door"; return; } ! 1042, case 2
		if (R == R_898) { print "Persuasion rule for asking people to try going"; return; } ! 1043, case 2
		if (R == R_899) { print "a procedural rule"; return; } ! 1044, case 2
		if (R == R_900) { print "carry out attacking"; return; } ! 1045, case 2
		if (R == R_901) { print "instead of teleporting to when cheats_bin is 0"; return; } ! 1046, case 2
		if (R == R_902) { print "before teleporting to"; return; } ! 1047, case 2
		if (R == R_903) { print "After teleporting to a noun"; return; } ! 1048, case 2
		if (R == R_904) { print "Instead of moving to when cheats_bin is 0"; return; } ! 1049, case 2
		if (R == R_905) { print "check moving to"; return; } ! 1050, case 2
		if (R == R_906) { print "check moving to"; return; } ! 1051, case 2
		if (R == R_907) { print "check moving to"; return; } ! 1052, case 2
		if (R == R_908) { print "check moving to"; return; } ! 1053, case 2
		if (R == R_909) { print "carry out moving to"; return; } ! 1054, case 2
		if (R == R_910) { print "does the player mean moving to something"; return; } ! 1055, case 2
		if (R == R_911) { print "check switching cheats on"; return; } ! 1056, case 2
		if (R == R_912) { print "check switching cheats off"; return; } ! 1057, case 2
		if (R == R_913) { print "A procedural rule"; return; } ! 1058, case 2
		if (R == R_914) { print "A procedural rule"; return; } ! 1059, case 2
		if (R == R_915) { print "A procedural rule"; return; } ! 1060, case 2
		if (R == R_916) { print "A procedural rule"; return; } ! 1061, case 2
		if (R == R_917) { print "A procedural rule"; return; } ! 1062, case 2
		if (R == R_918) { print "A procedural rule"; return; } ! 1063, case 2
		if (R == R_919) { print "before taking something"; return; } ! 1064, case 2
		if (R == R_920) { print "before going through a door"; return; } ! 1065, case 2
		if (R == R_921) { print "carry out putting back"; return; } ! 1066, case 2
		if (R == R_922) { print "check putting back"; return; } ! 1067, case 2
		if (R == R_923) { print "before putting back"; return; } ! 1068, case 2
		if (R == R_924) { print "carry out universal opening"; return; } ! 1069, case 2
		if (R == R_925) { print "Report universal opening"; return; } ! 1070, case 2
		if (R == R_926) { print "report changing player"; return; } ! 1071, case 2
		if (R == R_927) { print "after changing player"; return; } ! 1072, case 2
		if (R == R_928) { print "before point increasing a number ( called Num )"; return; } ! 1073, case 2
		if (R == R_929) { print "instead of point increasing a number ( called Num )"; return; } ! 1074, case 2
		if (R == R_930) { print "carry out restoring score"; return; } ! 1075, case 2
		if (R == R_931) { print "carry out removing"; return; } ! 1076, case 2
		if (R == R_932) { print "After reading a command when cheats_bin is 1"; return; } ! 1077, case 2
		if (R == R_933) { print "after taking a wizard coin ( called T )"; return; } ! 1078, case 2
		if (R == R_934) { print "before paying wizard money"; return; } ! 1079, case 2
		if (R == R_935) { print "When play begins"; return; } ! 1080, case 2
		if (R == R_936) { print "When play begins"; return; } ! 1081, case 2
		if (R == R_937) { print "When play begins"; return; } ! 1082, case 2
		if (R == R_940) { print "carry out inputting when first tumbler is 0"; return; } ! 1083, case 2
		if (R == R_941) { print "carry out inputting when second tumbler is 0"; return; } ! 1084, case 2
		if (R == R_942) { print "carry out inputting when third tumbler is 0"; return; } ! 1085, case 2
		if (R == R_943) { print "carry out inputting in the presence of a number unlockable ( called pnu )"; return; } ! 1086, case 2
		if (R == R_944) { print "report inputting in the presence of a number unlockable ( called prnu )"; return; } ! 1087, case 2
		if (R == R_956) { print "Instead of implicit-asking"; return; } ! 1088, case 2
		if (R == R_957) { print "Instead of implicit-telling"; return; } ! 1089, case 2
		if (R == R_958) { print "Instead of implicit-quizzing"; return; } ! 1090, case 2
		if (R == R_959) { print "Instead of implicit-informing"; return; } ! 1091, case 2
		if (R == R_960) { print "Instead of implicit-requesting"; return; } ! 1092, case 2
		if (R == R_961) { print "Instead of implicit-imploring"; return; } ! 1093, case 2
		if (R == R_975) { print "When play begins"; return; } ! 1094, case 2
		if (R == R_1032) { print "Rule for supplying a missing second noun while dialling"; return; } ! 1095, case 2
		if (R == R_1092) { print "carry out asking for hints"; return; } ! 1096, case 2
		if (R == R_1093) { print "after reading a command when the command prompt is ~Search:  ~"; return; } ! 1097, case 2
		if (R == R_1094) { print "A procedural rule"; return; } ! 1098, case 2
		if (R == R_1095) { print "before opening the wardrobe"; return; } ! 1099, case 2
		if (R == R_1096) { print "before opening the bedroomdoor"; return; } ! 1100, case 2
		if (R == R_1097) { print "instead of taking inventory"; return; } ! 1101, case 2
		if (R == R_1098) { print "before wearing clothing"; return; } ! 1102, case 2
		if (R == R_1099) { print "before wearing clothing"; return; } ! 1103, case 2
		if (R == R_1100) { print "report using toilet1"; return; } ! 1104, case 2
		if (R == R_1101) { print "report using sink1"; return; } ! 1105, case 2
		if (R == R_1102) { print "instead of turning tap1"; return; } ! 1106, case 2
		if (R == R_1103) { print "instead of switching on tap1"; return; } ! 1107, case 2
		if (R == R_1104) { print "instead of using tap1"; return; } ! 1108, case 2
		if (R == R_1105) { print "after opening stairs"; return; } ! 1109, case 2
		if (R == R_1106) { print "carry out climbing"; return; } ! 1110, case 2
		if (R == R_1107) { print "A procedural rule"; return; } ! 1111, case 2
		if (R == R_1108) { print "after mounting broom"; return; } ! 1112, case 2
		if (R == R_1109) { print "after dismounting"; return; } ! 1113, case 2
		if (R == R_1110) { print "before mounting a broom"; return; } ! 1114, case 2
		if (R == R_1111) { print "before dismounting when player was on lily'sbroom"; return; } ! 1115, case 2
		if (R == R_1112) { print "every turn during uncle vernon's scene"; return; } ! 1116, case 2
		if (R == R_1113) { print "instead of taking a toy"; return; } ! 1117, case 2
		if (R == R_1114) { print "instead of opening diary"; return; } ! 1118, case 2
		if (R == R_1115) { print "before taking howto spoil your children handbook"; return; } ! 1119, case 2
		if (R == R_1116) { print "rule for printing the name of howto spoil your children handbook when listing contents of dusty box"; return; } ! 1120, case 2
		if (R == R_1117) { print "every turn during uncle vernon's scene"; return; } ! 1121, case 2
		if (R == R_1118) { print "before moving to"; return; } ! 1122, case 2
		if (R == R_1119) { print "before examining petunia's diary"; return; } ! 1123, case 2
		if (R == R_1120) { print "a procedural rule"; return; } ! 1124, case 2
		if (R == R_1121) { print "Instead of eating Petunia"; return; } ! 1125, case 2
		if (R == R_1123) { print "After saying hello to petunia when the venture of work is incomplete"; return; } ! 1126, case 2
		if (R == R_1124) { print "after saying hello to dudley"; return; } ! 1127, case 2
		if (R == R_1125) { print "instead of eating a food when the foodlevel of the noun is uneaten"; return; } ! 1128, case 2
		if (R == R_1126) { print "before eating a food when the foodlevel of the noun is half-eaten"; return; } ! 1129, case 2
		if (R == R_1127) { print "A procedural rule"; return; } ! 1130, case 2
		if (R == R_1128) { print "instead of drinking something that is not a cup"; return; } ! 1131, case 2
		if (R == R_1129) { print "report drinking"; return; } ! 1132, case 2
		if (R == R_1130) { print "check drinking"; return; } ! 1133, case 2
		if (R == R_1131) { print "rule for printing the name of coffee cup when taking coffee cup"; return; } ! 1134, case 2
		if (R == R_1132) { print "rule for printing the name of coffee cup when drinking coffee cup"; return; } ! 1135, case 2
		if (R == R_1133) { print "before drinking coffee cup"; return; } ! 1136, case 2
		if (R == R_1134) { print "Instead of eating Dudley"; return; } ! 1137, case 2
		if (R == R_1135) { print "Procedural rule while eating something"; return; } ! 1138, case 2
		if (R == R_1136) { print "rule for printing the name of fridge when listing contents"; return; } ! 1139, case 2
		if (R == R_1137) { print "rule for printing the name of fridge while opening fridge"; return; } ! 1140, case 2
		if (R == R_1138) { print "rule for printing the name of steak when eating steak"; return; } ! 1141, case 2
		if (R == R_1139) { print "check rubbing cereal"; return; } ! 1142, case 2
		if (R == R_1140) { print "check rubbing cereal"; return; } ! 1143, case 2
		if (R == R_1141) { print "before eating cereal"; return; } ! 1144, case 2
		if (R == R_1142) { print "Rule for printing the name of the suitcase while taking inventory"; return; } ! 1145, case 2
		if (R == R_1143) { print "after reading a command during uncle vernon's scene"; return; } ! 1146, case 2
		if (R == R_1144) { print "before unlocking suitcase with dursley"; return; } ! 1147, case 2
		if (R == R_1145) { print "report taking suitcase"; return; } ! 1148, case 2
		if (R == R_1146) { print "check unlocking suitcase with"; return; } ! 1149, case 2
		if (R == R_1147) { print "after not opening car"; return; } ! 1150, case 2
		if (R == R_1148) { print "after not unlocking car with something"; return; } ! 1151, case 2
		if (R == R_1150) { print "instead of going to a road when the player is not in a vehicle"; return; } ! 1152, case 2
		if (R == R_1151) { print "Instead of going by a vehicle ( called the auto ) to somewhere offroad"; return; } ! 1153, case 2
		if (R == R_1155) { print "every turn when in Garden or garage"; return; } ! 1154, case 2
		if (R == R_1156) { print "every turn when in garage"; return; } ! 1155, case 2
		if (R == R_1157) { print "every turn when in garage"; return; } ! 1156, case 2
		if (R == R_1158) { print "every turn during uncle vernon's scene"; return; } ! 1157, case 2
		if (R == R_1159) { print "instead of exiting from a vehicle when the vehicle is in a road"; return; } ! 1158, case 2
		if (R == R_1160) { print "instead of exiting from a rideable vehicle when the rideable vehicle is in a road"; return; } ! 1159, case 2
		if (R == R_1161) { print "before going"; return; } ! 1160, case 2
		if (R == R_1162) { print "before going"; return; } ! 1161, case 2
		if (R == R_1163) { print "every turn when in ferrari enzo"; return; } ! 1162, case 2
		if (R == R_1164) { print "report switching on start button"; return; } ! 1163, case 2
		if (R == R_1165) { print "every turn when in ferrari enzo"; return; } ! 1164, case 2
		if (R == R_1166) { print "before going to highway when in car"; return; } ! 1165, case 2
		if (R == R_1167) { print "after going to highway when lily'sbroom is occupied for the first time"; return; } ! 1166, case 2
		if (R == R_1168) { print "instead of carjacking something that is not a vehicle"; return; } ! 1167, case 2
		if (R == R_1169) { print "instead of carjacking ferrari enzo"; return; } ! 1168, case 2
		if (R == R_1170) { print "Instead of carjacking car"; return; } ! 1169, case 2
		if (R == R_1171) { print "check carjacking a vehicle"; return; } ! 1170, case 2
		if (R == R_1172) { print "every turn when in_trouble is ~in trouble~"; return; } ! 1171, case 2
		if (R == R_1173) { print "every turn when in Grunnings Carpark"; return; } ! 1172, case 2
		if (R == R_1174) { print "after reading a command when the player is in corridor"; return; } ! 1173, case 2
		if (R == R_1175) { print "does the player mean switching on elevatorbutton"; return; } ! 1174, case 2
		if (R == R_1176) { print "after switching on elevatorbutton when in elevator"; return; } ! 1175, case 2
		if (R == R_1177) { print "after switching on elevatorbutton when not in elevator"; return; } ! 1176, case 2
		if (R == R_1178) { print "every turn during uncle vernon's scene"; return; } ! 1177, case 2
		if (R == R_1179) { print "every turn during uncle vernon's scene"; return; } ! 1178, case 2
		if (R == R_1180) { print "before going north when in corridor for the first time"; return; } ! 1179, case 2
		if (R == R_1181) { print "report using"; return; } ! 1180, case 2
		if (R == R_1182) { print "instead of taking the office phone when player's command includes ~Pick up phone~ for the first time"; return; } ! 1181, case 2
		if (R == R_1183) { print "carry out using phone for the first time"; return; } ! 1182, case 2
		if (R == R_1184) { print "instead of hanging up when lexicon is not table 5"; return; } ! 1183, case 2
		if (R == R_1185) { print "rule for printing the name of ics document when taking ics document"; return; } ! 1184, case 2
		if (R == R_1186) { print "every turn when the location is not work office"; return; } ! 1185, case 2
		if (R == R_1187) { print "every turn during customercall"; return; } ! 1186, case 2
		if (R == R_1188) { print "every turn during mrmason call"; return; } ! 1187, case 2
		if (R == R_1189) { print "every turn during uncle vernon's scene"; return; } ! 1188, case 2
		if (R == R_1190) { print "instead of swearing obscenely or swearing mildly when dialyes/no is 1"; return; } ! 1189, case 2
		if (R == R_1191) { print "after dialling 893 on the office phone"; return; } ! 1190, case 2
		if (R == R_1192) { print "before hanging up when dialyes/no is 1"; return; } ! 1191, case 2
		if (R == R_1193) { print "after exiting from work office"; return; } ! 1192, case 2
		if (R == R_1194) { print "after teleporting to a noun"; return; } ! 1193, case 2
		if (R == R_1195) { print "after moving to"; return; } ! 1194, case 2
		if (R == R_1196) { print "every turn when the player is not in work office"; return; } ! 1195, case 2
		if (R == R_1197) { print "carry out responding to customer when lexicon is table 5"; return; } ! 1196, case 2
		if (R == R_1198) { print "before asking or implicit-imploring or implicit-asking when lexicon is table 5"; return; } ! 1197, case 2
		if (R == R_1199) { print "before asking the customer about a topic listed in the lexicon when lexicon is table 1"; return; } ! 1198, case 2
		if (R == R_1200) { print "before saying yes during customercall"; return; } ! 1199, case 2
		if (R == R_1202) { print "before saying no during uncle vernon's scene"; return; } ! 1200, case 2
		if (R == R_1203) { print "before asking the customer about a topic listed in lexicon when lexicon is table 2"; return; } ! 1201, case 2
		if (R == R_1204) { print "before asking the customer about a topic listed in lexicon when lexicon is table 4"; return; } ! 1202, case 2
		if (R == R_1205) { print "before asking the customer about a topic listed in table 5 when lexicon is table 5"; return; } ! 1203, case 2
		if (R == R_1206) { print "before dialling 8953 on office phone when dialyes/no is 1"; return; } ! 1204, case 2
		if (R == R_1207) { print "rule for printing a parser error when dialyes/no is 1"; return; } ! 1205, case 2
		if (R == R_1208) { print "carry out saying"; return; } ! 1206, case 2
		if (R == R_1209) { print "before asking the customer about a topic when dialyes/no is 1"; return; } ! 1207, case 2
		if (R == R_1210) { print "instead of answering the customer that"; return; } ! 1208, case 2
		if (R == R_1211) { print "instead of telling the customer about a topic"; return; } ! 1209, case 2
		if (R == R_1212) { print "instead of saying hello to the customer for at least the second time"; return; } ! 1210, case 2
		if (R == R_1213) { print "does the player mean saying hello to"; return; } ! 1211, case 2
		if (R == R_1214) { print "before doing anything to rollerdex for the first time"; return; } ! 1212, case 2
		if (R == R_1215) { print "before doing anything to rollerdex for at least the second time"; return; } ! 1213, case 2
		if (R == R_1216) { print "carry out flipping for the first time"; return; } ! 1214, case 2
		if (R == R_1217) { print "carry out flipping for at least the second time"; return; } ! 1215, case 2
		if (R == R_1218) { print "when play begins"; return; } ! 1216, case 2
		if (R == R_1220) { print "after examining ics document"; return; } ! 1217, case 2
		if (R == R_1221) { print "after saying hello to the customer"; return; } ! 1218, case 2
		if (R == R_1222) { print "before opening filing cabinet"; return; } ! 1219, case 2
		if (R == R_1223) { print "before examining filing cabinet"; return; } ! 1220, case 2
		if (R == R_1224) { print "instead of opening fcdrawer"; return; } ! 1221, case 2
		if (R == R_1225) { print "instead of dialling 893 on office phone when the venture of customercall is success"; return; } ! 1222, case 2
		if (R == R_1226) { print "instead of dialling 12856 on office phone when the venture of mrmason call is success"; return; } ! 1223, case 2
		if (R == R_1227) { print "after reading a command during work"; return; } ! 1224, case 2
		if (R == R_1228) { print "after examining rollerdex"; return; } ! 1225, case 2
		if (R == R_1229) { print "after saying hello to mr mason"; return; } ! 1226, case 2
		if (R == R_1230) { print "before saying yes during mrmason call"; return; } ! 1227, case 2
		if (R == R_1231) { print "carry out responding to customer when lexicon is table 9"; return; } ! 1228, case 2
		if (R == R_1232) { print "report responding to customer when lexicon is table 9"; return; } ! 1229, case 2
		if (R == R_1233) { print "before responding to customer a topic listed in the lexicon when the lexicon is table 9"; return; } ! 1230, case 2
		if (R == R_1234) { print "before doing anything except hanging up or saying goodbye to when lexicon is table 10"; return; } ! 1231, case 2
		if (R == R_1235) { print "before responding to customer when lexicon is table 10"; return; } ! 1232, case 2
		if (R == R_1236) { print "after reading a command when the lexicon is table 10"; return; } ! 1233, case 2
		if (R == R_1237) { print "instead of swearing obscenely or swearing mildly when office phone is inuse"; return; } ! 1234, case 2
		if (R == R_1238) { print "carry out writing intro"; return; } ! 1235, case 2
		if (R == R_1239) { print "carry out writing on when the command prompt is ~What do you want to write: ~"; return; } ! 1236, case 2
		if (R == R_1240) { print "before doing anything when the command prompt is ~What do you want to write: ~"; return; } ! 1237, case 2
		if (R == R_1241) { print "before writing intro"; return; } ! 1238, case 2
		if (R == R_1242) { print "After reading a command when the command prompt is ~What do you want to write: ~"; return; } ! 1239, case 2
		if (R == R_1243) { print "does the player mean doing anything to living-room"; return; } ! 1240, case 2
		if (R == R_1244) { print "every turn during work"; return; } ! 1241, case 2
		if (R == R_1245) { print "carry out clearing the screen"; return; } ! 1242, case 2
		if (R == R_1246) { print "after reading a command during uncle vernon's scene"; return; } ! 1243, case 2
		if (R == R_1247) { print "after reading a command during uncle vernon's scene"; return; } ! 1244, case 2
		if (R == R_1248) { print "after reading a command during uncle vernon's scene"; return; } ! 1245, case 2
		if (R == R_1249) { print "rule for printing the name of bakery door when opening bakery door"; return; } ! 1246, case 2
		if (R == R_1250) { print "rule for printing the name of bakery door when going through bakery door"; return; } ! 1247, case 2
		if (R == R_1251) { print "after going through bakery door when the location is bakers"; return; } ! 1248, case 2
		if (R == R_1252) { print "after examining shop attendant"; return; } ! 1249, case 2
		if (R == R_1253) { print "after examining foods display case"; return; } ! 1250, case 2
		if (R == R_1254) { print "rule for printing the name of doughnut when taking doughnut"; return; } ! 1251, case 2
		if (R == R_1255) { print "rule for printing the name of doughnut when giving doughnut to yourself"; return; } ! 1252, case 2
		if (R == R_1256) { print "rule for printing the name of bun when taking bun"; return; } ! 1253, case 2
		if (R == R_1257) { print "rule for printing the name of bun when giving bun to yourself"; return; } ! 1254, case 2
		if (R == R_1258) { print "rule for printing the name of breadstick when taking breadstick"; return; } ! 1255, case 2
		if (R == R_1259) { print "rule for printing the name of breadstick when giving breadstick to yourself"; return; } ! 1256, case 2
		if (R == R_1260) { print "before giving the pound coin to the shop attendant"; return; } ! 1257, case 2
		if (R == R_1261) { print "before giving something in foods display case to the player when in bakers"; return; } ! 1258, case 2
		if (R == R_1262) { print "when play begins"; return; } ! 1259, case 2
		if (R == R_1263) { print "before buying anything when in bakers"; return; } ! 1260, case 2
		if (R == R_1264) { print "before wanting"; return; } ! 1261, case 2
		if (R == R_1265) { print "instead of asking the shop attendant to try doing anything"; return; } ! 1262, case 2
		if (R == R_1266) { print "instead of requesting the shop attendant for anything"; return; } ! 1263, case 2
		if (R == R_1267) { print "persuasion rule for asking shop attendant to try doing anything"; return; } ! 1264, case 2
		if (R == R_1268) { print "instead of looking when location is street"; return; } ! 1265, case 2
		if (R == R_1269) { print "after going west when bakers is visited"; return; } ! 1266, case 2
		if (R == R_1270) { print "a procedural rule"; return; } ! 1267, case 2
		if (R == R_1271) { print "after reading a command during uncle vernon's scene"; return; } ! 1268, case 2
		if (R == R_1272) { print "carry out listening when the location is street"; return; } ! 1269, case 2
		if (R == R_1273) { print "before going north when the location is corridor"; return; } ! 1270, case 2
		if (R == R_1274) { print "after going to Grunnings carpark when the venture of work is success"; return; } ! 1271, case 2
		if (R == R_1275) { print "after exiting from elevator when the location is Grunnings carpark"; return; } ! 1272, case 2
		if (R == R_1276) { print "does the player mean doing anything to car"; return; } ! 1273, case 2
		if (R == R_1277) { print "does the player mean moving to car"; return; } ! 1274, case 2
		if (R == R_1278) { print "after entering car"; return; } ! 1275, case 2
		if (R == R_1279) { print "after going to Garden when the venture of work is success"; return; } ! 1276, case 2
		if (R == R_1280) { print "carry out saying hello to petunia during uncle vernon's scene"; return; } ! 1277, case 2
		if (R == R_1281) { print "rule for printing the name of a door when going through a door"; return; } ! 1278, case 2
		if (R == R_1282) { print "rule for printing the name of a door when opening a door"; return; } ! 1279, case 2
		if (R == R_1283) { print "after reading a command when the location is dining room"; return; } ! 1280, case 2
		if (R == R_1284) { print "instead of examining chairs when in dining room"; return; } ! 1281, case 2
		if (R == R_1285) { print "Instead of taking a photo"; return; } ! 1282, case 2
		if (R == R_1286) { print "report playing"; return; } ! 1283, case 2
		if (R == R_1287) { print "report playing piano"; return; } ! 1284, case 2
		if (R == R_1288) { print "after reading a command when the player's command matches ~sit down~"; return; } ! 1285, case 2
		if (R == R_1289) { print "after going to living-room"; return; } ! 1286, case 2
		if (R == R_1290) { print "instead of examining television when television is switched on"; return; } ! 1287, case 2
		if (R == R_1291) { print "report switching on television when the venture of work is incomplete"; return; } ! 1288, case 2
		if (R == R_1292) { print "report switching on television when the venture of work is not incomplete"; return; } ! 1289, case 2
		if (R == R_1293) { print "a procedural rule"; return; } ! 1290, case 2
		if (R == R_1294) { print "a procedural rule"; return; } ! 1291, case 2
		if (R == R_1295) { print "report thinking"; return; } ! 1292, case 2
		if (R == R_1296) { print "report thinking during uncle vernon's scene"; return; } ! 1293, case 2
		if (R == R_1297) { print "report thinking during uncle vernon's scene"; return; } ! 1294, case 2
		if (R == R_1298) { print "every turn during living-room cut scene"; return; } ! 1295, case 2
		if (R == R_1299) { print "every turn when petunia's cup is not on tray"; return; } ! 1296, case 2
		if (R == R_1300) { print "rule for printing the name of vernon's cup when taking vernon's cup"; return; } ! 1297, case 2
		if (R == R_1301) { print "rule for printing the name of vernon's cup when dropping vernon's cup"; return; } ! 1298, case 2
		if (R == R_1302) { print "rule for printing the name of petunia's cup when taking petunia's cup"; return; } ! 1299, case 2
		if (R == R_1303) { print "rule for printing the name of petunia's cup when dropping petunia's cup"; return; } ! 1300, case 2
		if (R == R_1304) { print "rule for printing the name of vernon's cup when drinking vernon's cup"; return; } ! 1301, case 2
		if (R == R_1305) { print "rule for printing the name of vernon's cup when drinking petunia's cup"; return; } ! 1302, case 2
		if (R == R_1306) { print "every turn when tvonafterwork is 1"; return; } ! 1303, case 2
		if (R == R_1307) { print "a procedural rule"; return; } ! 1304, case 2
		if (R == R_1308) { print "carry out asking petunia about ~[potters]~ during uncle vernon's scene"; return; } ! 1305, case 2
		if (R == R_1309) { print "carry out imploring Petunia for ~[Potters]~ during uncle vernon's scene"; return; } ! 1306, case 2
		if (R == R_1310) { print "carry out answering petunia that ~[Potters]~ during uncle vernon's scene"; return; } ! 1307, case 2
		if (R == R_1311) { print "carry out telling petunia about ~[Potters]~ during uncle vernon's scene"; return; } ! 1308, case 2
		if (R == R_1312) { print "carry out thanking"; return; } ! 1309, case 2
		if (R == R_1313) { print "after drinking vernon's cup"; return; } ! 1310, case 2
		if (R == R_1314) { print "before thanking with no noun"; return; } ! 1311, case 2
		if (R == R_1315) { print "when living-room cut scene begins"; return; } ! 1312, case 2
		if (R == R_1316) { print "after entering bed during living-room cut scene"; return; } ! 1313, case 2
		if (R == R_1317) { print "rule for printing the name of cot when looking"; return; } ! 1314, case 2
		if (R == R_1318) { print "instead of entering cot"; return; } ! 1315, case 2
		if (R == R_1319) { print "instead of opening set of drawers"; return; } ! 1316, case 2
		if (R == R_1320) { print "instead of searching the set of drawers"; return; } ! 1317, case 2
		if (R == R_1321) { print "rule for printing the name of a pair of glasses when doing anything to a pair of glasses"; return; } ! 1318, case 2
		if (R == R_1322) { print "rule for printing the name of magic wand when doing anything to magic wand"; return; } ! 1319, case 2
		if (R == R_1323) { print "after going to Dudley's bedroom"; return; } ! 1320, case 2
		if (R == R_1324) { print "after reading a command during uncle vernon's scene"; return; } ! 1321, case 2
		if (R == R_1325) { print "carry out dursley's spellcasting when magic wand is carried"; return; } ! 1322, case 2
		if (R == R_1328) { print "carry out dursley's spellcasting when magic wand is not carried"; return; } ! 1323, case 2
		if (R == R_1329) { print "report using toilet2"; return; } ! 1324, case 2
		if (R == R_1330) { print "report using sink2"; return; } ! 1325, case 2
		if (R == R_1331) { print "instead of turning tap2"; return; } ! 1326, case 2
		if (R == R_1332) { print "instead of switching on tap2"; return; } ! 1327, case 2
		if (R == R_1333) { print "instead of using tap2"; return; } ! 1328, case 2
		if (R == R_1334) { print "carry out jumping out of bedroomwindow"; return; } ! 1329, case 2
		if (R == R_1335) { print "carry out jumping out of window"; return; } ! 1330, case 2
		if (R == R_1336) { print "instead of taking when the player's command includes ~steal~"; return; } ! 1331, case 2
		if (R == R_1337) { print "carry out timing"; return; } ! 1332, case 2
		if (R == R_8) { print "start in the correct scenes rule"; return; } ! 1333, case 1
		if (R == POSITION_PLAYER_IN_MODEL_R) { print "position player in model world rule"; return; } ! 1334, case 1
		if (R == UPDATE_CHRONOLOGICAL_RECORDS_R) { print "update chronological records rule"; return; } ! 1335, case 1
		if (R == SEED_RANDOM_NUMBER_GENERATOR_R) { print "seed random number generator rule"; return; } ! 1336, case 1
		if (R == VIRTUAL_MACHINE_STARTUP_R) { print "virtual machine startup rule"; return; } ! 1337, case 1
		if (R == INITIALISE_MEMORY_R) { print "initialise memory rule"; return; } ! 1338, case 1
		if (R == R_9) { print "when play begins stage rule"; return; } ! 1339, case 1
		if (R == R_10) { print "fix baseline scoring rule"; return; } ! 1340, case 1
		if (R == R_11) { print "display banner rule"; return; } ! 1341, case 1
		if (R == R_12) { print "initial room description rule"; return; } ! 1342, case 1
		if (R == GENERATE_ACTION_R) { print "generate action rule"; return; } ! 1343, case 1
		if (R == PARSE_COMMAND_R) { print "parse command rule"; return; } ! 1344, case 1
		if (R == TIMED_EVENTS_R) { print "timed events rule"; return; } ! 1345, case 1
		if (R == ADVANCE_TIME_R) { print "advance time rule"; return; } ! 1346, case 1
		if (R == UPDATE_CHRONOLOGICAL_RECORDS_R) { print "update chronological records rule"; return; } ! 1347, case 1
		if (R == ADJUST_LIGHT_R) { print "adjust light rule"; return; } ! 1348, case 1
		if (R == NOTE_OBJECT_ACQUISITIONS_R) { print "note object acquisitions rule"; return; } ! 1349, case 1
		if (R == R_16) { print "notify score changes rule"; return; } ! 1350, case 1
		if (R == R_17) { print "when play ends stage rule"; return; } ! 1351, case 1
		if (R == RESURRECT_PLAYER_IF_ASKED_R) { print "resurrect player if asked rule"; return; } ! 1352, case 1
		if (R == R_18) { print "print player's obituary rule"; return; } ! 1353, case 1
		if (R == ASK_FINAL_QUESTION_R) { print "ask the final question rule"; return; } ! 1354, case 1
		if (R == DetectSceneChange) { print "scene change machinery rule"; return; } ! 1355, case 1
		if (R == R_21) { print "before stage rule"; return; } ! 1356, case 1
		if (R == R_19) { print "set pronouns from items from multiple object lists rule"; return; } ! 1357, case 1
		if (R == R_20) { print "announce items from multiple object lists rule"; return; } ! 1358, case 1
		if (R == BASIC_VISIBILITY_R) { print "basic visibility rule"; return; } ! 1359, case 1
		if (R == BASIC_ACCESSIBILITY_R) { print "basic accessibility rule"; return; } ! 1360, case 1
		if (R == CARRYING_REQUIREMENTS_R) { print "carrying requirements rule"; return; } ! 1361, case 1
		if (R == R_22) { print "instead stage rule"; return; } ! 1362, case 1
		if (R == REQUESTED_ACTIONS_REQUIRE_R) { print "requested actions require persuasion rule"; return; } ! 1363, case 1
		if (R == CARRY_OUT_REQUESTED_ACTIONS_R) { print "carry out requested actions rule"; return; } ! 1364, case 1
		if (R == DESCEND_TO_SPECIFIC_ACTION_R) { print "descend to specific action-processing rule"; return; } ! 1365, case 1
		if (R == R_23) { print "end action-processing in success rule"; return; } ! 1366, case 1
		if (R == WORK_OUT_DETAILS_OF_SPECIFIC_R) { print "work out details of specific action rule"; return; } ! 1367, case 1
		if (R == ACCESS_THROUGH_BARRIERS_R) { print "access through barriers rule"; return; } ! 1368, case 1
		if (R == CANT_REACH_INSIDE_ROOMS_R) { print "can't reach inside rooms rule"; return; } ! 1369, case 1
		if (R == CANT_REACH_INSIDE_CLOSED_R) { print "can't reach inside closed containers rule"; return; } ! 1370, case 1
		if (R == CANT_REACH_OUTSIDE_CLOSED_R) { print "can't reach outside closed containers rule"; return; } ! 1371, case 1
		if (R == R_35) { print "can't act in the dark rule"; return; } ! 1372, case 1
		if (R == STANDARD_NAME_PRINTING_R) { print "standard name printing rule"; return; } ! 1373, case 1
		if (R == R_59) { print "standard printing the plural name rule"; return; } ! 1374, case 1
		if (R == R_60) { print "standard printing a number of something rule"; return; } ! 1375, case 1
		if (R == STANDARD_CONTENTS_LISTING_R) { print "standard contents listing rule"; return; } ! 1376, case 1
		if (R == R_61) { print "look around once light available rule"; return; } ! 1377, case 1
		if (R == ENABLE_GLULX_ACCEL_R) { print "enable Glulx acceleration rule"; return; } ! 1378, case 1
		if (R == PRINT_OBITUARY_HEADLINE_R) { print "print obituary headline rule"; return; } ! 1379, case 1
		if (R == PRINT_FINAL_SCORE_R) { print "print final score rule"; return; } ! 1380, case 1
		if (R == DISPLAY_FINAL_STATUS_LINE_R) { print "display final status line rule"; return; } ! 1381, case 1
		if (R == R_69) { print "print the final question rule"; return; } ! 1382, case 1
		if (R == R_68) { print "print the final prompt rule"; return; } ! 1383, case 1
		if (R == READ_FINAL_ANSWER_R) { print "read the final answer rule"; return; } ! 1384, case 1
		if (R == R_70) { print "standard respond to final question rule"; return; } ! 1385, case 1
		if (R == R_91) { print "can't take component parts rule"; return; } ! 1386, case 1
		if (R == R_148) { print "find what to enter rule"; return; } ! 1387, case 1
		if (R == QUIT_THE_GAME_R) { print "quit the game rule"; return; } ! 1388, case 1
		if (R == SAVE_THE_GAME_R) { print "save the game rule"; return; } ! 1389, case 1
		if (R == RESTORE_THE_GAME_R) { print "restore the game rule"; return; } ! 1390, case 1
		if (R == RESTART_THE_GAME_R) { print "restart the game rule"; return; } ! 1391, case 1
		if (R == VERIFY_THE_STORY_FILE_R) { print "verify the story file rule"; return; } ! 1392, case 1
		if (R == SWITCH_TRANSCRIPT_ON_R) { print "switch the story transcript on rule"; return; } ! 1393, case 1
		if (R == SWITCH_TRANSCRIPT_OFF_R) { print "switch the story transcript off rule"; return; } ! 1394, case 1
		if (R == ANNOUNCE_STORY_FILE_VERSION_R) { print "announce the story file version rule"; return; } ! 1395, case 1
		if (R == ANNOUNCE_SCORE_R) { print "announce the score rule"; return; } ! 1396, case 1
		if (R == PREFER_ABBREVIATED_R) { print "prefer abbreviated room descriptions rule"; return; } ! 1397, case 1
		if (R == REP_PREFER_ABBREVIATED_R) { print "standard report preferring abbreviated room descriptions rule"; return; } ! 1398, case 1
		if (R == PREFER_UNABBREVIATED_R) { print "prefer unabbreviated room descriptions rule"; return; } ! 1399, case 1
		if (R == REP_PREFER_UNABBREVIATED_R) { print "standard report preferring unabbreviated room descriptions rule"; return; } ! 1400, case 1
		if (R == PREFER_SOMETIMES_ABBREVIATED_R) { print "prefer sometimes abbreviated room descriptions rule"; return; } ! 1401, case 1
		if (R == REP_PREFER_SOMETIMES_ABBR_R) { print "standard report preferring sometimes abbreviated room descriptions rule"; return; } ! 1402, case 1
		if (R == SWITCH_SCORE_NOTIFY_ON_R) { print "switch score notification on rule"; return; } ! 1403, case 1
		if (R == REP_SWITCH_NOTIFY_ON_R) { print "standard report switching score notification on rule"; return; } ! 1404, case 1
		if (R == SWITCH_SCORE_NOTIFY_OFF_R) { print "switch score notification off rule"; return; } ! 1405, case 1
		if (R == REP_SWITCH_NOTIFY_OFF_R) { print "standard report switching score notification off rule"; return; } ! 1406, case 1
		if (R == ANNOUNCE_PRONOUN_MEANINGS_R) { print "announce the pronoun meanings rule"; return; } ! 1407, case 1
		if (R == R_837) { print "update ambiguous pronouns for actions rule"; return; } ! 1408, case 1
		if (R == R_946) { print "mark items as seen on opening a container rule"; return; } ! 1409, case 1
		if (R == R_971) { print "change greeting command to greeting rule"; return; } ! 1410, case 1
		if (R == R_984) { print "say goodbye when moving rule"; return; } ! 1411, case 1
		if (R == R_1062) { print "departure-posture rule"; return; } ! 1412, case 1
		if (R == R_1062) { print "departure-posture rule"; return; } ! 1413, case 1
		if (R == R_1063) { print "arrival-posture rule"; return; } ! 1414, case 1

		print "(nameless rule at address ", R, ")";
	}
#ifnot;
	if ((R>=0) && (R<NUMBER_RULEBOOKS_CREATED)) {
		print "(rulebook ", R, ")";
	} else {
		print "(rule at address ", R, ")";
	}
#endif;
];

[ DebugRulebooks subs parameter i;
	spaces(2*process_rulebook_count);
	print "[", (RulePrintingRule) subs;
	if (parameter) print " / on O", parameter;
	print "]^";
];

[ DB_Rule R N blocked;
	if (R==0) return;
	print "[Rule ~", (RulePrintingRule) R, "~ ";
	#ifdef NUMBERED_RULES; print "(", N, ") "; #endif;
	if (blocked == false) "applies.]";
	"does not apply.]";
];

Global I7S_Tab; ! The array to be sorted, which can have almost any format
Global I7S_Col; ! The "column number" in the array, if any
Global I7S_Dir; ! The direction of sorting: ascending (1) or descending (-1)
Global I7S_Swap; ! The current routine for swapping two fields
Global I7S_Comp; ! The current routine for comparing two fields

#ifdef MEASURE_SORT_PERFORMANCE;
Global I7S_CCOUNT; Global I7S_CCOUNT2; Global I7S_XCOUNT; ! For testing only
#endif;

[ SetSortDomain swapf compf;
	I7S_Swap = swapf;
	I7S_Comp = compf;
];

[ SortArray tab col dir size test_flag algorithm;
	I7S_Tab = tab;
	I7S_Col = col;
	I7S_Dir = dir;
	#ifdef MEASURE_SORT_PERFORMANCE;
	I7S_CCOUNT = 0;
	I7S_CCOUNT2 = 0;
	I7S_XCOUNT = 0;
	#endif;
	SortRange(0, size, algorithm);
	#ifdef MEASURE_SORT_PERFORMANCE;
	if (test_flag)
		print "Sorted array of size ", size, " with ", I7S_CCOUNT2, "*10000 + ", I7S_CCOUNT,
			" comparisons and ", I7S_XCOUNT, " exchanges^";
	#endif;
];

[ SortRange x y algorithm;
	if (y - x < 2) return;
	if (algorithm) {
		(algorithm)(x, y);
	} else {
		InPlaceMergeSortAlgorithm(x, y);
	}
];

[ CompareFields x y;
	#ifdef MEASURE_SORT_PERFORMANCE;
	I7S_CCOUNT++;
	if (I7S_CCOUNT == 10000) { I7S_CCOUNT = 0; I7S_CCOUNT2++; }
	#endif;
	return I7S_Dir*I7S_Comp(I7S_Tab, I7S_Col, x+1, y+1, I7S_Dir);
];

[ ExchangeFields x y;
	#ifdef MEASURE_SORT_PERFORMANCE;
	I7S_XCOUNT++;
	if (I7S_XCOUNT < 0) { print "XO^"; I7S_XCOUNT = 0; }
	#endif;
	return I7S_Swap(I7S_Tab, x+1, y+1);
];

[ OldSortAlgorithm x y
	f i j;
	if (y - x < 2) return;
	f = true;
	while (f) {
		f = false;
		for (i=x:i<y:i++)
		    for (j=i+1:j<y:j++)
				if (CompareFields(i, j) > 0) {
					ExchangeFields(i, j); f = true; break;
				}
	}
];

[ InsertionSortAlgorithm from to
	i j;
	if (to > from+1) { 
		for (i = from+1: i < to: i++) { 
			for (j = i: j > from: j--) { 
				if (CompareFields(j, j-1) < 0) 
					ExchangeFields(j, j-1);
				else break;
			}
		}
	}
];

[ InPlaceMergeSortAlgorithm from to
	middle;
	if (to - from < 12) {
		if (to - from < 2) return;
		InsertionSortAlgorithm(from, to);
		return;
	}
	middle = (from + to)/2; 
	InPlaceMergeSortAlgorithm(from, middle); 
	InPlaceMergeSortAlgorithm(middle, to); 
	IPMS_Merge(from, middle, to, middle-from, to - middle); 
];

[ IPMS_Lower from to val
	len half mid;
	len = to - from;
	while (len > 0) { 
		half = len/2; 
		mid = from + half;
		if (CompareFields(mid, val) < 0) {
			from = mid + 1;
			len = len - half -1; 
		} else len = half;
	}
	return from;
];

[ IPMS_Upper from to val
	len half mid;
	len = to - from;
	while (len > 0) { 
		half = len/2; 
		mid = from + half;
		if (CompareFields(val, mid) < 0)
			len = half;
		else {
			from = mid + 1;
			len = len - half -1; 
		}
	}
	return from;
];

[ IPMS_Reverse from to;
	while (from < to) {
		ExchangeFields(from++, to--);
	}
];

[ IPMS_Rotate from mid to
	n val shift p1 p2;
	if ((from==mid) || (mid==to)) return; 
	IPMS_Reverse(from, mid-1); 
	IPMS_Reverse(mid, to-1); 
	IPMS_Reverse(from, to-1);
];

[ IPMS_Merge from pivot to len1 len2
	first_cut second_cut len11 len22 new_mid;
	if ((len1 == 0) || (len2 == 0)) return; 
	if (len1+len2 == 2) { 
		if (CompareFields(pivot, from) < 0) 
		ExchangeFields(pivot, from); 
		return; 
	}
	if (len1 > len2) { 
		len11 = len1/2; 
		first_cut = from + len11; 
		second_cut = IPMS_Lower(pivot, to, first_cut); 
		len22 = second_cut - pivot; 
	} else { 
		len22 = len2/2; 
		second_cut = pivot + len22; 
		first_cut = IPMS_Upper(from, pivot, second_cut); 
		len11 = first_cut - from; 
	} 
	IPMS_Rotate(first_cut, pivot, second_cut); 
	new_mid = first_cut + len22; 
	IPMS_Merge(from, first_cut, new_mid, len11, len22); 
	IPMS_Merge(new_mid, second_cut, to, len1 - len11, len2 - len22); 
];

Constant TB_COLUMN_SIGNED      $4000;
Constant TB_COLUMN_TOPIC       $2000;
Constant TB_COLUMN_DONTSORTME  $1000;
Constant TB_COLUMN_NOBLANKBITS $0800;
Constant TB_COLUMN_CANEXCHANGE $0400;
Constant TB_COLUMN_ALLOCATED   $0200;
Constant TB_COLUMN_NUMBER      $01ff; ! Mask to remove upper bit flags

Constant COL_HSIZE 2; ! Column header size: two words (ID/flags, blank bits)

[ TableFindCol tab col f i no_cols n;
	no_cols = tab-->0;
	for (i=1: i<=no_cols: i++)
		if (col == ((tab-->i)-->1) & TB_COLUMN_NUMBER) return i;
	if (f) { RunTimeProblem(RTP_TABLE_NOCOL, tab); return 0; }
	return 0;
];

[ TableRows tab first_col;
	first_col = tab-->1; if (first_col == 0) return 0;
	return (first_col-->0) - COL_HSIZE;
];

Constant TABLE_NOVALUE = IMPROBABLE_VALUE;

Array CheckTableEntryIsBlank_LU
	->	$$00000001
		$$00000010
		$$00000100
		$$00001000
		$$00010000
		$$00100000
		$$01000000
		$$10000000;
Array CheckTableEntryIsNonBlank_LU
	->	$$11111110
		$$11111101
		$$11111011
		$$11110111
		$$11101111
		$$11011111
		$$10111111
		$$01111111;

[ CheckTableEntryIsBlank tab col row i at;
	if (col >= 100) col = TableFindCol(tab, col);
	if (col == 0) rtrue;
	if ((tab-->col)-->(row+COL_HSIZE) ~= TABLE_NOVALUE) {
		print "*** CTEIB on nonblank value ", tab, " ", col, " ", row, " ***^";
	}
	if (((tab-->col)-->1) & TB_COLUMN_NOBLANKBITS) rtrue;
	row--;
	at = ((tab-->col)-->2) + (row/8);
	if ((TB_Blanks->at) & (CheckTableEntryIsBlank_LU->(row%8))) rtrue;
	rfalse;
];

[ ForceTableEntryBlank tab col row i at oldv flags;
	if (col >= 100) col = TableFindCol(tab, col);
	if (col == 0) rtrue;
	flags = (tab-->col)-->1;
	oldv = (tab-->col)-->(row+COL_HSIZE);
	if ((flags & TB_COLUMN_ALLOCATED) && (oldv ~= 0 or TABLE_NOVALUE))
		BlkFree(oldv);
	(tab-->col)-->(row+COL_HSIZE) = TABLE_NOVALUE;
	if (flags & TB_COLUMN_NOBLANKBITS) return;
	row--;
	at = ((tab-->col)-->2) + (row/8);
	(TB_Blanks->at) = (TB_Blanks->at) | (CheckTableEntryIsBlank_LU->(row%8));
];

[ ForceTableEntryNonBlank tab col row i at oldv flags tc kov;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rtrue;
	if (((tab-->col)-->1) & TB_COLUMN_NOBLANKBITS) return;
	flags = (tab-->col)-->1;
	oldv = (tab-->col)-->(row+COL_HSIZE);
	if ((flags & TB_COLUMN_ALLOCATED) &&
		(oldv == 0 or TABLE_NOVALUE)) {
		kov = UNKNOWN_TY;
		tc = ((tab-->col)-->1) & TB_COLUMN_NUMBER;
		kov = TC_KOV(tc);
		if (kov ~= UNKNOWN_TY) {
			i = kov;
			if (KindBaseArity(i) > 0) i = KindAtomic(i); else i = 0;
			(tab-->col)-->(row+COL_HSIZE) = BlkValueCreate(kov, 0, i);
		}
	}
	row--;
	at = ((tab-->col)-->2) + (row/8);
	(TB_Blanks->at) = (TB_Blanks->at) & (CheckTableEntryIsNonBlank_LU->(row%8));
];

[ TableSwapBlankBits tab row1 row2 col at1 at2 bit1 bit2;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rtrue;
	if (((tab-->col)-->1) & TB_COLUMN_NOBLANKBITS) return;
	row1--;
	at1 = ((tab-->col)-->2) + (row1/8);
	row2--;
	at2 = ((tab-->col)-->2) + (row2/8);
	bit1 = ((TB_Blanks->at1) & (CheckTableEntryIsBlank_LU->(row1%8)));
	bit2 = ((TB_Blanks->at2) & (CheckTableEntryIsBlank_LU->(row2%8)));
	if (bit1) bit1 = true; 
	if (bit2) bit2 = true;
	if (bit1 == bit2) return;
	if (bit1) {
		(TB_Blanks->at1)
			= (TB_Blanks->at1) & (CheckTableEntryIsNonBlank_LU->(row1%8));
		(TB_Blanks->at2)
			= (TB_Blanks->at2) | (CheckTableEntryIsBlank_LU->(row2%8));
	} else {
		(TB_Blanks->at1)
			= (TB_Blanks->at1) | (CheckTableEntryIsBlank_LU->(row1%8));
		(TB_Blanks->at2)
			= (TB_Blanks->at2) & (CheckTableEntryIsNonBlank_LU->(row2%8));
	}
];

[ TableMoveBlankBitsDown tab row1 row2 col at atp1 bit rx;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rtrue;
	if (((tab-->col)-->1) & TB_COLUMN_NOBLANKBITS) return;
	row1--; row2--;
	! Read blank bit for row1:
	at = ((tab-->col)-->2) + (row1/8);
	bit = ((TB_Blanks->at) & (CheckTableEntryIsBlank_LU->(row1%8)));
	if (bit) bit = true;
	! Loop through, setting each blank bit to the next:
	for (rx=row1:rx<row2:rx++) {
		atp1 = ((tab-->col)-->2) + ((rx+1)/8);
		at = ((tab-->col)-->2) + (rx/8);
		if ((TB_Blanks->atp1) & (CheckTableEntryIsBlank_LU->((rx+1)%8))) {
			(TB_Blanks->at)
				= (TB_Blanks->at) | (CheckTableEntryIsBlank_LU->(rx%8));
		} else {
			(TB_Blanks->at)
				= (TB_Blanks->at) & (CheckTableEntryIsNonBlank_LU->(rx%8));
		}
	}
	! Write bit to blank bit for row2:
	at = ((tab-->col)-->2) + (row2/8);
	if (bit) {
		(TB_Blanks->at)
			= (TB_Blanks->at) | (CheckTableEntryIsBlank_LU->(row2%8));
	} else {
		(TB_Blanks->at)
			= (TB_Blanks->at) & (CheckTableEntryIsNonBlank_LU->(row2%8));
	}
];

[ TableRowCorr tab col lookup_value lookup_col i j f;
	if (col >= 100) col=TableFindCol(tab, col, true);
	lookup_col = tab-->col;
	j = lookup_col-->0 - COL_HSIZE;
	f=0;
	if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED) f=1;
	for (i=1:i<=j:i++) {
		if ((lookup_value == TABLE_NOVALUE) &&
			(CheckTableEntryIsBlank(tab,col,i))) continue;
		if (f) {
			if (BlkValueCompare(lookup_col-->(i+COL_HSIZE), lookup_value) == 0)
				return i;
		} else {
			if (lookup_col-->(i+COL_HSIZE) == lookup_value) return i;
		}
	}
	return RunTimeProblem(RTP_TABLE_NOCORR, tab);
];

[ ExistsTableRowCorr tab col entry i k v f kov;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rfalse;
	f=0;
	if (((tab-->col)-->1) & TB_COLUMN_TOPIC) f=1;
	else if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED) f=2;
	k = TableRows(tab);
	for (i=1:i<=k:i++) {
		v = (tab-->col)-->(i+COL_HSIZE);
		if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i))) continue;
		switch (f) {
			1: if ((v)(entry/100, entry%100) ~= GPR_FAIL) return i;
			2: if (BlkValueCompare(v, entry) == 0) return i;
			default: if (v == entry) return i;
		}
	}
	! print "Giving up^";
	return 0;
];

[ TableLookUpCorr tab col1 col2 lookup_value write_flag write_value cola1 cola2 i j v f;
	if (col1 >= 100) col1=TableFindCol(tab, col1, true);
	if (col2 >= 100) col2=TableFindCol(tab, col2, true);
	cola1 = tab-->col1;
	cola2 = tab-->col2;
	j = cola2-->0;
	f=0;
	if (((tab-->col2)-->1) & TB_COLUMN_ALLOCATED) f=1;
	if (((tab-->col2)-->1) & TB_COLUMN_TOPIC) f=2;
	for (i=1+COL_HSIZE:i<=j:i++) {
		v = cola2-->i;
		if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col2,i-COL_HSIZE))) continue;
		if (f == 1) {
			if (BlkValueCompare(v, lookup_value) ~= 0) continue;
		} else if (f == 2) {
			if ((v)(lookup_value/100, lookup_value%100) == GPR_FAIL) continue;
		} else {
			if (v ~= lookup_value) continue;
		}
		if (write_flag) {
			ForceTableEntryNonBlank(tab,col1,i-COL_HSIZE);
			switch (write_flag) {
				2: cola1-->i = cola1-->i + write_value;
				3: cola1-->i = cola1-->i - write_value;
				default: cola1-->i = write_value;
			}
			rfalse;
		}
		v = cola1-->i;
		if ((v == TABLE_NOVALUE) &&
			(CheckTableEntryIsBlank(tab,col1,i-COL_HSIZE))) continue;
		return v;
	}
	return RunTimeProblem(RTP_TABLE_NOCORR, tab);
];

[ ExistsTableLookUpCorr tab col1 col2 lookup_value cola1 cola2 i j f;
	if (col1 >= 100) col1=TableFindCol(tab, col1, false);
	if (col2 >= 100) col2=TableFindCol(tab, col2, false);
	if (col1*col2 == 0) rfalse;
	cola1 = tab-->col1; cola2 = tab-->col2;
	j = cola2-->0;
	f=0;
	if (((tab-->col2)-->1) & TB_COLUMN_ALLOCATED) f=1;
	if (((tab-->col2)-->1) & TB_COLUMN_TOPIC) f=2;
	for (i=1+COL_HSIZE:i<=j:i++) {
		if (f == 1) {
			if (BlkValueCompare(cola2-->i, lookup_value) ~= 0) continue;
		} else if (f == 2) {
			if ((cola2-->i)(lookup_value/100, lookup_value%100) == GPR_FAIL) continue;
		} else {
			if (cola2-->i ~= lookup_value) continue;
		}
		if ((cola1-->i == TABLE_NOVALUE) &&
			(CheckTableEntryIsBlank(tab,col1,i-COL_HSIZE))) continue;
		rtrue;
	}
	rfalse;
];

[ TableLookUpEntry tab col index write_flag write_value v;
	if (col >= 100) col=TableFindCol(tab, col, true);
	if ((index < 1) || (index > TableRows(tab)))
		return RunTimeProblem(RTP_TABLE_NOROW, tab, index);
	if (write_flag) {
		switch(write_flag) {
			1:	ForceTableEntryNonBlank(tab,col,index);
				(tab-->col)-->(index+COL_HSIZE) = write_value;
			2:	ForceTableEntryNonBlank(tab,col,index);
				(tab-->col)-->(index+COL_HSIZE) =
					((tab-->col)-->(index+COL_HSIZE)) + write_value;
			3:	ForceTableEntryNonBlank(tab,col,index);
				(tab-->col)-->(index+COL_HSIZE) =
					((tab-->col)-->(index+COL_HSIZE)) - write_value;
			4:	ForceTableEntryBlank(tab,col,index);
			5:	ForceTableEntryNonBlank(tab,col,index);
				return ((tab-->col)-->(index+COL_HSIZE));
		}
		rfalse;
	}
	v = ((tab-->col)-->(index+COL_HSIZE));
	if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,index)))
		return RunTimeProblem(RTP_TABLE_NOENTRY, tab, col, index);
	return v;
];

[ ExistsTableLookUpEntry tab col index v;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rfalse;
	if ((index<1) || (index > TableRows(tab))) rfalse;
	v = ((tab-->col)-->(index+COL_HSIZE));
	if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,index)))
		rfalse;
	rtrue;
];

[ TableRowIsBlank tab j k;
	for (k=1:k<=tab-->0:k++) {
		if (((tab-->k)-->(j+COL_HSIZE)) ~= TABLE_NOVALUE) rfalse;
		if (CheckTableEntryIsBlank(tab, k, j) == false) rfalse;
	}
	rtrue;
];

[ TableBlankOutRow tab row k;
	if (tab==0) return RunTimeProblem(RTP_TABLE_NOTABLE, tab);
	for (k=1:k<=tab-->0:k++)
		ForceTableEntryBlank(tab, k, row);
];

[ TableBlankOutColumn tab col n k;
	if (tab==0) return RunTimeProblem(RTP_TABLE_NOTABLE, tab);
	n = TableRows(tab);
	for (k=1:k<=n:k++)
		ForceTableEntryBlank(tab, col, k);
];

[ TableBlankOutAll tab n k;
	if (tab==0) return RunTimeProblem(RTP_TABLE_NOTABLE, tab);
	n = TableRows(tab);
	for (k=1:k<=n:k++)
		TableBlankOutRow(tab, k);
];

[ TableBlankRows tab i j c;
	i = TableRows(tab); !print i, " rows^";
	for (j=1:j<=i:j++)
		if (TableRowIsBlank(tab, j)) c++;
	!print c, " blank^";
	return c;
];

[ TableFilledRows tab;
	return TableRows(tab) - TableBlankRows(tab);
];

[ TableBlankRow tab i j;
	i = TableRows(tab);
	for (j=1:j<=i:j++)
		if (TableRowIsBlank(tab, j)) return j;
	RunTimeProblem(RTP_TABLE_NOMOREBLANKS, tab);
	return i;
];

[ TableRandomRow tab i j k;
	i = TableRows(tab);
	j = TableFilledRows(tab);
	if (j==0) return RunTimeProblem(RTP_TABLE_NOROWS, tab);
	if (j>1) j = random(j);
	for (k=1:k<=i:k++) {
		if (TableRowIsBlank(tab, k) == false) j--;
		if (j==0) return k;
	}
];

[ TableSwapRows tab i j k l v1 v2;
	if (i==j) return;
	l = tab-->0;
	for (k=1:k<=l:k++) {
		v1 = (tab-->k)-->(i+COL_HSIZE);
		v2 = (tab-->k)-->(j+COL_HSIZE);
		(tab-->k)-->(i+COL_HSIZE) = v2;
		(tab-->k)-->(j+COL_HSIZE) = v1;
		if ((v1 == TABLE_NOVALUE) || (v2 == TABLE_NOVALUE))
			TableSwapBlankBits(tab, i, j, k);
	}
];

[ TableCompareRows tab col row1 row2 dir val1 val2 bl1 bl2 f;
	if (col >= 100) col=TableFindCol(tab, col, false);
	val1 = (tab-->col)-->(row1+COL_HSIZE);
	val2 = (tab-->col)-->(row2+COL_HSIZE);
	if (val1 == TABLE_NOVALUE) bl1 = CheckTableEntryIsBlank(tab,col,row1);
	if (val2 == TABLE_NOVALUE) bl2 = CheckTableEntryIsBlank(tab,col,row2);
	if ((val1 == val2) && (bl1 == bl2)) {
		if (val1 ~= TABLE_NOVALUE) return 0;
		if (bl1 == false) return 0;
		! The two entries are both blank:
		if (TableRowIsBlank(tab, row1)) {
		    if (TableRowIsBlank(tab, row2)) return 0;
		    return -1*dir;
		}
		if (TableRowIsBlank(tab, row2)) return dir;
		return 0;
	}
	if (bl1) return dir;
	if (bl2) return -1*dir;
	f = ((tab-->col)-->1);
	if (f & TB_COLUMN_ALLOCATED) {
		if (BlkValueCompare(val2, val1) < 0) return 1;
		return -1;
	} else if (f & TB_COLUMN_SIGNED) {
		if (val1 > val2) return 1;
		return -1;
	} else {
		if (UnsignedCompare(val1, val2) > 0) return 1;
		return -1;
	}
];

[ TableMoveRowDown tab r1 r2 rx k l m v f;
	if (r1==r2) return;
	l = tab-->0;
	for (k=1:k<=l:k++) {
		f = false;
		m = (tab-->k)-->(r1+COL_HSIZE);
		if (m == TABLE_NOVALUE) f = true;
		for (rx=r1:rx<r2:rx++) {
			v = (tab-->k)-->(rx+COL_HSIZE+1);
			(tab-->k)-->(rx+COL_HSIZE) = v;
			if (v == TABLE_NOVALUE) f = true;
		}
		(tab-->k)-->(r2+COL_HSIZE) = m;
		if (f) TableMoveBlankBitsDown(tab, r1, r2, k);
	}
];

[ TableShuffle tab i to;
	TableMoveBlanksToBack(tab, 1, TableRows(tab));
	to = TableFilledRows(tab);
	for (i=2:i<=to:i++) TableSwapRows(tab, i, random(i));
];

[ TableNextRow tab col row dir i k val v dv min_dv min_at signed_arithmetic f;
	if (col >= 100) col=TableFindCol(tab, col, false);
	f = ((tab-->col)-->1);
	if (f & TB_COLUMN_ALLOCATED) RunTimeProblem(RTP_TABLE_CANTRUNTHROUGH, tab);
	signed_arithmetic = f & TB_COLUMN_SIGNED;
	#Iftrue (WORDSIZE == 2);
	if (row == 0) {
		if (signed_arithmetic) {
		    if (dir == 1) val = $8000; else val = $7fff;
		} else {
		    if (dir == 1) val = 0; else val = $ffff;
		}
	} else val = (tab-->col)-->(row+COL_HSIZE);
	if (signed_arithmetic) min_dv = $7fff; else min_dv = $ffff;
	#ifnot; ! WORDSIZE == 4
	if (row == 0) {
		if (signed_arithmetic) {
		    if (dir == 1) val = $80000000; else val = $7fffffff;
		} else {
		    if (dir == 1) val = 0; else val = $ffffffff;
		}
	} else val = (tab-->col)-->(row+COL_HSIZE);
	if (signed_arithmetic) min_dv = $7fffffff; else min_dv = $ffffffff;
	#endif;
	k = TableRows(tab);
	if (dir == 1) {
		for (i=1:i<=k:i++) {
		    v = (tab-->col)-->(i+COL_HSIZE);
		    if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i)))
		    	continue;
		    dv = dir*v;
		    if (signed_arithmetic)
		    f = (((dv > dir*val) || ((v == val) && (i>row))) &&
				  (dv < min_dv));
		    else
		    f = (((UnsignedCompare(dv, dir*val) > 0) || ((v == val) && (i>row))) &&
				  (UnsignedCompare(dv, min_dv) < 0));
		    if (f) { min_dv = dv; min_at = i; }
		}
	} else {
		for (i=k:i>=1:i--) {
		    v = (tab-->col)-->(i+COL_HSIZE);
		    if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i)))
		    	continue;
		    dv = dir*v;
		    if (signed_arithmetic)
		    f = (((dv > dir*val) || ((v == val) && (i<row))) &&
				  (dv < min_dv));
		    else
		    f = (((UnsignedCompare(dv, dir*val) > 0) || ((v == val) && (i<row))) &&
				  (UnsignedCompare(dv, min_dv) < 0));
		    if (f) { min_dv = dv; min_at = i; }
		}
	}
	return min_at;
];

[ TableMoveBlanksToBack tab fromrow torow i fbl lnbl blc;
	if (torow < fromrow) return;
	fbl = 0; lnbl = 0;
	for (i=fromrow: i<=torow: i++)
		if (TableRowIsBlank(tab, i)) {
			if (fbl == 0) fbl = i;
			blc++;
		} else {
			lnbl = i;
		}
	if ((fbl>0) && (lnbl>0) && (fbl < lnbl)) {
		TableMoveRowDown(tab, fbl, lnbl); ! Move first blank just past last nonblank
		TableMoveBlanksToBack(tab, fbl, lnbl-1);
	}
	return torow-blc; ! Final non-blank row
];

[ TableSort tab col dir test_flag algorithm i j k f;
	for (i=1:i<=tab-->0:i++) {
		j = tab-->i; ! Address of column table
		if ((j-->1) & TB_COLUMN_DONTSORTME)
		    return RunTimeProblem(RTP_TABLE_CANTSORT, tab);
	}
	if (col >= 100) col=TableFindCol(tab, col, false);
	k = TableRows(tab);
	k = TableMoveBlanksToBack(tab, 1, k);
	if (test_flag) {
		print "After moving blanks to back:^"; TableColumnDebug(tab, col);
	}

	SetSortDomain(TableSwapRows, TableCompareRows);
	SortArray(tab, col, dir, k, test_flag, algorithm);

	if (test_flag) {
		print "Final state:^"; TableColumnDebug(tab, col);
	}
];

[ PrintTableName T;
	switch(T) {
  TheEmptyTable: print "(the empty table)"; return;
  T0_final_question_options: print "Table of Final Question Options"; return;
  T1_locale_priorities: print "Table of Locale Priorities"; return;
  T2_sample_options: print "Table of Sample Options"; return;
  T3_menu_commands: print "Table of Menu Commands"; return;
  T4_shallow_menu_status: print "Table of Shallow Menu Status"; return;
  T5_deep_menu_status: print "Table of Deep Menu Status"; return;
  T6_sample_hints: print "Table of Sample Hints"; return;
  T8_options: print "Table of Options"; return;
  T9_setting_options: print "Table of Setting Options"; return;
  T10_command_hints: print "Table of Command Hints"; return;
  T11_misdialled_numbers: print "Table of Misdialled Numbers"; return;
  T12_ordinary_status: print "Table of Ordinary Status"; return;
  T14_customer_responses: print "Table 1 - customer responses"; return;
  T15_customer_responses_2: print "Table 2 - customer responses 2"; return;
  T16_first_half_customer_resp: print "Table 4 - first half customer responses 3"; return;
  T17_second_half_customer_res: print "table 5 - second half customer responses 3"; return;
  T18_rollerdex_entries_day: print "table 6 - rollerdex entries day"; return;
  T19_rollerdex_entries_month: print "table 7 - rollerdex entries month"; return;
  T20_rollerdex_entries_days_o: print "table 8 - rollerdex entries days of months"; return;
  T21_drill_order_part_of_mrma: print "table 9 - drill order part of mrmason call"; return;
  T22_chatting_part_of_mrmason: print "table 10 - chatting part of mrmason call"; return;

		default: print "** No such table **";
	}
];

[ TablePrint tab i j k row col v tc kov;
	for (i=1:i<=tab-->0:i++) {
		j = tab-->i; ! Address of column table
		if (((j-->1) & TB_COLUMN_CANEXCHANGE) == 0)
		    rtrue;
	}
	k = TableRows(tab);
	k = TableMoveBlanksToBack(tab, 1, k);
	print "! ", (PrintTableName) tab, " (", k, ")^";
	for (row=1:row<=k:row++) {
		for (col=1:col<=tab-->0:col++) {
			tc = ((tab-->col)-->1) & TB_COLUMN_NUMBER;
			kov = KindAtomic(TC_KOV(tc));
			if (kov == UNKNOWN_TY) kov = NUMBER_TY;
			v = (tab-->col)-->(row+COL_HSIZE);
			if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,row)))
				print "-- ";
			else {
				if (BlkValueWriteToFile(v, kov) == false) print v;
				print " ";
			}
		}
		print "^";
	}
	rfalse;
];

#ifdef TARGET_GLULX;
[ TableRead tab auxf row maxrow col ch v sgn dg j tc kov;
	for (col=1:col<=tab-->0:col++) {
		j = tab-->col; ! Address of column table
		if (((j-->1) & TB_COLUMN_CANEXCHANGE) == 0)
		    return RunTimeProblem(RTP_TABLE_CANTSAVE, tab);
	}
	maxrow = TableRows(tab);
	!print maxrow, " rows available.^";
	for (row=1: row<=maxrow: row++) {
		TableBlankOutRow(tab, row);
	}
	for (row=1: row<=maxrow: row++) {
		!print "Reading row ", row, "^";
		ch = FileIO_GetC(auxf);
		if (ch == '!') {
			while (ch ~= -1 or 10 or 13) ch = FileIO_GetC(auxf);
			while (ch == 10 or 13) ch = FileIO_GetC(auxf);
		}
		for (col=1: col<=tab-->0: col++) {
			if (ch == -1) { row++; jump NoMore; }
			if (ch == 10 or 13) break;
			tc = ((tab-->col)-->1) & TB_COLUMN_NUMBER;
			kov = KindAtomic(TC_KOV(tc));
			if (kov == UNKNOWN_TY) kov = NUMBER_TY;
			!print "tc = ", tc, " kov = ", kov, "^";
			sgn = 1;
			if (ch == '-') {
				ch = FileIO_GetC(auxf);
				if (ch == -1) jump NotTable;
				if (ch == '-') { ch = FileIO_GetC(auxf); jump EntryDone; }
				sgn = -1;
			}
			if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED)
				ForceTableEntryNonBlank(tab, col, row);
			!print "A";
			v = BlkValueReadFromFile(0, 0, -1, kov);
			if (v) {
				if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED)
					v = BlkValueReadFromFile(TableLookUpEntry(tab, col, row),
						auxf, ch, kov);
				else
					v = BlkValueReadFromFile(0, auxf, ch, kov);
				ch = 32;
			} else {
				dg = ch - '0';
				if ((dg < 0) || (dg > 9)) jump NotTable;
				v = dg;
				for (::) {
					ch = FileIO_GetC(auxf);
					dg = ch - '0';
					if ((dg < 0) || (dg > 9)) break;
					v = 10*v + dg;
				}
				v = v*sgn;
			}
			!print "v=", v, " ";
			if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED == 0)
				TableLookUpEntry(tab, col, row, true, v);
			.EntryDone;
			!print "First nd is ", ch, "^";
			while (ch == 9 or 32) ch = FileIO_GetC(auxf);
		}
		while (ch ~= -1 or 10 or 13) {
			if ((ch ~= '-') && (((ch-'0')<0) || ((ch-'0')>9))) jump NotTable;
			if (ch ~= 9 or 32) jump WontFit;
			ch = FileIO_GetC(auxf);
		}
	}
	.NoMore;
	while (ch == 9 or 32 or 10 or 13) ch = FileIO_GetC(auxf);
	if (ch == -1) return;
	.WontFit;
	return RunTimeProblem(RTP_TABLE_WONTFIT, tab);
	.NotTable;
	return RunTimeProblem(RTP_TABLE_BADFILE, tab);
];
#ENDIF; ! TARGET_GLULX

[ PrintRank i j v;
#ifdef RANKING_TABLE;
	L__M(##Score, 3);
	j = TableRows(RANKING_TABLE);
	for (i=j:i>=1:i--)
		if (score >= TableLookUpEntry(RANKING_TABLE, 1, i)) {
		    v = TableLookUpEntry(RANKING_TABLE, 2, i);
		    if (v ofclass String) print (string) v;
		    else v();
		    ".";
		}
#endif;
	".";
];

[ TableColumnDebug tab col k i v;
	if (col >= 100) col=TableFindCol(tab, col, false);
	k = TableRows(tab);
	print "Table col ", col, ": ";
	for (i=1:i<=k:i++) {
		v = (tab-->col)-->(i+COL_HSIZE);
		if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i)))
			print "BLANK ";
		else
			print v, " ";
	}
	print "*^";
];

[ HolderOf o;
	if (InitialSituation-->DONE_INIS == false) return thedark;
	if (o && (o.component_parent)) return o.component_parent;
	if (o && (parent(o))) return parent(o);
	return nothing;
];

[ ParentOf o;
	if (o) o = parent(o);
	return o;
];

[ CoreOf o;
	while (o && (o provides component_parent) && (o.component_parent)) o = o.component_parent;
	return o;
];

[ CoreOfParentOfCoreOf o;
	while (o && (o provides component_parent) && (o.component_parent)) o = o.component_parent;
	if (o) o = parent(o);
	while (o && (o provides component_parent) && (o.component_parent)) o = o.component_parent;
	return o;
];

[ LocationOf o;
	if (~~(O ofclass K1_room or K2_thing)) return nothing;
	if (O ofclass K4_door) return FrontSideOfDoor(O);
	if (O ofclass K7_backdrop) return nothing;
	while (o) {
		if (o ofclass K1_room) return o;
		o = CoreOfParentOfCoreOf(o);
	}
	return nothing;
];

[ CommonAncestor o1 o2 i j;
	o1 = CoreOf(o1);
	o2 = CoreOf(o2);
	
	for (i=o1: i: i = CoreOfParentOfCoreOf(i))
		for (j=o2: j: j = CoreOfParentOfCoreOf(j))
			if (j == i) return j;

	return nothing;
];

[ IndirectlyContains o1 o2;
	if ((o1 == nothing) || (o2 == nothing)) rfalse;
	if ((o1 ofclass K1_room) && (o2 ofclass K4_door)) {
		if (o1 == FrontSideOfDoor(o2)) rtrue;
		if (o1 == BackSideOfDoor(o2)) rtrue;
		rfalse;
	}
	if (o2 ofclass K7_backdrop) rfalse;
	for (o2 = HolderOf(o2) : o2 && o2 ~= thedark : o2 = HolderOf(o2)) if (o2 == o1) rtrue;
	rfalse;
];

[ WhetherIn obj;
	if (obj has enterable) {
		if (IndirectlyContains(obj, player)) rtrue;
		rfalse;
	}
	if (obj ofclass K9_region) return TestRegionalContainment(real_location, obj);
	if (obj ofclass K1_room) {
		if (obj == real_location) rtrue;
		rfalse;
	}
	RunTimeProblem(RTP_NOTINAROOM, obj);
	rfalse;
];

[ ContainerOf A p;
	if (A ofclass K1_room) return A.map_region;
	p = parent(A);
	if (p == nothing) return nothing;
	if (p ofclass K5_container) return p;
	if (p ofclass K1_room) return p;
	if (p ofclass K9_region) return p;
	return nothing;
];

[ TestContainmentRange obj e f;
	if (obj ofclass K9_region) {
		objectloop (f ofclass K1_room && f.map_region == obj)
			if (f > e) return f;
		return nothing;
	}
	if (obj ofclass K5_container or K1_room) {
		if (e == nothing) return child(obj);
		return sibling(e);
	}
	return nothing;
];

[ SupporterOf obj p;
	p = parent(obj);
	if (p == nothing) return nothing;
	if (p ofclass K6_supporter) return p;
	return nothing;
];

[ CarrierOf obj p;
	p = parent(obj);
	if (p && (p ofclass K8_person) && (obj hasnt worn)) return p;
	return nothing;
];

[ WearerOf obj p;
	p = parent(obj);
	if (p && (p ofclass K8_person) && (obj has worn)) return p;
	return nothing;
];

[ OwnerOf obj p;
	p = parent(obj);
	if (p && (p ofclass K8_person)) return p;
	return nothing;
];

[ MakePart P Of First;
	if (parent(P)) remove P; give P ~worn;
	if (Of == nothing) { DetachPart(P); return; }
	if (P.component_parent) DetachPart(P);
	P.component_parent = Of;
	First = Of.component_child;
	Of.component_child = P; P.component_sibling = First;
];

[ DetachPart P From Daddy O;
	Daddy = P.component_parent; P.component_parent = nothing;
	if (Daddy == nothing) { P.component_sibling = nothing; return; }
	if (Daddy.component_child == P) {
		Daddy.component_child = P.component_sibling;
		P.component_sibling = nothing; return;
	}
	for (O = Daddy.component_child: O: O = O.component_sibling)
		if (O.component_sibling == P) {
			O.component_sibling = P.component_sibling;
			P.component_sibling = nothing; return;
		}
];

[ MoveObject F T opt going_mode was;
	if (F == nothing) return RunTimeProblem(RTP_CANTMOVENOTHING);
	if (F ofclass K7_backdrop) {
		if (T ofclass K9_region) {
			give F ~absent; F.found_in = T.regional_found_in;
			if (TestRegionalContainment(LocationOf(player), T)) move F to LocationOf(player);
			else remove F;
			return; }
		return RunTimeProblem(RTP_BACKDROP, F, T);
	}
	if (~~(F ofclass K2_thing)) return RunTimeProblem(RTP_NOTTHING, F, T);
	if (T ofclass K9_region) return RunTimeProblem(RTP_NOTBACKDROP, F, T);
	if (F has worn) {
		give F ~worn;
		if (F in T) return;
	}
	DetachPart(F);
	if (going_mode == false) {
		if (F == player) { PlayerTo(T, opt); return; }
		if ((IndirectlyContains(F, player)) && (LocationOf(player) ~= LocationOf(T))) {
			was = parent(player);
			move player to real_location;
			move F to T;
			PlayerTo(was, true);
			return;
		}
	}
	move F to T;
];

[ RemoveFromPlay F;
	if (F == nothing) return RunTimeProblem(RTP_CANTREMOVENOTHING);
	if (F == player) return RunTimeProblem(RTP_CANTREMOVEPLAYER);
	if (F ofclass K4_door) return RunTimeProblem(RTP_CANTREMOVEDOORS);
	give F ~worn; DetachPart(F);
	if (F ofclass K7_backdrop) give F absent;
	remove F;
];

[ OnStage O set x;
	if (O ofclass K1_room) rfalse;
	if (set < 0) {
		while (metaclass(O) == Object) {
			if (O ofclass K1_room) rtrue;
			if (O ofclass K9_region) rfalse;
			if (O ofclass K4_door) rtrue;
			if (O ofclass K7_backdrop) { if (O has absent) rfalse; rtrue; }
			x = O.component_parent; if (x) { O = x; continue; }
			x = parent(O); if (x) { O = x; continue; }
			rfalse;
		}
	}
	x = OnStage(O, -1);
	if ((x) && (set == false)) RemoveFromPlay(O);
	if ((x == false) && (set)) MoveObject(O, real_location);
	rfalse;
];

[ PlayerTo newplace flag;
	@push actor; actor = player;
    move player to newplace;
    location = LocationOf(newplace);
    real_location = location;
    MoveFloatingObjects();
    SilentlyConsiderLight();
    DivideParagraphPoint();
    if (flag == 0) <Look>;
    if (flag == 1) give location visited;
    if (flag == 2) AbbreviatedRoomDescription();
    @pull actor;
];

[ MoveDuringGoing F T;
	MoveObject(F, T, 0, true);
	if (actor == player) {
		location = LocationOf(player);
		real_location = location;
	}
];

[ FoundEverywhere; rtrue; ];

[ ChangePlayer obj flag i;
	if (~~(obj ofclass K8_person)) return RunTimeProblem(RTP_CANTCHANGE, obj);
	if (~~(OnStage(obj, -1))) return RunTimeProblem(RTP_CANTCHANGEOFFSTAGE, obj);
	if (obj == player) return;

    give player ~concealed;
    if (player has remove_proper) give player ~proper;
    if (player == selfobj) {
    	player.saved_short_name = player.short_name; player.short_name = FORMER__TX;
    }
    player = obj;
    if (player == selfobj) {
    	player.short_name = player.saved_short_name;
    }
    if (player hasnt proper) give player remove_proper; ! when changing out again
    give player concealed proper;

    location = LocationOf(player); real_location = location;
    MoveFloatingObjects();
    SilentlyConsiderLight();
];

[ MoveFloatingObjects i k l m address flag;
    if (real_location == nothing) return;
    objectloop (i) {
        address = i.&found_in;
        if (address ~= 0 && i hasnt absent) {
            if (ZRegion(address-->0) == 2) {
                m = address-->0;
                .TestPropositionally;
                if (m.call(real_location) ~= 0) move i to real_location;
                else remove i;
            }
            else {
                k = i.#found_in;
                for (l=0 : l<k/WORDSIZE : l++) {
                    m = address-->l;
                    if (ZRegion(m) == 2) jump TestPropositionally;
                    if (m == real_location || m in real_location) {
                        if (i notin real_location) move i to real_location;
                        flag = true;
                    }
                }
                if (flag == false) { if (parent(i)) remove i; }
            }
        }
    }
];

[ MoveBackdrop bd D x address;
	if (~~(bd ofclass K7_backdrop)) return RunTimeProblem(RTP_BACKDROPONLY, bd);
	if (bd.#found_in > WORDSIZE) {
		address = bd.&found_in;
		address-->0 = D;
	} else bd.found_in = D;
	give bd ~absent;
	MoveFloatingObjects();
];

[ WearObject X P opt;
	if (X == false) rfalse;
	if (X notin P) MoveObject(X, P, opt);
	give X worn;
];

[ MapConnection from_room dir
	in_direction through_door;
	if ((from_room ofclass K1_room) && (dir ofclass K3_direction)) {
		in_direction = Map_Storage-->
			((from_room.IK1_Count)*No_Directions + dir.IK3_Count);
		if (in_direction ofclass K1_room) return in_direction;
		if (in_direction ofclass K4_door) {
			@push location;
			location = from_room;
			through_door = in_direction.door_to();
			@pull location;
			if (through_door ofclass K1_room) return through_door;
		}
	}
	return nothing;
];

[ DoorFrom obj dir rv;
	rv = RoomOrDoorFrom(obj, dir);
	if (rv ofclass K4_door) return rv;
	return nothing;
];

[ RoomOrDoorFrom obj dir use_doors in_direction sl through_door;
	if ((obj ofclass K1_room) && (dir ofclass K3_direction)) {
		in_direction = Map_Storage-->
			((obj.IK1_Count)*No_Directions + dir.IK3_Count);
		if (in_direction ofclass K1_room or K4_door) return in_direction;	
	}
	return nothing;
];

[ AssertMapConnection r1 dir r2 in_direction;
	SignalMapChange();
	in_direction = Map_Storage-->
		((r1.IK1_Count)*No_Directions + dir.IK3_Count);
	if ((in_direction == 0) || (in_direction ofclass K1_room)) {
		Map_Storage-->((r1.IK1_Count)*No_Directions + dir.IK3_Count) = r2;
		return;
	}
	if (in_direction ofclass K4_door) {
		RunTimeProblem(RTP_EXITDOOR, r1, dir);
		return;
	}
	RunTimeProblem(RTP_NOEXIT, r1, dir);
];

[ AssertMapUnconnection r1 dir r2 in_direction;
	SignalMapChange();
	in_direction = Map_Storage-->
		((r1.IK1_Count)*No_Directions + dir.IK3_Count);
	if (r1 ofclass K4_door) {
		RunTimeProblem(RTP_EXITDOOR, r1, dir);
		return;
	}
	if (in_direction == r2)
		Map_Storage-->((r1.IK1_Count)*No_Directions + dir.IK3_Count) = 0;
	return;
];

[ TestAdjacency R1 R2 i row;
	row = (R1.IK1_Count)*No_Directions;
	for (i=0: i<No_Directions: i++, row++)
		if (Map_Storage-->row == R2) rtrue;
	rfalse;
];

[ TestRegionalContainment obj region o;
	if ((obj == nothing) || (region == nothing)) rfalse;
	if (~~(obj ofclass K1_room)) obj = LocationOf(obj);
	if (obj == nothing) rfalse;
	o = obj.map_region;
	while (o) {
		if (o == region) rtrue;
		o = parent(o);
	}
	rfalse;
];

[ FrontSideOfDoor D; if (~~(D ofclass K4_door)) rfalse;
	if (D provides found_in) return (D.&found_in)-->0; ! Two-sided
	return parent(D); ! One-sided
];

[ BackSideOfDoor D; if (~~(D ofclass K4_door)) rfalse;
	if (D provides found_in) return (D.&found_in)-->1; ! Two-sided
	return nothing; ! One-sided
];

[ OtherSideOfDoor D from_room rv;
	if (D ofclass K4_door) {
		@push location;
		location = LocationOf(from_room);
		rv = D.door_to();
		@pull location;
	}
	return rv;
];

[ DirectionDoorLeadsIn D from_room rv dir;
	if (D ofclass K4_door) {
		@push location;
		location = LocationOf(from_room);
		rv = D.door_dir();
		@pull location;
	}
	return rv;
];

[ TestVisibility A B;
	if (~~OffersLight(parent(CoreOf(A)))) rfalse;
	if (suppress_scope_loops) rtrue;
	return TestScope(B, A);
];

[ TestTouchability A B;
	if (TestScope(B,A) == false) rfalse;
	if (ObjectIsUntouchable(B, 1, 0, A)) rfalse;
	rtrue;
];

[ TestConcealment A B;
	if (A ofclass K2_thing && B ofclass K2_thing) {
		particular_possession = B;
		if (CarryOutActivity(DECIDING_CONCEALED_POSSESS_ACT, A)) rtrue;
	}
	rfalse;
];





[ Cond_Token_240 ;
if ((((I120_bed == ContainerOf(player))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_241 ;
if ((((I245_red_car == ContainerOf(player))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_242 ;
if ((((I246_blue_car == ContainerOf(player))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_243 ;
if ((((I247_rainbow_car == ContainerOf(player))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_244 ;
if ((((I248_green_car == ContainerOf(player))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_245 ;
if ((((I234_ferrari_enzo == ContainerOf(player))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_246 ;
if ((((I233_car == ContainerOf(player))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_247 ;
if ((((I249_elevator == ContainerOf(player))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_248 ;
if ((((I249_elevator == ContainerOf(player))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_249 ;
if ((((I249_elevator == ContainerOf(player))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_250 ;
if ((((I249_elevator == ContainerOf(player))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_360 ;
if (((((Global_Vars-->72) == T17_second_half_customer_res)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_188 ;
if (((((Global_Vars-->25) == 1)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_189 ;
if (((((Global_Vars-->25) == 1)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_181 ;
if (((((Global_Vars-->25) == 1)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_182 ;
if (((((Global_Vars-->25) == 1)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_183 ;
if (((((Global_Vars-->25) == 1)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_381 ;
if (((((Global_Vars-->72) == T21_drill_order_part_of_mrma)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_184 ;
if (((((Global_Vars-->25) == 1)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_178 ;
if (((((Global_Vars-->25) == 1)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_179 ;
if (((((Global_Vars-->25) == 1)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_180 ;
if (((((Global_Vars-->25) == 1)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_357 ;
if (((((Global_Vars-->72) == T17_second_half_customer_res)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_253 ;
if ((((SupporterOf(player) ofclass K40_broom)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_286 ;
if ((((SupporterOf(player) ofclass K40_broom)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_185 ;
if (((((Global_Vars-->25) == 1)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_186 ;
if (((((Global_Vars-->25) == 1)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_355 ;
if ((((real_location == I254_work_office)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_372 ;
if (((((Global_Vars-->71) == 1)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_389 ;
if (((((Global_Vars-->72) == T22_chatting_part_of_mrmason)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_397 ;
if (((((Global_Vars-->1) == SC_255)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_384 ;
if (((((Global_Vars-->72) == T21_drill_order_part_of_mrma)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_279 ;
if (((Prop_77()))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_281 ;
if (((Prop_78()))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_282 ;
if (((Prop_79()))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_324 ;
if ((((I233_car == ContainerOf(player))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_356 ;
if (((((Global_Vars-->72) == T17_second_half_customer_res)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_358 ;
if (((((Global_Vars-->72) == T17_second_half_customer_res)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_380 ;
if (((((Global_Vars-->72) == T21_drill_order_part_of_mrma)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_359 ;
if (((((Global_Vars-->72) == T17_second_half_customer_res)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_361 ;
if (((((Global_Vars-->72) == T17_second_half_customer_res)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_382 ;
if (((((Global_Vars-->72) == T21_drill_order_part_of_mrma)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_383 ;
if (((((Global_Vars-->72) == T21_drill_order_part_of_mrma)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_385 ;
if (((((Global_Vars-->72) == T21_drill_order_part_of_mrma)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_386 ;
if (((((Global_Vars-->72) == T21_drill_order_part_of_mrma)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_387 ;
if (((((Global_Vars-->72) == T21_drill_order_part_of_mrma)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_388 ;
if (((((Global_Vars-->72) == T21_drill_order_part_of_mrma)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Mistake_Token_393;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 493;
    return GPR_PREPOSITION;
];
[ Mistake_Token_394;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 494;
    return GPR_PREPOSITION;
];
[ Mistake_Token_395;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 495;
    return GPR_PREPOSITION;
];
[ Mistake_Token_396;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 496;
    return GPR_PREPOSITION;
];
[ Cond_Token_400 ;
if (((((Adj_38_t1_v9(I288_shop_attendant)))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_401 ;
if (((((Adj_38_t1_v9(I288_shop_attendant)))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_438 ;
if ((((GProperty(SCENE_TY, I92_uncle_vernon_s_scene,p80_venture) == I268_incomplete)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_439 ;
if ((((GProperty(SCENE_TY, I92_uncle_vernon_s_scene,p80_venture) == I268_incomplete)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_440 ;
if ((((GProperty(SCENE_TY, I92_uncle_vernon_s_scene,p80_venture) == I268_incomplete)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_441 ;
if ((((GProperty(SCENE_TY, I92_uncle_vernon_s_scene,p80_venture) == I268_incomplete)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_442 ;
if ((((GProperty(SCENE_TY, I92_uncle_vernon_s_scene,p80_venture) == I268_incomplete)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_443 ;
if ((((GProperty(SCENE_TY, I92_uncle_vernon_s_scene,p80_venture) == I268_incomplete)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_444 ;
if ((((GProperty(SCENE_TY, I92_uncle_vernon_s_scene,p80_venture) == I268_incomplete)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_445 ;
if ((((GProperty(SCENE_TY, I92_uncle_vernon_s_scene,p80_venture) == I268_incomplete)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_446 ;
if ((((GProperty(SCENE_TY, I92_uncle_vernon_s_scene,p80_venture) == I268_incomplete)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_447 ;
if ((((GProperty(SCENE_TY, I92_uncle_vernon_s_scene,p80_venture) == I268_incomplete)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_448 ;
if ((((GProperty(SCENE_TY, I92_uncle_vernon_s_scene,p80_venture) == I268_incomplete)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];



[ DECIMAL_TOKEN wnc wna r n wa wl sign base digit digit_count original_wn group_wn;
	wnc = wn; original_wn = wn; group_wn = wn;

	wn = wnc;
	r = ParseTokenStopped(ELEMENTARY_TT, NUMBER_TOKEN);
	if ((r == GPR_NUMBER) && (parsed_number ~= 10000)) return r;
	wn = wnc;
	wa = WordAddress(wn);
	wl = WordLength(wn);
	sign = 1; base = 10; digit_count = 0;
	if (wa->0 ~= '-' or '$' or '0' or '1' or '2' or '3' or '4'
		or '5' or '6' or '7' or '8' or '9')
		return GPR_FAIL;
	if (wa->0 == '-') { sign = -1; wl--; wa++; }
	if (wl == 0) return GPR_FAIL;
	n = 0;
	while (wl > 0) {
		if (wa->0 >= 'a') digit = wa->0 - 'a' + 10;
		else digit = wa->0 - '0';
		digit_count++;
		switch (base) {
			2:  if (digit_count == 17) return GPR_FAIL;
			10:
				#Iftrue (WORDSIZE == 2);
				if (digit_count == 6) return GPR_FAIL;
				if (digit_count == 5) {
					if (n > 3276) return GPR_FAIL;
					if (n == 3276) {
						if (sign == 1 && digit > 7) return GPR_FAIL;
						if (sign == -1 && digit > 8) return GPR_FAIL;
					}
				}
				#Ifnot; ! i.e., if (WORDSIZE == 4)
				if (digit_count == 11) return GPR_FAIL;
				if (digit_count == 10) {
					if (n > 214748364) return GPR_FAIL;
					if (n == 214748364) {
						if (sign == 1 && digit > 7) return GPR_FAIL;
						if (sign == -1 && digit > 8) return GPR_FAIL;
					}
				}
				#Endif; 
			16: if (digit_count == 5) return GPR_FAIL;
		}
		if (digit >= 0 && digit < base) n = base*n + digit;
		else return GPR_FAIL;
		wl--; wa++;
	}
	parsed_number = n*sign; wn++;
	return GPR_NUMBER;
];

[ TRUTH_STATE_TOKEN original_wn wd;
	original_wn = wn;

	wn = original_wn;
	wd = NextWordStopped();
	if (wd == 'true') { parsed_number = 1; return GPR_NUMBER; }
	if (wd == 'false') { parsed_number = 0; return GPR_NUMBER; }
	wn = original_wn;
	return GPR_FAIL;
];

[ RoundOffTime t1 t2; return ((t1+t2/2)/t2)*t2; ];

[ SquareRoot num
	op res one;
	op = num;
	if (num < 0) { RunTimeProblem(RTP_NEGATIVEROOT); return 1; }
	! "one" starts at the highest power of four <= the argument.
	for (one = WORD_NEXTTOHIGHBIT: one > op: one = one/4) ;

	while (one ~= 0) {
		!print "Round: op = ", op, " res = ", res, ", res**2 = ", res*res, " one = ", one, "^";
		if (op >= res + one) {
			op = op - res - one;
			res = res + one*2;
		}
		res = res/2;
		one = one/4;
	}
	!print "Res is ", res, "^";
	return res;
];

[ CubeRoot num x y n;
	if (num < 0) x = -SquareRoot(-num); else x = SquareRoot(num);
	for (n=0: (y ~= x) && (n++ < 100): y = x, x = (2*x + num/x/x)/3) ;
	return x;
];

[ PrintTimeOfDay t h aop;
	if (t<0) { print "<no time>"; return; }
	if (t >= TWELVE_HOURS) { aop = "pm"; t = t - TWELVE_HOURS; } else aop = "am";
	h = t/ONE_HOUR; if (h==0) h=12;
	print h, ":";
	if (t%ONE_HOUR < 10) print "0"; print t%ONE_HOUR, " ", (string) aop;
];

[ PrintTimeOfDayEnglish t h m dir aop;
	h = (t/ONE_HOUR) % 12; m = t%ONE_HOUR; if (h==0) h=12;
	if (m==0) { print (number) h, " o'clock"; return; }
	dir = "past";
	if (m > HALF_HOUR) { m = ONE_HOUR-m; h = (h+1)%12; if (h==0) h=12; dir = "to"; }
	switch(m) {
		QUARTER_HOUR: print "quarter"; HALF_HOUR: print "half";
		default: print (number) m;
		    if (m%5 ~= 0) {
				if (m == 1) print " minute"; else print " minutes";
		    }
	}
	print " ", (string) dir, " ", (number) h;
];

[ TIME_TOKEN first_word second_word at length flag
	illegal_char offhour hr mn i original_wn;
	original_wn = wn;

	wn = original_wn;
	first_word = NextWordStopped();
	switch (first_word) {
		'midnight': parsed_number = 0; return GPR_NUMBER;
		'midday', 'noon': parsed_number = TWELVE_HOURS;
		return GPR_NUMBER;
	}
	! Next try the format 12:02
	at = WordAddress(wn-1); length = WordLength(wn-1);
	for (i=0: i<length: i++) {
		switch (at->i) {
			':': if (flag == false && i>0 && i<length-1) flag = true;
			else illegal_char = true;
			'0', '1', '2', '3', '4', '5', '6', '7', '8', '9': ;
			default: illegal_char = true;
		}
	}
	if (length < 3 || length > 5 || illegal_char) flag = false;
	if (flag) {
		for (i=0: at->i~=':': i++, hr=hr*10) hr = hr + at->i - '0';
		hr = hr/10;
		for (i++: i<length: i++, mn=mn*10) mn = mn + at->i - '0';
		mn = mn/10;
		second_word = NextWordStopped();
		parsed_number = HoursMinsWordToTime(hr, mn, second_word);
		if (parsed_number == -1) return GPR_FAIL;
		if (second_word ~= 'pm' or 'am') wn--;
		return GPR_NUMBER;
	}
	! Lastly the wordy format
	offhour = -1;
	if (first_word == 'half') offhour = HALF_HOUR;
	if (first_word == 'quarter') offhour = QUARTER_HOUR;
	if (offhour < 0) offhour = TryNumber(wn-1);
	if (offhour < 0 || offhour >= ONE_HOUR) return GPR_FAIL;
	second_word = NextWordStopped();
	switch (second_word) {
		! "six o'clock", "six"
		'o^clock', 'am', 'pm', -1:
			hr = offhour; if (hr > 12) return GPR_FAIL;
		! "quarter to six", "twenty past midnight"
		'to', 'past':
			mn = offhour; hr = TryNumber(wn);
			if (hr <= 0) {
				switch (NextWordStopped()) {
					'noon', 'midday': hr = 12;
					'midnight': hr = 0;
					default: return GPR_FAIL;
				}
			}
			if (hr >= 13) return GPR_FAIL;
			if (second_word == 'to') {
				mn = ONE_HOUR-mn; hr--; if (hr<0) hr=23;
			}
			wn++; second_word = NextWordStopped();
		! "six thirty"
		default:
			hr = offhour; mn = TryNumber(--wn);
			if (mn < 0 || mn >= ONE_HOUR) return GPR_FAIL;
			wn++; second_word = NextWordStopped();
	}
	parsed_number = HoursMinsWordToTime(hr, mn, second_word);
	if (parsed_number < 0) return GPR_FAIL;
	if (second_word ~= 'pm' or 'am' or 'o^clock') wn--;
	return GPR_NUMBER;
];

[ HoursMinsWordToTime hour minute word x;
	if (hour >= 24) return -1;
	if (minute >= ONE_HOUR) return -1;
	x = hour*ONE_HOUR + minute; if (hour >= 13) return x;
	x = x % TWELVE_HOURS; if (word == 'pm') x = x + TWELVE_HOURS;
	if (word ~= 'am' or 'pm' && hour == 12) x = x + TWELVE_HOURS;
	return x;
];

[ RELATIVE_TIME_TOKEN first_word second_word offhour mult mn original_wn;
	original_wn = wn;
	wn = original_wn;
	
	first_word = NextWordStopped(); wn--;
	if (first_word == 'an' or 'a//') mn=1; else mn=TryNumber(wn);
	
    if (mn == -1000) {
		first_word = NextWordStopped();
		if (first_word == 'half') offhour = HALF_HOUR;
		if (first_word == 'quarter') offhour = QUARTER_HOUR;
		if (offhour > 0) {
			second_word = NextWordStopped();
			if (second_word == 'of') second_word = NextWordStopped();
			if (second_word == 'an') second_word = NextWordStopped();
			if (second_word == 'hour') {
				parsed_number = offhour;
				return GPR_NUMBER;
			}
		}
		return GPR_FAIL;
    }
	wn++;
	
	first_word = NextWordStopped();
	switch (first_word) {
		'minutes', 'minute': mult = 1;
		'hours', 'hour': mult = 60;
		default: return GPR_FAIL;
	}
	parsed_number = mn*mult;
	if (mult == 60) {
		mn=TryNumber(wn);
		if (mn ~= -1000) {
			wn++;
			first_word = NextWordStopped();
			if (first_word == 'minutes' or 'minute')
				parsed_number = parsed_number + mn;
			else wn = wn - 2;
		}
	}
	return GPR_NUMBER;
];

[ DuringSceneMatching prop sc;
	for (sc=0: sc<NUMBER_SCENES_CREATED: sc++)
		if ((scene_status-->sc == 1) && (prop(sc+1))) rtrue;
	rfalse;
];

[ SceneUtility sc task;
	if (sc <= 0) return 0;
	if (task == 1 or 2) {
		if (scene_endings-->(sc-1) == 0) return RunTimeProblem(RTP_SCENEHASNTSTARTED, sc);
	} else {
		if (scene_endings-->(sc-1) <= 1) return RunTimeProblem(RTP_SCENEHASNTENDED, sc);
	}
	switch (task) {
		1: return (the_time - scene_started-->(sc-1))%(TWENTY_FOUR_HOURS);
		2: return scene_started-->(sc-1);
		3: return (the_time - scene_ended-->(sc-1))%(TWENTY_FOUR_HOURS);
		4: return scene_ended-->(sc-1);
	}
];

[ Kind_GPR_10 original_wn group_wn v wpos mid_word matched_number cur_word cur_len cur_addr sgn tot f w rv x;
    original_wn = wn;
    return GPR_FAIL;
];



[ Noun_Filter_0 x;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_3_t1_v9(noun))));
];
[ Scope_Filter_1 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_2 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_3 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_4 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && ((Adj_51_t1_v9(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_5 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_6 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_7 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_8 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_9 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_10 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_11 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K1_room)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Noun_Filter_12 x;
    x=noun;
    return ((noun ofclass K23_wizard_coin));
];
[ Noun_Filter_13 x;
    x=noun;
    return ((noun ofclass K23_wizard_coin));
];
[ Noun_Filter_14 x;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Scope_Filter_15 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Noun_Filter_16 x;
    x=noun;
    return ((noun == I119_bedroomwindow));
];
[ Noun_Filter_17 x;
    x=noun;
    return ((noun == I119_bedroomwindow));
];
[ Noun_Filter_18 x;
    x=noun;
    return ((noun == I121_mirror));
];
[ Noun_Filter_19 x;
    x=noun;
    return ((noun == I229_window));
];
[ Noun_Filter_20 x;
    x=noun;
    return ((noun == I229_window));
];
[ Noun_Filter_21 x;
    x=noun;
    return ((noun == I257_workwindow));
];
[ Noun_Filter_22 x;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_23 x;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Scope_Filter_24 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_25 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_26 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_27 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K1_room)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Noun_Filter_28 x;
    x=noun;
    return ((noun == I236_light_switch));
];
[ Noun_Filter_29 x;
    x=noun;
    return ((noun == I236_light_switch));
];
[ Noun_Filter_30 x;
    x=noun;
    return ((noun == I235_start_button));
];
[ Noun_Filter_31 x;
    x=noun;
    return ((noun == I235_start_button));
];
[ Noun_Filter_32 x;
    x=noun;
    return ((noun == I235_start_button));
];
[ Noun_Filter_33 x;
    x=noun;
    return ((noun == I235_start_button));
];
[ Noun_Filter_34 x;
    x=noun;
    return ((noun == I250_elevatorbutton));
];
[ Noun_Filter_35 x;
    x=noun;
    return ((noun == I250_elevatorbutton));
];
[ Noun_Filter_36 x;
    x=noun;
    return ((noun == I273_rollerdex));
];
[ Noun_Filter_37 x;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_75_t1_v9(noun))));
];
[ Scope_Filter_38 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && ((Adj_32_t1_v9(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_39 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && ((Adj_32_t1_v9(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_40 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && ((Adj_32_t1_v9(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_41 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && ((Adj_32_t1_v9(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_42 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && ((Adj_32_t1_v9(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Noun_Filter_43 x;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_44 x;
    x=noun;
    return ((noun == I119_bedroomwindow));
];
[ Noun_Filter_45 x;
    x=noun;
    return ((noun == I229_window));
];
[ Noun_Filter_46 x;
    x=noun;
    return ((noun == I119_bedroomwindow));
];
[ Noun_Filter_47 x;
    x=noun;
    return ((noun == I229_window));
];
[ Noun_Filter_48 x;
    x=noun;
    return ((noun == I229_window));
];
[ Noun_Filter_49 x;
    x=noun;
    return ((noun == I119_bedroomwindow));
];
[ Scope_Filter_50 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && ((Adj_51_t1_v9(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_51 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_52 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K1_room)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_53 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K1_room)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_54 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K8_person)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Noun_Filter_55 x;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Scope_Filter_56 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && ((Adj_32_t1_v9(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_57 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && ((Adj_32_t1_v9(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_58 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && ((Adj_32_t1_v9(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Noun_Filter_59 x;
    x=noun;
    return ((noun ofclass K8_person));
];
[ Noun_Filter_60 x;
    x=noun;
    return ((noun ofclass K8_person));
];
[ Noun_Filter_61 x;
    x=noun;
    return ((noun ofclass K8_person));
];
[ Noun_Filter_62 x;
    x=noun;
    return ((noun ofclass K8_person));
];
[ Noun_Filter_63 x;
    x=noun;
    return ((noun ofclass K8_person));
];
[ Noun_Filter_64 x;
    x=noun;
    return ((noun ofclass K8_person));
];
[ Noun_Filter_65 x;
    x=noun;
    return ((noun ofclass K8_person));
];
[ Noun_Filter_66 x;
    x=noun;
    return ((noun ofclass K8_person));
];
[ Noun_Filter_67 x;
    x=noun;
    return ((noun ofclass K8_person));
];
[ Noun_Filter_68 x;
    x=noun;
    return ((noun ofclass K8_person));
];
[ Noun_Filter_69 x;
    x=noun;
    return ((noun ofclass K8_person));
];
[ Noun_Filter_70 x;
    x=noun;
    return ((noun ofclass K8_person));
];
[ Noun_Filter_71 x;
    x=noun;
    return ((noun ofclass K8_person));
];
[ Noun_Filter_72 x;
    x=noun;
    return ((noun ofclass K8_person));
];
[ Noun_Filter_73 x;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_74 x;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_75 x;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_76 x;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_77 x;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_78 x;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_79 x;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_80 x;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_81 x;
    x=noun;
    return ((noun == I273_rollerdex));
];
[ Scope_Filter_82 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_83 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_84 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];


#IFDEF DEBUG;
Array TestText_0 ->
    "orion/stats/get up/open drawer/read paper/take paper/open wardrobe/look in mirror/wear muumuu/look in mirror/nw/stats/go up stairs/read diary/read letter/open box/take cookbook/read history/go down stairs/d/n/stats/take broom/look at broom/ride broom/fly s/go through white door/stats/say hello to petunia/eat dudley/eat toast/drink coffee/open fridge/go through white door/e/n/stats/look/w/stats/get off/get in elevator/press button/get out/stats/n/stats/call 893/hello/good/sure/call 8953/try asking for a hal 6502/call 12856/hello/wait/sure/try the hal 6502/try the t1000/try the qz 77/try the bk 44 model t/wait/hmmm.../read dex/flip dex/read dex/call 5552368/take pen/take coin/take coin/write on notepad/write major irrelivancies/s/press button/wait/get in elevator/press button/get out/e/go through shop door/stats/look at shop attendant/look/buy roll/pay coin/eat roll/w/w/go up/n/wait/s/go down/mount broom/e/s/get off broom/w/s/sit down/turn on tv/wait/think/drink tea/look window/get in bed||||";
Array TestReq_0 -->
    0 0;
Array TestText_1 ->
    "orion/gonear carpark/gonear work/call 893/hello/good/call 8953/ask for a t1000/read rolodex/hello/wait/sure/try the t1000/try the hal 6502/try the qz 77/try the bk 44 model t/hmmm.../take coins/s/go down/e/e/buy roll/pay coin/w/w/go up/n/wait/gonear living-room/turn on tv/think/drink tea/look window/get in bed||||";
Array TestReq_1 -->
    0 0;
Array TestText_2 ->
    "try the hal 6502/try the qz 77/try the t1000/try the bk 44 model t||||";
Array TestReq_2 -->
    0 0;

[ XAbstractSub;
    if (XTestMove(noun, second)) return;
    move noun to second;
    "[Abstracted.]";
];

[ XTestMove obj dest;
    if ((obj <= InformLibrary) || (obj == LibraryMessages))
        "[Can't move ", (name) obj, ": it's a system object.]";
    if (obj.component_parent)
        "[Can't move ", (name) obj, ": it's part of ",
        (the) obj.component_parent, ".]";
    while (dest) {
        if (dest == obj) "[Can't move ", (name) obj, ": it would contain itself.]";
        dest = CoreOfParentOfCoreOf(dest);
    }
    rfalse;
];

[ ActionsOnSub; trace_actions = 1; say__p = 1; "Actions listing on."; ];
[ ActionsOffSub; trace_actions = 0; say__p = 1; "Actions listing off."; ];

[ GonearSub;
	PlayerTo(LocationOf(noun));
];

[ XPurloinSub;
    if (XTestMove(noun, player)) return;
    move noun to player; give noun moved ~concealed;
    say__p = 1;
    "[Purloined.]";
];

[ PredictableSub;
    VM_Seed_RNG(-100);
    say__p = 1;
    "[Random number generator now predictable.]";
];

[ ShowRelationsSub;
   IterateRelations(ShowOneRelation);
];

[ ShowOneRelation rel;
   if ((rel-->RR_PERMISSIONS) & (RELS_SHOW)) {
       (rel-->RR_HANDLER)(rel, RELS_SHOW);
   }
];

[ RulesOnSub;
	debug_rules = 1; say__p = 1;
	"Rules tracing now switched on. Type ~rules off~ to switch it off again,
	 or ~rules all~ to include even rules which do not apply.";
];
[ RulesAllSub;
	debug_rules = 2; say__p = 1;
	"Rules tracing now switched to ~all~. Type ~rules off~ to switch it off again.";
];
[ RulesOffSub;
	debug_rules = 0; say__p = 1;
	"Rules tracing now switched off. Type ~rules~ to switch it on again.";
];

[ ScenesOnSub;
	debug_scenes = 1;
	ShowSceneStatus(); say__p = 1;
	"(Scene monitoring now switched on. Type ~scenes off~ to switch it off again.)";
];
[ ScenesOffSub;
	debug_scenes = 0; say__p = 1;
	"(Scene monitoring now switched off. Type ~scenes~ to switch it on again.)";
];

Global x_scope_count;
[ ScopeSub;
    x_scope_count = 0;
    LoopOverScope(Print_ScL, noun);
    if (x_scope_count == 0) "Nothing is in scope.";
];
[ Print_ScL obj; print_ret ++x_scope_count, ": ", (a) obj, " (", obj, ")"; ];

[ ShowHeapSub;
	DebugHeap();
];

[ ShowMeSub t_0 na;
	t_0 = noun;
 	if (noun == nothing) noun = real_location;
 	if (ShowMeRecursively(noun, 0, (noun == real_location))) {
 		if (noun == real_location)
			print "* denotes things which are not in scope^";
	}
 	if (t_0 ofclass K2_thing) {
 		print "location:"; ShowRLocation(noun, true); print "^";
 	}
 	if (t_0) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(pluralname)) && (t_0  has pluralname)) { if (na++ > 0) print ", "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (t_0  hasnt pluralname)) { if (na++ > 0) print ", "; print "singular-named"; }
    if ((AllowInShowme(proper)) && (t_0  has proper)) { if (na++ > 0) print ", "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (t_0  hasnt proper)) { if (na++ > 0) print ", "; print "improper-named"; }
}
if (t_0 ofclass K1_room) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(light)) && (t_0  has light)) { if (na++ > 0) print ", "; print "lighted"; }
    if ((AllowInShowme(light)) && (t_0  hasnt light)) { if (na++ > 0) print ", "; print "dark"; }
    if ((AllowInShowme(visited)) && (t_0  has visited)) { if (na++ > 0) print ", "; print "visited"; }
    if ((AllowInShowme(visited)) && (t_0  hasnt visited)) { if (na++ > 0) print ", "; print "unvisited"; }
    if ((AllowInShowme(p75_posture_friendly)) && (t_0  has p75_posture_friendly)) { if (na++ > 0) print ", "; print "posture-friendly"; }
    if ((AllowInShowme(p75_posture_friendly)) && (t_0  hasnt p75_posture_friendly)) { if (na++ > 0) print ", "; print "posture-unfriendly"; }
}
if (t_0 ofclass K2_thing) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(light)) && (t_0  has light)) { if (na++ > 0) print ", "; print "lit"; }
    if ((AllowInShowme(light)) && (t_0  hasnt light)) { if (na++ > 0) print ", "; print "unlit"; }
    if ((AllowInShowme(edible)) && (t_0  has edible)) { if (na++ > 0) print ", "; print "edible"; }
    if ((AllowInShowme(edible)) && (t_0  hasnt edible)) { if (na++ > 0) print ", "; print "inedible"; }
    if ((AllowInShowme(static)) && (t_0  has static)) { if (na++ > 0) print ", "; print "fixed in place"; }
    if ((AllowInShowme(static)) && (t_0  hasnt static)) { if (na++ > 0) print ", "; print "portable"; }
    if ((AllowInShowme(scenery)) && (t_0  has scenery)) { if (na++ > 0) print ", "; print "scenery"; }
    if ((AllowInShowme(clothing)) && (t_0  has clothing)) { if (na++ > 0) print ", "; print "wearable"; }
    if ((AllowInShowme(pushable)) && (t_0  has pushable)) { if (na++ > 0) print ", "; print "pushable between rooms"; }
    if ((AllowInShowme(moved)) && (t_0  has moved)) { if (na++ > 0) print ", "; print "handled"; }
    if ((AllowInShowme(concealed)) && (t_0  hasnt concealed)) { if (na++ > 0) print ", "; print "described"; }
    if ((AllowInShowme(concealed)) && (t_0  has concealed)) { if (na++ > 0) print ", "; print "undescribed"; }
    if ((AllowInShowme(workflag)) && (t_0  has workflag)) { if (na++ > 0) print ", "; print "marked for listing"; }
    if ((AllowInShowme(workflag)) && (t_0  hasnt workflag)) { if (na++ > 0) print ", "; print "unmarked for listing"; }
    if ((AllowInShowme(mentioned)) && (t_0  has mentioned)) { if (na++ > 0) print ", "; print "mentioned"; }
    if ((AllowInShowme(mentioned)) && (t_0  hasnt mentioned)) { if (na++ > 0) print ", "; print "unmentioned"; }
    if ((AllowInShowme(neuter)) && (t_0  has neuter)) { if (na++ > 0) print ", "; print "neuter"; }
    if ((AllowInShowme(p60_large)) && (t_0  has p60_large)) { if (na++ > 0) print ", "; print "large"; }
    if ((AllowInShowme(p61_small)) && (t_0  has p61_small)) { if (na++ > 0) print ", "; print "small"; }
    if ((AllowInShowme(p62_medium)) && (t_0  has p62_medium)) { if (na++ > 0) print ", "; print "medium"; }
    if ((AllowInShowme(p63_huge)) && (t_0  has p63_huge)) { if (na++ > 0) print ", "; print "huge"; }
    if ((AllowInShowme(p64_ambiguously_plural)) && (t_0  has p64_ambiguously_plural)) { if (na++ > 0) print ", "; print "ambiguously plural"; }
    if ((AllowInShowme(p64_ambiguously_plural)) && (t_0  hasnt p64_ambiguously_plural)) { if (na++ > 0) print ", "; print "ordinarily enumerated"; }
    if ((AllowInShowme(p67_seen)) && (t_0  has p67_seen)) { if (na++ > 0) print ", "; print "seen"; }
    if ((AllowInShowme(p67_seen)) && (t_0  hasnt p67_seen)) { if (na++ > 0) print ", "; print "unseen"; }
    if ((AllowInShowme(p69_familiar)) && (t_0  has p69_familiar)) { if (na++ > 0) print ", "; print "familiar"; }
    if ((AllowInShowme(p69_familiar)) && (t_0  hasnt p69_familiar)) { if (na++ > 0) print ", "; print "unfamiliar"; }
}
if (t_0 ofclass K3_direction) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(workflag)) && (t_0  has workflag)) { if (na++ > 0) print ", "; print "marked for listing"; }
    if ((AllowInShowme(workflag)) && (t_0  hasnt workflag)) { if (na++ > 0) print ", "; print "unmarked for listing"; }
}
if (t_0 ofclass K4_door) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(open)) && (t_0  has open)) { if (na++ > 0) print ", "; print "open"; }
    if ((AllowInShowme(open)) && (t_0  hasnt open)) { if (na++ > 0) print ", "; print "closed"; }
    if ((AllowInShowme(openable)) && (t_0  has openable)) { if (na++ > 0) print ", "; print "openable"; }
    if ((AllowInShowme(openable)) && (t_0  hasnt openable)) { if (na++ > 0) print ", "; print "unopenable"; }
    if ((AllowInShowme(lockable)) && (t_0  has lockable)) { if (na++ > 0) print ", "; print "lockable"; }
    if ((AllowInShowme(locked)) && (t_0  has locked)) { if (na++ > 0) print ", "; print "locked"; }
    if ((AllowInShowme(locked)) && (t_0  hasnt locked)) { if (na++ > 0) print ", "; print "unlocked"; }
}
if (t_0 ofclass K5_container) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(enterable)) && (t_0  has enterable)) { if (na++ > 0) print ", "; print "enterable"; }
    if ((AllowInShowme(transparent)) && (t_0  hasnt transparent)) { if (na++ > 0) print ", "; print "opaque"; }
    if ((AllowInShowme(transparent)) && (t_0  has transparent)) { if (na++ > 0) print ", "; print "transparent"; }
    if ((AllowInShowme(open)) && (t_0  has open)) { if (na++ > 0) print ", "; print "open"; }
    if ((AllowInShowme(open)) && (t_0  hasnt open)) { if (na++ > 0) print ", "; print "closed"; }
    if ((AllowInShowme(openable)) && (t_0  has openable)) { if (na++ > 0) print ", "; print "openable"; }
    if ((AllowInShowme(openable)) && (t_0  hasnt openable)) { if (na++ > 0) print ", "; print "unopenable"; }
    if ((AllowInShowme(lockable)) && (t_0  has lockable)) { if (na++ > 0) print ", "; print "lockable"; }
    if ((AllowInShowme(locked)) && (t_0  has locked)) { if (na++ > 0) print ", "; print "locked"; }
    if ((AllowInShowme(locked)) && (t_0  hasnt locked)) { if (na++ > 0) print ", "; print "unlocked"; }
}
if (t_0 ofclass K6_supporter) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(enterable)) && (t_0  has enterable)) { if (na++ > 0) print ", "; print "enterable"; }
}
if (t_0 ofclass K8_person) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(female)) && (t_0  has female)) { if (na++ > 0) print ", "; print "female"; }
    if ((AllowInShowme(female)) && (t_0  hasnt female)) { if (na++ > 0) print ", "; print "male"; }
}
if (t_0 ofclass K13_device) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(on)) && (t_0  has on)) { if (na++ > 0) print ", "; print "switched on"; }
    if ((AllowInShowme(on)) && (t_0  hasnt on)) { if (na++ > 0) print ", "; print "switched off"; }
}
if (t_0 ofclass K29_telephone) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p71_inuse)) && (t_0  has p71_inuse)) { if (na++ > 0) print ", "; print "inuse"; }
}
if (t_0 ofclass K40_broom) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p77_occupied)) && (t_0  has p77_occupied)) { if (na++ > 0) print ", "; print "occupied"; }
}
if (t_0) {if (na > 0) { na = 0; print "^"; }
    print "printed name: "; if (GProperty(OBJECT_TY, t_0, short_name) == EMPTY_TEXT_VALUE) print "none^"; else print "~", (PrintText) GProperty(OBJECT_TY, t_0, short_name), "~", "^";
    print "printed plural name: "; if (GProperty(OBJECT_TY, t_0, plural) == EMPTY_TEXT_VALUE) print "none^"; else print "~", (PrintText) GProperty(OBJECT_TY, t_0, plural), "~", "^";
    print "indefinite article: "; if (GProperty(OBJECT_TY, t_0, article) == EMPTY_TEXT_VALUE) print "none^"; else print "~", (PrintText) GProperty(OBJECT_TY, t_0, article), "~", "^";
}
if (t_0 ofclass K1_room) {if (na > 0) { na = 0; print "^"; }
    print "description: "; if (GProperty(OBJECT_TY, t_0, description) == EMPTY_TEXT_VALUE) print "none^"; else print "~", (PrintText) GProperty(OBJECT_TY, t_0, description), "~", "^";
    if (GProperty(OBJECT_TY, t_0, map_region)) { print "map region: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, map_region), "^";
    }
}
if (t_0 ofclass K2_thing) {if (na > 0) { na = 0; print "^"; }
    print "description: "; if (GProperty(OBJECT_TY, t_0, description) == EMPTY_TEXT_VALUE) print "none^"; else print "~", (PrintText) GProperty(OBJECT_TY, t_0, description), "~", "^";
    print "initial appearance: "; if (GProperty(OBJECT_TY, t_0, initial) == EMPTY_TEXT_VALUE) print "none^"; else print "~", (PrintText) GProperty(OBJECT_TY, t_0, initial), "~", "^";
    if (GProperty(OBJECT_TY, t_0, with_key)) { print "matching key: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, with_key), "^";
    }
    print "cost: "; print (T65) GProperty(OBJECT_TY, t_0, p66_cost), "^";
}
if (t_0 ofclass K3_direction) {if (na > 0) { na = 0; print "^"; }
    if (GProperty(OBJECT_TY, t_0, p9_opposite)) { print "opposite: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, p9_opposite), "^";
    }
}
if (t_0 ofclass K4_door) {if (na > 0) { na = 0; print "^"; }
    if (GProperty(OBJECT_TY, t_0, door_to)) { print "other side: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, door_to), "^";
    }
    print "Openyesno: "; print (DecimalNumber) GProperty(OBJECT_TY, t_0, p13_openyesno), "^";
}
if (t_0 ofclass K5_container) {if (na > 0) { na = 0; print "^"; }
    print "carrying capacity: "; print (DecimalNumber) GProperty(OBJECT_TY, t_0, capacity), "^";
    print "posture: "; print (T74) GProperty(OBJECT_TY, t_0, p73_posture), "^";
}
if (t_0 ofclass K6_supporter) {if (na > 0) { na = 0; print "^"; }
    print "carrying capacity: "; print (DecimalNumber) GProperty(OBJECT_TY, t_0, capacity), "^";
    print "posture: "; print (T74) GProperty(OBJECT_TY, t_0, p73_posture), "^";
}
if (t_0 ofclass K8_person) {if (na > 0) { na = 0; print "^"; }
    print "carrying capacity: "; print (DecimalNumber) GProperty(OBJECT_TY, t_0, capacity), "^";
    if (GProperty(OBJECT_TY, t_0, p72_other_party)) { print "other party: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, p72_other_party), "^";
    }
    print "posture: "; print (T74) GProperty(OBJECT_TY, t_0, p73_posture), "^";
}
if (t_0 ofclass K29_telephone) {if (na > 0) { na = 0; print "^"; }
    print "calling number: "; print (DecimalNumber) GProperty(OBJECT_TY, t_0, p14_calling_number), "^";
    if (GProperty(OBJECT_TY, t_0, p15_owner)) { print "owner: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, p15_owner), "^";
    }
}
if (t_0 ofclass K44_food) {if (na > 0) { na = 0; print "^"; }
    print "foodlevel: "; print (T90) GProperty(OBJECT_TY, t_0, p78_foodlevel), "^";
}
if (t_0 ofclass K45_cup) {if (na > 0) { na = 0; print "^"; }
    print "drinklevel: "; print (T93) GProperty(OBJECT_TY, t_0, p79_drinklevel), "^";
}

];

[ ShowRLocation obj top;
	if (obj ofclass K1_room) return;
	print " ";
	if (parent(obj)) {
		if (obj has worn) print "worn by ";
		else {
			if (parent(obj) has animate) print "carried by ";
			if (parent(obj) has container) print "in ";
			if (parent(obj) ofclass K1_room) print "in ";
			if (parent(obj) has supporter) print "on ";
		}
		print (the) parent(obj);
		ShowRLocation(parent(obj));
	} else {
		if (obj.component_parent) {
			if (top == false) print ", which is ";
			print "part of ", (the) obj.component_parent;
			ShowRLocation(obj.component_parent);
		}
		else print "out of play";
	}
];

[ ShowMeRecursively obj depth f c i k;
	spaces(2*depth);
	if (f && (depth > 0) && (TestScope(obj, player) == false)) { print "*"; c = true; }
	print (name) obj;
	if (depth > 0) {
		if (obj.component_parent) print " (part of ", (name) obj.component_parent, ")";
		if (obj has worn) print " (worn)";
	}
	if (obj provides KD_Count) {
		k = KindHierarchy-->((obj.KD_Count)*2);
		if ((k ~= K2_thing) || (depth==0)) {
			print " - ";
			if (k == K4_door or K5_container) {
				if (obj has transparent) print "transparent ";
				if (obj has locked) print "locked ";
				else if (obj has open) print "open ";
				else print "closed ";
			}
			print (I7_Kind_Name) k;
		}
	}
	print "^";
	if (obj.component_child) c = c | ShowMeRecursively(obj.component_child, depth+2, f);
	if ((depth>0) && (obj.component_sibling))
		c = c | ShowMeRecursively(obj.component_sibling, depth, f);
	if (child(obj)) c = c | ShowMeRecursively(child(obj), depth+2, f);
	if ((depth>0) && (sibling(obj))) c = c | ShowMeRecursively(sibling(obj), depth, f);
	return c;
];

[ AllowInShowme pr;
	if (pr == workflag or concealed or mentioned) rfalse;
	rtrue;
];

[ ShowVerbSub address lines meta i x;
	wn = 2; x = NextWordStopped();
    if (x == 0 || ((x->#dict_par1) & 1) == 0)
        "Try typing ~showverb~ and then the name of a verb.";
    meta = ((x->#dict_par1) & 2)/2;
    i = DictionaryWordToVerbNum(x);
    address = VM_CommandTableAddress(i);
    lines = address->0;
    address++;
    print "Verb ";
    if (meta) print "meta ";
    VM_PrintCommandWords(i);
    new_line;
    if (lines == 0) "has no grammar lines.";
    for (: lines>0 : lines--) {
        address = UnpackGrammarLine(address);
        print "    "; DebugGrammarLine(); new_line;
    }
    ParaContent();
];

[ DebugGrammarLine pcount;
    print " * ";
    for (: line_token-->pcount ~= ENDIT_TOKEN : pcount++) {
        if ((line_token-->pcount)->0 & $10) print "/ ";
        print (DebugToken) line_token-->pcount, " ";
    }
    print "-> ", (DebugAction) action_to_be;
    if (action_reversed) print " reverse";
];

[ DebugToken token;
    AnalyseToken(token);
    switch (found_ttype) {
      ILLEGAL_TT:
        print "<illegal token number ", token, ">";
      ELEMENTARY_TT:
        switch (found_tdata) {
          NOUN_TOKEN:           print "noun";
          HELD_TOKEN:           print "held";
          MULTI_TOKEN:          print "multi";
          MULTIHELD_TOKEN:      print "multiheld";
          MULTIEXCEPT_TOKEN:    print "multiexcept";
          MULTIINSIDE_TOKEN:    print "multiinside";
          CREATURE_TOKEN:       print "creature";
          SPECIAL_TOKEN:        print "special";
          NUMBER_TOKEN:         print "number";
          TOPIC_TOKEN:          print "topic";
          ENDIT_TOKEN:          print "END";
        }
      PREPOSITION_TT:
        print "'", (address) found_tdata, "'";
      ROUTINE_FILTER_TT:
        print "noun=Routine(", found_tdata, ")";
      ATTR_FILTER_TT:
        print (DebugAttribute) found_tdata;
      SCOPE_TT:
        print "scope=Routine(", found_tdata, ")";
      GPR_TT:
        print "Routine(", found_tdata, ")";
    }
];

#Iftrue (3 > 0);

[ TestScriptSub;
	switch(special_word) {
'me//': TestStart(TestText_0, TestReq_0, 1001);
'two//': TestStart(TestText_1, TestReq_1, 311);
'three//': TestStart(TestText_2, TestReq_2, 66);

	default:
		print ">--> The following tests are available:^";
print "'test me'^";
print "'test two'^";
print "'test three'^";

	}
];

#ifdef TARGET_GLULX;
Constant TEST_STACK_SIZE = 128;
#ifnot;
Constant TEST_STACK_SIZE = 48;
#endif;

Array test_stack --> TEST_STACK_SIZE;
Global test_sp = 0;
[ TestStart T R l k;
	if (test_sp >= TEST_STACK_SIZE) ">--> Testing too many levels deep";
	test_stack-->test_sp = T;
	test_stack-->(test_sp+1) = 0;
	test_stack-->(test_sp+3) = l;
	test_sp = test_sp + 4;
	if ((R-->0) && (R-->0 ~= real_location)) {
	     print "(first moving to ", (name) R-->0, ")^";
	     PlayerTo(R-->0, 1);
	}
	k=1;
	while (R-->k) {
	    if (R-->k notin player) {
	        print "(first acquiring ", (the) R-->k, ")^";
	        move R-->k to player;
	    }
	    k++;
	}
	print "(Testing.)^"; say__p = 1;
];
[ TestKeyboardPrimitive a_buffer a_table p i j l spaced ch;
	if (test_sp == 0) {
	    test_stack-->2 = 1;
	    return VM_ReadKeyboard(a_buffer, a_table);
	}
	else {
	    p = test_stack-->(test_sp-4);
	    i = test_stack-->(test_sp-3);
	    l = test_stack-->(test_sp-1);
	    print "[";
	    print test_stack-->2;
	    print "] ";
	    test_stack-->2 = test_stack-->2 + 1;
	    style bold;
	    while ((i < l) && (p->i ~= '/')) {
	    	ch = p->i;
	        if (spaced || (ch ~= ' ')) {
	        	if ((p->i == '[') && (p->(i+1) == '/') && (p->(i+2) == ']')) {
	        		ch = '/'; i = i+2;
	        	}
	            a_buffer->(j+WORDSIZE) = ch;
	            print (char) ch;
	            i++; j++;
	            spaced = true;
	        } else i++;
	    }
	    style roman;
	    print "^";
	    #ifdef TARGET_ZCODE;
	    a_buffer->1 = j;
	    #ifnot; ! TARGET_GLULX
	    a_buffer-->0 = j;
	    #endif;
	    VM_Tokenise(a_buffer, a_table);
	    if (p->i == '/') i++;
	    if (i >= l) {
	        test_sp = test_sp - 4;
	    } else test_stack-->(test_sp-3) = i;
	}
];

#IFNOT;

[ TestScriptSub;
	">--> No test scripts exist for this game.";
];

#ENDIF;

[ TraceOnSub; parser_trace=1; say__p = 1; "[Trace on.]"; ];

[ TraceLevelSub;
    parser_trace = parsed_number; say__p = 1;
    print "[Parser tracing set to level ", parser_trace, ".]^";
];

[ TraceOffSub; parser_trace=0; say__p = 1; "Trace off."; ];

[ XTreeSub i;
    if (noun == 0) {
        objectloop (i)
            if (i ofclass Object && parent(i) == 0) XObj(i);
    }
    else XObj(noun,1);
];

[ XObj obj f;
    if (parent(obj) == 0) print (name) obj; else print (a) obj;
    print " (", obj, ") ";
    if (f == 1 && parent(obj) ~= 0)
        print "(in ", (name) parent(obj), " ", parent(obj), ")";
    new_line;
    if (child(obj) == 0) rtrue;
    if (obj == Class)
        WriteListFrom(child(obj), NEWLINE_BIT+INDENT_BIT+ALWAYS_BIT+NOARTICLE_BIT, 1);
    else
        WriteListFrom(child(obj), NEWLINE_BIT+INDENT_BIT+ALWAYS_BIT+FULLINV_BIT, 1);
];

[ testcommandnoun obj o2;
	switch (scope_stage) {
		1: rtrue; ! allow multiple objects
		2: objectloop (obj)
        	if ((obj ofclass Object) && (obj provides KD_Count))
            	PlaceInScope(obj, true);
        3: print "There seems to be no such object anywhere in the model world.^";
    }
];

Verb meta 'abstract'

    * scope=testcommandnoun 'to' scope=testcommandnoun -> XAbstract;
Verb meta 'actions'

    *                                           -> ActionsOn
    * 'on'                                      -> ActionsOn
    * 'off'                                     -> ActionsOff;
Verb meta 'gonear'

    * scope=testcommandnoun                     -> Gonear;
Verb meta 'purloin'

    * scope=testcommandnoun                     -> XPurloin;
Verb meta 'random'

    *                                           -> Predictable;
Verb meta 'relations'

	*                                           -> ShowRelations;
Verb meta 'rules'

	*                                           -> RulesOn
	* 'all'                                     -> RulesAll
	* 'on'                                      -> RulesOn
	* 'off'                                     -> RulesOff;
Verb meta 'scenes'

	*                                           -> ScenesOn
	* 'on'                                      -> ScenesOn
	* 'off'                                     -> ScenesOff;
Verb meta 'scope'

    *                                           -> Scope
    * scope=testcommandnoun                     -> Scope;
Verb meta 'showheap'

	*                                           -> ShowHeap;
Verb meta 'showme'

	*                                           -> ShowMe
	* scope=testcommandnoun                     -> ShowMe;
Verb meta 'showverb'

    * special                                   -> Showverb;
Verb meta 'test'

	*                                           -> TestScript
	* special                                   -> TestScript;
Verb meta 'trace'

    *                                           -> TraceOn
    * number                                    -> TraceLevel
    * 'on'                                      -> TraceOn
    * 'off'                                     -> TraceOff;
Verb meta 'tree'

    *                                           -> XTree
    * scope=testcommandnoun                     -> XTree;

[ InternalTestCases;
];

#ENDIF; ! DEBUG

! "Include (- ... -)" inclusions with no specified position appear here.


	[ CheckDPMR result sinp1 sinp2 rv;
		sinp1 = inp1; sinp2 = inp2; inp1 = noun; inp2 = second;
		rv = FollowRulebook( 26 );
		inp1 = sinp1; inp2 = sinp2;
		if ((rv) && RulebookSucceeded()) {
			result = ResultOfRule();
			if (result == RBNO_6 ) return 4;
			if (result == RBNO_7 ) return 3;
			if (result == RBNO_8 ) return 2;
			if (result == RBNO_9 ) return 1;
			if (result == RBNO_10 ) return 0;
		}
		return 2;
	];

[ LITTLE_USED_DO_NOTHING_R; rfalse; ];


[ PlugPlural obj;
	SetPronoun('them', obj);
	SetPronoun('it', obj);
];



[ EscDelay key ix;
	while (wait_flag) {
		glk_select(gg_event); 
		ix = HandleGlkEvent(gg_event, 0, gg_arguments);
	}
];

[ WaitDelay key ix;
	glk_request_char_event(gg_mainwin);
	while (wait_flag) {
		glk_select(gg_event); 
		ix = HandleGlkEvent(gg_event, 1, gg_arguments); 
		if (ix >= 0 && gg_event-->0 == 2) { 
			key = gg_event-->2;
			if ((key == $fffffff8) || (key == -6) || (key == 3) || (key == 32)) {
				wait_flag = 0;
			}
		} 
	}
	glk_cancel_char_event(gg_mainwin);  
];



[ KeyPause i; 
	i = VM_KeyChar(); 
	rfalse;
];

[ SPACEPause i;
	while (i ~= 13 or 31 or 32)
	{
		i = VM_KeyChar();	
	}
];

[ GetKey i;
	i = VM_KeyChar(); 
	return i;
];



#ifndef printed_text;
Array printed_text --> 64;
#endif;

[ CenterPrint str depth i j;
	font off;
	i = VM_ScreenWidth();
			VM_PrintToBuffer(printed_text, 63, str);
	j = (i-(printed_text-->0))/2; 
	j = j-1;
	VM_MoveCursorInStatusLine(depth, j);
	print (I7_string) str; 
	font on;
];

[ CenterPrintComplex str i j;
	font off;
	print "^"; 
	i = VM_ScreenWidth();
			VM_PrintToBuffer(printed_text, 63, str);
	j = (i-(printed_text-->0))/2; 
	spaces j-1;
	print (I7_string) str; 
	font on;
];



[ I7ScreenHeight i screen_height;
	i = 0->32;
		  if (screen_height == 0 or 255) screen_height = 18;
		  screen_height = screen_height - 7;
	return screen_height;
];

 

[ DeepStatus depth i screen_width;
    VM_StatusLineHeight(depth);
    screen_width = VM_ScreenWidth();
    #ifdef TARGET_GLULX;
        VM_ClearScreen(1);
    #ifnot;
        style reverse;
        for (i=1:i<depth+1:i++)
        {
             @set_cursor i 1;
             spaces(screen_width);
        } 
    #endif;
]; 

[ I7VM_MoveCursorInStatusLine depth;
	VM_MoveCursorInStatusLine(depth, 1);
];

[ RightAlign depth screen_width o n;
	screen_width = VM_ScreenWidth(); 
	n = (Global_Vars-->44);
	o = screen_width - n;
	VM_MoveCursorInStatusLine(depth, o);
];


[ BeginAction a n s moi notrack rv save1 save2 save3 previous_actor;
	 ChronologyPoint();

	 @push action; @push noun; @push second; @push self; @push multiple_object_item;

	 action = a; noun = n; second = s; self = noun; multiple_object_item = moi;
	 if (action < 4096) { 
		previous_actor = actor;
		rv = ActionPrimitive();
		if (rv == false && RulebookFailed()) {
			save1 = rulechange_stack-->rulechange_sp;
			save2 = rulechange_stack-->(rulechange_sp + 1);
			save3 = rulechange_stack-->(rulechange_sp + 2);  

			actor = previous_actor;
			ProcessRulebook(513);

			rulechange_stack-->rulechange_sp  = save1;
			rulechange_stack-->(rulechange_sp + 1) = save2;
			rulechange_stack-->(rulechange_sp + 2) = save3;
		}
	 }

	 @pull multiple_object_item; @pull self; @pull second; @pull noun; @pull action;

	 if (notrack == false) TrackActions(true, meta);
	 return rv;
]; 




! Request 0: phrase nothing -> nothing
! From the Standard Rules
! To decide if intervened in miscellaneous message:
[ PHR_717_r0 ;
      ! phrase 1
      ! [1: decide on false]
       return 0; 
   rfalse;
];
! Request 1: phrase nothing -> nothing
! From the Standard Rules
! To decide if intervened in miscellaneous list message:
[ PHR_718_r1 ;
      ! phrase 1
      ! [1: decide on false]
       return 0; 
   rfalse;
];
! Request 2: phrase nothing -> nothing
! From the Standard Rules
! To decide if intervened in action message:
[ PHR_719_r2 ;
      ! phrase 1
      ! [1: decide on false]
       return 0; 
   rfalse;
];
! Request 3: phrase nothing -> nothing
! From "Conversation Framework" by Eric Eve
! To reset the interlocutor:
[ PHR_976_r3 ;
      ! phrase 1
      ! [1: now the current interlocutor is nothing]
       (Global_Vars-->36) = nothing; 
   rfalse;
];
! Request 4: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say is-are:
[ PHR_777_r4 ;
      ! phrase 1
      ! [1: say is-are of prior named noun]
      say__p=1;ParaContent(); (PHR_778_r34 ((Global_Vars-->17))); .L_Say391; .L_SayX386;
   rfalse;
];
! Request 5: phrase thing -> nothing
! From "Conversation Framework" by Eric Eve
! To implicitly greet ( character - a thing ):
[ PHR_966_r5 
    t_0 ! Call parameter 'character' = thing
    ;
      ! phrase 1
      ! [1: now the greeting type is implicit]
       (Global_Vars-->37) = I111_implicit; 
      ! phrase 2
      ! [2: try saying hello to the character]
       TryAction(0, player, ##A109_saying_hello_to, t_0, 0);; 
   rfalse;
];
! Request 6: phrase number -> nothing
! From "Real-Time Delays" by Erik Temple
! To wait ( T - a number ) millisecond/milliseconds/ms before continuing , strictly:
[ PHR_1016_r6 
    t_0 ! Call parameter 'T' = number
    phrase_options ! Bitmap of options called with
    ;
      ! phrase 1
      ! [1: if glulx timekeeping is supported begin]
       if (( ( glk_gestalt(gestalt_Timer, 0) ) ))  {
         ! phrase 2
         ! [2: if donotdelay is 0 begin]
          if ((((Global_Vars-->23) == 0)))  {
            ! phrase 3
            ! [3: now the waiting flag is true]
             wait_flag = 1; 
            ! phrase 4
            ! [4: start a t millisecond timer]
             if (glk_gestalt(gestalt_Timer, 0)) glk_request_timer_events(t_0);  
            ! phrase 5
            ! [5: if strictly begin]
             if (phrase_options & 1)  {
               ! phrase 6
               ! [6: wait strictly for the timer flag]
                EscDelay(); 
               ! phrase 7
               ! [7: otherwise]
               } else {

               ! phrase 8
               ! [8: wait for the timer flag]
                WaitDelay(); 
               ! phrase 9
               ! [9: end if]
               }

            ! phrase 10
            ! [10: otherwise]
            } else {

            ! phrase 11
            ! [11: continue the action]
             rfalse; 
            ! phrase 12
            ! [12: end if]
            }

         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 7: phrase nothing -> nothing
! From the Standard Rules
! To say no line break -- running on ( documented at phs_nolinebreak ):
[ PHR_335_r7 ;
      ! phrase 1
      ! [1: do nothing]
       ; 
   rfalse;
];
! Request 8: phrase nothing -> nothing
! From "Telephones" by George Tryfonas
! To end current conversation:
[ PHR_1041_r8 ;
      ! phrase 1
      ! [1: silently try hanging up]
       @push keep_silent; keep_silent=1; TryAction(0, player, ##A114_hanging_up, 0, 0);; @pull keep_silent; 
   rfalse;
];
! Request 9: phrase nothing -> nothing
! to say mason drill specifics:
[ PHR_1201_r9 ;
      ! phrase 1
      ! [1: say ~[if first digit is 1]work with large, tough, unweildy bolts[no line break][otherwise if first digit is 2]work with large, tough, unweildy bolts[no line break][otherwise if first digit is 3]working with small, fiddly screws[no line break][otherwise if first digit is 4]working with small, fiddly screws[no line break][otherwise if first digit is 5]hardiness and ability to withstand impact[no line break][otherwise if first digit is 6]hardiness and ability to withstand impact[no line break][otherwise]its low price[no line break][end if][no line break]?'~]
      say__p=1;
	if (~~(((((Global_Vars-->28) == 1))))) jump L_Say392;
		ParaContent();  print (PrintText) SC_570; ParaContent(); (PHR_335_r7 ());ParaContent(); 
	jump L_SayX387; .L_Say392; if (~~(((((Global_Vars-->28) == 2))))) jump L_Say393;
		ParaContent();  print (PrintText) SC_570; ParaContent(); (PHR_335_r7 ());ParaContent(); 
	jump L_SayX387; .L_Say393; if (~~(((((Global_Vars-->28) == 3))))) jump L_Say394;
		ParaContent();  print (PrintText) SC_571; ParaContent(); (PHR_335_r7 ());ParaContent(); 
	jump L_SayX387; .L_Say394; if (~~(((((Global_Vars-->28) == 4))))) jump L_Say395;
		ParaContent();  print (PrintText) SC_571; ParaContent(); (PHR_335_r7 ());ParaContent(); 
	jump L_SayX387; .L_Say395; if (~~(((((Global_Vars-->28) == 5))))) jump L_Say396;
		ParaContent();  print (PrintText) SC_572; ParaContent(); (PHR_335_r7 ());ParaContent(); 
	jump L_SayX387; .L_Say396; if (~~(((((Global_Vars-->28) == 6))))) jump L_Say397;
		ParaContent();  print (PrintText) SC_572; ParaContent(); (PHR_335_r7 ());
	jump L_SayX387; .L_Say397;
		ParaContent();  print (PrintText) SC_573; ParaContent(); (PHR_335_r7 ());
	.L_Say398; .L_SayX387;
		ParaContent(); (PHR_335_r7 ());ParaContent();  print (PrintText) SC_574;  new_line; .L_Say399; .L_SayX388;
   rfalse;
];
! Request 10: phrase person -> nothing
! From "Postures" by Emily Short
! To decide whether ( N - a person ) can lie here:
[ PHR_1045_r10 
    t_0 ! Call parameter 'N' = person
    ;
      ! phrase 1
      ! [1: if the holder of n is a thing and the holder of n allows reclining begin]
       if (((( (HolderOf(t_0))  ofclass K2_thing))) && ((((Relation_TestVtoV( (HolderOf(t_0)) ,Rel_Record_71,I117_reclining,false))))))  {
         ! phrase 2
         ! [2: yes]
          rtrue; 
         ! phrase 3
         ! [3: end if]
         }

      ! phrase 4
      ! [4: if the location of n is posture-friendly begin]
       if ((((Adj_93_t1_v9( LocationOf(t_0) )))))  {
         ! phrase 5
         ! [5: yes]
          rtrue; 
         ! phrase 6
         ! [6: end if]
         }

      ! phrase 7
      ! [7: no]
       rfalse; 
   rfalse;
];
! Request 11: phrase person -> nothing
! From "Postures" by Emily Short
! To decide whether ( N - a person ) can sit here:
[ PHR_1047_r11 
    t_0 ! Call parameter 'N' = person
    ;
      ! phrase 1
      ! [1: if the holder of n is a thing and the holder of n allows seated begin]
       if (((( (HolderOf(t_0))  ofclass K2_thing))) && ((((Relation_TestVtoV( (HolderOf(t_0)) ,Rel_Record_71,I115_seated,false))))))  {
         ! phrase 2
         ! [2: yes]
          rtrue; 
         ! phrase 3
         ! [3: end if]
         }

      ! phrase 4
      ! [4: if the location of n is posture-friendly begin]
       if ((((Adj_93_t1_v9( LocationOf(t_0) )))))  {
         ! phrase 5
         ! [5: yes]
          rtrue; 
         ! phrase 6
         ! [6: end if]
         }

      ! phrase 7
      ! [7: no]
       rfalse; 
   rfalse;
];
! Request 12: phrase thing -> nothing
! From "Plurality" by Emily Short
! To mark ( target - a thing ) in output:
[ PHR_773_r12 
    t_0 ! Call parameter 'target' = thing
    ;
      ! phrase 1
      ! [1: if the target acts plural or target is the player , mark-future-plural]
       if ((((PHR_776_r33 (t_0)))) || (((t_0 == player)))) {  say__n = 1;   }
      ! phrase 2
      ! [2: otherwise mark-future-singular]
       else {  say__n = 29;   }
      ! phrase 3
      ! [3: now the prior named noun is the target]
       (Global_Vars-->17) = t_0; 
   rfalse;
];
! Request 13: phrase table name -> nothing
! From "Basic Screen Effects" by Emily Short
! To fill the/-- status bar/line with ( selected table - a table-name ):
[ PHR_1082_r13 
    t_0 ! Call parameter 'selected table' = table name
    t_1 ! Local variable e.g. '__n' = number
    t_2 ! Local variable e.g. '__index' = number
    t_3 ! Local variable e.g. '?-1,-1?' = number
    t_4 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: let __n be the number of rows in the selected table]
       t_1 =  TableRows(t_0) ; 
      ! phrase 2
      ! [2: deepen status line to __n rows]
       DeepStatus(t_1); 
      ! phrase 3
      ! [3: let __index be 1]
       t_2 = 1; 
      ! phrase 4
      ! [4: repeat through selected table begin]
       @push ct_0; @push ct_1;
		for (t_3=t_0,t_4=1,ct_0=t_3,ct_1=t_4:
			t_4<=TableRows(t_3):t_4++,ct_0=t_3,ct_1=t_4)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
         ! phrase 5
         ! [5: move cursor to __index]
          I7VM_MoveCursorInStatusLine(t_2); 
         ! phrase 6
         ! [6: say ~[left entry]~]
         say__p=1;ParaContent();  print (PrintText) TableLookUpEntry(ct_0,113,ct_1);  .L_Say400; .L_SayX389;
         ! phrase 7
         ! [7: center central entry at row __index]
          CenterPrint(TableLookUpEntry(ct_0,114,ct_1), t_2); 
         ! phrase 8
         ! [8: right align cursor to __index]
          RightAlign(t_2); 
         ! phrase 9
         ! [9: say ~[right entry]~]
         say__p=1;ParaContent();  print (PrintText) TableLookUpEntry(ct_0,115,ct_1);  .L_Say401; .L_SayX390;
         ! phrase 10
         ! [10: increase __index by 1]
          t_2 = t_2 + 1; 
         ! phrase 11
         ! [11: end repeat]
         }
@pull ct_1; @pull ct_0;
   rfalse;
];
! Request 14: phrase nothing -> nothing
! to say now bannerprinted is 1:
[ PHR_743_r14 ;
      ! phrase 1
      ! [1: now bannerprinted is 1]
       (Global_Vars-->13) = 1; 
   rfalse;
];
! Request 15: phrase number -> snippet
! From "Snippetage" by Dave Robinson
! To decide which snippet is the word at ( N - a number ):
[ PHR_874_r15 
    t_0 ! Call parameter 'N' = number
    ;
      ! phrase 1
      ! [1: decide on the snippet at n of 1]
       return  (100*t_0 + 1) ; 
   return 101;
];
! Request 16: phrase nothing -> nothing
! From "Telephones" by George Tryfonas
! To assign a phone:
[ PHR_1033_r16 
    t_0 ! Local variable e.g. 'current phone' = telephone
    ;
      ! phrase 1
      ! [1: if the player can touch a telephone ( called the current phone ) begin]
       if ((Prop_80() && (t_0=deferred_calling_list-->0, true)))  {
         ! phrase 2
         ! [2: say ~(on [the current phone])[line break]~]
         say__p=1;ParaContent();  print (PrintText) SC_575; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_230; ParaContent();  new_line;  .L_Say402; .L_SayX391;
         ! phrase 3
         ! [3: change the second noun to the current phone]
          second = t_0; 
         ! phrase 4
         ! [4: otherwise]
         } else {

         ! phrase 5
         ! [5: say ~You don't have a phone handy.~]
         say__p=1;ParaContent();  print (PrintText) SC_576;  new_line; .L_Say403; .L_SayX392;
         ! phrase 6
         ! [6: end if]
         }

   rfalse;
];
! Request 17: phrase (object, number) -> nothing
! From the Standard Rules
! To set the/-- locale priority of ( O - an object ) to ( N - a number ):
[ PHR_72_r17 
    t_0 ! Call parameter 'O' = object
    t_1 ! Call parameter 'N' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: if o is a thing begin]
       if (((t_0 ofclass K2_thing)))  {
         ! phrase 2
         ! [2: if n <= 0 , now o is mentioned]
          if (((t_1 <= 0))) {  (Adj_60_t2_v9(t_0));   }
         ! phrase 3
         ! [3: if there is a notable-object of o in the table of locale priorities begin]
          if (( (ExistsTableLookUpCorr(T1_locale_priorities,105,105,t_0)) ))  {
            ! phrase 4
            ! [4: choose row with a notable-object of o in the table of locale priorities]
             ct_0 = T1_locale_priorities; ct_1 = TableRowCorr(ct_0, 105, t_0); 
            ! phrase 5
            ! [5: if n <= 0 , blank out the whole row]
             if (((t_1 <= 0))) {  TableBlankOutRow(ct_0, ct_1);   }
            ! phrase 6
            ! [6: otherwise now the locale description priority entry is n]
             else {  TableLookUpEntry(ct_0,106,ct_1,1,t_1);   }
            ! phrase 7
            ! [7: otherwise]
            } else {

            ! phrase 8
            ! [8: if n is greater than 0 begin]
             if (((t_1 > 0)))  {
               ! phrase 9
               ! [9: choose a blank row in the table of locale priorities]
                ct_0 = T1_locale_priorities; ct_1 = TableBlankRow(ct_0); 
               ! phrase 10
               ! [10: now the notable-object entry is o]
                TableLookUpEntry(ct_0,105,ct_1,1,t_0); 
               ! phrase 11
               ! [11: now the locale description priority entry is n]
                TableLookUpEntry(ct_0,106,ct_1,1,t_1); 
               ! phrase 12
               ! [12: end if]
               }

            ! phrase 13
            ! [13: end if]
            }

         ! phrase 14
         ! [14: end if]
         }

   rfalse;
];
! Request 18: phrase object -> nothing
! From the Standard Rules
! To describe locale for ( O - object ):
[ PHR_71_r18 
    t_0 ! Call parameter 'O' = object
    ;
      ! phrase 1
      ! [1: carry out the printing the locale description activity with o]
       CarryOutActivity(V29_printing_the_locale_desc, t_0); 
   rfalse;
];
! Request 19: phrase nothing -> nothing
! From "Menus" by Emily Short
! To show menu contents:
[ PHR_868_r19 
    t_0 ! Local variable e.g. 'temporary depth' = number
    t_1 ! Local variable e.g. 'temporary menu' = table name
    t_2 ! Local variable e.g. 'temporary title' = text
    t_3 ! Local variable e.g. '__x' = number
    t_4 ! Local variable e.g. '__index' = number
    t_5 ! Local variable e.g. '?-1,-1?' = number
    t_6 ! Local variable e.g. '?-1,-1?' = number
    t_7 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: increase the menu depth by 1]
       (Global_Vars-->18) = (Global_Vars-->18) + 1; 
      ! phrase 2
      ! [2: let temporary depth be the menu depth]
       t_0 = (Global_Vars-->18); 
      ! phrase 3
      ! [3: let temporary menu be the current menu]
       t_1 = (Global_Vars-->21); 
      ! phrase 4
      ! [4: let temporary title be the current menu title]
       t_2 = (Global_Vars-->20); 
      ! phrase 5
      ! [5: let __x be 0]
       t_3 = 0; 
      ! phrase 6
      ! [6: let __index be 0]
       t_4 = 0; 
      ! phrase 7
      ! [7: while __index is not 1 begin]
       while (((~~((t_4 == 1)))))  {
         ! phrase 8
         ! [8: now the current menu is the temporary menu]
          (Global_Vars-->21) = t_1; 
         ! phrase 9
         ! [9: let __n be 0]
          t_5 = 0; 
         ! phrase 10
         ! [10: repeat through current menu begin]
          @push ct_0; @push ct_1;
		for (t_6=(Global_Vars-->21),t_7=1,ct_0=t_6,ct_1=t_7:
			t_7<=TableRows(t_6):t_7++,ct_0=t_6,ct_1=t_7)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
            ! phrase 11
            ! [11: increase __n by 1]
             t_5 = t_5 + 1; 
            ! phrase 12
            ! [12: if title entry is current menu title , now current menu selection is __n]
             if (((TableLookUpEntry(ct_0,107,ct_1) == (Global_Vars-->20)))) {  (Global_Vars-->22) = t_5;   }
            ! phrase 13
            ! [13: end repeat]
            }
@pull ct_1; @pull ct_0;
         ! phrase 14
         ! [14: now the current menu title is the temporary title]
          (Global_Vars-->20) = t_2; 
         ! phrase 15
         ! [15: reprint current menu]
         (PHR_867_r24 ((Global_Vars-->21)));
         ! phrase 16
         ! [16: let __x be the chosen letter]
          t_3 =  GetKey() ; 
         ! phrase 17
         ! [17: if __x is a number listed in the table of menu commands begin]
          if (((true) && ((ct_1=ExistsTableRowCorr(ct_0=T3_menu_commands,111,t_3)))))  {
            ! phrase 18
            ! [18: consider the effect entry]
             ProcessRulebook(TableLookUpEntry(ct_0,112,ct_1)); 
            ! phrase 19
            ! [19: if temporary depth > menu depth begin]
             if (((t_0 > (Global_Vars-->18))))  {
               ! phrase 20
               ! [20: now __index is 1]
                t_4 = 1; 
               ! phrase 21
               ! [21: end if]
               }

            ! phrase 22
            ! [22: end if]
            }

         ! phrase 23
         ! [23: end while]
         }

   rfalse;
];
! Request 20: phrase thing -> nothing
! From "Postures" by Emily Short
! To say in-on ( item - a thing ):
[ PHR_1061_r20 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: if the item is a container , say ~in [the item]~]
       if (((t_0 ofclass K5_container))) { say__p=1;ParaContent();  print (PrintText) SC_577; ParaContent();  print (the) t_0;  .L_Say404; .L_SayX393;  }
      ! phrase 2
      ! [2: otherwise say ~on [the item]~]
       else { say__p=1;ParaContent();  print (PrintText) SC_578; ParaContent();  print (the) t_0;  .L_Say405; .L_SayX394;  }
   rfalse;
];
! Request 21: phrase number -> nothing
! From "HPMenu" by Orion Zymaris
! to say wait ( S - a number ) ms/milliseconds/--:
[ PHR_892_r21 
    t_0 ! Call parameter 'S' = number
    ;
      ! phrase 1
      ! [1: say ~[run paragraph on]~]
      say__p=1;ParaContent();  RunParagraphOn();  .L_Say406; .L_SayX395;
      ! phrase 2
      ! [2: if glulx timekeeping is supported begin]
       if (( ( glk_gestalt(gestalt_Timer, 0) ) ))  {
         ! phrase 3
         ! [3: if donotdelay is 0 begin]
          if ((((Global_Vars-->23) == 0)))  {
            ! phrase 4
            ! [4: wait s ms before continuing]
            (PHR_1016_r6 (t_0));
            ! phrase 5
            ! [5: otherwise]
            } else {

            ! phrase 6
            ! [6: continue the action]
             rfalse; 
            ! phrase 7
            ! [7: end if]
            }

         ! phrase 8
         ! [8: end if]
         }

   rfalse;
];
! Request 22: phrase nothing -> nothing
! to say spark colours:
[ PHR_1326_r22 ;
      ! phrase 1
      ! [1: if the player's command includes ~expelliarmus~ begin]
       if (( (matched_text=SnippetIncludes(Consult_Grammar_336,players_command)) ))  {
         ! phrase 2
         ! [2: say ~blue sparks~]
         say__p=1;ParaContent();  print (PrintText) SC_579;  .L_Say407; .L_SayX396;
         ! phrase 3
         ! [3: otherwise if the player's command includes ~avada kadavra~]
          } else if (( (matched_text=SnippetIncludes(Consult_Grammar_337,players_command)) )) { 
         ! phrase 4
         ! [4: say ~a green jet of light~]
         say__p=1;ParaContent();  print (PrintText) SC_580;  .L_Say408; .L_SayX397;
         ! phrase 5
         ! [5: otherwise if the player's command includes ~expecto patronum~]
          } else if (( (matched_text=SnippetIncludes(Consult_Grammar_338,players_command)) )) { 
         ! phrase 6
         ! [6: say ~a gorilla shaped cloud of mist~]
         say__p=1;ParaContent();  print (PrintText) SC_581;  .L_Say409; .L_SayX398;
         ! phrase 7
         ! [7: otherwise if the player's command includes ~wingardium leviosa~]
          } else if (( (matched_text=SnippetIncludes(Consult_Grammar_339,players_command)) )) { 
         ! phrase 8
         ! [8: say ~white sparks~]
         say__p=1;ParaContent();  print (PrintText) SC_582;  .L_Say410; .L_SayX399;
         ! phrase 9
         ! [9: otherwise]
         } else {

         ! phrase 10
         ! [10: say ~red sparks~]
         say__p=1;ParaContent();  print (PrintText) SC_583;  .L_Say411; .L_SayX400;
         ! phrase 11
         ! [11: end if]
         }

   rfalse;
];
! Request 23: phrase nothing -> nothing
! to say result of spell:
[ PHR_1327_r23 ;
      ! phrase 1
      ! [1: if the player's command includes ~expelliarmus~ begin]
       if (( (matched_text=SnippetIncludes(Consult_Grammar_340,players_command)) ))  {
         ! phrase 2
         ! [2: say ~the wand to shoot out of your hand!~]
         say__p=1;ParaContent();  print (PrintText) SC_584;  new_line; .L_Say412; .L_SayX401;
         ! phrase 3
         ! [3: now magic wand is in the location]
          MoveObject(I342_magic_wand,real_location); 
         ! phrase 4
         ! [4: otherwise if the player's command includes ~avada kadavra~]
          } else if (( (matched_text=SnippetIncludes(Consult_Grammar_341,players_command)) )) { 
         ! phrase 5
         ! [5: say ~the wand to burn a hole in the wall!~]
         say__p=1;ParaContent();  print (PrintText) SC_585;  new_line; .L_Say413; .L_SayX402;
         ! phrase 6
         ! [6: otherwise if the player's command includes ~expecto patronum~]
          } else if (( (matched_text=SnippetIncludes(Consult_Grammar_342,players_command)) )) { 
         ! phrase 7
         ! [7: say ~[unless current interlocutor is nothing][current interlocutor] to jump back[otherwise]no obvious ill effects[end if], while spreading warmth.~]
         say__p=1;
	if (((((Global_Vars-->36) == nothing)))) jump L_Say414;
		ParaContent();  print (PrintShortName) (Global_Vars-->36); ParaContent();  print (PrintText) SC_586; 
	jump L_SayX403; .L_Say414;
		ParaContent();  print (PrintText) SC_587; 
	.L_Say415; .L_SayX403;
		ParaContent();  print (PrintText) SC_588;  new_line; .L_Say416; .L_SayX404;
         ! phrase 8
         ! [8: otherwise if the player's command includes ~wingardium leviosa~]
          } else if (( (matched_text=SnippetIncludes(Consult_Grammar_343,players_command)) )) { 
         ! phrase 9
         ! [9: say ~[a random visible thing which is not worn by the player] to fly into the air, before coming slowly back down.~]
         say__p=1;ParaContent();  print (a)  (Prop_81()) ; ParaContent();  print (PrintText) SC_589;  new_line; .L_Say417; .L_SayX405;
         ! phrase 10
         ! [10: otherwise if the player's command includes ~incendio~]
          } else if (( (matched_text=SnippetIncludes(Consult_Grammar_344,players_command)) )) { 
         ! phrase 11
         ! [11: say ~a fire to start, which you quickly extinguish!~]
         say__p=1;ParaContent();  print (PrintText) SC_590;  new_line; .L_Say418; .L_SayX406;
         ! phrase 12
         ! [12: otherwise if the player's command includes ~xyzzy~]
          } else if (( (matched_text=SnippetIncludes(Consult_Grammar_345,players_command)) )) { 
         ! phrase 13
         ! [13: say ~you to appear in another room.~]
         say__p=1;ParaContent();  print (PrintText) SC_591;  new_line; .L_Say419; .L_SayX407;
         ! phrase 14
         ! [14: now the player is in a random room in dursley's house]
          MoveObject(player, (Prop_82()) ); 
         ! phrase 15
         ! [15: otherwise if the player's command includes ~squiggly wiggly~]
          } else if (( (matched_text=SnippetIncludes(Consult_Grammar_346,players_command)) )) { 
         ! phrase 16
         ! [16: if dudley is in the location begin]
          if (((real_location == ContainerOf(I221_dudley))))  {
            ! phrase 17
            ! [17: say ~Dudley to run squealing around the room.~]
            say__p=1;ParaContent();  print (PrintText) SC_592;  new_line; .L_Say420; .L_SayX408;
            ! phrase 18
            ! [18: otherwise]
            } else {

            ! phrase 19
            ! [19: say ~objects to dance around more energetically than you could ever manage.~]
            say__p=1;ParaContent();  print (PrintText) SC_593;  new_line; .L_Say421; .L_SayX409;
            ! phrase 20
            ! [20: end if]
            }

         ! phrase 21
         ! [21: otherwise]
         } else {

         ! phrase 22
         ! [22: say ~objects to dance around more energetically than you could ever manage~]
         say__p=1;ParaContent();  print (PrintText) SC_594;  .L_Say422; .L_SayX410;
         ! phrase 23
         ! [23: end if]
         }

   rfalse;
];
! Request 24: phrase table name -> nothing
! From "Menus" by Emily Short
! To reprint ( selected menu - a table-name ):
[ PHR_867_r24 
    t_0 ! Call parameter 'selected menu' = table name
    t_1 ! Local variable e.g. '__index' = number
    t_2 ! Local variable e.g. '?-1,-1?' = number
    t_3 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: redraw status line]
       DrawStatusLine(); 
      ! phrase 2
      ! [2: say fixed letter spacing]
      say__p=1;ParaContent();  font off;  .L_Say423; .L_SayX411;
      ! phrase 3
      ! [3: let __index be 1]
       t_1 = 1; 
      ! phrase 4
      ! [4: clear only the main screen]
       VM_ClearScreen(2); 
      ! phrase 5
      ! [5: repeat through selected menu begin]
       @push ct_0; @push ct_1;
		for (t_2=t_0,t_3=1,ct_0=t_2,ct_1=t_3:
			t_3<=TableRows(t_2):t_3++,ct_0=t_2,ct_1=t_3)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
         ! phrase 6
         ! [6: if __index is current menu selection , say ~ >~]
          if (((t_1 == (Global_Vars-->22)))) { say__p=1;ParaContent();  print (PrintText) SC_595;  .L_Say424; .L_SayX412;  }
         ! phrase 7
         ! [7: otherwise say ~  ~]
          else { say__p=1;ParaContent();  print (PrintText) SC_596;  .L_Say425; .L_SayX413;  }
         ! phrase 8
         ! [8: say ~ [title entry][line break]~]
         say__p=1;ParaContent();  print (PrintText) SC_88; ParaContent();  print (PrintText) TableLookUpEntry(ct_0,107,ct_1); ParaContent();  new_line;  .L_Say426; .L_SayX414;
         ! phrase 9
         ! [9: increase __index by 1]
          t_1 = t_1 + 1; 
         ! phrase 10
         ! [10: end repeat]
         }
@pull ct_1; @pull ct_0;
      ! phrase 11
      ! [11: say variable letter spacing]
      say__p=1;ParaContent();  font on;  .L_Say427; .L_SayX415;
   rfalse;
];
! Request 25: phrase nothing -> nothing
! From "Basic Screen Effects" by Emily Short
! To pause the/-- game:
[ PHR_1072_r25 ;
      ! phrase 1
      ! [1: say ~[paragraph break]Please press SPACE to continue.~]
      say__p=1;ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_597;  new_line; .L_Say428; .L_SayX416;
      ! phrase 2
      ! [2: wait for the space key]
       SPACEPause(); 
      ! phrase 3
      ! [3: clear the screen]
       VM_ClearScreen(0); 
   rfalse;
];
! Request 26: phrase table name -> nothing
! From "Menus" by Emily Short
! To say known hints from ( hint booklet - table-name ):
[ PHR_871_r26 
    t_0 ! Call parameter 'hint booklet' = table name
    t_1 ! Local variable e.g. '__index' = number
    t_2 ! Local variable e.g. '?-1,-1?' = number
    t_3 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: let __index be 0]
       t_1 = 0; 
      ! phrase 2
      ! [2: clear only the main screen]
       VM_ClearScreen(2); 
      ! phrase 3
      ! [3: repeat through hint booklet begin]
       @push ct_0; @push ct_1;
		for (t_2=t_0,t_3=1,ct_0=t_2,ct_1=t_3:
			t_3<=TableRows(t_2):t_3++,ct_0=t_2,ct_1=t_3)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
         ! phrase 4
         ! [4: increase __index by 1]
          t_1 = t_1 + 1; 
         ! phrase 5
         ! [5: if there is a used entry begin]
          if (( (ExistsTableLookUpEntry(ct_0,117,ct_1)) ))  {
            ! phrase 6
            ! [6: say ~[__index]/[number of rows in hint booklet]: [hint entry][paragraph break]~]
            say__p=1;ParaContent();  print (say__n=t_1); ParaContent();  print (PrintText) SC_598; ParaContent();  print (say__n= TableRows(t_0) ); ParaContent();  print (PrintText) SC_199; ParaContent();  print (PrintText) TableLookUpEntry(ct_0,116,ct_1); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say429; .L_SayX417;
            ! phrase 7
            ! [7: otherwise]
            } else {

            ! phrase 8
            ! [8: if __index is 1 begin]
             if (((t_1 == 1)))  {
               ! phrase 9
               ! [9: now used entry is turn count]
                TableLookUpEntry(ct_0,117,ct_1,1,turns); 
               ! phrase 10
               ! [10: say ~[__index]/[number of rows in hint booklet]: [hint entry][paragraph break]~]
               say__p=1;ParaContent();  print (say__n=t_1); ParaContent();  print (PrintText) SC_598; ParaContent();  print (say__n= TableRows(t_0) ); ParaContent();  print (PrintText) SC_199; ParaContent();  print (PrintText) TableLookUpEntry(ct_0,116,ct_1); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say430; .L_SayX418;
               ! phrase 11
               ! [11: end if]
               }

            ! phrase 12
            ! [12: end if]
            }

         ! phrase 13
         ! [13: end repeat]
         }
@pull ct_1; @pull ct_0;
      ! phrase 14
      ! [14: say ~Press SPACE to return to the menu or H to reveal another hint.~]
      say__p=1;ParaContent();  print (PrintText) SC_599;  new_line; .L_Say431; .L_SayX419;
   rfalse;
];
! Request 27: phrase table name -> nothing
! From "Menus" by Emily Short
! To say hints from ( hint booklet - table-name ):
[ PHR_872_r27 
    t_0 ! Call parameter 'hint booklet' = table name
    t_1 ! Local variable e.g. '__index' = number
    t_2 ! Local variable e.g. '?-1,-1?' = number
    t_3 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: let __index be 0]
       t_1 = 0; 
      ! phrase 2
      ! [2: clear only the main screen]
       VM_ClearScreen(2); 
      ! phrase 3
      ! [3: repeat through hint booklet begin]
       @push ct_0; @push ct_1;
		for (t_2=t_0,t_3=1,ct_0=t_2,ct_1=t_3:
			t_3<=TableRows(t_2):t_3++,ct_0=t_2,ct_1=t_3)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
         ! phrase 4
         ! [4: increase __index by 1]
          t_1 = t_1 + 1; 
         ! phrase 5
         ! [5: say ~[__index]/[number of rows in hint booklet]: [hint entry][paragraph break]~]
         say__p=1;ParaContent();  print (say__n=t_1); ParaContent();  print (PrintText) SC_598; ParaContent();  print (say__n= TableRows(t_0) ); ParaContent();  print (PrintText) SC_199; ParaContent();  print (PrintText) TableLookUpEntry(ct_0,116,ct_1); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say432; .L_SayX420;
         ! phrase 6
         ! [6: if there is a used entry begin]
          if (( (ExistsTableLookUpEntry(ct_0,117,ct_1)) ))  {
            ! phrase 7
            ! [7: do nothing]
             ; 
            ! phrase 8
            ! [8: otherwise]
            } else {

            ! phrase 9
            ! [9: now used entry is turn count]
             TableLookUpEntry(ct_0,117,ct_1,1,turns); 
            ! phrase 10
            ! [10: say ~Press SPACE to return to the menu[if __index < number of rows in hint booklet] or H to reveal another hint[end if].~]
            say__p=1;ParaContent();  print (PrintText) SC_600; 
	if (~~((((t_1 <  TableRows(t_0) ))))) jump L_Say433;
		ParaContent();  print (PrintText) SC_601; 
	.L_Say433; .L_SayX421;
		ParaContent();  print (PrintText) SC_201;  new_line; .L_Say434; .L_SayX422;
            ! phrase 11
            ! [11: make no decision]
             rfalse; 
            ! phrase 12
            ! [12: end if]
            }

         ! phrase 13
         ! [13: end repeat]
         }
@pull ct_1; @pull ct_0;
      ! phrase 14
      ! [14: say ~Press SPACE to return to the menu[if __index < number of rows in hint booklet] or H to reveal another hint[end if].~]
      say__p=1;ParaContent();  print (PrintText) SC_600; 
	if (~~((((t_1 <  TableRows(t_0) ))))) jump L_Say435;
		ParaContent();  print (PrintText) SC_601; 
	.L_Say435; .L_SayX423;
		ParaContent();  print (PrintText) SC_201;  new_line; .L_Say436; .L_SayX424;
   rfalse;
];
! Request 28: phrase object -> nothing
! From the Standard Rules
! To say contents of ( O - an object ) ( deprecated ) ( documented at phs_contents_dep ):
[ PHR_357_r28 
    t_0 ! Call parameter 'O' = object
    ;
      ! phrase 1
      ! [1: list the contents of o , as a sentence]
       WriteListFrom(child(t_0), 8); 
   rfalse;
];
! Request 29: phrase object -> nothing
! From the Standard Rules
! To say the contents of ( O - an object ) ( deprecated ) ( documented at phs_contents_dep ):
[ PHR_358_r29 
    t_0 ! Call parameter 'O' = object
    ;
      ! phrase 1
      ! [1: list the contents of o , as a sentence , using the definite article]
       WriteListFrom(child(t_0), 264); 
   rfalse;
];
! Request 30: phrase indexed text -> nothing
! To teletype ( text-to-be-printed - an indexed text ):
[ PHR_740_r30 
    t_0 ! Call parameter 'text-to-be-printed' = indexed text
    ;blockv_stack-->(blockv_sp+4) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+3) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+2) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+1) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+0) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_sp = blockv_sp + 5;
    blockv_stack-->(blockv_sp++) = R_SHELL_13(blockv_sp-5,
        t_0
        );
    blockv_sp = blockv_sp - 6;
    BlkFree(blockv_stack-->(blockv_sp+4));
    BlkFree(blockv_stack-->(blockv_sp+3));
    BlkFree(blockv_stack-->(blockv_sp+2));
    BlkFree(blockv_stack-->(blockv_sp+1));
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+5);
];
[ R_SHELL_13 I7BASPL 
    t_0 ! Call parameter 'text-to-be-printed' = indexed text
    t_1 ! Local variable e.g. '?-1,-1?' = number
    ;
      ! phrase 1
      ! [1: repeat with n running from 1 to the number of characters in the text-to-be-printed begin]
       for (t_1=1: t_1<= IT_BlobAccess(t_0, CHR_BLOB) : t_1++)  {
           if (debug_rules>1) print "  [repetition with N set to ", (DecimalNumber) t_1, "]^";
         ! phrase 2
         ! [2: if character number n in the text-to-be-printed is ~[line break]~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+1)), t_0, t_1, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+0)), INDEXED_TEXT_TY, TEXT_TY, ((LocalParking-->0=t_0)*0+(LocalParking-->1=t_1)*0+text_routine_130)))==0)))  {
            ! phrase 3
            ! [3: wait ( current teletype line break delay ) milliseconds before continuing]
            (PHR_1016_r6 ((Global_Vars-->10)));
            ! phrase 4
            ! [4: end if]
            }

         ! phrase 5
         ! [5: if character number n in the text-to-be-printed is ~[paragraph break]~ begin]
          if (((BlkValueCompare( IT_GetBlob((blockv_stack-->(I7BASPL+3)), t_0, t_1, CHR_BLOB) , BlkValueCast((blockv_stack-->(I7BASPL+2)), INDEXED_TEXT_TY, TEXT_TY, ((LocalParking-->0=t_0)*0+(LocalParking-->1=t_1)*0+text_routine_131)))==0)))  {
            ! phrase 6
            ! [6: wait ( current teletype paragraph break delay ) milliseconds before continuing]
            (PHR_1016_r6 ((Global_Vars-->12)));
            ! phrase 7
            ! [7: end if]
            }

         ! phrase 8
         ! [8: say ~[character number N in the text-to-be-printed][run paragraph on]~]
         say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say)  IT_GetBlob((blockv_stack-->(I7BASPL+4)), t_0, t_1, CHR_BLOB) ; ParaContent();  RunParagraphOn();  .L_Say437; .L_SayX425;
         ! phrase 9
         ! [9: wait ( current teletype character delay ) milliseconds before continuing , strictly]
         (PHR_1016_r6 ((Global_Vars-->11),1));
         ! phrase 10
         ! [10: end repeat]
         }

        if (debug_rules>1) print "  [10: end repeat]^";
   rfalse;
];
! Request 31: phrase (indexed text, number) -> nothing
! To teletype ( text-to-be-printed - an indexed text ) at/with ( speed - a number ) ms/milliseconds/-- delay/--:
[ PHR_741_r31 
    t_0 ! Call parameter 'text-to-be-printed' = indexed text
    t_1 ! Call parameter 'speed' = number
    ;blockv_stack-->(blockv_sp+0) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_sp = blockv_sp + 1;
    blockv_stack-->(blockv_sp++) = R_SHELL_14(blockv_sp-1,
        t_0,
        t_1
        );
    blockv_sp = blockv_sp - 2;
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+1);
];
[ R_SHELL_14 I7BASPL 
    t_0 ! Call parameter 'text-to-be-printed' = indexed text
    t_1 ! Call parameter 'speed' = number
    ;
      ! phrase 1
      ! [1: change the current teletype character delay to the speed]
       (Global_Vars-->11) = t_1; 
      ! phrase 2
      ! [2: teletype the text-to-be-printed]
      (PHR_740_r30 (BlkValueCopy((blockv_stack-->(I7BASPL+0)), t_0)));
   rfalse;
];
! Request 32: phrase number -> nothing
! To say change teletype delay to ( speed - a number ) ms/milliseconds/--:
[ PHR_742_r32 
    t_0 ! Call parameter 'speed' = number
    ;
      ! phrase 1
      ! [1: change the current teletype character delay to speed]
       (Global_Vars-->11) = t_0; 
   rfalse;
];
! Request 33: phrase object -> nothing
! From "Plurality" by Emily Short
! To decide whether ( item - an object ) acts plural:
[ PHR_776_r33 
    t_0 ! Call parameter 'item' = object
    ;
      ! phrase 1
      ! [1: if the item is plural-named or the item is ambiguously plural begin]
       if (((((Adj_36_t1_v9(t_0))))) || ((((Adj_83_t1_v9(t_0))))))  {
         ! phrase 2
         ! [2: yes]
          rtrue; 
         ! phrase 3
         ! [3: end if]
         }

      ! phrase 4
      ! [4: no]
       rfalse; 
   rfalse;
];
! Request 34: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say is-are of ( item - a thing ):
[ PHR_778_r34 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->17) = t_0; 
      ! phrase 2
      ! [2: if prior named noun acts plural or the prior named noun is the player , say ~are~]
       if ((((PHR_776_r33 ((Global_Vars-->17))))) || ((((Global_Vars-->17) == player)))) { say__p=1;ParaContent();  print (PrintText) SC_602;  .L_Say438; .L_SayX426;  }
      ! phrase 3
      ! [3: otherwise say ~is~]
       else { say__p=1;ParaContent();  print (PrintText) SC_603;  .L_Say439; .L_SayX427;  }
   rfalse;
];
! Request 35: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Cap is-are:
[ PHR_779_r35 ;
      ! phrase 1
      ! [1: say is-are of prior named noun]
      say__p=1;ParaContent(); (PHR_782_r38 ((Global_Vars-->17))); .L_Say440; .L_SayX428;
   rfalse;
];
! Request 36: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Cap is-are of ( item - a thing ) ( deprecated ):
[ PHR_780_r36 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->17) = t_0; 
      ! phrase 2
      ! [2: if prior named noun acts plural or the prior named noun is the player , say ~Are~]
       if ((((PHR_776_r33 ((Global_Vars-->17))))) || ((((Global_Vars-->17) == player)))) { say__p=1;ParaContent();  print (PrintText) SC_604;  .L_Say441; .L_SayX429;  }
      ! phrase 3
      ! [3: otherwise say ~Is~]
       else { say__p=1;ParaContent();  print (PrintText) SC_605;  .L_Say442; .L_SayX430;  }
   rfalse;
];
! Request 37: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Is-are:
[ PHR_781_r37 ;
      ! phrase 1
      ! [1: say is-are of prior named noun]
      say__p=1;ParaContent(); (PHR_782_r38 ((Global_Vars-->17))); .L_Say443; .L_SayX431;
   rfalse;
];
! Request 38: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Is-are of ( item - a thing ):
[ PHR_782_r38 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->17) = t_0; 
      ! phrase 2
      ! [2: if prior named noun acts plural or the prior named noun is the player , say ~Are~]
       if ((((PHR_776_r33 ((Global_Vars-->17))))) || ((((Global_Vars-->17) == player)))) { say__p=1;ParaContent();  print (PrintText) SC_604;  .L_Say444; .L_SayX432;  }
      ! phrase 3
      ! [3: otherwise say ~Is~]
       else { say__p=1;ParaContent();  print (PrintText) SC_605;  .L_Say445; .L_SayX433;  }
   rfalse;
];
! Request 39: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say has-have:
[ PHR_783_r39 ;
      ! phrase 1
      ! [1: say has-have of prior named noun]
      say__p=1;ParaContent(); (PHR_784_r40 ((Global_Vars-->17))); .L_Say446; .L_SayX434;
   rfalse;
];
! Request 40: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say has-have of ( item - a thing ):
[ PHR_784_r40 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: if the item acts plural or the item is the player begin]
       if ((((PHR_776_r33 (t_0)))) || (((t_0 == player))))  {
         ! phrase 2
         ! [2: say ~have~]
         say__p=1;ParaContent();  print (PrintText) SC_606;  .L_Say447; .L_SayX435;
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~has~]
         say__p=1;ParaContent();  print (PrintText) SC_607;  .L_Say448; .L_SayX436;
         ! phrase 5
         ! [5: end if]
         }

   rfalse;
];
! Request 41: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Has-have of ( item - a thing ):
[ PHR_785_r41 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: if the item acts plural or the item is the player begin]
       if ((((PHR_776_r33 (t_0)))) || (((t_0 == player))))  {
         ! phrase 2
         ! [2: say ~Have~]
         say__p=1;ParaContent();  print (PrintText) SC_608;  .L_Say449; .L_SayX437;
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~Has~]
         say__p=1;ParaContent();  print (PrintText) SC_609;  .L_Say450; .L_SayX438;
         ! phrase 5
         ! [5: end if]
         }

   rfalse;
];
! Request 42: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Has-have:
[ PHR_786_r42 ;
      ! phrase 1
      ! [1: say has-have of prior named noun]
      say__p=1;ParaContent(); (PHR_785_r41 ((Global_Vars-->17))); .L_Say451; .L_SayX439;
   rfalse;
];
! Request 43: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say 's-'re of ( item - a thing ):
[ PHR_787_r43 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->17) = t_0; 
      ! phrase 2
      ! [2: if the item acts plural or the item is the player begin]
       if ((((PHR_776_r33 (t_0)))) || (((t_0 == player))))  {
         ! phrase 3
         ! [3: say ~[']re~]
         say__p=1;ParaContent();  print "'"; ParaContent();  print (PrintText) SC_610;  .L_Say452; .L_SayX440;
         ! phrase 4
         ! [4: otherwise]
         } else {

         ! phrase 5
         ! [5: say ~[']s~]
         say__p=1;ParaContent();  print "'"; ParaContent();  print (PrintText) SC_611;  .L_Say453; .L_SayX441;
         ! phrase 6
         ! [6: end if]
         }

   rfalse;
];
! Request 44: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say 's-'re:
[ PHR_788_r44 ;
      ! phrase 1
      ! [1: say 's-'re of the prior named noun]
      say__p=1;ParaContent(); (PHR_787_r43 ((Global_Vars-->17))); .L_Say454; .L_SayX442;
   rfalse;
];
! Request 45: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say es:
[ PHR_794_r45 ;
      ! phrase 1
      ! [1: say es of prior named noun]
      say__p=1;ParaContent(); (PHR_795_r46 ((Global_Vars-->17))); .L_Say455; .L_SayX443;
   rfalse;
];
! Request 46: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say es of ( item - a thing ):
[ PHR_795_r46 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: if the item acts plural or the item is the player begin]
       if ((((PHR_776_r33 (t_0)))) || (((t_0 == player))))  {
         ! phrase 2
         ! [2: say ~~]
         say__p=1;ParaContent();  print (PrintText) EMPTY_TEXT_VALUE;  .L_Say456; .L_SayX444;
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~es~]
         say__p=1;ParaContent();  print (PrintText) SC_517;  .L_Say457; .L_SayX445;
         ! phrase 5
         ! [5: end if]
         }

   rfalse;
];
! Request 47: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say ies:
[ PHR_796_r47 ;
      ! phrase 1
      ! [1: say ies of prior named noun]
      say__p=1;ParaContent(); (PHR_797_r48 ((Global_Vars-->17))); .L_Say458; .L_SayX446;
   rfalse;
];
! Request 48: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say ies of ( item - a thing ):
[ PHR_797_r48 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: if the item acts plural or the item is the player begin]
       if ((((PHR_776_r33 (t_0)))) || (((t_0 == player))))  {
         ! phrase 2
         ! [2: say ~y~]
         say__p=1;ParaContent();  print (PrintText) SC_612;  .L_Say459; .L_SayX447;
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~ies~]
         say__p=1;ParaContent();  print (PrintText) SC_613;  .L_Say460; .L_SayX448;
         ! phrase 5
         ! [5: end if]
         }

   rfalse;
];
! Request 49: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say that-those:
[ PHR_798_r49 ;
      ! phrase 1
      ! [1: say that-those prior named noun]
      say__p=1;ParaContent(); (PHR_802_r53 ((Global_Vars-->17))); .L_Say461; .L_SayX449;
   rfalse;
];
! Request 50: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Cap that-those ( deprecated ):
[ PHR_799_r50 ;
      ! phrase 1
      ! [1: say that-those prior named noun]
      say__p=1;ParaContent(); (PHR_803_r54 ((Global_Vars-->17))); .L_Say462; .L_SayX450;
   rfalse;
];
! Request 51: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say That-those:
[ PHR_800_r51 ;
      ! phrase 1
      ! [1: say that-those prior named noun]
      say__p=1;ParaContent(); (PHR_803_r54 ((Global_Vars-->17))); .L_Say463; .L_SayX451;
   rfalse;
];
! Request 52: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Cap that-those ( item - a thing ) ( deprecated ):
[ PHR_801_r52 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->17) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_773_r12 ((Global_Vars-->17)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_776_r33 (t_0))))  {
         ! phrase 4
         ! [4: say ~Those~]
         say__p=1;ParaContent();  print (PrintText) SC_614;  .L_Say464; .L_SayX452;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~You~]
         say__p=1;ParaContent();  print (PrintText) SC_615;  .L_Say465; .L_SayX453;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_73_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~He~]
         say__p=1;ParaContent();  print (PrintText) SC_616;  .L_Say466; .L_SayX454;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_72_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~She~]
         say__p=1;ParaContent();  print (PrintText) SC_617;  .L_Say467; .L_SayX455;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~That~]
         say__p=1;ParaContent();  print (PrintText) SC_618;  .L_Say468; .L_SayX456;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 53: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say that-those ( item - a thing ):
[ PHR_802_r53 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->17) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_773_r12 ((Global_Vars-->17)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_776_r33 (t_0))))  {
         ! phrase 4
         ! [4: say ~those~]
         say__p=1;ParaContent();  print (PrintText) SC_619;  .L_Say469; .L_SayX457;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~you~]
         say__p=1;ParaContent();  print (PrintText) SC_620;  .L_Say470; .L_SayX458;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_73_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~he~]
         say__p=1;ParaContent();  print (PrintText) SC_621;  .L_Say471; .L_SayX459;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_72_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~she~]
         say__p=1;ParaContent();  print (PrintText) SC_622;  .L_Say472; .L_SayX460;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~that~]
         say__p=1;ParaContent();  print (PrintText) SC_623;  .L_Say473; .L_SayX461;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 54: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say That-those ( item - a thing ):
[ PHR_803_r54 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->17) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_773_r12 ((Global_Vars-->17)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_776_r33 (t_0))))  {
         ! phrase 4
         ! [4: say ~Those~]
         say__p=1;ParaContent();  print (PrintText) SC_614;  .L_Say474; .L_SayX462;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~You~]
         say__p=1;ParaContent();  print (PrintText) SC_615;  .L_Say475; .L_SayX463;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_73_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~He~]
         say__p=1;ParaContent();  print (PrintText) SC_616;  .L_Say476; .L_SayX464;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_72_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~She~]
         say__p=1;ParaContent();  print (PrintText) SC_617;  .L_Say477; .L_SayX465;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~That~]
         say__p=1;ParaContent();  print (PrintText) SC_618;  .L_Say478; .L_SayX466;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 55: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Cap that-those of ( item - a thing ) ( deprecated ):
[ PHR_804_r55 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->17) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_773_r12 ((Global_Vars-->17)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_776_r33 (t_0))))  {
         ! phrase 4
         ! [4: say ~Those~]
         say__p=1;ParaContent();  print (PrintText) SC_614;  .L_Say479; .L_SayX467;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~You~]
         say__p=1;ParaContent();  print (PrintText) SC_615;  .L_Say480; .L_SayX468;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_73_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~He~]
         say__p=1;ParaContent();  print (PrintText) SC_616;  .L_Say481; .L_SayX469;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_72_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~She~]
         say__p=1;ParaContent();  print (PrintText) SC_617;  .L_Say482; .L_SayX470;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~That~]
         say__p=1;ParaContent();  print (PrintText) SC_618;  .L_Say483; .L_SayX471;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 56: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say that-those of ( item - a thing ):
[ PHR_805_r56 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->17) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_773_r12 ((Global_Vars-->17)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_776_r33 (t_0))))  {
         ! phrase 4
         ! [4: say ~those~]
         say__p=1;ParaContent();  print (PrintText) SC_619;  .L_Say484; .L_SayX472;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~you~]
         say__p=1;ParaContent();  print (PrintText) SC_620;  .L_Say485; .L_SayX473;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_73_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~he~]
         say__p=1;ParaContent();  print (PrintText) SC_621;  .L_Say486; .L_SayX474;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_72_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~she~]
         say__p=1;ParaContent();  print (PrintText) SC_622;  .L_Say487; .L_SayX475;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~that~]
         say__p=1;ParaContent();  print (PrintText) SC_623;  .L_Say488; .L_SayX476;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 57: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say That-those of ( item - a thing ):
[ PHR_806_r57 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->17) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_773_r12 ((Global_Vars-->17)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_776_r33 (t_0))))  {
         ! phrase 4
         ! [4: say ~Those~]
         say__p=1;ParaContent();  print (PrintText) SC_614;  .L_Say489; .L_SayX477;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~You~]
         say__p=1;ParaContent();  print (PrintText) SC_615;  .L_Say490; .L_SayX478;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_73_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~He~]
         say__p=1;ParaContent();  print (PrintText) SC_616;  .L_Say491; .L_SayX479;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_72_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~She~]
         say__p=1;ParaContent();  print (PrintText) SC_617;  .L_Say492; .L_SayX480;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~That~]
         say__p=1;ParaContent();  print (PrintText) SC_618;  .L_Say493; .L_SayX481;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 58: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say it-they:
[ PHR_807_r58 ;
      ! phrase 1
      ! [1: say it-they of prior named noun]
      say__p=1;ParaContent(); (PHR_808_r59 ((Global_Vars-->17))); .L_Say494; .L_SayX482;
   rfalse;
];
! Request 59: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say it-they of ( item - a thing ):
[ PHR_808_r59 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->17) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_773_r12 ((Global_Vars-->17)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_776_r33 (t_0))))  {
         ! phrase 4
         ! [4: say ~they~]
         say__p=1;ParaContent();  print (PrintText) SC_624;  .L_Say495; .L_SayX483;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~you~]
         say__p=1;ParaContent();  print (PrintText) SC_620;  .L_Say496; .L_SayX484;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_73_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~he~]
         say__p=1;ParaContent();  print (PrintText) SC_621;  .L_Say497; .L_SayX485;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_72_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~she~]
         say__p=1;ParaContent();  print (PrintText) SC_622;  .L_Say498; .L_SayX486;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~it~]
         say__p=1;ParaContent();  print (PrintText) SC_625;  .L_Say499; .L_SayX487;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 60: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Cap it-they ( deprecated ):
[ PHR_809_r60 ;
      ! phrase 1
      ! [1: say it-they of prior named noun]
      say__p=1;ParaContent(); (PHR_812_r63 ((Global_Vars-->17))); .L_Say500; .L_SayX488;
   rfalse;
];
! Request 61: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Cap it-they of ( item - a thing ) ( deprecated ):
[ PHR_810_r61 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->17) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_773_r12 ((Global_Vars-->17)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_776_r33 (t_0))))  {
         ! phrase 4
         ! [4: say ~They~]
         say__p=1;ParaContent();  print (PrintText) SC_626;  .L_Say501; .L_SayX489;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~You~]
         say__p=1;ParaContent();  print (PrintText) SC_615;  .L_Say502; .L_SayX490;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_73_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~He~]
         say__p=1;ParaContent();  print (PrintText) SC_616;  .L_Say503; .L_SayX491;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_72_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~She~]
         say__p=1;ParaContent();  print (PrintText) SC_617;  .L_Say504; .L_SayX492;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~It~]
         say__p=1;ParaContent();  print (PrintText) SC_627;  .L_Say505; .L_SayX493;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 62: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say It-they:
[ PHR_811_r62 ;
      ! phrase 1
      ! [1: say it-they of prior named noun]
      say__p=1;ParaContent(); (PHR_812_r63 ((Global_Vars-->17))); .L_Say506; .L_SayX494;
   rfalse;
];
! Request 63: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say It-they of ( item - a thing ):
[ PHR_812_r63 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->17) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_773_r12 ((Global_Vars-->17)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_776_r33 (t_0))))  {
         ! phrase 4
         ! [4: say ~They~]
         say__p=1;ParaContent();  print (PrintText) SC_626;  .L_Say507; .L_SayX495;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~You~]
         say__p=1;ParaContent();  print (PrintText) SC_615;  .L_Say508; .L_SayX496;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_73_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~He~]
         say__p=1;ParaContent();  print (PrintText) SC_616;  .L_Say509; .L_SayX497;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_72_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~She~]
         say__p=1;ParaContent();  print (PrintText) SC_617;  .L_Say510; .L_SayX498;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~It~]
         say__p=1;ParaContent();  print (PrintText) SC_627;  .L_Say511; .L_SayX499;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 64: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say its-their:
[ PHR_813_r64 ;
      ! phrase 1
      ! [1: say its-their of prior named noun]
      say__p=1;ParaContent(); (PHR_814_r65 ((Global_Vars-->17))); .L_Say512; .L_SayX500;
   rfalse;
];
! Request 65: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say its-their of ( item - a thing ):
[ PHR_814_r65 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->17) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_773_r12 ((Global_Vars-->17)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_776_r33 (t_0))))  {
         ! phrase 4
         ! [4: say ~their~]
         say__p=1;ParaContent();  print (PrintText) SC_628;  .L_Say513; .L_SayX501;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~your~]
         say__p=1;ParaContent();  print (PrintText) SC_629;  .L_Say514; .L_SayX502;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_73_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~his~]
         say__p=1;ParaContent();  print (PrintText) SC_630;  .L_Say515; .L_SayX503;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_72_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~her~]
         say__p=1;ParaContent();  print (PrintText) SC_631;  .L_Say516; .L_SayX504;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~its~]
         say__p=1;ParaContent();  print (PrintText) SC_632;  .L_Say517; .L_SayX505;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 66: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Cap its-their ( deprecated ):
[ PHR_815_r66 ;
      ! phrase 1
      ! [1: say its-their of prior named noun]
      say__p=1;ParaContent(); (PHR_818_r69 ((Global_Vars-->17))); .L_Say518; .L_SayX506;
   rfalse;
];
! Request 67: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Cap its-their of ( item - a thing ) ( deprecated ):
[ PHR_816_r67 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->17) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_773_r12 ((Global_Vars-->17)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_776_r33 (t_0))))  {
         ! phrase 4
         ! [4: say ~Their~]
         say__p=1;ParaContent();  print (PrintText) SC_633;  .L_Say519; .L_SayX507;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~Your~]
         say__p=1;ParaContent();  print (PrintText) SC_634;  .L_Say520; .L_SayX508;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_73_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~His~]
         say__p=1;ParaContent();  print (PrintText) SC_635;  .L_Say521; .L_SayX509;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_72_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~Her~]
         say__p=1;ParaContent();  print (PrintText) SC_636;  .L_Say522; .L_SayX510;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~Its~]
         say__p=1;ParaContent();  print (PrintText) SC_637;  .L_Say523; .L_SayX511;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 68: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Its-their:
[ PHR_817_r68 ;
      ! phrase 1
      ! [1: say its-their of prior named noun]
      say__p=1;ParaContent(); (PHR_818_r69 ((Global_Vars-->17))); .L_Say524; .L_SayX512;
   rfalse;
];
! Request 69: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Its-their of ( item - a thing ):
[ PHR_818_r69 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->17) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_773_r12 ((Global_Vars-->17)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_776_r33 (t_0))))  {
         ! phrase 4
         ! [4: say ~Their~]
         say__p=1;ParaContent();  print (PrintText) SC_633;  .L_Say525; .L_SayX513;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~Your~]
         say__p=1;ParaContent();  print (PrintText) SC_634;  .L_Say526; .L_SayX514;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_73_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~His~]
         say__p=1;ParaContent();  print (PrintText) SC_635;  .L_Say527; .L_SayX515;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_72_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~Her~]
         say__p=1;ParaContent();  print (PrintText) SC_636;  .L_Say528; .L_SayX516;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~Its~]
         say__p=1;ParaContent();  print (PrintText) SC_637;  .L_Say529; .L_SayX517;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 70: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say it-them:
[ PHR_819_r70 ;
      ! phrase 1
      ! [1: say it-them of prior named noun]
      say__p=1;ParaContent(); (PHR_820_r71 ((Global_Vars-->17))); .L_Say530; .L_SayX518;
   rfalse;
];
! Request 71: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say it-them of ( item - a thing ):
[ PHR_820_r71 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->17) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_773_r12 ((Global_Vars-->17)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_776_r33 (t_0))))  {
         ! phrase 4
         ! [4: say ~them~]
         say__p=1;ParaContent();  print (PrintText) SC_638;  .L_Say531; .L_SayX519;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~you~]
         say__p=1;ParaContent();  print (PrintText) SC_620;  .L_Say532; .L_SayX520;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_73_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~him~]
         say__p=1;ParaContent();  print (PrintText) SC_639;  .L_Say533; .L_SayX521;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_72_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~her~]
         say__p=1;ParaContent();  print (PrintText) SC_631;  .L_Say534; .L_SayX522;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~it~]
         say__p=1;ParaContent();  print (PrintText) SC_625;  .L_Say535; .L_SayX523;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 72: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Cap it-them ( deprecated ):
[ PHR_821_r72 ;
      ! phrase 1
      ! [1: say it-them of prior named noun]
      say__p=1;ParaContent(); (PHR_824_r75 ((Global_Vars-->17))); .L_Say536; .L_SayX524;
   rfalse;
];
! Request 73: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Cap it-them of ( item - a thing ) ( deprecated ):
[ PHR_822_r73 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->17) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_773_r12 ((Global_Vars-->17)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_776_r33 (t_0))))  {
         ! phrase 4
         ! [4: say ~Them~]
         say__p=1;ParaContent();  print (PrintText) SC_640;  .L_Say537; .L_SayX525;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~You~]
         say__p=1;ParaContent();  print (PrintText) SC_615;  .L_Say538; .L_SayX526;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_73_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~Him~]
         say__p=1;ParaContent();  print (PrintText) SC_641;  .L_Say539; .L_SayX527;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_72_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~Her~]
         say__p=1;ParaContent();  print (PrintText) SC_636;  .L_Say540; .L_SayX528;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~It~]
         say__p=1;ParaContent();  print (PrintText) SC_627;  .L_Say541; .L_SayX529;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 74: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say It-them:
[ PHR_823_r74 ;
      ! phrase 1
      ! [1: say it-them of prior named noun]
      say__p=1;ParaContent(); (PHR_824_r75 ((Global_Vars-->17))); .L_Say542; .L_SayX530;
   rfalse;
];
! Request 75: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say It-them of ( item - a thing ):
[ PHR_824_r75 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->17) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_773_r12 ((Global_Vars-->17)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_776_r33 (t_0))))  {
         ! phrase 4
         ! [4: say ~Them~]
         say__p=1;ParaContent();  print (PrintText) SC_640;  .L_Say543; .L_SayX531;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~You~]
         say__p=1;ParaContent();  print (PrintText) SC_615;  .L_Say544; .L_SayX532;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_73_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~Him~]
         say__p=1;ParaContent();  print (PrintText) SC_641;  .L_Say545; .L_SayX533;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_72_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~Her~]
         say__p=1;ParaContent();  print (PrintText) SC_636;  .L_Say546; .L_SayX534;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~It~]
         say__p=1;ParaContent();  print (PrintText) SC_627;  .L_Say547; .L_SayX535;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 76: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say its-theirs:
[ PHR_825_r76 ;
      ! phrase 1
      ! [1: say its-theirs of prior named noun]
      say__p=1;ParaContent(); (PHR_826_r77 ((Global_Vars-->17))); .L_Say548; .L_SayX536;
   rfalse;
];
! Request 77: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say its-theirs of ( item - a thing ):
[ PHR_826_r77 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->17) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_773_r12 ((Global_Vars-->17)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_776_r33 (t_0))))  {
         ! phrase 4
         ! [4: say ~theirs~]
         say__p=1;ParaContent();  print (PrintText) SC_642;  .L_Say549; .L_SayX537;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~yours~]
         say__p=1;ParaContent();  print (PrintText) SC_643;  .L_Say550; .L_SayX538;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_73_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~his~]
         say__p=1;ParaContent();  print (PrintText) SC_630;  .L_Say551; .L_SayX539;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_72_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~hers~]
         say__p=1;ParaContent();  print (PrintText) SC_644;  .L_Say552; .L_SayX540;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~its~]
         say__p=1;ParaContent();  print (PrintText) SC_632;  .L_Say553; .L_SayX541;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 78: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Cap its-theirs ( deprecated ):
[ PHR_827_r78 ;
      ! phrase 1
      ! [1: say its-theirs of prior named noun]
      say__p=1;ParaContent(); (PHR_830_r81 ((Global_Vars-->17))); .L_Say554; .L_SayX542;
   rfalse;
];
! Request 79: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Cap its-theirs of ( item - a thing ) ( deprecated ):
[ PHR_828_r79 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->17) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_773_r12 ((Global_Vars-->17)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_776_r33 (t_0))))  {
         ! phrase 4
         ! [4: say ~Theirs~]
         say__p=1;ParaContent();  print (PrintText) SC_645;  .L_Say555; .L_SayX543;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~Yours~]
         say__p=1;ParaContent();  print (PrintText) SC_646;  .L_Say556; .L_SayX544;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_73_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~His~]
         say__p=1;ParaContent();  print (PrintText) SC_635;  .L_Say557; .L_SayX545;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_72_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~Hers~]
         say__p=1;ParaContent();  print (PrintText) SC_647;  .L_Say558; .L_SayX546;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~Its~]
         say__p=1;ParaContent();  print (PrintText) SC_637;  .L_Say559; .L_SayX547;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 80: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Its-theirs:
[ PHR_829_r80 ;
      ! phrase 1
      ! [1: say its-theirs of prior named noun]
      say__p=1;ParaContent(); (PHR_830_r81 ((Global_Vars-->17))); .L_Say560; .L_SayX548;
   rfalse;
];
! Request 81: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Its-theirs of ( item - a thing ):
[ PHR_830_r81 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->17) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_773_r12 ((Global_Vars-->17)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_776_r33 (t_0))))  {
         ! phrase 4
         ! [4: say ~Theirs~]
         say__p=1;ParaContent();  print (PrintText) SC_645;  .L_Say561; .L_SayX549;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~Yours~]
         say__p=1;ParaContent();  print (PrintText) SC_646;  .L_Say562; .L_SayX550;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_73_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~His~]
         say__p=1;ParaContent();  print (PrintText) SC_635;  .L_Say563; .L_SayX551;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_72_t1_v9(t_0))))) && (((~~(((Adj_74_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~Hers~]
         say__p=1;ParaContent();  print (PrintText) SC_647;  .L_Say564; .L_SayX552;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~Its~]
         say__p=1;ParaContent();  print (PrintText) SC_637;  .L_Say565; .L_SayX553;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 82: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say possessive:
[ PHR_831_r82 ;
      ! phrase 1
      ! [1: say possessive of prior named noun]
      say__p=1;ParaContent(); (PHR_832_r83 ((Global_Vars-->17))); .L_Say566; .L_SayX554;
   rfalse;
];
! Request 83: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say possessive of ( item - a thing ):
[ PHR_832_r83 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->17) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_773_r12 ((Global_Vars-->17)));
      ! phrase 3
      ! [3: if the item is the player begin]
       if (((t_0 == player)))  {
         ! phrase 4
         ! [4: say ~your~]
         say__p=1;ParaContent();  print (PrintText) SC_629;  .L_Say567; .L_SayX555;
         ! phrase 5
         ! [5: otherwise if the item acts plural]
          } else if (((PHR_776_r33 (t_0)))) { 
         ! phrase 6
         ! [6: say ~[the item][apostrophe]~]
         say__p=1;ParaContent();  print (the) t_0; ParaContent();  print "'";  .L_Say568; .L_SayX556;
         ! phrase 7
         ! [7: otherwise]
         } else {

         ! phrase 8
         ! [8: say ~[the item][apostrophe]s~]
         say__p=1;ParaContent();  print (the) t_0; ParaContent();  print "'"; ParaContent();  print (PrintText) SC_611;  .L_Say569; .L_SayX557;
         ! phrase 9
         ! [9: end if]
         }

   rfalse;
];
! Request 84: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Cap possessive ( deprecated ):
[ PHR_833_r84 ;
      ! phrase 1
      ! [1: say possessive of prior named noun]
      say__p=1;ParaContent(); (PHR_836_r87 ((Global_Vars-->17))); .L_Say570; .L_SayX558;
   rfalse;
];
! Request 85: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Cap possessive of ( item - a thing ) ( deprecated ):
[ PHR_834_r85 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->17) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_773_r12 ((Global_Vars-->17)));
      ! phrase 3
      ! [3: if the item is the player begin]
       if (((t_0 == player)))  {
         ! phrase 4
         ! [4: say ~Your~]
         say__p=1;ParaContent();  print (PrintText) SC_634;  .L_Say571; .L_SayX559;
         ! phrase 5
         ! [5: otherwise if the item acts plural]
          } else if (((PHR_776_r33 (t_0)))) { 
         ! phrase 6
         ! [6: say ~[The item][apostrophe]~]
         say__p=1;ParaContent();  print (The) t_0; ParaContent();  print "'";  .L_Say572; .L_SayX560;
         ! phrase 7
         ! [7: otherwise]
         } else {

         ! phrase 8
         ! [8: say ~[The item][apostrophe]s~]
         say__p=1;ParaContent();  print (The) t_0; ParaContent();  print "'"; ParaContent();  print (PrintText) SC_611;  .L_Say573; .L_SayX561;
         ! phrase 9
         ! [9: end if]
         }

   rfalse;
];
! Request 86: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Possessive:
[ PHR_835_r86 ;
      ! phrase 1
      ! [1: say possessive of prior named noun]
      say__p=1;ParaContent(); (PHR_836_r87 ((Global_Vars-->17))); .L_Say574; .L_SayX562;
   rfalse;
];
! Request 87: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Possessive of ( item - a thing ):
[ PHR_836_r87 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->17) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_773_r12 ((Global_Vars-->17)));
      ! phrase 3
      ! [3: if the item is the player begin]
       if (((t_0 == player)))  {
         ! phrase 4
         ! [4: say ~Your~]
         say__p=1;ParaContent();  print (PrintText) SC_634;  .L_Say575; .L_SayX563;
         ! phrase 5
         ! [5: otherwise if the item acts plural]
          } else if (((PHR_776_r33 (t_0)))) { 
         ! phrase 6
         ! [6: say ~[The item][apostrophe]~]
         say__p=1;ParaContent();  print (The) t_0; ParaContent();  print "'";  .L_Say576; .L_SayX564;
         ! phrase 7
         ! [7: otherwise]
         } else {

         ! phrase 8
         ! [8: say ~[The item][apostrophe]s~]
         say__p=1;ParaContent();  print (The) t_0; ParaContent();  print "'"; ParaContent();  print (PrintText) SC_611;  .L_Say577; .L_SayX565;
         ! phrase 9
         ! [9: end if]
         }

   rfalse;
];
! Request 88: phrase object -> nothing
! From "Plurality" by Emily Short
! To have the parser notice ( o - an object ):
[ PHR_840_r88 
    t_0 ! Call parameter 'o' = object
    ;
      ! phrase 1
      ! [1: if o is ambiguously plural , notice the plurality of o]
       if ((((Adj_83_t1_v9(t_0))))) {  PlugPlural(t_0);   }
      ! phrase 2
      ! [2: otherwise set pronouns from o]
       else {  PronounNotice(t_0);   }
   rfalse;
];
! Request 89: phrase (number, number) -> snippet
! From "Snippetage" by Dave Robinson
! To decide which snippet is the snippet of length ( L - a number ) at ( N - a number ):
[ PHR_875_r89 
    t_0 ! Call parameter 'L' = number
    t_1 ! Call parameter 'N' = number
    ;
      ! phrase 1
      ! [1: decide on the snippet at n of l]
       return  (100*t_1 + t_0) ; 
   return 101;
];
! Request 90: phrase (number, number) -> snippet
! From "Snippetage" by Dave Robinson
! To decide which snippet is the snippet at word ( N - a number ) of length ( L - a number ):
[ PHR_876_r90 
    t_0 ! Call parameter 'N' = number
    t_1 ! Call parameter 'L' = number
    ;
      ! phrase 1
      ! [1: decide on the snippet at n of l]
       return  (100*t_0 + t_1) ; 
   return 101;
];
! Request 91: phrase (number, number) -> snippet
! From "Snippetage" by Dave Robinson
! To decide which snippet is the snippet at ( N - a number ) of length ( L - a number ):
[ PHR_877_r91 
    t_0 ! Call parameter 'N' = number
    t_1 ! Call parameter 'L' = number
    ;
      ! phrase 1
      ! [1: decide on the snippet at n of l]
       return  (100*t_0 + t_1) ; 
   return 101;
];
! Request 92: phrase nothing -> number
! From "Snippetage" by Dave Robinson
! To decide what number is the command length:
[ PHR_879_r92 ;
      ! phrase 1
      ! [1: decide on the length of the player's command]
       return  players_command%100 ; 
   return 0;
];
! Request 93: phrase snippet -> number
! From "Snippetage" by Dave Robinson
! To decide what number is the end of ( S - a snippet ):
[ PHR_882_r93 
    t_0 ! Call parameter 'S' = snippet
    t_1 ! Local variable e.g. 'N' = number
    ;
      ! phrase 1
      ! [1: let n be the start of s plus the length of s minus 1]
       t_1 =  ( ( t_0/100 + t_0%100 ) -1) ; 
      ! phrase 2
      ! [2: decide on n]
       return t_1; 
   return 0;
];
! Request 94: phrase snippet -> nothing
! From "Snippetage" by Dave Robinson
! To decide whether ( S - a snippet ) is valid:
[ PHR_883_r94 
    t_0 ! Call parameter 'S' = snippet
    ;
      ! phrase 1
      ! [1: if the start of s is less than 1 , decide no]
       if ((( t_0/100  < 1))) {  rfalse;   }
      ! phrase 2
      ! [2: if the length of s is less than 1 , decide no]
       if ((( t_0%100  < 1))) {  rfalse;   }
      ! phrase 3
      ! [3: if the end of s is greater than the command length , decide no]
       if ((((PHR_882_r93 (t_0)) > (PHR_879_r92 ())))) {  rfalse;   }
      ! phrase 4
      ! [4: decide yes]
       rtrue; 
   rfalse;
];
! Request 95: phrase snippet -> nothing
! From "Snippetage" by Dave Robinson
! To decide whether ( S - a snippet ) is invalid:
[ PHR_884_r95 
    t_0 ! Call parameter 'S' = snippet
    ;
      ! phrase 1
      ! [1: if s is valid , decide no]
       if (((PHR_883_r94 (t_0)))) {  rfalse;   }
      ! phrase 2
      ! [2: otherwise decide yes]
       else {  rtrue;   }
   rfalse;
];
! Request 96: phrase number -> snippet
! From "Snippetage" by Dave Robinson
! To decide what snippet is the command from ( N - a number ) onwards:
[ PHR_886_r96 
    t_0 ! Call parameter 'N' = number
    t_1 ! Local variable e.g. 'L' = number
    ;
      ! phrase 1
      ! [1: let l be the command length plus 1 minus n]
       t_1 =  ( ((PHR_879_r92 ())+1) -t_0) ; 
      ! phrase 2
      ! [2: decide on the snippet at n of l]
       return  (100*t_0 + t_1) ; 
   return 101;
];
! Request 97: phrase nothing -> snippet
! From "Snippetage" by Dave Robinson
! To decide what snippet is the verb word:
[ PHR_887_r97 ;
      ! phrase 1
      ! [1: decide on the word at the verb position]
       return (PHR_874_r15 ( verb_wordnum )); 
   return 101;
];
! Request 98: phrase nothing -> nothing
! From "HPMenu" by Orion Zymaris
! to say topbar:
[ PHR_888_r98 ;
      ! phrase 1
      ! [1: say ~The black bar at the top of the game (Not the top of the hints menu) has a bunch of stats about the game so far. The first two numbers, 0/1, tell you the score (Not needed till later) and the turn count respectively. The next bit tells you the time within the game. Next is the current room, and last of all is the current region, e.g. Dursley's house, rather than a single room.~]
      say__p=1;ParaContent();  print (PrintText) SC_648;  new_line; .L_Say578; .L_SayX566;
   rfalse;
];
! Request 99: phrase nothing -> nothing
! From "HPMenu" by Orion Zymaris
! to say acknowledgements:
[ PHR_889_r99 ;
      ! phrase 1
      ! [1: say ~My first acknowledgements go to Graham Nelson, the creator of inform 7, Without which i would be more than a little bit stuck.[line break]Second, to Emily Short, who has done a lot of work to improve Inform.[line break]Next, I would, slightly unneccesarily, like to acknowledge J.K. Rowling, who wrote the Harry Potter books, without which I wouldn't be able to create the game.[line break]I would also like to thank my Dad, for a lot of helpful input and ideas, as well as all the game testers who helped me find and remove bugs.[line break]Also, I would like to thank Stephen Fry, for unwittingly lending his dulcet tones to the introduction. The audiobook introduction to the first book is on soundcloud for free, although it only covers the first five minutes.[line break]Then there are all the authors of the extensions in the game:[paragraph break][list of extension credits][line break]I would like to give a special mention to Erik Temple, since I used some of the code in one of his examples.~]
      say__p=1;ParaContent();  print (PrintText) SC_649; ParaContent();  new_line; ParaContent();  print (PrintText) SC_650; ParaContent();  new_line; ParaContent();  print (PrintText) SC_651; ParaContent();  new_line; ParaContent();  print (PrintText) SC_652; ParaContent();  new_line; ParaContent();  print (PrintText) SC_653; ParaContent();  new_line; ParaContent();  print (PrintText) SC_654; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  ShowExtensionVersions(); ParaContent();  new_line; ParaContent();  print (PrintText) SC_655;  new_line; .L_Say579; .L_SayX567;
   rfalse;
];
! Request 100: phrase nothing -> nothing
! From "HPMenu" by Orion Zymaris
! to say cheathints:
[ PHR_890_r100 ;
      ! phrase 1
      ! [1: say ~[if cheats_bin is 1]These are the cheats commands:[line break]teleport to/Apparate to [bracket]any room[close bracket][line break]Move [bracket]any thing[close bracket] to [bracket]any thing/any room[close bracket][line break]Put [bracket]something off-stage[close bracket]back in/on [bracket]somewhere[close bracket][line break]take (anything, even fixed things or doors)[line break]open sesame (opens and unlocks all doors and containers and vehicles in the whole game)[line break]Change to [bracket]Person[close bracket][line break]Increase score by [bracket]a number[close bracket][line break]restore score (changes the score to what it was before being artificially inflated)[line break]remove [bracket]something[close bracket] from play~]
      say__p=1;
	if (~~(((((Global_Vars-->25) == 1))))) jump L_Say580;
		ParaContent();  print (PrintText) SC_656; ParaContent();  new_line; ParaContent();  print (PrintText) SC_657; ParaContent();  print "["; ParaContent();  print (PrintText) SC_658; ParaContent();  print "]"; ParaContent();  new_line; ParaContent();  print (PrintText) SC_659; ParaContent();  print "["; ParaContent();  print (PrintText) SC_660; ParaContent();  print "]"; ParaContent();  print (PrintText) SC_492; ParaContent();  print "["; ParaContent();  print (PrintText) SC_661; ParaContent();  print "]"; ParaContent();  new_line; ParaContent();  print (PrintText) SC_662; ParaContent();  print "["; ParaContent();  print (PrintText) SC_663; ParaContent();  print "]"; ParaContent();  print (PrintText) SC_664; ParaContent();  print "["; ParaContent();  print (PrintText) SC_665; ParaContent();  print "]"; ParaContent();  new_line; ParaContent();  print (PrintText) SC_666; ParaContent();  new_line; ParaContent();  print (PrintText) SC_667; ParaContent();  new_line; ParaContent();  print (PrintText) SC_668; ParaContent();  print "["; ParaContent();  print (PrintText) SC_669; ParaContent();  print "]"; ParaContent();  new_line; ParaContent();  print (PrintText) SC_670; ParaContent();  print "["; ParaContent();  print (PrintText) SC_671; ParaContent();  print "]"; ParaContent();  new_line; ParaContent();  print (PrintText) SC_672; ParaContent();  new_line; ParaContent();  print (PrintText) SC_673; ParaContent();  print "["; ParaContent();  print (PrintText) SC_674; ParaContent();  print "]"; ParaContent();  print (PrintText) SC_675;  .L_Say580; .L_SayX568;
   rfalse;
];
! Request 101: phrase nothing -> nothing
! From "3 Digit Number Lock" by Orion Zymaris
! to say random lock number:
[ PHR_938_r101 ;
      ! phrase 1
      ! [1: say ~[first digit][second digit][third digit]~]
      say__p=1;ParaContent();  print (say__n=(Global_Vars-->28)); ParaContent();  print (say__n=(Global_Vars-->29)); ParaContent();  print (say__n=(Global_Vars-->30));  .L_Say581; .L_SayX569;
   rfalse;
];
! Request 102: phrase nothing -> nothing
! From "3 Digit Number Lock" by Orion Zymaris
! to say tumbler arrangement:
[ PHR_939_r102 ;
      ! phrase 1
      ! [1: say ~[first tumbler][second tumbler][third tumbler]~]
      say__p=1;ParaContent();  print (say__n=(Global_Vars-->31)); ParaContent();  print (say__n=(Global_Vars-->32)); ParaContent();  print (say__n=(Global_Vars-->33));  .L_Say582; .L_SayX570;
   rfalse;
];
! Request 103: phrase thing -> nothing
! From "Conversation Framework" by Eric Eve
! To say make ( obj - a thing ) known/familiar:
[ PHR_994_r103 
    t_0 ! Call parameter 'obj' = thing
    ;
      ! phrase 1
      ! [1: now obj is familiar]
       (Adj_87_t2_v9(t_0)); 
   rfalse;
];
! Request 104: phrase nothing -> nothing
! From "Hpmenu for chapter 1" by Orion Zymaris
! to say first daily activity:
[ PHR_1083_r104 ;
      ! phrase 1
      ! [1: say ~Getting up: [if player is not in bed][italic type]Success[roman type][end if][line break]~]
      say__p=1;ParaContent();  print (PrintText) SC_676; 
	if (~~((((~~((I120_bed == ContainerOf(player)))))))) jump L_Say583;
		ParaContent();  style underline; ParaContent();  print (PrintText) SC_677; ParaContent();  style roman; 
	.L_Say583; .L_SayX571;
		ParaContent();  new_line;  .L_Say584; .L_SayX572;
   rfalse;
];
! Request 105: phrase nothing -> nothing
! From "Hpmenu for chapter 1" by Orion Zymaris
! to say second daily activity:
[ PHR_1084_r105 ;
      ! phrase 1
      ! [1: say ~Getting onto public roads: [if the location has been highway][italic type]Success[roman type][end if][line break]~]
      say__p=1;ParaContent();  print (PrintText) SC_678; 
	if (~~((TestSinglePastState(0, 7, false, 5)))) jump L_Say585;
		ParaContent();  style underline; ParaContent();  print (PrintText) SC_677; ParaContent();  style roman; 
	.L_Say585; .L_SayX573;
		ParaContent();  new_line;  .L_Say586; .L_SayX574;
   rfalse;
];
! Request 106: phrase nothing -> nothing
! From "Hpmenu for chapter 1" by Orion Zymaris
! to say third daily activity:
[ PHR_1085_r106 ;
      ! phrase 1
      ! [1: say ~First phone call: [if the venture of customercall is success][italic type]Success[roman type][end if][line break]~]
      say__p=1;ParaContent();  print (PrintText) SC_679; 
	if (~~((((GProperty(SCENE_TY, I264_customercall,p80_venture) == I266_success))))) jump L_Say587;
		ParaContent();  style underline; ParaContent();  print (PrintText) SC_677; ParaContent();  style roman; 
	.L_Say587; .L_SayX575;
		ParaContent();  new_line;  .L_Say588; .L_SayX576;
      ! phrase 2
      ! [2: say ~Second call: [if the venture of mrmason call is success][italic type]Success[roman type][end if][line break]~]
      say__p=1;ParaContent();  print (PrintText) SC_680; 
	if (~~((((GProperty(SCENE_TY, I276_mrmason_call,p80_venture) == I266_success))))) jump L_Say589;
		ParaContent();  style underline; ParaContent();  print (PrintText) SC_677; ParaContent();  style roman; 
	.L_Say589; .L_SayX577;
		ParaContent();  new_line;  .L_Say590; .L_SayX578;
   rfalse;
];
! Request 107: phrase nothing -> nothing
! From "Hpmenu for chapter 1" by Orion Zymaris
! to say fourth daily activity:
[ PHR_1086_r107 ;
      ! phrase 1
      ! [1: say ~Lunch: [if bakers is visited][italic type]Success[roman type][end if][line break]~]
      say__p=1;ParaContent();  print (PrintText) SC_681; 
	if (~~(((((Adj_44_t1_v9(I287_bakers))))))) jump L_Say591;
		ParaContent();  style underline; ParaContent();  print (PrintText) SC_677; ParaContent();  style roman; 
	.L_Say591; .L_SayX579;
		ParaContent();  new_line;  .L_Say592; .L_SayX580;
   rfalse;
];
! Request 108: phrase nothing -> nothing
! From "Hpmenu for chapter 1" by Orion Zymaris
! to say fifth daily activity:
[ PHR_1087_r108 ;
      ! phrase 1
      ! [1: say ~Finishing work: [if the venture of work is success][italic type]Success[roman type][end if][line break]~]
      say__p=1;ParaContent();  print (PrintText) SC_682; 
	if (~~((((GProperty(SCENE_TY, I238_work,p80_venture) == I266_success))))) jump L_Say593;
		ParaContent();  style underline; ParaContent();  print (PrintText) SC_677; ParaContent();  style roman; 
	.L_Say593; .L_SayX581;
		ParaContent();  new_line;  .L_Say594; .L_SayX582;
   rfalse;
];
! Request 109: phrase nothing -> nothing
! From "Hpmenu for chapter 1" by Orion Zymaris
! to say sixth daily activity:
[ PHR_1088_r109 ;
      ! phrase 1
      ! [1: say ~Watching television: [if television has been switched on]Success[end if][line break]~]
      say__p=1;ParaContent();  print (PrintText) SC_683; 
	if (~~((TestSinglePastState(0, 8, false, 5)))) jump L_Say595;
		ParaContent();  print (PrintText) SC_677; 
	.L_Say595; .L_SayX583;
		ParaContent();  new_line;  .L_Say596; .L_SayX584;
   rfalse;
];
! Request 110: phrase nothing -> nothing
! From "Hpmenu for chapter 1" by Orion Zymaris
! to say seventh daily activity:
[ PHR_1089_r110 ;
      ! phrase 1
      ! [1: say ~Talking to petunia about Potters: [if venture of living-room cut scene is not incomplete]Success[end if][line break]~]
      say__p=1;ParaContent();  print (PrintText) SC_684; 
	if (~~((((~~((GProperty(SCENE_TY, I328_living_room_cut_scene,p80_venture) == I268_incomplete))))))) jump L_Say597;
		ParaContent();  print (PrintText) SC_677; 
	.L_Say597; .L_SayX585;
		ParaContent();  new_line;  .L_Say598; .L_SayX586;
   rfalse;
];
! Request 111: phrase nothing -> nothing
! From "Hpmenu for chapter 1" by Orion Zymaris
! to say eighth daily activity:
[ PHR_1090_r111 ;
      ! phrase 1
      ! [1: say ~Finishing day: [if the venture of uncle vernon's scene is success]Success[line break] ~]
      say__p=1;ParaContent();  print (PrintText) SC_685; 
	if (~~((((GProperty(SCENE_TY, I92_uncle_vernon_s_scene,p80_venture) == I266_success))))) jump L_Say599;
		ParaContent();  print (PrintText) SC_677; ParaContent();  new_line; ParaContent();  print (PrintText) SC_88;  .L_Say599; .L_SayX587;
   rfalse;
];
! Request 112: phrase nothing -> nothing
! From "Hpmenu for chapter 1" by Orion Zymaris
! to say itinerary:
[ PHR_1091_r112 ;
      ! phrase 1
      ! [1: say ~[first daily activity][if player is not in bed][second daily activity][end if][if the location has been highway][third daily activity][end if][if the venture of mrmason call is success][fourth daily activity][end if][if bakers is visited][fifth daily activity][end if][if the venture of work is success][sixth daily activity][end if][if television has been switched on][seventh daily activity][end if][if venture of living-room cut scene is not incomplete][eighth daily activity][end if]~]
      say__p=1;ParaContent(); (PHR_1083_r104 ());
	if (~~((((~~((I120_bed == ContainerOf(player)))))))) jump L_Say600;
		ParaContent(); (PHR_1084_r105 ());
	.L_Say600; .L_SayX588;
		
	if (~~((TestSinglePastState(0, 9, false, 5)))) jump L_Say601;
		ParaContent(); (PHR_1085_r106 ());
	.L_Say601; .L_SayX589;
		
	if (~~((((GProperty(SCENE_TY, I276_mrmason_call,p80_venture) == I266_success))))) jump L_Say602;
		ParaContent(); (PHR_1086_r107 ());
	.L_Say602; .L_SayX590;
		
	if (~~(((((Adj_44_t1_v9(I287_bakers))))))) jump L_Say603;
		ParaContent(); (PHR_1087_r108 ());
	.L_Say603; .L_SayX591;
		
	if (~~((((GProperty(SCENE_TY, I238_work,p80_venture) == I266_success))))) jump L_Say604;
		ParaContent(); (PHR_1088_r109 ());
	.L_Say604; .L_SayX592;
		
	if (~~((TestSinglePastState(0, 10, false, 5)))) jump L_Say605;
		ParaContent(); (PHR_1089_r110 ());
	.L_Say605; .L_SayX593;
		
	if (~~((((~~((GProperty(SCENE_TY, I328_living_room_cut_scene,p80_venture) == I268_incomplete))))))) jump L_Say606;
		ParaContent(); (PHR_1090_r111 ());
	.L_Say606; .L_SayX594;
		 .L_Say607; .L_SayX595;
   rfalse;
];
! Request 113: phrase nothing -> nothing
! to say petunia:
[ PHR_1152_r113 ;
      ! phrase 1
      ! [1: if player is petunia begin]
       if (((player == I202_petunia)))  {
         ! phrase 2
         ! [2: say ~[no line break] ~]
         say__p=1;ParaContent(); (PHR_335_r7 ());ParaContent();  print (PrintText) SC_88;  .L_Say608; .L_SayX596;
         ! phrase 3
         ! [3: otherwise if player is dudley]
          } else if (((player == I221_dudley))) { 
         ! phrase 4
         ! [4: say ~Mummy at the table, ~]
         say__p=1;ParaContent();  print (PrintText) SC_686;  .L_Say609; .L_SayX597;
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: say ~Petunia at the table, ~]
         say__p=1;ParaContent();  print (PrintText) SC_687;  .L_Say610; .L_SayX598;
         ! phrase 7
         ! [7: end if]
         }

   rfalse;
];
! Request 114: phrase nothing -> nothing
! to say dudley:
[ PHR_1153_r114 ;
      ! phrase 1
      ! [1: if player is dudley begin]
       if (((player == I221_dudley)))  {
         ! phrase 2
         ! [2: say ~[no line break]~]
         say__p=1;ParaContent(); (PHR_335_r7 ()); .L_Say611; .L_SayX599;
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~Dudley on his highchair, ~]
         say__p=1;ParaContent();  print (PrintText) SC_688;  .L_Say612; .L_SayX600;
         ! phrase 5
         ! [5: end if]
         }

   rfalse;
];
! Request 115: phrase nothing -> nothing
! to say dursley:
[ PHR_1154_r115 ;
      ! phrase 1
      ! [1: if player is dursley begin]
       if (((player == I97_dursley)))  {
         ! phrase 2
         ! [2: say ~[no line break]~]
         say__p=1;ParaContent(); (PHR_335_r7 ()); .L_Say613; .L_SayX601;
         ! phrase 3
         ! [3: otherwise if the player is dudley]
          } else if (((player == I221_dudley))) { 
         ! phrase 4
         ! [4: say ~Daddy, ~]
         say__p=1;ParaContent();  print (PrintText) SC_689;  .L_Say614; .L_SayX602;
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: say ~Vernon, ~]
         say__p=1;ParaContent();  print (PrintText) SC_690;  .L_Say615; .L_SayX603;
         ! phrase 7
         ! [7: end if]
         }

   rfalse;
];
! Request 116: phrase nothing -> nothing
! to say rollerdexentry:
[ PHR_1219_r116 
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: choose a random row from table 6]
       ct_0 = T18_rollerdex_entries_day; ct_1 = TableRandomRow(ct_0); 
      ! phrase 2
      ! [2: say ~[Day entry] ~]
      say__p=1;ParaContent();  print (PrintText) TableLookUpEntry(ct_0,120,ct_1); ParaContent();  print (PrintText) SC_88;  .L_Say616; .L_SayX604;
      ! phrase 3
      ! [3: choose a random row from table 7]
       ct_0 = T19_rollerdex_entries_month; ct_1 = TableRandomRow(ct_0); 
      ! phrase 4
      ! [4: say ~[month entry] ~]
      say__p=1;ParaContent();  print (PrintText) TableLookUpEntry(ct_0,121,ct_1); ParaContent();  print (PrintText) SC_88;  .L_Say617; .L_SayX605;
      ! phrase 5
      ! [5: choose a random row from table 8]
       ct_0 = T20_rollerdex_entries_days_o; ct_1 = TableRandomRow(ct_0); 
      ! phrase 6
      ! [6: say ~[DOM entry] 1981[paragraph break]Call [one of]Doc Brown at 5554385[or]Mr Plow at 5553226[or]The Simpsons at 5558707[or]The Ghostbusters at 5552368[or]Buffy at 5550101[or]God at 5550123[or]Xander at 5550168[or]Dawn at 5550193[purely at random]~]
      say__p=1;ParaContent();  print (PrintText) TableLookUpEntry(ct_0,122,ct_1); ParaContent();  print (PrintText) SC_691; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_692; ParaContent();  I7_ST_say_one_of-->9 =
	i7_soo_par(I7_ST_say_one_of-->9, 8);
	switch((I7_ST_say_one_of-->9)%(8+1)-1) {
		0: ParaContent();  print (PrintText) SC_693; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_694; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_695; ParaContent();  @nop; 3: ParaContent();  print (PrintText) SC_696; ParaContent();  @nop; 4: ParaContent();  print (PrintText) SC_697; ParaContent();  @nop; 5: ParaContent();  print (PrintText) SC_698; ParaContent();  @nop; 6: ParaContent();  print (PrintText) SC_699; ParaContent();  @nop; 7: ParaContent();  print (PrintText) SC_700; ParaContent();  }  .L_Say618; .L_SayX606;
   rfalse;
];
[ LOS_0 
    t_0 ! Call parameter 'it' = object
    ;
if (((t_0 ofclass K27_number_unlockable))) los_rv = t_0;
];
[ LOS_1 
    t_0 ! Call parameter 'it' = object
    ;
if (((t_0 ofclass K27_number_unlockable))) los_rv = t_0;
];
[ text_routine_0;
say__p=1;ParaContent(); @push self;  print (PrintText) GProperty(OBJECT_TY, self=self,short_name); @pull self; ParaContent();  print (PrintText) SC_701; ParaContent();  print (PrintShortName) (Resolver_5(self,real_location,"source", 1)); 
	if (~~((((GProperty(OBJECT_TY, self,p13_openyesno) == 1))))) jump L_Say619;
		ParaContent();  print (PrintText) SC_702; ParaContent(); @push self;  print (the) GProperty(OBJECT_TY, self=self,door_to); @pull self; 
	.L_Say619; .L_SayX607;
		ParaContent();  print (PrintText) SC_201; ParaContent();  new_line;  .L_Say620; .L_SayX608;
    rtrue;
];

[ text_routine_1;
say__p=1;ParaContent();  I7_ST_say_one_of-->10 =
	i7_soo_par(I7_ST_say_one_of-->10, 3);
	switch((I7_ST_say_one_of-->10)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_703; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_704; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_705; ParaContent();  } ParaContent();  print (PrintText) SC_201;  .L_Say621; .L_SayX609;
    rtrue;
];

[ text_routine_2;
say__p=1;
	if (~~((((GProperty(SCENE_TY, I238_work,p80_venture) == I268_incomplete))))) jump L_Say622;
		ParaContent();  print (PrintText) SC_706; 
	jump L_SayX610; .L_Say622;
		ParaContent();  print (PrintText) SC_707;  .L_Say623; .L_SayX610;
    rtrue;
];

[ text_routine_3;
say__p=1;ParaContent();  print (PrintText) SC_708; ParaContent();  print (PrintTimeOfDayEnglish) the_time; ParaContent();  print (PrintText) SC_709; 
	if (~~((( (((the_time+20*ONE_HOUR)%(TWENTY_FOUR_HOURS))<((511+20*ONE_HOUR)%(TWENTY_FOUR_HOURS))) )))) jump L_Say624;
		ParaContent();  print (PrintText) SC_710; 
	jump L_SayX611; .L_Say624;
		ParaContent();  print (PrintText) SC_711; 
	.L_Say625; .L_SayX611;
		ParaContent();  print (PrintText) SC_712; 
	if ((((the_time == 510)))) jump L_Say626;
		ParaContent();  print (PrintText) SC_713; 
	jump L_SayX612; .L_Say626;
		ParaContent();  print (PrintText) SC_714; 
	.L_Say627; .L_SayX612;
		ParaContent();  print (PrintText) SC_201;  .L_Say628; .L_SayX613;
    rtrue;
];

[ text_routine_4;
say__p=1;
	if (~~(((Prop_83())))) jump L_Say629;
		ParaContent();  print (PrintText) SC_715; ParaContent(); 
	jump L_SayX614; .L_Say629; if (~~((((player == WearerOf(I130_pyjamas)))))) jump L_Say630;
		ParaContent();  print (PrintText) SC_716; ParaContent(); 
	jump L_SayX614; .L_Say630; if (~~(((Prop_84())))) jump L_Say631;
		ParaContent();  print (PrintText) SC_717; 
	jump L_SayX614; .L_Say631;
		ParaContent();  print (PrintText) SC_718; ParaContent();  I7_ST_say_one_of-->11 =
	i7_soo_par(I7_ST_say_one_of-->11, 4);
	switch((I7_ST_say_one_of-->11)%(4+1)-1) {
		0: ParaContent();  print (PrintText) SC_719; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_720; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_721; ParaContent();  @nop; 3: ParaContent();  print (PrintText) SC_722; ParaContent();  }  .L_Say632; .L_SayX614;
    rtrue;
];

[ text_routine_5;
say__p=1;ParaContent(); (PHR_938_r101 ()); .L_Say633; .L_SayX615;
    rtrue;
];

[ text_routine_6;
say__p=1;
	if (~~((TestSinglePastState(0, 11, false, 5)))) jump L_Say634;
		ParaContent();  print (PrintText) SC_723; 
	jump L_SayX616; .L_Say634;
		ParaContent();  print (PrintText) SC_724;  .L_Say635; .L_SayX616;
    rtrue;
];

[ text_routine_7;
say__p=1;ParaContent();  print (PrintText) SC_725; 
	if ((((player == I221_dudley)))) jump L_Say636;
		ParaContent();  print (PrintText) SC_726; 
	jump L_SayX617; .L_Say636;
		ParaContent();  print (PrintText) SC_620; 
	.L_Say637; .L_SayX617;
		ParaContent();  print (PrintText) SC_727; ParaContent(); (PHR_335_r7 ()); .L_Say638; .L_SayX618;
    rtrue;
];

[ text_routine_8;
say__p=1;ParaContent();  print (PrintText) SC_728; ParaContent();  new_line; ParaContent();  print (PrintText) SC_729;  .L_Say639; .L_SayX619;
    rtrue;
];

[ text_routine_9;
say__p=1;ParaContent();  
	if ((I7_ST_say_first_time-->2)++ == 0) {
		ParaContent();  print (PrintText) SC_730; ParaContent();  new_line; ParaContent();  } ParaContent();  print (PrintText) SC_731;  .L_Say640; .L_SayX620;
    rtrue;
];

[ text_routine_10;
say__p=1;
	if (~~(((((Adj_45_t1_v9(I148_broomcupboard))))))) jump L_Say641;
		ParaContent();  print (PrintText) SC_732; 
	jump L_SayX621; .L_Say641;
		ParaContent();  print (PrintText) SC_733;  .L_Say642; .L_SayX621;
    rtrue;
];

[ text_routine_11;
say__p=1;ParaContent();  print (PrintText) SC_734; ParaContent();  style underline; ParaContent();  new_line; ParaContent();  print (PrintText) SC_735; ParaContent();  new_line; ParaContent();  print (PrintText) SC_736; ParaContent();  style roman; ParaContent();  new_line; ParaContent();  print (PrintText) SC_737;  .L_Say643; .L_SayX622;
    rtrue;
];

[ text_routine_12;
say__p=1;ParaContent();  print (PrintText) SC_738; ParaContent();  style underline; ParaContent();  new_line; ParaContent();  print (PrintText) SC_739; ParaContent();  new_line; ParaContent();  print (PrintText) SC_740; ParaContent();  new_line; ParaContent();  print (PrintText) SC_741; ParaContent();  new_line; ParaContent();  print (PrintText) SC_742; ParaContent();  new_line; ParaContent();  print (PrintText) SC_743; ParaContent();  new_line; ParaContent();  print (PrintText) SC_744; ParaContent();  new_line; ParaContent();  print (PrintText) SC_745; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  style roman; ParaContent();  print (PrintText) SC_746;  .L_Say644; .L_SayX623;
    rtrue;
];

[ text_routine_13;
say__p=1;
	if (~~((((~~(((Adj_44_t1_v9(I198_kitchen))))))))) jump L_Say645;
		ParaContent();  print (PrintText) SC_747; 
	jump L_SayX624; .L_Say645;
		ParaContent();  print (PrintText) SC_748;  .L_Say646; .L_SayX624;
    rtrue;
];

[ text_routine_14;
say__p=1;ParaContent();  print (PrintText) SC_749; 
	if (~~((((player == I221_dudley))))) jump L_Say647;
		ParaContent();  print (PrintText) SC_750; ParaContent(); 
	jump L_SayX625; .L_Say647; if (~~((((player == I202_petunia))))) jump L_Say648;
		ParaContent();  print (PrintText) SC_751; 
	jump L_SayX625; .L_Say648;
		
	.L_Say649; .L_SayX625;
		ParaContent();  print (PrintText) SC_752; 
	if (~~((((I198_kitchen == ContainerOf(I202_petunia)))))) jump L_Say650;
		ParaContent(); (PHR_1152_r113 ());
	.L_Say650; .L_SayX626;
		
	if (~~((((I198_kitchen == ContainerOf(I221_dudley)))))) jump L_Say651;
		ParaContent(); (PHR_1153_r114 ());ParaContent(); 
	jump L_SayX627; .L_Say651; if (~~((((I205_highchair == SupporterOf(I221_dudley)))))) jump L_Say652;
		ParaContent(); (PHR_1153_r114 ());
	.L_Say652; .L_SayX627;
		
	if (~~((((I198_kitchen == ContainerOf(I97_dursley)))))) jump L_Say653;
		ParaContent(); (PHR_1154_r115 ());
	.L_Say653; .L_SayX628;
		
	if (~~(((((Adj_9_t1_v9(I225_cereal))))))) jump L_Say654;
		ParaContent();  print (PrintText) SC_753; 
	.L_Say654; .L_SayX629;
		ParaContent();  print (PrintText) SC_754;  .L_Say655; .L_SayX630;
    rtrue;
];

[ text_routine_15;
say__p=1;ParaContent();  print (PrintText) SC_292; ParaContent();  new_line; ParaContent();  print (PrintText) SC_293; ParaContent();  new_line; ParaContent();  print (PrintText) SC_294; ParaContent();  new_line; ParaContent();  print (PrintText) SC_295; ParaContent();  new_line; ParaContent();  print (PrintText) SC_755;  .L_Say656; .L_SayX631;
    rtrue;
];

[ text_routine_16;
say__p=1;ParaContent();  print (PrintText) SC_756; ParaContent();  I7_ST_say_one_of-->12 =
	i7_soo_par(I7_ST_say_one_of-->12, 4);
	switch((I7_ST_say_one_of-->12)%(4+1)-1) {
		0: ParaContent();  print (PrintText) SC_757; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_758; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_759; ParaContent();  @nop; 3: ParaContent();  print (PrintText) SC_760; ParaContent();  } ParaContent();  print (PrintText) SC_761;  .L_Say657; .L_SayX632;
    rtrue;
];

[ text_routine_17;
say__p=1;
	if (~~(((((Adj_70_t1_v9(self))))))) jump L_Say658;
		ParaContent();  print (PrintText) SC_762; 
	jump L_SayX633; .L_Say658;
		ParaContent();  print (PrintText) SC_763;  .L_Say659; .L_SayX633;
    rtrue;
];

[ text_routine_18;
say__p=1;
	if (~~(((((Adj_71_t1_v9(self))))))) jump L_Say660;
		ParaContent();  print (PrintText) SC_764; 
	jump L_SayX634; .L_Say660;
		ParaContent();  print (PrintText) SC_765;  .L_Say661; .L_SayX634;
    rtrue;
];

[ text_routine_19;
say__p=1;
	if (~~((((player == WearerOf(I127_wizards_robes)))))) jump L_Say662;
		ParaContent();  print (PrintText) SC_766; ParaContent(); 
	jump L_SayX635; .L_Say662; if (~~((((GProperty(SCENE_TY, I238_work,p80_venture) == I268_incomplete))))) jump L_Say663;
		ParaContent();  print (PrintText) SC_767; 
	jump L_SayX635; .L_Say663;
		ParaContent();  print (PrintText) SC_768; ParaContent();  DivideParagraphPoint(); new_line; 
	.L_Say664; .L_SayX635;
		ParaContent();  print (PrintText) SC_769;  .L_Say665; .L_SayX636;
    rtrue;
];

[ text_routine_20;
say__p=1;ParaContent();  I7_ST_say_one_of-->13 =
	i7_soo_par(I7_ST_say_one_of-->13, 3);
	switch((I7_ST_say_one_of-->13)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_770; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_771; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_772; ParaContent();  }  .L_Say666; .L_SayX637;
    rtrue;
];

[ text_routine_21;
say__p=1;ParaContent();  
	if ((I7_ST_say_first_time-->3)++ == 0) {
		ParaContent();  print (PrintText) SC_773; ParaContent();  } ParaContent();  print (PrintText) SC_774;  .L_Say667; .L_SayX638;
    rtrue;
];

[ text_routine_22;
say__p=1;ParaContent();  print (PrintText) SC_775; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_776; ParaContent();  new_line; ParaContent();  print (PrintText) SC_777; ParaContent();  new_line; ParaContent();  print (PrintText) SC_778; ParaContent();  new_line; ParaContent();  print (PrintText) SC_779; ParaContent();  new_line; ParaContent();  print (PrintText) SC_780; ParaContent();  new_line; ParaContent();  print (PrintText) SC_781; ParaContent();  new_line; ParaContent();  print (PrintText) SC_782; ParaContent();  I7_ST_say_one_of-->14 =
	i7_soo_par(I7_ST_say_one_of-->14, 3);
	switch((I7_ST_say_one_of-->14)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_783; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_784; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_785; ParaContent();  } ParaContent();  print (PrintText) SC_786; ParaContent();  new_line;  .L_Say668; .L_SayX639;
    rtrue;
];

[ text_routine_23;
say__p=1;ParaContent();  print (PrintText) SC_136; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_787; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_788; ParaContent();  new_line; ParaContent();  print (PrintText) SC_789; 
	if (~~((((GProperty(SCENE_TY, I264_customercall,p80_venture) == I266_success))))) jump L_Say669;
		ParaContent();  print (PrintText) SC_199; ParaContent();  style bold; ParaContent();  print (PrintText) SC_790; ParaContent();  style roman; ParaContent(); 
	jump L_SayX640; .L_Say669; if (~~((((GProperty(SCENE_TY, I264_customercall,p80_venture) == I267_failure))))) jump L_Say670;
		ParaContent();  print (PrintText) SC_199; ParaContent();  style bold; ParaContent();  print (PrintText) SC_791; ParaContent();  style roman; 
	jump L_SayX640; .L_Say670;
		ParaContent();  print (PrintText) SC_201; 
	.L_Say671; .L_SayX640;
		ParaContent();  new_line; ParaContent();  print (PrintText) SC_792; 
	if (~~((((GProperty(SCENE_TY, I276_mrmason_call,p80_venture) == I266_success))))) jump L_Say672;
		ParaContent();  print (PrintText) SC_446; ParaContent();  style bold; ParaContent();  print (PrintText) SC_793; ParaContent();  style roman; ParaContent(); 
	jump L_SayX641; .L_Say672; if (~~((((GProperty(SCENE_TY, I276_mrmason_call,p80_venture) == I267_failure))))) jump L_Say673;
		ParaContent();  print (PrintText) SC_446; ParaContent();  style bold; ParaContent();  print (PrintText) SC_794; ParaContent();  style roman; ParaContent(); 
	jump L_SayX641; .L_Say673; if (~~((((GProperty(SCENE_TY, I276_mrmason_call,p80_venture) == I269_pending))))) jump L_Say674;
		ParaContent();  print (PrintText) SC_446; ParaContent();  style bold; ParaContent();  print (PrintText) SC_795; ParaContent();  style roman; 
	jump L_SayX641; .L_Say674;
		ParaContent();  print (PrintText) SC_201; 
	.L_Say675; .L_SayX641;
		 .L_Say676; .L_SayX642;
    rtrue;
];

[ text_routine_24;
say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->74);  .L_Say677; .L_SayX643;
    rtrue;
];

[ text_routine_25;
say__p=1;ParaContent();  print (PrintText) SC_756; ParaContent();  I7_ST_say_one_of-->15 =
	i7_soo_par(I7_ST_say_one_of-->15, 5);
	switch((I7_ST_say_one_of-->15)%(5+1)-1) {
		0: ParaContent();  print (PrintText) SC_757; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_758; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_759; ParaContent();  @nop; 3: ParaContent();  print (PrintText) SC_760; ParaContent();  @nop; 4: ParaContent();  print (PrintText) SC_796; ParaContent();  } ParaContent();  print (PrintText) SC_761;  .L_Say678; .L_SayX644;
    rtrue;
];

[ text_routine_26;
say__p=1;ParaContent();  print (PrintText) SC_797; ParaContent();  new_line; ParaContent();  print (PrintText) SC_798;  .L_Say679; .L_SayX645;
    rtrue;
];

[ text_routine_27;
say__p=1;ParaContent();  print (PrintText) SC_799; ParaContent();  style underline; ParaContent();  print (PrintText) SC_362; ParaContent();  style roman; ParaContent();  print (PrintText) SC_257;  .L_Say680; .L_SayX646;
    rtrue;
];

[ text_routine_28;
say__p=1;
	if (~~((((I291_foods_display_case == ContainerOf(I292_doughnut)))))) jump L_Say681;
		ParaContent();  print (PrintText) SC_800; 
	.L_Say681; .L_SayX647;
		ParaContent();  print (PrintText) SC_378;  .L_Say682; .L_SayX648;
    rtrue;
];

[ text_routine_29;
say__p=1;
	if (~~((((I291_foods_display_case == ContainerOf(I293_bun)))))) jump L_Say683;
		ParaContent();  print (PrintText) SC_800; 
	.L_Say683; .L_SayX649;
		ParaContent();  print (PrintText) SC_379;  .L_Say684; .L_SayX650;
    rtrue;
];

[ text_routine_30;
say__p=1;
	if (~~((((I291_foods_display_case == ContainerOf(I294_breadstick)))))) jump L_Say685;
		ParaContent();  print (PrintText) SC_800; 
	.L_Say685; .L_SayX651;
		ParaContent();  print (PrintText) SC_380;  .L_Say686; .L_SayX652;
    rtrue;
];

[ text_routine_31;
say__p=1;
	if (~~((((real_location == I301_dining_room))))) jump L_Say687;
		ParaContent();  print (PrintText) SC_801; 
	jump L_SayX653; .L_Say687;
		ParaContent();  print (PrintText) SC_802;  .L_Say688; .L_SayX653;
    rtrue;
];

[ text_routine_32;
say__p=1;ParaContent();  print (PrintText) SC_803; ParaContent();  new_line;  .L_Say689; .L_SayX654;
    rtrue;
];

[ text_routine_33;
say__p=1;ParaContent();  print (PrintText) SC_804; ParaContent();  new_line;  .L_Say690; .L_SayX655;
    rtrue;
];

[ text_routine_34;
say__p=1;ParaContent();  print (PrintText) SC_805; ParaContent();  new_line;  .L_Say691; .L_SayX656;
    rtrue;
];

[ text_routine_35;
say__p=1;ParaContent();  print (PrintText) SC_806; ParaContent();  new_line;  .L_Say692; .L_SayX657;
    rtrue;
];

[ text_routine_36;
say__p=1;ParaContent();  print (PrintText) SC_807; ParaContent();  new_line;  .L_Say693; .L_SayX658;
    rtrue;
];

[ text_routine_37;
say__p=1;ParaContent();  print (PrintText) SC_808; ParaContent();  new_line;  .L_Say694; .L_SayX659;
    rtrue;
];

[ text_routine_38;
say__p=1;ParaContent();  print (PrintText) SC_809; ParaContent();  new_line;  .L_Say695; .L_SayX660;
    rtrue;
];

[ text_routine_39;
say__p=1;ParaContent();  print (PrintText) SC_810; ParaContent();  new_line;  .L_Say696; .L_SayX661;
    rtrue;
];

[ text_routine_40;
say__p=1;ParaContent();  print (PrintText) SC_811; ParaContent();  new_line;  .L_Say697; .L_SayX662;
    rtrue;
];

[ text_routine_41;
say__p=1;ParaContent();  print (PrintText) SC_812; ParaContent();  new_line;  .L_Say698; .L_SayX663;
    rtrue;
];

[ text_routine_42;
say__p=1;ParaContent();  print (PrintText) SC_813; ParaContent();  new_line;  .L_Say699; .L_SayX664;
    rtrue;
];

[ text_routine_43;
say__p=1;ParaContent();  print (PrintText) SC_814; ParaContent();  new_line;  .L_Say700; .L_SayX665;
    rtrue;
];

[ text_routine_44;
say__p=1;ParaContent();  print (PrintText) SC_815; ParaContent();  new_line;  .L_Say701; .L_SayX666;
    rtrue;
];

[ text_routine_45;
say__p=1;ParaContent();  print (PrintText) SC_816; ParaContent();  new_line;  .L_Say702; .L_SayX667;
    rtrue;
];

[ text_routine_46;
say__p=1;ParaContent();  print (PrintText) SC_817; ParaContent();  new_line;  .L_Say703; .L_SayX668;
    rtrue;
];

[ text_routine_47;
say__p=1;ParaContent();  print (PrintText) SC_818; ParaContent();  new_line;  .L_Say704; .L_SayX669;
    rtrue;
];

[ text_routine_48;
say__p=1;ParaContent();  print (PrintText) SC_819; ParaContent();  new_line; ParaContent();  print (PrintText) SC_88;  .L_Say705; .L_SayX670;
    rtrue;
];

[ text_routine_49;
say__p=1;ParaContent();  print (PrintText) SC_820; ParaContent();  new_line;  .L_Say706; .L_SayX671;
    rtrue;
];

[ text_routine_50;
say__p=1;ParaContent();  print (PrintText) SC_821; ParaContent();  new_line;  .L_Say707; .L_SayX672;
    rtrue;
];

[ text_routine_51;
say__p=1;ParaContent();  print (PrintText) SC_822; ParaContent();  new_line;  .L_Say708; .L_SayX673;
    rtrue;
];

[ text_routine_52;
say__p=1;ParaContent();  print (PrintText) SC_823; ParaContent();  new_line;  .L_Say709; .L_SayX674;
    rtrue;
];

[ text_routine_53;
say__p=1;ParaContent();  print (PrintText) SC_824; ParaContent();  new_line;  .L_Say710; .L_SayX675;
    rtrue;
];

[ text_routine_54;
say__p=1;ParaContent();  print (PrintText) SC_825; ParaContent();  new_line;  .L_Say711; .L_SayX676;
    rtrue;
];

[ text_routine_55;
say__p=1;ParaContent();  print (PrintText) SC_826; ParaContent();  new_line;  .L_Say712; .L_SayX677;
    rtrue;
];

[ text_routine_56;
say__p=1;ParaContent();  print (PrintText) (Global_Vars-->20);  .L_Say713; .L_SayX678;
    rtrue;
];

[ text_routine_57;
say__p=1;ParaContent();  print (PrintText) (Global_Vars-->20);  .L_Say714; .L_SayX679;
    rtrue;
];

[ text_routine_58;
say__p=1;ParaContent();  print (PrintText) SC_827; 
	if (~~(((((Global_Vars-->18) > 1))))) jump L_Say715;
		ParaContent();  print (PrintText) SC_828; 
	jump L_SayX680; .L_Say715;
		ParaContent();  print (PrintText) SC_829; 
	.L_Say716; .L_SayX680;
		 .L_Say717; .L_SayX681;
    rtrue;
];

[ text_routine_59;
say__p=1;
	if (~~(((((Global_Vars-->25) == 1))))) jump L_Say718;
		ParaContent();  print (PrintText) SC_830; 
	jump L_SayX682; .L_Say718;
		 .L_Say719; .L_SayX682;
    rtrue;
];

[ text_routine_60;
say__p=1;ParaContent(); (PHR_1091_r112 ()); .L_Say720; .L_SayX683;
    rtrue;
];

[ text_routine_61;
say__p=1;ParaContent(); (PHR_890_r100 ()); .L_Say721; .L_SayX684;
    rtrue;
];

[ text_routine_62;
say__p=1;
	if (~~(((((Global_Vars-->23) == 0))))) jump L_Say722;
		ParaContent();  print (PrintText) SC_831; 
	jump L_SayX685; .L_Say722;
		ParaContent();  print (PrintText) SC_832;  .L_Say723; .L_SayX685;
    rtrue;
];

[ text_routine_63;
say__p=1;ParaContent();  print (PrintText) SC_833; ParaContent();  print "["; ParaContent();  print (PrintText) SC_674; ParaContent();  print "]";  .L_Say724; .L_SayX686;
    rtrue;
];

[ text_routine_64;
say__p=1;ParaContent();  print (PrintText) SC_834; ParaContent();  print "["; ParaContent();  print (PrintText) SC_674; ParaContent();  print "]";  .L_Say725; .L_SayX687;
    rtrue;
];

[ text_routine_65;
say__p=1;ParaContent();  print (PrintText) SC_835; ParaContent();  print "["; ParaContent();  print (PrintText) SC_674; ParaContent();  print "]";  .L_Say726; .L_SayX688;
    rtrue;
];

[ text_routine_66;
say__p=1;ParaContent();  print (PrintText) SC_836; ParaContent();  print "["; ParaContent();  print (PrintText) SC_674; ParaContent();  print "]";  .L_Say727; .L_SayX689;
    rtrue;
];

[ text_routine_67;
say__p=1;ParaContent();  print (PrintText) SC_837; ParaContent();  print "["; ParaContent();  print (PrintText) SC_674; ParaContent();  print "]"; ParaContent();  print (PrintText) SC_477; ParaContent();  print "["; ParaContent();  print (PrintText) SC_674; ParaContent();  print "]";  .L_Say728; .L_SayX690;
    rtrue;
];

[ text_routine_68;
say__p=1;ParaContent();  print (PrintText) SC_838; ParaContent();  print "["; ParaContent();  print (PrintText) SC_839; ParaContent();  print "]";  .L_Say729; .L_SayX691;
    rtrue;
];

[ text_routine_69;
say__p=1;ParaContent();  print (PrintText) SC_840; ParaContent();  print "["; ParaContent();  print (PrintText) SC_674; ParaContent();  print "]"; ParaContent();  print (PrintText) SC_841; ParaContent();  print "["; ParaContent();  print (PrintText) SC_842; ParaContent();  print "]"; ParaContent();  print (PrintText) SC_327;  .L_Say730; .L_SayX692;
    rtrue;
];

[ text_routine_70;
say__p=1;ParaContent();  print (PrintShortName) real_location;  .L_Say731; .L_SayX693;
    rtrue;
];

[ text_routine_71;
say__p=1;ParaContent();  print (say__n=score); ParaContent();  print (PrintText) SC_598; ParaContent();  print (say__n=turns);  .L_Say732; .L_SayX694;
    rtrue;
];

[ text_routine_72;
say__p=1;ParaContent();  print (PrintText) SC_327; ParaContent();  I7_ST_say_one_of-->16 =
	i7_soo_par(I7_ST_say_one_of-->16, 3);
	switch((I7_ST_say_one_of-->16)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_843; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_844; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_845; ParaContent();  } ParaContent();  print (PrintText) SC_327;  .L_Say733; .L_SayX695;
    rtrue;
];

[ text_routine_73;
say__p=1;ParaContent();  print (PrintText) SC_327; ParaContent();  I7_ST_say_one_of-->17 =
	i7_soo_par(I7_ST_say_one_of-->17, 3);
	switch((I7_ST_say_one_of-->17)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_843; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_844; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_845; ParaContent();  } ParaContent();  print (PrintText) SC_327;  .L_Say734; .L_SayX696;
    rtrue;
];

[ text_routine_74;
say__p=1;ParaContent();  print (PrintText) SC_327; ParaContent();  I7_ST_say_one_of-->18 =
	i7_soo_par(I7_ST_say_one_of-->18, 3);
	switch((I7_ST_say_one_of-->18)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_843; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_844; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_845; ParaContent();  } ParaContent();  print (PrintText) SC_327;  .L_Say735; .L_SayX697;
    rtrue;
];

[ text_routine_75;
say__p=1;ParaContent();  print (PrintText) SC_327; ParaContent();  I7_ST_say_one_of-->19 =
	i7_soo_par(I7_ST_say_one_of-->19, 3);
	switch((I7_ST_say_one_of-->19)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_843; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_844; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_845; ParaContent();  } ParaContent();  print (PrintText) SC_327;  .L_Say736; .L_SayX698;
    rtrue;
];

[ text_routine_76;
say__p=1;ParaContent();  print (PrintText) SC_327; ParaContent();  I7_ST_say_one_of-->20 =
	i7_soo_par(I7_ST_say_one_of-->20, 3);
	switch((I7_ST_say_one_of-->20)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_843; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_844; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_845; ParaContent();  } ParaContent();  print (PrintText) SC_327;  .L_Say737; .L_SayX699;
    rtrue;
];

[ text_routine_77;
say__p=1;ParaContent();  print (PrintText) SC_327; ParaContent();  I7_ST_say_one_of-->21 =
	i7_soo_par(I7_ST_say_one_of-->21, 3);
	switch((I7_ST_say_one_of-->21)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_843; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_844; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_845; ParaContent();  } ParaContent();  print (PrintText) SC_327;  .L_Say738; .L_SayX700;
    rtrue;
];

[ text_routine_78;
say__p=1;ParaContent();  print (PrintText) SC_327; ParaContent();  I7_ST_say_one_of-->22 =
	i7_soo_tap(I7_ST_say_one_of-->22, 3);
	switch((I7_ST_say_one_of-->22)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_846; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_847; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_848; ParaContent();  } ParaContent();  print (PrintText) SC_327;  .L_Say739; .L_SayX701;
    rtrue;
];

[ text_routine_79;
say__p=1;ParaContent();  print (PrintText) SC_327; ParaContent();  I7_ST_say_one_of-->23 =
	i7_soo_tap(I7_ST_say_one_of-->23, 3);
	switch((I7_ST_say_one_of-->23)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_846; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_847; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_848; ParaContent();  } ParaContent();  print (PrintText) SC_327;  .L_Say740; .L_SayX702;
    rtrue;
];

[ text_routine_80;
say__p=1;ParaContent();  print (PrintText) SC_327; ParaContent();  I7_ST_say_one_of-->24 =
	i7_soo_par(I7_ST_say_one_of-->24, 3);
	switch((I7_ST_say_one_of-->24)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_843; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_844; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_845; ParaContent();  } ParaContent();  print (PrintText) SC_327;  .L_Say741; .L_SayX703;
    rtrue;
];

[ text_routine_81;
say__p=1;ParaContent();  print (PrintText) SC_327; ParaContent();  I7_ST_say_one_of-->25 =
	i7_soo_par(I7_ST_say_one_of-->25, 3);
	switch((I7_ST_say_one_of-->25)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_843; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_844; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_845; ParaContent();  } ParaContent();  print (PrintText) SC_327;  .L_Say742; .L_SayX704;
    rtrue;
];

[ text_routine_82;
say__p=1;ParaContent();  print (PrintText) SC_327; ParaContent();  I7_ST_say_one_of-->26 =
	i7_soo_par(I7_ST_say_one_of-->26, 3);
	switch((I7_ST_say_one_of-->26)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_843; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_844; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_845; ParaContent();  } ParaContent();  print (PrintText) SC_327;  .L_Say743; .L_SayX705;
    rtrue;
];

[ text_routine_83;
say__p=1;ParaContent();  print (PrintText) SC_327; ParaContent();  I7_ST_say_one_of-->27 =
	i7_soo_par(I7_ST_say_one_of-->27, 3);
	switch((I7_ST_say_one_of-->27)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_843; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_844; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_845; ParaContent();  } ParaContent();  print (PrintText) SC_327;  .L_Say744; .L_SayX706;
    rtrue;
];

[ text_routine_84;
say__p=1;ParaContent();  print (PrintText) SC_327; ParaContent();  I7_ST_say_one_of-->28 =
	i7_soo_par(I7_ST_say_one_of-->28, 3);
	switch((I7_ST_say_one_of-->28)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_843; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_844; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_845; ParaContent();  } ParaContent();  print (PrintText) SC_327;  .L_Say745; .L_SayX707;
    rtrue;
];

[ text_routine_85;
say__p=1;ParaContent();  print (PrintText) SC_327; ParaContent();  I7_ST_say_one_of-->29 =
	i7_soo_par(I7_ST_say_one_of-->29, 3);
	switch((I7_ST_say_one_of-->29)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_843; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_844; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_845; ParaContent();  } ParaContent();  print (PrintText) SC_327;  .L_Say746; .L_SayX708;
    rtrue;
];

[ text_routine_86;
say__p=1;ParaContent();  print (PrintText) SC_327; ParaContent();  I7_ST_say_one_of-->30 =
	i7_soo_tap(I7_ST_say_one_of-->30, 3);
	switch((I7_ST_say_one_of-->30)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_846; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_847; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_848; ParaContent();  } ParaContent();  print (PrintText) SC_327;  .L_Say747; .L_SayX709;
    rtrue;
];

[ text_routine_87;
say__p=1;ParaContent();  print (PrintText) SC_327; ParaContent();  I7_ST_say_one_of-->31 =
	i7_soo_tap(I7_ST_say_one_of-->31, 3);
	switch((I7_ST_say_one_of-->31)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_846; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_847; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_848; ParaContent();  } ParaContent();  print (PrintText) SC_327;  .L_Say748; .L_SayX710;
    rtrue;
];

[ text_routine_88;
say__p=1;ParaContent();  print (PrintText) SC_849; ParaContent();  print (PrintShortName) noun; ParaContent();  print (PrintText) SC_850; ParaContent();  print "["; ParaContent();  print (PrintText) SC_842; ParaContent();  print "]"; ParaContent();  print (PrintText) SC_257;  .L_Say749; .L_SayX711;
    rtrue;
];

[ text_routine_89;
say__p=1;ParaContent();  print (PrintText) SC_849; ParaContent();  print (PrintShortName) noun; ParaContent();  print (PrintText) SC_851; ParaContent();  print "["; ParaContent();  print (PrintText) SC_842; ParaContent();  print "]"; ParaContent();  print (PrintText) SC_257;  .L_Say750; .L_SayX712;
    rtrue;
];

[ text_routine_90;
say__p=1;ParaContent();  print (PrintText) SC_852; ParaContent();  print (PrintShortName) noun; ParaContent();  print (PrintText) SC_850; ParaContent();  print "["; ParaContent();  print (PrintText) SC_842; ParaContent();  print "]"; ParaContent();  print (PrintText) SC_257;  .L_Say751; .L_SayX713;
    rtrue;
];

[ text_routine_91;
say__p=1;ParaContent();  print (PrintText) SC_852; ParaContent();  print (PrintShortName) noun; ParaContent();  print (PrintText) SC_851; ParaContent();  print "["; ParaContent();  print (PrintText) SC_842; ParaContent();  print "]"; ParaContent();  print (PrintText) SC_257;  .L_Say752; .L_SayX714;
    rtrue;
];

[ text_routine_92;
say__p=1;ParaContent();  print (say__n=score); ParaContent();  print (PrintText) SC_598; ParaContent();  print (say__n=turns); ParaContent();  print (PrintText) SC_88; ParaContent();  print (PrintTimeOfDay) the_time; ParaContent();  print (PrintText) SC_596; ParaContent();  SL_Location();  .L_Say753; .L_SayX715;
    rtrue;
];

[ text_routine_93;
say__p=1;ParaContent(); @push self;  print (PrintShortName) GProperty(OBJECT_TY, self=real_location,map_region); @pull self;  .L_Say754; .L_SayX716;
    rtrue;
];

[ text_routine_94;
say__p=1;ParaContent(); (PHR_1219_r116 ()); .L_Say755; .L_SayX717;
    rtrue;
];

[ text_routine_95;
say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->73);  .L_Say756; .L_SayX718;
    rtrue;
];

[ text_routine_96;
say__p=1;ParaContent(); (PHR_1219_r116 ()); .L_Say757; .L_SayX719;
    rtrue;
];

[ text_routine_97;
say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->73);  .L_Say758; .L_SayX720;
    rtrue;
];

[ text_routine_98;
say__p=1;ParaContent(); (PHR_1219_r116 ()); .L_Say759; .L_SayX721;
    rtrue;
];

[ text_routine_99;
say__p=1;ParaContent();  print (PrintText) SC_136; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_787; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_788; ParaContent();  new_line; ParaContent();  print (PrintText) SC_789; 
	if (~~((((GProperty(SCENE_TY, I264_customercall,p80_venture) == I266_success))))) jump L_Say760;
		ParaContent();  print (PrintText) SC_199; ParaContent();  style bold; ParaContent();  print (PrintText) SC_790; ParaContent();  style roman; ParaContent(); 
	jump L_SayX722; .L_Say760; if (~~((((GProperty(SCENE_TY, I264_customercall,p80_venture) == I267_failure))))) jump L_Say761;
		ParaContent();  print (PrintText) SC_199; ParaContent();  style bold; ParaContent();  print (PrintText) SC_791; ParaContent();  style roman; 
	jump L_SayX722; .L_Say761;
		ParaContent();  print (PrintText) SC_201; 
	.L_Say762; .L_SayX722;
		ParaContent();  new_line; ParaContent();  print (PrintText) SC_792; 
	if (~~((((GProperty(SCENE_TY, I276_mrmason_call,p80_venture) == I266_success))))) jump L_Say763;
		ParaContent();  print (PrintText) SC_446; ParaContent();  style bold; ParaContent();  print (PrintText) SC_793; ParaContent();  style roman; ParaContent(); 
	jump L_SayX723; .L_Say763; if (~~((((GProperty(SCENE_TY, I276_mrmason_call,p80_venture) == I267_failure))))) jump L_Say764;
		ParaContent();  print (PrintText) SC_446; ParaContent();  style bold; ParaContent();  print (PrintText) SC_794; ParaContent();  style roman; ParaContent(); 
	jump L_SayX723; .L_Say764; if (~~((((GProperty(SCENE_TY, I276_mrmason_call,p80_venture) == I269_pending))))) jump L_Say765;
		ParaContent();  print (PrintText) SC_446; ParaContent();  style bold; ParaContent();  print (PrintText) SC_795; ParaContent();  style roman; 
	jump L_SayX723; .L_Say765;
		ParaContent();  print (PrintText) SC_201; 
	.L_Say766; .L_SayX723;
		 .L_Say767; .L_SayX724;
    rtrue;
];

[ text_routine_100
    t_0 ! Local variable e.g. 'T' = indexed text
    ;
t_0=LocalParking-->0;
    say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) t_0;  .L_Say768; .L_SayX725;
    rtrue;
];

[ text_routine_101
    t_0 ! Local variable e.g. 'T' = indexed text
    ;
t_0=LocalParking-->0;
    say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) t_0;  .L_Say769; .L_SayX726;
    rtrue;
];

[ text_routine_102
    t_0 ! Local variable e.g. 'T' = indexed text
    ;
t_0=LocalParking-->0;
    say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) t_0;  .L_Say770; .L_SayX727;
    rtrue;
];

[ text_routine_103
    t_0 ! Local variable e.g. 'T' = indexed text
    ;
t_0=LocalParking-->0;
    say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) t_0;  .L_Say771; .L_SayX728;
    rtrue;
];

[ text_routine_104
    t_0 ! Local variable e.g. 'T' = indexed text
    ;
t_0=LocalParking-->0;
    say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) t_0;  .L_Say772; .L_SayX729;
    rtrue;
];

[ text_routine_105
    t_0 ! Local variable e.g. 'T' = indexed text
    ;
t_0=LocalParking-->0;
    say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) t_0;  .L_Say773; .L_SayX730;
    rtrue;
];

[ text_routine_106
    t_0 ! Local variable e.g. 'T' = indexed text
    ;
t_0=LocalParking-->0;
    say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) t_0;  .L_Say774; .L_SayX731;
    rtrue;
];

[ text_routine_107
    t_0 ! Local variable e.g. 'T' = indexed text
    ;
t_0=LocalParking-->0;
    say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) t_0;  .L_Say775; .L_SayX732;
    rtrue;
];

[ text_routine_108
    t_0 ! Local variable e.g. 'T' = indexed text
    ;
t_0=LocalParking-->0;
    say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) t_0;  .L_Say776; .L_SayX733;
    rtrue;
];

[ text_routine_109
    t_0 ! Local variable e.g. 'T' = indexed text
    ;
t_0=LocalParking-->0;
    say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) t_0;  .L_Say777; .L_SayX734;
    rtrue;
];

[ text_routine_110
    t_0 ! Local variable e.g. 'T' = indexed text
    ;
t_0=LocalParking-->0;
    say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) t_0;  .L_Say778; .L_SayX735;
    rtrue;
];

[ text_routine_111
    t_0 ! Local variable e.g. 'T' = indexed text
    ;
t_0=LocalParking-->0;
    say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) t_0;  .L_Say779; .L_SayX736;
    rtrue;
];

[ text_routine_112
    t_0 ! Local variable e.g. 'T' = indexed text
    ;
t_0=LocalParking-->0;
    say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) t_0;  .L_Say780; .L_SayX737;
    rtrue;
];

[ text_routine_113
    t_0 ! Local variable e.g. 'T' = indexed text
    ;
t_0=LocalParking-->0;
    say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) t_0;  .L_Say781; .L_SayX738;
    rtrue;
];

[ text_routine_114
    t_0 ! Local variable e.g. 'T' = indexed text
    ;
t_0=LocalParking-->0;
    say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) t_0;  .L_Say782; .L_SayX739;
    rtrue;
];

[ text_routine_115
    t_0 ! Local variable e.g. 'T' = indexed text
    ;
t_0=LocalParking-->0;
    say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) t_0;  .L_Say783; .L_SayX740;
    rtrue;
];

[ text_routine_116
    t_0 ! Local variable e.g. 'T' = indexed text
    ;
t_0=LocalParking-->0;
    say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) t_0;  .L_Say784; .L_SayX741;
    rtrue;
];

[ text_routine_117
    t_0 ! Local variable e.g. 'T' = indexed text
    ;
t_0=LocalParking-->0;
    say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) t_0;  .L_Say785; .L_SayX742;
    rtrue;
];

[ text_routine_118
    t_0 ! Local variable e.g. 'T' = indexed text
    ;
t_0=LocalParking-->0;
    say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) t_0;  .L_Say786; .L_SayX743;
    rtrue;
];

[ text_routine_119
    t_0 ! Local variable e.g. 'T' = indexed text
    ;
t_0=LocalParking-->0;
    say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) t_0;  .L_Say787; .L_SayX744;
    rtrue;
];

[ text_routine_120
    t_0 ! Local variable e.g. 'T' = indexed text
    ;
t_0=LocalParking-->0;
    say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) t_0;  .L_Say788; .L_SayX745;
    rtrue;
];

[ text_routine_121
    t_0 ! Local variable e.g. 'T' = indexed text
    ;
t_0=LocalParking-->0;
    say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) t_0;  .L_Say789; .L_SayX746;
    rtrue;
];

[ text_routine_122
    t_0 ! Local variable e.g. 'T' = indexed text
    ;
t_0=LocalParking-->0;
    say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) t_0;  .L_Say790; .L_SayX747;
    rtrue;
];

[ text_routine_123
    t_0 ! Local variable e.g. 'T' = indexed text
    ;
t_0=LocalParking-->0;
    say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) t_0;  .L_Say791; .L_SayX748;
    rtrue;
];

[ text_routine_124;
say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->73);  .L_Say792; .L_SayX749;
    rtrue;
];

[ text_routine_125;
say__p=1;ParaContent(); (PHR_1219_r116 ()); .L_Say793; .L_SayX750;
    rtrue;
];

[ text_routine_126;
say__p=1;ParaContent();  print (INDEXED_TEXT_TY_Say) (Global_Vars-->73);  .L_Say794; .L_SayX751;
    rtrue;
];

[ text_routine_127;
say__p=1;ParaContent(); (PHR_1219_r116 ()); .L_Say795; .L_SayX752;
    rtrue;
];

[ text_routine_128;
say__p=1;ParaContent();  print (PrintText) SC_136; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_787; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_788; ParaContent();  new_line; ParaContent();  print (PrintText) SC_789; 
	if (~~((((GProperty(SCENE_TY, I264_customercall,p80_venture) == I266_success))))) jump L_Say796;
		ParaContent();  print (PrintText) SC_199; ParaContent();  style bold; ParaContent();  print (PrintText) SC_790; ParaContent();  style roman; ParaContent(); 
	jump L_SayX753; .L_Say796; if (~~((((GProperty(SCENE_TY, I264_customercall,p80_venture) == I267_failure))))) jump L_Say797;
		ParaContent();  print (PrintText) SC_199; ParaContent();  style bold; ParaContent();  print (PrintText) SC_791; ParaContent();  style roman; 
	jump L_SayX753; .L_Say797;
		ParaContent();  print (PrintText) SC_201; 
	.L_Say798; .L_SayX753;
		ParaContent();  new_line; ParaContent();  print (PrintText) SC_792; 
	if (~~((((GProperty(SCENE_TY, I276_mrmason_call,p80_venture) == I266_success))))) jump L_Say799;
		ParaContent();  print (PrintText) SC_446; ParaContent();  style bold; ParaContent();  print (PrintText) SC_793; ParaContent();  style roman; ParaContent(); 
	jump L_SayX754; .L_Say799; if (~~((((GProperty(SCENE_TY, I276_mrmason_call,p80_venture) == I267_failure))))) jump L_Say800;
		ParaContent();  print (PrintText) SC_446; ParaContent();  style bold; ParaContent();  print (PrintText) SC_794; ParaContent();  style roman; ParaContent(); 
	jump L_SayX754; .L_Say800; if (~~((((GProperty(SCENE_TY, I276_mrmason_call,p80_venture) == I269_pending))))) jump L_Say801;
		ParaContent();  print (PrintText) SC_446; ParaContent();  style bold; ParaContent();  print (PrintText) SC_795; ParaContent();  style roman; 
	jump L_SayX754; .L_Say801;
		ParaContent();  print (PrintText) SC_201; 
	.L_Say802; .L_SayX754;
		 .L_Say803; .L_SayX755;
    rtrue;
];

[ text_routine_129;
say__p=1;ParaContent();  I7_ST_say_one_of-->32 =
	i7_soo_stop(I7_ST_say_one_of-->32, 2);
	switch((I7_ST_say_one_of-->32)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_853; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_854; ParaContent();  }  .L_Say804; .L_SayX756;
    rtrue;
];

[ text_routine_130
    t_0 ! Call parameter 'text-to-be-printed' = indexed text
    t_1 ! Local variable e.g. 'N' = number
    ;
t_0=LocalParking-->0;
t_1=LocalParking-->1;
    say__p=1;ParaContent();  new_line;  .L_Say805; .L_SayX757;
    rtrue;
];

[ text_routine_131
    t_0 ! Call parameter 'text-to-be-printed' = indexed text
    t_1 ! Local variable e.g. 'N' = number
    ;
t_0=LocalParking-->0;
t_1=LocalParking-->1;
    say__p=1;ParaContent();  DivideParagraphPoint(); new_line;  .L_Say806; .L_SayX758;
    rtrue;
];









[ ChronologyPoint pt;
	for (pt=0:pt<NO_PAST_TENSE_CONDS:pt++)
		past_chronological_record-->pt = present_chronological_record-->pt;
];

[ UPDATE_CHRONOLOGICAL_RECORDS_R pt;
	for (pt=0: pt<NO_PAST_TENSE_CONDS: pt++) TestSinglePastState(false, pt, true, -1);
	ChronologyPoint();
	rfalse;
];

[ PAPR_0 ;
if ((action ==##Go) &&  (actor==player) && ((noun == I46_north) && (true)) && (self=actor,true) && (( (WhetherIn(I252_corridor)) ))) rtrue;
    rfalse;
];
[ PAPR_1 ;
if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun == I273_rollerdex) && (true))) rtrue;
    rfalse;
];
[ PAPR_2 ;
if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun == I273_rollerdex) && (true))) rtrue;
    rfalse;
];
[ PAPR_3 ;
if ((action ==##Take) &&  (actor==player) && ((noun == I258_office_phone) && (true)) && (self=actor,true) && (( (matched_text=SnippetIncludes(Consult_Grammar_347,players_command)) ))) rtrue;
    rfalse;
];
[ PAPR_4 ;
if ((action ==##A109_saying_hello_to) &&  (actor==player) && ((noun == I259_customer) && (true))) rtrue;
    rfalse;
];
[ PAPR_5 ;
if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,1)) == I240_highway) && (true)) && (self=actor,true) && ((((Adj_34_t1_v9(I183_lily_sbroom)))))) rtrue;
    rfalse;
];
[ PAPR_6 ;
if ((action ==##A125_using) &&  (actor==player) && ((noun == I258_office_phone) && (true))) rtrue;
    rfalse;
];
[ PAPR_7 ;
if ((action ==##A128_flipping) &&  (actor==player)) rtrue;
    rfalse;
];
[ PAPR_8 ;
if ((action ==##A128_flipping) &&  (actor==player)) rtrue;
    rfalse;
];
Array PastActionsI6Routines --> PAPR_0 PAPR_1 PAPR_2 PAPR_3 PAPR_4 PAPR_5 PAPR_6 PAPR_7 PAPR_8 0 0;

Constant NO_PAST_TENSE_CONDS 12;
Constant NO_PAST_TENSE_ACTIONS 9;

[ TestSinglePastState past_flag pt turn_end wanted
	old new trips consecutives ct_0 ct_1 I7BASPL;
	if (past_flag) {
		new = (past_chronological_record-->pt) & 1;
		trips = ((past_chronological_record-->pt) & $$11111110)/2;
		consecutives = ((past_chronological_record-->pt) & $$111111100000000)/256;
	} else {
		old = (present_chronological_record-->pt) & 1;
		trips = ((present_chronological_record-->pt) & $$11111110)/2;
		consecutives = ((present_chronological_record-->pt) & $$111111100000000)/256;
! Test cases for conditions by PT number: each sets "new" to whether it is true or false now
I7BASPL = blockv_sp;
blockv_sp = blockv_sp + 16;
switch(pt) {
    0: new = (((I234_ferrari_enzo == ContainerOf(player))));
    1: new = (((I201_garage == ContainerOf(I234_ferrari_enzo))));
    2: new = ((((Adj_75_t1_v9(I235_start_button)))));
    3: new = (((I234_ferrari_enzo == ContainerOf(player))));
    4: new = (((I244_grunnings_carpark == ContainerOf(I233_car))));
    5: new = (((I183_lily_sbroom == SupporterOf(player))));
    6: new = ((((Global_Vars-->71) == 1)));
    7: new = (((real_location == I240_highway)));
    8: new = ((((Adj_75_t1_v9(I324_television)))));
    9: new = (((real_location == I240_highway)));
    10: new = ((((Adj_75_t1_v9(I324_television)))));
    11: new = ((((Adj_44_t1_v9(I147_attic)))));
    default: print "*** No such past tense condition ***^"; new = false;
}
blockv_sp = blockv_sp - 16;

		if (new == false) {
			consecutives = 0;
		} else {
			if (old == false) { trips++; if (trips > 127) trips = 127; }
			if (turn_end) { consecutives++; if (consecutives > 127) consecutives = 127; }
		}
		present_chronological_record-->pt = new + 2*trips + 256*consecutives;
	}
	! print pt, ": old=", old, " new=", new, " trips=", trips, " consec=", consecutives,
	!	" wanted=", wanted, "^";
	switch(wanted) {
		0: if (new) return new;
		1: if (new) return trips;
		2: if (new) return consecutives+1; ! Plus one because we count the current turn
		4: return new;
		5: return trips;
		6: return consecutives;
	}
	return 0;
];

[ TrackActions readjust oow ct_0 ct_1 i;
	for (i=0: PastActionsI6Routines-->i: i++) {
		if ((PastActionsI6Routines-->i).call()) {
			! Yes, the current action matches action pattern i:
			if (readjust) continue;
			(TimesActionHasHappened-->i)++;
			if (LastTurnActionHappenedOn-->i ~= turns + 5) {
				LastTurnActionHappenedOn-->i = turns + 5;
				ActionCurrentlyHappeningFlag->i = 1;
				if (keep_silent == false)
					(TurnsActionHasBeenHappening-->i)++;
			}
		} else {
			! No, the current action doesn't match action pattern i:
			if (oow == false) {
				if (keep_silent == false) { TurnsActionHasBeenHappening-->i = 0; }
				if (LastTurnActionHappenedOn-->i ~= turns + 5)
					ActionCurrentlyHappeningFlag->i = 0;
			}
		}
	}
];

Array TimesActionHasHappened-->(NO_PAST_TENSE_ACTIONS+1);
Array TurnsActionHasBeenHappening-->(NO_PAST_TENSE_ACTIONS+1);
Array LastTurnActionHappenedOn-->(NO_PAST_TENSE_ACTIONS+1);
Array ActionCurrentlyHappeningFlag->(NO_PAST_TENSE_ACTIONS+1);

Array past_chronological_record-->(NO_PAST_TENSE_CONDS+1);
Array present_chronological_record-->(NO_PAST_TENSE_CONDS+1);




[ GPR_Line_189
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    original_wn = wn; rv = GPR_PREPOSITION;
        w = ParseTokenStopped(ELEMENTARY_TT, TOPIC_TOKEN);
        if (w == GPR_FAIL) jump Fail_1; rv = w;
        return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ GPR_Line_208
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'harry') jump Fail_1;
        if (NextWordStopped() ~= 'potter') jump Fail_1;
        return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
        group_wn = wn;
        .group_3_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'harry') jump group_3_1_2;
        jump group_3_1_end;
        .group_3_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'potter') jump group_3_1_3;
        jump group_3_1_end;
        .group_3_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'lily') jump group_3_1_4;
        jump group_3_1_end;
        .group_3_1_4; wn = group_wn;
        if (NextWordStopped() ~= 'james') jump group_3_1_5;
        jump group_3_1_end;
        .group_3_1_5; wn = group_wn;
        if (NextWordStopped() ~= 'wizards') jump group_3_1_6;
        jump group_3_1_end;
        .group_3_1_6; wn = group_wn;
        if (NextWordStopped() ~= 'wizard') jump group_3_1_7;
        jump group_3_1_end;
        .group_3_1_7; wn = group_wn;
        if (NextWordStopped() ~= 'potters') jump Fail_2;
        .group_3_1_end;
        return rv;
        .Fail_2; rv = GPR_PREPOSITION; wn = original_wn;
        group_wn = wn;
        .group_4_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'witch') jump group_4_1_2;
        jump group_4_1_end;
        .group_4_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'witches') jump group_4_1_3;
        jump group_4_1_end;
        .group_4_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'magic') jump group_4_1_4;
        jump group_4_1_end;
        .group_4_1_4; wn = group_wn;
        if (NextWordStopped() ~= 'sister') jump group_4_1_5;
        jump group_4_1_end;
        .group_4_1_5; wn = group_wn;
        if (NextWordStopped() ~= 'family') jump group_4_1_6;
        jump group_4_1_end;
        .group_4_1_6; wn = group_wn;
        if (NextWordStopped() ~= 'hogwarts') jump group_4_1_7;
        jump group_4_1_end;
        .group_4_1_7; wn = group_wn;
        if (NextWordStopped() ~= 'dementors') jump Fail_3;
        .group_4_1_end;
        return rv;
        .Fail_3; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

Verb 'take' 'carry' 'hold'
    * 'inventory'  -> Inv
    * noun=Noun_Filter_0  -> Take
    * multi  -> Take
    * 'off' noun  -> Disrobe
    * noun 'off'  -> Disrobe
    * multiinside 'from' noun  -> Remove
    * multiinside 'off' noun  -> Remove
;
Verb 'get'
    * 'out' / 'off' / 'down' / 'up'  -> Exit
    * 'in' / 'on'  -> Enter
    * multi  -> Take
    * 'in' / 'into' / 'on' / 'onto' noun  -> Enter
    * 'off' / 'down' noun  -> GetOff
    * 'to' noun  -> Enter
    * 'under' scope=Scope_Filter_1  -> A82_going_under
    * Cond_Token_240 'out' 'of' 'bed'  -> Exit
    * Cond_Token_241 'out' 'of' 'red'  -> Exit
    * Cond_Token_242 'out' 'of' 'blue'  -> Exit
    * Cond_Token_243 'out' 'of' 'rainbow'  -> Exit
    * Cond_Token_244 'out' 'of' 'green'  -> Exit
    * Cond_Token_245 'out' 'of' 'ferrari'  -> Exit
    * Cond_Token_246 'out' 'of' 'car'  -> Exit
    * Cond_Token_247 'out' 'of' 'elevator'  -> Exit
    * Cond_Token_250 'out' 'of' 'lift'  -> Exit
    * multiinside 'from' noun  -> Remove
    * Cond_Token_248 'out' 'of' 'the' 'lift'  -> Exit
    * Cond_Token_249 'out' 'of' 'the' 'elevator'  -> Exit
    * 'out' 'from' 'under' scope=Scope_Filter_2  -> A83_getting_out_from_under
    * Cond_Token_360 topic  -> A126_responding_to_customer
;
Verb 'pick'
    * 'up' multi  -> Take
    * multi 'up'  -> Take
;
Verb 'stand'
    *  -> A120_standing_up
    * 'up'  -> A120_standing_up
    * 'on' / 'in' noun  -> A117_standing_up_on
;
Verb 'remove'
    * held  -> Disrobe
    * multiinside 'from' noun  -> Remove
    * Cond_Token_189 multi 'from' 'play'  -> A96_removing
    * Cond_Token_188 scope=Scope_Filter_3 'from' 'play'  -> A96_removing
;
Verb 'shed' 'doff' 'disrobe'
    * held  -> Disrobe
;
Verb 'wear' 'don'
    * held  -> Wear
;
Verb 'put'
    * 'on' held  -> Wear
    * held 'on'  -> Wear
    * 'down' multiheld  -> Drop
    * multiheld 'down'  -> Drop
    * multiexcept 'in' / 'inside' / 'into' noun  -> Insert
    * multiexcept 'on' / 'onto' noun  -> PutOn
    * scope=Scope_Filter_4 'under' scope=Scope_Filter_5  -> A80_putting_it_under
    * Cond_Token_181 scope=Scope_Filter_6 'back' 'in' scope=Scope_Filter_7  -> A91_putting_back
    * Cond_Token_182 scope=Scope_Filter_8 'back' 'on' scope=Scope_Filter_9  -> A91_putting_back
    * Cond_Token_183 scope=Scope_Filter_10 'back' 'in' scope=Scope_Filter_11  -> A91_putting_back
;
Verb 'insert'
    * multiexcept 'in' / 'into' noun  -> Insert
;
Verb 'drop' 'throw' 'discard'
    * multiheld  -> Drop
    * held 'at' / 'against' noun  -> ThrowAt
    * multiexcept 'in' / 'into' / 'down' noun  -> Insert
    * multiexcept 'on' / 'onto' noun  -> PutOn
;
Verb 'give' 'pay' 'offer' 'feed'
    * creature noun=Noun_Filter_12  -> A97_paying_wizard_money
    * creature held  -> Give reverse
    * creature multiheld  -> Give reverse
    * noun=Noun_Filter_13 'for' noun  -> A97_paying_wizard_money reverse
    * held 'to' creature  -> Give
;
Verb 'show' 'present' 'display'
    * creature held  -> Show reverse
    * held 'to' creature  -> Show
;
Verb 'go' 'walk' 'run'
    *  -> Go
    * noun=Noun_Filter_14  -> Go
    * noun  -> Enter
    * 'into' / 'in' / 'inside' / 'through' noun  -> Enter
    * 'down' noun  -> Go
    * 'up' noun  -> Go
    * 'to' noun  -> Enter
    * 'under' scope=Scope_Filter_15  -> A82_going_under
;
Verb 'inventory' 'i//' 'inv'
    *  -> Inv
    * 'want' noun  -> A132_wanting
    * Cond_Token_381 topic  -> A126_responding_to_customer
;
Verb 'look' 'l//'
    *  -> Look
    * 'around'  -> Look
    * noun=Noun_Filter_16  -> Examine
    * noun  -> Examine
    * 'out' noun=Noun_Filter_17  -> Examine
    * 'in' noun=Noun_Filter_18  -> Examine
    * 'in' noun=Noun_Filter_19  -> Examine
    * 'out' noun=Noun_Filter_20  -> Examine
    * 'out' noun=Noun_Filter_21  -> Examine
    * 'at' noun  -> Examine
    * 'inside' / 'in' / 'into' / 'through' noun  -> Search
    * 'under' noun  -> LookUnder
    * 'up' topic 'in' noun  -> Consult reverse
;
Verb 'consult'
    * noun 'on' / 'about' topic  -> Consult
;
Verb 'open' 'unwrap' 'uncover'
    * Cond_Token_184 'sesame'  -> A92_universal_opening
    * noun  -> Open
    * noun 'with' held  -> Unlock
;
Verb 'close' 'shut' 'cover'
    * noun  -> Close
    * 'up' noun  -> Close
    * 'off' noun  -> SwitchOff
;
Verb 'enter' 'cross'
    *  -> Enter
    * noun  -> Enter
;
Verb 'sit'
    *  -> A119_sitting_down
    * 'down'  -> A119_sitting_down
    * 'up'  -> A119_sitting_down
    * 'on' / 'in' noun  -> A115_sitting_on
;
Verb 'exit' 'leave' 'out'
    *  -> Exit
;
Verb 'examine' 'x//' 'watch' 'describe' 'check'
    * noun  -> Examine
;
Verb 'read'
    * noun  -> Examine
    * 'about' topic 'in' noun  -> Consult reverse
    * topic 'in' noun  -> Consult reverse
;
Verb 'yes' 'y//'
    *  -> Yes
    * 'you' 'can'  -> Yes
;
Verb 'no'
    *  -> No
;
Verb 'sorry'
    *  -> Sorry
;
Verb 'bother' 'curses' 'drat' 'darn'
    *  -> Mild
;
Verb 'shit' 'fuck' 'damn'
    *  -> Strong
;
Verb 'search'
    * noun  -> Search
;
Verb 'wave'
    *  -> WaveHands
    * noun  -> Wave
;
Verb 'set' 'adjust'
    * noun 'to' topic  -> SetTo
;
Verb 'pull' 'drag'
    * noun  -> Pull
;
Verb 'push' 'move' 'shift' 'clear' 'press'
    * noun=Noun_Filter_28  -> SwitchOn
    * noun=Noun_Filter_29  -> SwitchOn
    * noun=Noun_Filter_30  -> SwitchOn
    * noun=Noun_Filter_31  -> SwitchOn
    * noun=Noun_Filter_32  -> SwitchOn
    * noun=Noun_Filter_33  -> SwitchOn
    * noun=Noun_Filter_34  -> SwitchOn
    * noun=Noun_Filter_35  -> SwitchOn
    * noun  -> Push
    * 'the' 'screen'  -> A131_clearing_the_screen
    * noun noun=Noun_Filter_22  -> PushDir
    * noun 'to' noun=Noun_Filter_23  -> PushDir
    * Cond_Token_179 multi 'to' multi  -> A90_moving_to
    * Cond_Token_178 scope=Scope_Filter_24 'to' scope=Scope_Filter_25  -> A90_moving_to
    * Cond_Token_180 scope=Scope_Filter_26 'to' scope=Scope_Filter_27  -> A90_moving_to
;
Verb 'turn' 'rotate' 'twist' 'unscrew' 'screw'
    * noun=Noun_Filter_36  -> A128_flipping
    * noun  -> Turn
    * noun 'on'  -> SwitchOn
    * 'on' noun  -> SwitchOn
    * noun 'off'  -> SwitchOff
    * 'off' noun  -> SwitchOff
;
Verb 'switch'
    * noun=Noun_Filter_37  -> SwitchOff
    * noun  -> SwitchOn
    * 'on' noun  -> SwitchOn
    * noun 'on'  -> SwitchOn
    * noun 'off'  -> SwitchOff
    * 'off' noun  -> SwitchOff
;
Verb 'lock'
    * noun 'with' held  -> Lock
;
Verb 'unlock'
    * noun 'with' held  -> Unlock
;
Verb 'attack' 'break' 'smash' 'hit' 'fight' 'torture' 'wreck' 'crack' 'destroy' 'murder' 'kill' 'punch' 'thump'
    * noun  -> Attack
;
Verb 'wait' 'z//'
    *  -> Wait
;
Verb 'answer' 'say' 'shout' 'speak'
    * 'hello' / 'hi'  -> A110_hailing
    * 'hello'  -> A109_saying_hello_to
    * 'hello' / 'hi' 'to' noun  -> A109_saying_hello_to
    * 'bye' / 'goodbye' / 'farewell' / 'cheerio' 'to' creature  -> A112_saying_goodbye_to
    * topic 'to' creature  -> Answer reverse
;
Verb 'tell'
    * creature 'about' scope=Scope_Filter_38  -> A102_informing_it_about
    * creature 'about' topic  -> Tell
    * creature 'that' topic  -> Answer
    * creature topic  -> Answer
;
Verb 'ask'
    * 'about' scope=Scope_Filter_41  -> A105_implicit_quizzing
    * 'for' scope=Scope_Filter_42  -> A107_implicit_requesting
    * creature 'for' scope=Scope_Filter_39  -> A99_requesting_it_for
    * creature 'about' scope=Scope_Filter_40  -> A101_quizzing_it_about
    * creature 'about' 'the' topic  -> A100_imploring_it_for
    * creature 'about' topic  -> Ask
    * creature 'for' topic  -> A100_imploring_it_for
    * creature 'about' topic  -> A100_imploring_it_for
    * creature 'of' topic  -> Ask
    * 'about' topic  -> A103_implicit_asking
    * 'for' topic  -> A108_implicit_imploring
    * Cond_Token_357 topic  -> A126_responding_to_customer
;
Verb 'eat'
    * held  -> Eat
;
Verb 'sleep' 'nap'
    *  -> Sleep
;
Verb 'sing'
    *  -> Sing
;
Verb 'climb' 'scale'
    * noun=Noun_Filter_43  -> Go
    * noun  -> Climb
    * noun  -> Climb
    * 'up' / 'over' noun  -> Climb
    * 'up' noun  -> Climb
;
Verb 'buy' 'purchase'
    * noun  -> Buy
;
Verb 'squeeze' 'squash'
    * noun  -> Squeeze
;
Verb 'swing'
    * noun  -> Swing
    * 'on' noun  -> Swing
;
Verb 'wake' 'awake' 'awaken'
    *  -> Wake
    * 'up'  -> Wake
    * creature  -> WakeOther
    * creature 'up'  -> WakeOther
    * 'up' creature  -> WakeOther
;
Verb 'kiss' 'embrace' 'hug'
    * creature  -> Kiss
;
Verb 'think'
    *  -> Think
;
Verb 'smell' 'sniff'
    *  -> Smell
    * noun  -> Smell
;
Verb 'listen'
    *  -> Listen
    * 'to' noun  -> Listen
;
Verb 'hear'
    * noun  -> Listen
;
Verb 'taste'
    * noun  -> Taste
;
Verb 'touch' 'feel'
    * noun  -> Touch
;
Verb 'rub' 'shine' 'polish' 'sweep' 'clean' 'dust' 'wipe' 'scrub'
    * noun  -> Rub
    * noun  -> Rub
;
Verb 'tie' 'attach' 'fasten'
    * noun 'to' noun  -> Tie
;
Verb 'burn' 'light'
    * noun  -> Burn
;
Verb 'drink' 'swallow' 'sip'
    * noun  -> Drink
    * 'from' noun  -> Drink
    * 'out' 'of' noun  -> Drink
;
Verb 'cut' 'slice' 'prune' 'chop'
    * noun  -> Cut
;
Verb 'jump' 'skip' 'hop'
    *  -> Jump
    * noun=Noun_Filter_48  -> A137_jumping_out_of
    * noun=Noun_Filter_49  -> A137_jumping_out_of
    * 'out' noun=Noun_Filter_46  -> A137_jumping_out_of
    * 'out' noun=Noun_Filter_47  -> A137_jumping_out_of
    * 'out' 'of' noun=Noun_Filter_44  -> A137_jumping_out_of
    * 'out' 'of' noun=Noun_Filter_45  -> A137_jumping_out_of
;
Verb 'score'
    *  -> Score
;
Verb 'quit'
    *  -> Quit
;
Verb 'q//'
    *  -> Quit
;
Verb 'save'
    *  -> Save
;
Verb 'restart'
    *  -> Restart
;
Verb 'restore'
    *  -> Restore
    * 'score'  -> A95_restoring_score
;
Verb 'verify'
    *  -> Verify
;
Verb 'version'
    *  -> Version
;
Verb 'script'
    *  -> ScriptOn
    * 'on'  -> ScriptOn
    * 'off'  -> ScriptOff
;
Verb 'transcript'
    *  -> ScriptOn
    * 'on'  -> ScriptOn
    * 'off'  -> ScriptOff
;
Verb 'superbrief'
    *  -> LMode3
;
Verb 'short'
    *  -> LMode3
;
Verb 'verbose'
    *  -> LMode2
;
Verb 'long'
    *  -> LMode2
;
Verb 'brief'
    *  -> LMode1
;
Verb 'normal'
    *  -> LMode1
;
Verb 'nouns'
    *  -> Pronouns
;
Verb 'pronouns'
    *  -> Pronouns
;
Verb 'notify'
    *  -> NotifyOn
    * 'on'  -> NotifyOn
    * 'off'  -> NotifyOff
;
Verb 'hide'
    * scope=Scope_Filter_50 'under' scope=Scope_Filter_51  -> A80_putting_it_under
;
Verb 'ride'
    * noun  -> A84_mounting
;
Verb 'mount'
    *  -> A84_mounting
    * noun  -> A84_mounting
;
Verb 'dismount'
    *  -> A85_dismounting
    *  -> A85_dismounting
    * Cond_Token_253 'broom'  -> A85_dismounting
    * Cond_Token_286 'broom'  -> A85_dismounting
;
Verb 'help'
    *  -> A86_asking_for_help
;
Verb 'about'
    *  -> A86_asking_for_help
;
Verb 'info'
    *  -> A86_asking_for_help
;
Verb 'setting'
    *  -> A86_asking_for_help
;
Verb 'settings'
    *  -> A86_asking_for_help
;
Verb 'cheats'
    * 'on'  -> A87_switching_cheats_on
    * 'off'  -> A88_switching_cheats_off
;
Verb 'apparate'
    * 'to' scope=Scope_Filter_52  -> A89_teleporting_to
;
Verb 'teleport'
    * 'to' scope=Scope_Filter_53  -> A89_teleporting_to
;
Verb 'change'
    * Cond_Token_185 'to' scope=Scope_Filter_54  -> A93_changing_player
;
Verb 'increase'
    * Cond_Token_186 'score' 'by' DECIMAL_TOKEN  -> A94_point_increasing
;
Verb 'no.verb'
    * noun=Noun_Filter_55  -> Go
    * Cond_Token_355 DECIMAL_TOKEN  -> A113_dialling_it_on
    * DECIMAL_TOKEN  -> A98_inputting
    * Cond_Token_372 topic  -> A127_saying
    * Cond_Token_389 topic  -> A126_responding_to_customer
    * Cond_Token_397 topic  -> A130_writing_on
;
Verb 'a//'
    * scope=Scope_Filter_56  -> A105_implicit_quizzing
    * Cond_Token_384 topic  -> A126_responding_to_customer
    * topic  -> A103_implicit_asking
;
Verb 't//'
    * scope=Scope_Filter_57  -> A106_implicit_informing
    * topic  -> A104_implicit_telling
;
Verb 'talk'
    * 'to' noun  -> A109_saying_hello_to
    * 'about' scope=Scope_Filter_58  -> A106_implicit_informing
    * 'to' creature 'about' 'the' topic  -> Tell
    * 'to' creature 'about' topic  -> Tell
;
Verb 'greet'
    * noun  -> A109_saying_hello_to
;
Verb 'hello'
    *  -> A110_hailing
    * noun=Noun_Filter_59  -> A109_saying_hello_to
;
Verb 'hi'
    *  -> A110_hailing
;
Verb 'bye'
    *  -> A111_leavetaking
    * noun=Noun_Filter_60  -> A112_saying_goodbye_to
;
Verb 'goodbye'
    *  -> A111_leavetaking
    * noun=Noun_Filter_61  -> A112_saying_goodbye_to
;
Verb 'cheerio'
    *  -> A111_leavetaking
;
Verb 'farewell'
    *  -> A111_leavetaking
;
Verb 'dial' 'call' 'phone' 'telephone'
    * DECIMAL_TOKEN  -> A113_dialling_it_on
    * DECIMAL_TOKEN 'on' / 'using' noun  -> A113_dialling_it_on
;
Verb 'hang'
    * 'up'  -> A114_hanging_up
    * 'up' 'phone'  -> A114_hanging_up
;
Verb 'lie'
    * 'down'  -> A118_lying_down
    * 'on' / 'in' noun  -> A116_lying_on
;
Verb 'hints'
    *  -> A122_asking_for_hints
;
Verb 'hint'
    *  -> A122_asking_for_hints
;
Verb 'up'
    * noun  -> Go
    * noun  -> Go
;
Verb 'down'
    * noun  -> Go
    * noun  -> Climb
    * noun  -> Go
;
Verb 'howdy'
    *  -> A110_hailing
    * noun=Noun_Filter_62  -> A109_saying_hello_to
;
Verb 'good'
    * 'morning' noun=Noun_Filter_63  -> A109_saying_hello_to
    * 'afternoon' noun=Noun_Filter_64  -> A109_saying_hello_to
;
Verb 'how'
    * 'are' 'you' noun=Noun_Filter_65  -> A109_saying_hello_to
    * 'are' 'you' 'going' noun=Noun_Filter_66  -> A109_saying_hello_to
    * 'are' 'you' 'going' noun=Noun_Filter_67  -> A109_saying_hello_to
    * 'are' 'you' 'doing' noun=Noun_Filter_68  -> A109_saying_hello_to
;
Verb 'how^s'
    * 'it' 'going' noun=Noun_Filter_69  -> A109_saying_hello_to
;
Verb 'morning'
    * noun=Noun_Filter_70  -> A109_saying_hello_to
;
Verb 'i^ll'
    * 'be' 'off' noun=Noun_Filter_72  -> A112_saying_goodbye_to
    * 'be' 'off' 'then' noun=Noun_Filter_71  -> A112_saying_goodbye_to
;
Verb 'byebye'
    *  -> A112_saying_goodbye_to
;
Verb 'consume'
    * noun  -> Eat
;
Verb 'drive'
    * noun=Noun_Filter_73  -> Go
    * 'car' noun=Noun_Filter_74  -> Go
    * 'ferrari' noun=Noun_Filter_75  -> Go
    * 'enzo' noun=Noun_Filter_76  -> Go
    * 'through' noun  -> Go
    * 'ferrari' 'enzo' noun=Noun_Filter_77  -> Go
;
Verb 'fly'
    * noun=Noun_Filter_78  -> Go
    * 'broom' noun=Noun_Filter_79  -> Go
    * 'broomstick' noun=Noun_Filter_80  -> Go
;
Verb 'carjack'
    * noun  -> A124_carjacking
;
Verb 'hijack'
    * noun  -> A124_carjacking
;
Verb 'ring'
    * DECIMAL_TOKEN  -> A113_dialling_it_on
;
Verb 'use'
    * noun  -> A125_using
;
Verb 'and'
    * Cond_Token_356 topic  -> A126_responding_to_customer
;
Verb 'try'
    * 'dialling' DECIMAL_TOKEN  -> A113_dialling_it_on
    * 'calling' DECIMAL_TOKEN  -> A113_dialling_it_on
    * 'ringing' DECIMAL_TOKEN  -> A113_dialling_it_on
    * Cond_Token_358 topic  -> A126_responding_to_customer
    * Cond_Token_380 topic  -> A126_responding_to_customer
;
Verb 'then'
    * Cond_Token_359 topic  -> A126_responding_to_customer
;
Verb 'next'
    * Cond_Token_361 topic  -> A126_responding_to_customer
;
Verb 'sure'
    *  -> Yes
    * 'you' 'can'  -> Yes
;
Verb 'fine'
    *  -> Yes
;
Verb 'you'
    * 'can'  -> Yes
;
Verb 'ok'
    *  -> Yes
;
Verb 'why'
    * 'not'  -> Yes
;
Verb 'flip'
    * noun=Noun_Filter_81  -> A128_flipping
;
Verb 'reccomend'
    * Cond_Token_382 topic  -> A126_responding_to_customer
;
Verb 'the'
    * Cond_Token_383 topic  -> A126_responding_to_customer
;
Verb 'hal'
    * Cond_Token_385 topic  -> A126_responding_to_customer
;
Verb 't1000'
    * Cond_Token_386  -> A126_responding_to_customer
;
Verb 'bk'
    * Cond_Token_387 topic  -> A126_responding_to_customer
;
Verb 'qz'
    * Cond_Token_388 topic  -> A126_responding_to_customer
;
Verb 'write'
    * 'on' scope=Scope_Filter_82  -> A129_writing_intro
    * 'in' scope=Scope_Filter_83  -> A129_writing_intro
    * Mistake_Token_394 'on' noun 'with' noun  -> MistakeAction
    * Mistake_Token_396 'in' noun 'with' noun  -> MistakeAction
    * Mistake_Token_393 topic 'on' noun  -> MistakeAction
    * Mistake_Token_395 topic 'in' noun  -> MistakeAction
;
Verb 'can'
    * 'i//' 'have' noun  -> A132_wanting
;
Verb 'play'
    * noun  -> A133_playing
    * 'with' noun  -> A133_playing
;
Verb 'ruminesce'
    *  -> Think
;
Verb 'ponder'
    *  -> Think
;
Verb 'wonder'
    *  -> Think
;
Verb 'worry'
    *  -> Think
;
Verb 'philosophise'
    *  -> Think
;
Verb 'reminisce'
    *  -> Think
;
Verb 'mull'
    * 'over'  -> Think
;
Verb 'inquire'
    * creature 'about' topic  -> A100_imploring_it_for
    * topic 'of' creature  -> A100_imploring_it_for reverse
;
Verb 'thank'
    * 'you'  -> A135_thanking_with_no_noun
    * creature  -> A134_thanking
    * 'you' creature  -> A134_thanking
;
Verb 'thanks'
    *  -> A135_thanking_with_no_noun
    * creature  -> A134_thanking
;
Verb 'thankyou'
    *  -> A135_thanking_with_no_noun
;
Verb 'flibbertigibbet'
    * Cond_Token_438  -> A136_dursley_s_spellcasting
;
Verb 'expelliarmus'
    * Cond_Token_439  -> A136_dursley_s_spellcasting
;
Verb 'avada'
    * Cond_Token_440 'kadavra'  -> A136_dursley_s_spellcasting
;
Verb 'expecto'
    * Cond_Token_441 'patronum'  -> A136_dursley_s_spellcasting
;
Verb 'abra'
    * Cond_Token_442 'cadabra'  -> A136_dursley_s_spellcasting
;
Verb 'alohamora'
    * Cond_Token_443  -> A136_dursley_s_spellcasting
;
Verb 'wingardium'
    * Cond_Token_444 'leviosa'  -> A136_dursley_s_spellcasting
;
Verb 'incendio'
    * Cond_Token_445  -> A136_dursley_s_spellcasting
;
Verb 'xyzzy'
    * Cond_Token_446  -> A136_dursley_s_spellcasting
;
Verb 'squiggly'
    * Cond_Token_447 'wiggly'  -> A136_dursley_s_spellcasting
;
Verb 'stupefy'
    * Cond_Token_448  -> A136_dursley_s_spellcasting
;
Verb 'steal'
    * noun  -> Take
;
Verb 'time'
    *  -> A138_timing
    * 'of' 'day'  -> A138_timing
;
Verb 'loook'
    *  -> Look
;
Verb 'load'
    *  -> Restore
;
[ Parse_Name_GV1
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV2
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV3
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV4
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV5
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV6
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV7
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV8
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV9
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV10
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV11
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV12
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV120
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV126
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'bedroom') jump Fail_1;
                if (NextWordStopped() ~= 'window') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV127
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV128
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV129
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV130
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV131
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV132
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV133
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'work') jump Fail_1;
                if (NextWordStopped() ~= 'clothes') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV134
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'bedroom') jump Fail_1;
                if (NextWordStopped() ~= 'door') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV135
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV136
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV137
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV138
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV139
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'latched') jump Fail_1;
                if (NextWordStopped() ~= 'panel') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                if (Cond_Token_279() == GPR_FAIL) jump Fail_2;
                if (NextWordStopped() ~= 'ceiling') jump Fail_2;
                if (NextWordStopped() ~= 'panel') jump Fail_2;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
                if (Cond_Token_282() == GPR_FAIL) jump Fail_3;
                if (NextWordStopped() ~= 'latched') jump Fail_3;
                if (NextWordStopped() ~= 'panel') jump Fail_3;
                try_from_wn = wn; f = true; continue;
                .Fail_3; wn = try_from_wn;
                if (NextWordStopped() ~= 'attic') jump Fail_4;
                if (NextWordStopped() ~= 'stairs') jump Fail_4;
                try_from_wn = wn; f = true; continue;
                .Fail_4; wn = try_from_wn;
                if (Cond_Token_281() == GPR_FAIL) jump Fail_5;
                if (NextWordStopped() ~= 'panel') jump Fail_5;
                try_from_wn = wn; f = true; continue;
                .Fail_5; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV142
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (Cond_Token_279() == GPR_FAIL) jump Fail_1;
                if (NextWordStopped() ~= 'ceiling') jump Fail_1;
                if (NextWordStopped() ~= 'panel') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                if (Cond_Token_282() == GPR_FAIL) jump Fail_2;
                if (NextWordStopped() ~= 'latched') jump Fail_2;
                if (NextWordStopped() ~= 'panel') jump Fail_2;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
                if (NextWordStopped() ~= 'attic') jump Fail_3;
                if (NextWordStopped() ~= 'stairs') jump Fail_3;
                try_from_wn = wn; f = true; continue;
                .Fail_3; wn = try_from_wn;
                if (Cond_Token_281() == GPR_FAIL) jump Fail_4;
                if (NextWordStopped() ~= 'panel') jump Fail_4;
                try_from_wn = wn; f = true; continue;
                .Fail_4; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV143
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV144
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV145
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV153
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV154
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'kitchen') jump Fail_1;
                if (NextWordStopped() ~= 'table') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV156
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV157
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV158
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV159
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'garage') jump Fail_1;
                if (NextWordStopped() ~= 'door') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                if (NextWordStopped() ~= 'garage') jump Fail_2;
                if (NextWordStopped() ~= 'door') jump Fail_2;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV160
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV161
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'car') jump Fail_1;
                if (NextWordStopped() ~= 'door') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                if (Cond_Token_324() == GPR_FAIL) jump Fail_2;
                if (NextWordStopped() ~= 'door') jump Fail_2;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV164
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'elevator') jump Fail_1;
                if (NextWordStopped() ~= 'button') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV167
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (Cond_Token_279() == GPR_FAIL) jump Fail_1;
                if (NextWordStopped() ~= 'ceiling') jump Fail_1;
                if (NextWordStopped() ~= 'panel') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                if (Cond_Token_282() == GPR_FAIL) jump Fail_2;
                if (NextWordStopped() ~= 'latched') jump Fail_2;
                if (NextWordStopped() ~= 'panel') jump Fail_2;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
                if (NextWordStopped() ~= 'attic') jump Fail_3;
                if (NextWordStopped() ~= 'stairs') jump Fail_3;
                try_from_wn = wn; f = true; continue;
                .Fail_3; wn = try_from_wn;
                if (Cond_Token_281() == GPR_FAIL) jump Fail_4;
                if (NextWordStopped() ~= 'panel') jump Fail_4;
                try_from_wn = wn; f = true; continue;
                .Fail_4; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV169
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV180
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV182
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV191
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'shop') jump Fail_1;
                if (NextWordStopped() ~= 'door') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV192
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (Cond_Token_400() == GPR_FAIL) jump Fail_1;
                if (NextWordStopped() ~= 'mr') jump Fail_1;
                if (NextWordStopped() ~= 'finnigan') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                if (Cond_Token_401() == GPR_FAIL) jump Fail_2;
                if (NextWordStopped() ~= 'finnigan') jump Fail_2;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV193
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV194
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV197
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV198
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV206
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV212
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV224
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV225
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV226
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV227
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Consult_Grammar_232
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'restart') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_233
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'restore') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_234
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'amusing') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_235
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'quit') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_236
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'undo') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_237
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'good') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_238
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'great') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_239
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'epic') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_240
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'awesome') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_241
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'fine') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_242
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'well') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_243
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'bad') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_244
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'terrible') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_245
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'i//') jump Fail_1;
        if (NextWordStopped() ~= 'feel') jump Fail_1;
        if (NextWordStopped() ~= 'good') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_246
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'i//') jump Fail_1;
        if (NextWordStopped() ~= 'feel') jump Fail_1;
        if (NextWordStopped() ~= 'great') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_247
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'i//') jump Fail_1;
        if (NextWordStopped() ~= 'feel') jump Fail_1;
        if (NextWordStopped() ~= 'epic') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_248
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'i//') jump Fail_1;
        if (NextWordStopped() ~= 'feel') jump Fail_1;
        if (NextWordStopped() ~= 'awesome') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_249
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'i//') jump Fail_1;
        if (NextWordStopped() ~= 'feel') jump Fail_1;
        if (NextWordStopped() ~= 'fine') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_250
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'i//') jump Fail_1;
        if (NextWordStopped() ~= 'feel') jump Fail_1;
        if (NextWordStopped() ~= 'well') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_251
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'i//') jump Fail_1;
        if (NextWordStopped() ~= 'feel') jump Fail_1;
        if (NextWordStopped() ~= 'bad') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_252
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'i//') jump Fail_1;
        if (NextWordStopped() ~= 'feel') jump Fail_1;
        if (NextWordStopped() ~= 'terrible') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_253
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'call') jump Fail_1;
        if (NextWordStopped() ~= '8953') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_254
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'try') jump Fail_1;
        if (NextWordStopped() ~= 'calling') jump Fail_1;
        if (NextWordStopped() ~= '8953') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_255
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'try') jump Fail_1;
        if (NextWordStopped() ~= 'dialling') jump Fail_1;
        if (NextWordStopped() ~= '8953') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_256
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'try') jump Fail_1;
        if (NextWordStopped() ~= 'ringing') jump Fail_1;
        if (NextWordStopped() ~= '8953') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_257
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'call') jump Fail_1;
        if (NextWordStopped() ~= '8953') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_258
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'try') jump Fail_1;
        if (NextWordStopped() ~= 'calling') jump Fail_1;
        if (NextWordStopped() ~= '8953') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_259
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'try') jump Fail_1;
        if (NextWordStopped() ~= 'dialling') jump Fail_1;
        if (NextWordStopped() ~= '8953') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_260
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'try') jump Fail_1;
        if (NextWordStopped() ~= 'ringing') jump Fail_1;
        if (NextWordStopped() ~= '8953') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_261
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'ask') jump Fail_1;
        if (NextWordStopped() ~= 'them') jump Fail_1;
        if (NextWordStopped() ~= 'for') jump Fail_1;
        if (NextWordStopped() ~= 'the') jump Fail_1;
        if (NextWordStopped() ~= 'bk') jump Fail_1;
        if (NextWordStopped() ~= '44') jump Fail_1;
        if (NextWordStopped() ~= 'model') jump Fail_1;
        if (NextWordStopped() ~= 't//') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_262
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'ask') jump Fail_1;
        if (NextWordStopped() ~= 'them') jump Fail_1;
        if (NextWordStopped() ~= 'for') jump Fail_1;
        if (NextWordStopped() ~= 'the') jump Fail_1;
        if (NextWordStopped() ~= 'hal') jump Fail_1;
        if (NextWordStopped() ~= '6502') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_263
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'ask') jump Fail_1;
        if (NextWordStopped() ~= 'them') jump Fail_1;
        if (NextWordStopped() ~= 'for') jump Fail_1;
        if (NextWordStopped() ~= 'the') jump Fail_1;
        if (NextWordStopped() ~= 'qz') jump Fail_1;
        if (NextWordStopped() ~= '77') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_264
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'ask') jump Fail_1;
        if (NextWordStopped() ~= 'them') jump Fail_1;
        if (NextWordStopped() ~= 'for') jump Fail_1;
        if (NextWordStopped() ~= 'the') jump Fail_1;
        if (NextWordStopped() ~= 't1000') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_265
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'xc912') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_266
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'xc914') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_267
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'xc913') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_268
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'yes') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_269
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'no') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_270
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'sorry') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_271
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'drink') jump Fail_1;
        if (NextWordStopped() ~= 'coffee') jump Fail_1;
        if (NextWordStopped() ~= 'cup') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_272
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'drink') jump Fail_1;
        if (NextWordStopped() ~= 'cup') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_273
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'pyjamas') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_274
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'hal') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_275
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= '6502') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_276
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'bk') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_277
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= '44') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_278
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'qz') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_279
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= '77') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_280
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 't1000') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_281
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'write') jump Fail_1;
        if (NextWordStopped() ~= 'on') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_282
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'write') jump Fail_1;
        if (NextWordStopped() ~= 'in') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_283
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'handbook') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_284
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'drive') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_285
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'fly') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_286
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'good') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_287
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'morning') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_288
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'herself') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_289
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'himself') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_290
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'hang') jump Fail_1;
        if (NextWordStopped() ~= 'up') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_291
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'call') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_292
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'dial') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_293
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'ring') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_294
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'put') jump Fail_1;
        if (NextWordStopped() ~= 'me') jump Fail_1;
        if (NextWordStopped() ~= 'under') jump Fail_1;
        w = ParseTokenStopped(SCOPE_TT, Scope_Filter_84);
        if (w == GPR_FAIL) jump Fail_1; rv = w;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_295
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'steal') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_296
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'good') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_297
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'morning') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_298
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'eat') jump Fail_1;
        if (NextWordStopped() ~= 'me') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_299
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'get') jump Fail_1;
        if (NextWordStopped() ~= 'in') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_300
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'push') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_301
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'elevator') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_302
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'press') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_303
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'write') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_304
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'look') jump Fail_1;
        if (NextWordStopped() ~= 'chairs') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_305
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'sit') jump Fail_1;
        if (NextWordStopped() ~= 'down') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_306
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'unlock') jump Fail_1;
        if (NextWordStopped() ~= 'case') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_307
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'unlock') jump Fail_1;
        if (NextWordStopped() ~= 'suitcase') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_308
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'cross') jump Fail_1;
        if (NextWordStopped() ~= 'road') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_309
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'cross') jump Fail_1;
        if (NextWordStopped() ~= 'highway') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_310
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'cross') jump Fail_1;
        if (NextWordStopped() ~= 'street') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_311
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'look') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_312
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'wave') jump Fail_1;
        if (NextWordStopped() ~= 'wand') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_313
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'kill') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_314
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        w = ParseTokenStopped(GPR_TT, GPR_Line_208);
        if (w == GPR_FAIL) jump Fail_1;
        if (w ~= GPR_PREPOSITION) rv = w;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_315
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        w = ParseTokenStopped(GPR_TT, GPR_Line_208);
        if (w == GPR_FAIL) jump Fail_1;
        if (w ~= GPR_PREPOSITION) rv = w;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_316
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        w = ParseTokenStopped(GPR_TT, GPR_Line_208);
        if (w == GPR_FAIL) jump Fail_1;
        if (w ~= GPR_PREPOSITION) rv = w;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_317
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'climb') jump Fail_1;
        if (NextWordStopped() ~= 'up') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_318
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'climb') jump Fail_1;
        if (NextWordStopped() ~= 'down') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_319
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'climb') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_320
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        w = ParseTokenStopped(GPR_TT, GPR_Line_208);
        if (w == GPR_FAIL) jump Fail_1;
        if (w ~= GPR_PREPOSITION) rv = w;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_321
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'hal') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_322
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= '6502') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_323
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'bk') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_324
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= '44') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_325
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'qz') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_326
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= '77') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_327
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 't1000') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_328
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'hal') jump Fail_1;
        if (NextWordStopped() ~= '6502') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_329
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'hal') jump Fail_1;
        if (NextWordStopped() ~= '6502') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_330
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 't1000') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_331
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 't1000') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_332
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'bk') jump Fail_1;
        if (NextWordStopped() ~= '44') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_333
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'bk') jump Fail_1;
        if (NextWordStopped() ~= '44') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_334
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'qz') jump Fail_1;
        if (NextWordStopped() ~= '77') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_335
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'xc912') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_336
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'expelliarmus') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_337
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'avada') jump Fail_1;
        if (NextWordStopped() ~= 'kadavra') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_338
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'expecto') jump Fail_1;
        if (NextWordStopped() ~= 'patronum') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_339
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'wingardium') jump Fail_1;
        if (NextWordStopped() ~= 'leviosa') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_340
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'expelliarmus') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_341
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'avada') jump Fail_1;
        if (NextWordStopped() ~= 'kadavra') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_342
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'expecto') jump Fail_1;
        if (NextWordStopped() ~= 'patronum') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_343
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'wingardium') jump Fail_1;
        if (NextWordStopped() ~= 'leviosa') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_344
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'incendio') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_345
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'xyzzy') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_346
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'squiggly') jump Fail_1;
        if (NextWordStopped() ~= 'wiggly') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_347
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'pick') jump Fail_1;
        if (NextWordStopped() ~= 'up') jump Fail_1;
        if (NextWordStopped() ~= 'phone') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];



#IFTRUE (1 == 1);
[ UnknownVerb; verb_wordnum = 0; return 'no.verb'; ];
[ PrintVerb v;
	if (v == 'no.verb') { print "do something to"; rtrue; }
	rfalse;
];
#Ifnot;
[ UnknownVerb; rfalse; ]; [ PrintVerb v; rfalse; ];
#ENDIF;


Array Rel_Record_63 -->
    REL_BLOCK_HEADER
    RELATION_TY
    NULL NULL
    "leading-through relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_X_UNIQUE+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     door_to KD4_relation_of_rooms_to_doors Rel_Handler_63 "Leading-through relates one room (called the other side) to various doors";
[ Rel_Handler_63 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST: if (X == (Y.door_to)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK1_First: Z1: Z1=Z1.IK1_Link) {
                if (Rel_Handler_63(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(9);
        } else {
            for (Z1=IK4_First: Z1: Z1=Z1.IK4_Link) {
                if (Rel_Handler_63(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(9);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK1_First: Z1: Z1=Z1.IK1_Link) {
                if (Rel_Handler_63(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK4_First: Z1: Z1=Z1.IK4_Link) {
                if (Rel_Handler_63(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK1_First: Z1: Z1=Z1.IK1_Link) {
                for (Z3=IK4_First: Z3: Z3=Z3.IK4_Link) {
                    if (Rel_Handler_63(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK1_First: Z1: Z1=Z1.IK1_Link) {
                for (Z3=IK4_First: Z3: Z3=Z3.IK4_Link) {
                    if (Rel_Handler_63(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: Y.door_to = X; rtrue;
        RELS_ASSERT_FALSE: Relation_NowN1toV(Y,door_to,X); rtrue;
        RELS_SHOW: Relation_RShowOtoO(rr, false); rtrue;
        RELS_ROUTE_FIND: return OtoVRelRouteTo(rr-->RR_STORAGE, X, Y);
        RELS_ROUTE_FIND_COUNT: return RelFollowVector(OtoVRelRouteTo(rr-->RR_STORAGE, X, Y), X, Y);
    }
    rfalse;
];
Array Rel_Record_65 -->
    REL_BLOCK_HEADER
    RELATION_TY
    NULL NULL
    "lock-fitting relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_X_UNIQUE+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     with_key KD5_relation_of_things_to_thin Rel_Handler_65 "Lock-fitting relates one thing (called the matching key) to various things";
[ Rel_Handler_65 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST: if (X == (Y.with_key)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_65(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(9);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_65(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(9);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_65(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_65(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_65(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_65(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: Y.with_key = X; rtrue;
        RELS_ASSERT_FALSE: Relation_NowN1toV(Y,with_key,X); rtrue;
        RELS_SHOW: Relation_RShowOtoO(rr, false); rtrue;
        RELS_ROUTE_FIND: return OtoVRelRouteTo(rr-->RR_STORAGE, X, Y);
        RELS_ROUTE_FIND_COUNT: return RelFollowVector(OtoVRelRouteTo(rr-->RR_STORAGE, X, Y), X, Y);
    }
    rfalse;
];
Array Rel_Record_67 -->
    REL_BLOCK_HEADER
    RELATION_TY
    NULL NULL
    "underlying relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_Y_UNIQUE+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     p59_underlying KD5_relation_of_things_to_thin Rel_Handler_67 "Underlying relates various things to one thing";
[ Rel_Handler_67 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST: if (Y == (X.p59_underlying)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_67(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(9);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_67(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(9);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_67(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_67(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_67(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_67(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: X.p59_underlying = Y; rtrue;
        RELS_ASSERT_FALSE: Relation_NowN1toV(X,p59_underlying,Y); rtrue;
        RELS_SHOW: Relation_ShowOtoO(rr, false); rtrue;
        RELS_ROUTE_FIND: return VtoORelRouteTo(rr-->RR_STORAGE, X, Y);
        RELS_ROUTE_FIND_COUNT: return RelFollowVector(VtoORelRouteTo(rr-->RR_STORAGE, X, Y), X, Y);
    }
    rfalse;
];
Array Rel_Record_69 -->
    REL_BLOCK_HEADER
    RELATION_TY
    NULL NULL
    "connection relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_SYMMETRIC+RELS_X_UNIQUE+RELS_Y_UNIQUE+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     p72_other_party KD6_relation_of_people_to_peop Rel_Handler_69 "Connection relates one person to another (called the other party)";
[ Rel_Handler_69 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST: if (X == (Y.p72_other_party)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_69(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(9);
        } else {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_69(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(9);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_69(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_69(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK8_First: Z3: Z3=Z3.IK8_Link) {
                    if (Rel_Handler_69(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK8_First: Z3: Z3=Z3.IK8_Link) {
                    if (Rel_Handler_69(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: Relation_NowS1to1(Y,p72_other_party,X); rtrue;
        RELS_ASSERT_FALSE: Relation_NowSN1to1(Y,p72_other_party,X); rtrue;
        RELS_SHOW: Relation_ShowOtoO(rr, true); rtrue;
    }
    rfalse;
];
Array Rel_Record_71 -->
    REL_BLOCK_HEADER
    RELATION_TY
    NULL NULL
    "posture-permission relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     V2V_Bitmap_71 KD7_relation_of_things_to_post Rel_Handler_71 "Posture-permission relates various things to various postures";
[ Rel_Handler_71 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST: if ((Relation_TestVtoV(X,Rel_Record_71,Y,false))) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_71(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(9);
        } else {
            for (Z1=1: Z1<=3: Z1++) {
                if (Rel_Handler_71(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(46);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_71(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=1: Z1<=3: Z1++) {
                if (Rel_Handler_71(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=1: Z3<=3: Z3++) {
                    if (Rel_Handler_71(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=1: Z3<=3: Z3++) {
                    if (Rel_Handler_71(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: (Relation_NowVtoV(X,Rel_Record_71,Y,false)); rtrue;
        RELS_ASSERT_FALSE: (Relation_NowNVtoV(X,Rel_Record_71,Y,false)); rtrue;
        RELS_SHOW: Relation_ShowVtoV(rr, false); rtrue;
        RELS_ROUTE_FIND: return VtoVRelRouteTo(rr, X, Y);
        RELS_ROUTE_FIND_COUNT: return VtoVRelRouteTo(rr, X, Y, true);
    }
    rfalse;
];
[ CreateDynamicRelations i rel;
];

! Abstraction for set of x such that:
! [ telephone(x) ]
[ Prop_0 reason x x_ix total counter selection best best_with;
    if (reason >= 0) { x = reason; reason = -1; }
    switch (reason) {
        -6: ! Find the extremal x satisfying:
            if (property_loop_sign>0) best=MIN_NEGATIVE_NUMBER;
            else best=MAX_POSITIVE_NUMBER;
            for (x=IK29_First: x: x=x.IK29_Link){
                if (property_loop_sign>0) {
                    if (x.property_to_be_totalled >= best) {
                        best = x.property_to_be_totalled;
                        best_with = x;
                    }
                } else {
                    if (x.property_to_be_totalled <= best) {
                        best = x.property_to_be_totalled;
                        best_with = x;
                    }
                }
                .NextOuterLoop_3;
            }
            return best_with;
        -5: ! Find a total property value over all x satisfying:
            for (x=IK29_First: x: x=x.IK29_Link){
                total = total + x.property_to_be_totalled;
                jump NextOuterLoop_6;
                .NextOuterLoop_6;
            }
            return total;
        -4: ! Find a random x satisfying:
            selection = -1;
            while (true) {
                counter = 0;
                for (x=IK29_First: x: x=x.IK29_Link){
                    counter++;
                    if (counter == selection) return x;
                    jump NextOuterLoop_7;
                    .NextOuterLoop_7;
                }
                if ((counter == 0) || (selection >= 0)) return nothing;
                selection = random(counter);
            }
        -3: ! How many x satisfy this?
            for (x=IK29_First: x: x=x.IK29_Link){
                counter++;
                jump NextOuterLoop_5;
                .NextOuterLoop_5;
            }
            return counter;
        -2: ! Find next x satisfying:
            if (x_ix > 0) {
                x_ix--;
                jump NextOuterLoop_4;
            }
            if (x) jump NextOuterLoop_4;
            for (x=IK29_First: x: x=x.IK29_Link){
                return x;
                .NextOuterLoop_4;
            }
            return nothing;
        -1: ! True or false?
            if ((x ofclass K29_telephone)){
                rtrue;
            }
            rfalse;
    }
];

! Abstraction for set of x such that:
! [ telephone(x) ]
[ Prop_1 reason x x_ix total counter selection best best_with;
    if (reason >= 0) { x = reason; reason = -1; }
    switch (reason) {
        -6: ! Find the extremal x satisfying:
            if (property_loop_sign>0) best=MIN_NEGATIVE_NUMBER;
            else best=MAX_POSITIVE_NUMBER;
            for (x=IK29_First: x: x=x.IK29_Link){
                if (property_loop_sign>0) {
                    if (x.property_to_be_totalled >= best) {
                        best = x.property_to_be_totalled;
                        best_with = x;
                    }
                } else {
                    if (x.property_to_be_totalled <= best) {
                        best = x.property_to_be_totalled;
                        best_with = x;
                    }
                }
                .NextOuterLoop_3;
            }
            return best_with;
        -5: ! Find a total property value over all x satisfying:
            for (x=IK29_First: x: x=x.IK29_Link){
                total = total + x.property_to_be_totalled;
                jump NextOuterLoop_6;
                .NextOuterLoop_6;
            }
            return total;
        -4: ! Find a random x satisfying:
            selection = -1;
            while (true) {
                counter = 0;
                for (x=IK29_First: x: x=x.IK29_Link){
                    counter++;
                    if (counter == selection) return x;
                    jump NextOuterLoop_7;
                    .NextOuterLoop_7;
                }
                if ((counter == 0) || (selection >= 0)) return nothing;
                selection = random(counter);
            }
        -3: ! How many x satisfy this?
            for (x=IK29_First: x: x=x.IK29_Link){
                counter++;
                jump NextOuterLoop_5;
                .NextOuterLoop_5;
            }
            return counter;
        -2: ! Find next x satisfying:
            if (x_ix > 0) {
                x_ix--;
                jump NextOuterLoop_4;
            }
            if (x) jump NextOuterLoop_4;
            for (x=IK29_First: x: x=x.IK29_Link){
                return x;
                .NextOuterLoop_4;
            }
            return nothing;
        -1: ! True or false?
            if ((x ofclass K29_telephone)){
                rtrue;
            }
            rfalse;
    }
];

! Abstraction for set of x such that:
! [ telephone(x) ]
[ Prop_2 reason x x_ix total counter selection best best_with;
    if (reason >= 0) { x = reason; reason = -1; }
    switch (reason) {
        -6: ! Find the extremal x satisfying:
            if (property_loop_sign>0) best=MIN_NEGATIVE_NUMBER;
            else best=MAX_POSITIVE_NUMBER;
            for (x=IK29_First: x: x=x.IK29_Link){
                if (property_loop_sign>0) {
                    if (x.property_to_be_totalled >= best) {
                        best = x.property_to_be_totalled;
                        best_with = x;
                    }
                } else {
                    if (x.property_to_be_totalled <= best) {
                        best = x.property_to_be_totalled;
                        best_with = x;
                    }
                }
                .NextOuterLoop_3;
            }
            return best_with;
        -5: ! Find a total property value over all x satisfying:
            for (x=IK29_First: x: x=x.IK29_Link){
                total = total + x.property_to_be_totalled;
                jump NextOuterLoop_6;
                .NextOuterLoop_6;
            }
            return total;
        -4: ! Find a random x satisfying:
            selection = -1;
            while (true) {
                counter = 0;
                for (x=IK29_First: x: x=x.IK29_Link){
                    counter++;
                    if (counter == selection) return x;
                    jump NextOuterLoop_7;
                    .NextOuterLoop_7;
                }
                if ((counter == 0) || (selection >= 0)) return nothing;
                selection = random(counter);
            }
        -3: ! How many x satisfy this?
            for (x=IK29_First: x: x=x.IK29_Link){
                counter++;
                jump NextOuterLoop_5;
                .NextOuterLoop_5;
            }
            return counter;
        -2: ! Find next x satisfying:
            if (x_ix > 0) {
                x_ix--;
                jump NextOuterLoop_4;
            }
            if (x) jump NextOuterLoop_4;
            for (x=IK29_First: x: x=x.IK29_Link){
                return x;
                .NextOuterLoop_4;
            }
            return nothing;
        -1: ! True or false?
            if ((x ofclass K29_telephone)){
                rtrue;
            }
            rfalse;
    }
];

! Find a random x satisfying:
! [ telephone(x) & 'inuse'(x) & can-touch('player', x) ]
[ Prop_3  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK29_First: x: x=x.IK29_Link){
            if (((Adj_89_t1_v9(x))) && (TestTouchability(player,x))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! Find a random x satisfying:
! [ rideable animal(x) & is(x, CarrierOf('person asked')) ]
[ Prop_4  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=nothing: false: ){
            if ((x == CarrierOf(actor))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! Find a random x satisfying:
! [ rideable vehicle(x) & is(x, SupporterOf('person asked')) ]
[ Prop_5  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK22_First: x: x=x.IK22_Link){
            if ((x == SupporterOf(actor))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! True or false?
! [ Exists x : thing(x) & called='under-contents'(x) & is((x.p59_underlying), 'noun') ]
[ Prop_6  x x_ix ;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((x.p59_underlying) == noun)){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];

! Force this to be true via 'now':
! [ DoesNotExist x IN[ thing(x) IN] : is((x.p59_underlying), 'noun') ]
[ Prop_7  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK2_First: x: x=x.IK2_Link){
        qcn_0++;
        Relation_NowN1toV(x,p59_underlying,noun);
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];

! True or false?
! [ Exists x : person(x) & is('player', (x.p72_other_party)) ]
[ Prop_8  x x_ix ;
    for (x=IK8_First: x: x=x.IK8_Link){
        if ((player == (x.p72_other_party))){
            rtrue;
        }
    }
    rfalse;
];

! How many x satisfy this?
! [ telephone(x) & 'inuse'(x) & is('player', HolderOf(x)) ]
[ Prop_9  x x_ix counter;
    for (x=IK29_First: x: x=x.IK29_Link){
        if (((Adj_89_t1_v9(x))) && (player == HolderOf(x))){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! True or false?
! [ Exists x : broom(x) & is('player', CarrierOf(x)) ]
[ Prop_10  x x_ix ;
    objectloop (x in player) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K40_broom)){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : clothing(x) & is('player', WearerOf(x)) ]
[ Prop_11  x x_ix ;
    objectloop (x in player) if (WearerOf(x)==parent(x)){
        if ((x ofclass K30_clothing)){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : person(x) & is('player', (x.p72_other_party)) ]
[ Prop_12  x x_ix ;
    for (x=IK8_First: x: x=x.IK8_Link){
        if ((player == (x.p72_other_party))){
            rtrue;
        }
    }
    rfalse;
];

! How many x satisfy this?
! [ person(x) & 'visible'(x) & NOT[ is(x, 'player') NOT] ]
[ Prop_13  x x_ix counter;
    for (x=IK8_First: x: x=x.IK8_Link){
        if (((Adj_3_t1_v9(x)))){
            if (~~((x == player))){
                counter++;
                jump NextOuterLoop_5;
            }
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! Find a random x satisfying:
! [ person(x) & 'visible'(x) & NOT[ is(x, 'player') NOT] ]
[ Prop_14  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK8_First: x: x=x.IK8_Link){
            if (((Adj_3_t1_v9(x)))){
                if (~~((x == player))){
                    counter++;
                    if (counter == selection) return x;
                    jump NextOuterLoop_7;
                }
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! Force this to be true via 'now':
! [ DoesNotExist x IN[ thing(x) IN] : is(('player'.p59_underlying), x) ]
[ Prop_15  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK2_First: x: x=x.IK2_Link){
        qcn_0++;
        Relation_NowN1toV(player,p59_underlying,x);
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];

! True or false?
! [ Exists x : penquill(x) & is('player', CarrierOf(x)) ]
[ Prop_16  x x_ix ;
    objectloop (x in player) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K51_penquill)){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ DoesNotExist x IN[ vehicle(x) IN] : is(x, ContainerOf('player')) ]
[ Prop_17  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK14_First: x: x=x.IK14_Link){
        qcn_0++;
        if ((x == ContainerOf(player))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ Exists x : person(x) & is('player', (x.p72_other_party)) ]
[ Prop_18  x x_ix ;
    for (x=IK8_First: x: x=x.IK8_Link){
        if ((player == (x.p72_other_party))){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : vehicle(x) & road(ContainerOf(x)) ]
[ Prop_19  x x_ix ;
    for (x=IK14_First: x: x=x.IK14_Link){
        if ((ContainerOf(x) ofclass K43_road)){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : rideable vehicle(x) & road(ContainerOf(x)) ]
[ Prop_20  x x_ix ;
    for (x=IK22_First: x: x=x.IK22_Link){
        if ((ContainerOf(x) ofclass K43_road)){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & called='target'(x) & posture-permission(x, 'reclining') & is(const_0, ContainerOf(x)) ]
[ Prop_21  const_0 x x_ix ;
    for (x=TestContainmentRange(const_0): x: x=TestContainmentRange(const_0,x)){
        if ((x ofclass K2_thing) && ((Relation_TestVtoV(x,Rel_Record_71,I117_reclining,false)))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & called='better target'(x) & 'enterable'(x) & 'reclining'(x) & is(const_0, ContainerOf(x)) ]
[ Prop_22  const_0 x x_ix ;
    for (x=TestContainmentRange(const_0): x: x=TestContainmentRange(const_0,x)){
        if ((x ofclass K2_thing) && ((Adj_62_t1_v9(x))) && ((Adj_92_t1_v9(x)))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & called='target'(x) & posture-permission(x, 'seated') & is(const_0, ContainerOf(x)) ]
[ Prop_23  const_0 x x_ix ;
    for (x=TestContainmentRange(const_0): x: x=TestContainmentRange(const_0,x)){
        if ((x ofclass K2_thing) && ((Relation_TestVtoV(x,Rel_Record_71,I115_seated,false)))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & called='better target'(x) & 'enterable'(x) & 'seated'(x) & is(const_0, ContainerOf(x)) ]
[ Prop_24  const_0 x x_ix ;
    for (x=TestContainmentRange(const_0): x: x=TestContainmentRange(const_0,x)){
        if ((x ofclass K2_thing) && ((Adj_62_t1_v9(x))) && ((Adj_90_t1_v9(x)))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Card>=6 x IN[ thing(x) IN] : is('player', CarrierOf(x)) ]
[ Prop_25  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK2_First: x: x=x.IK2_Link){
        qcn_0++;
        if ((player == CarrierOf(x))){
            qcy_0++;
        }
    }
    if (qcy_0 >= 6){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ Card>=6 x IN[ thing(x) IN] : is('player', WearerOf(x)) ]
[ Prop_26  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK2_First: x: x=x.IK2_Link){
        qcn_0++;
        if ((player == WearerOf(x))){
            qcy_0++;
        }
    }
    if (qcy_0 >= 6){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & is('player', WearerOf(x)) ]
[ Prop_27  x x_ix ;
    objectloop (x in player) if (WearerOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & thing((x.p59_underlying)) ]
[ Prop_28  x x_ix ;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((x.p59_underlying) ofclass K2_thing)){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ DoesNotExist x IN[ thing(x) IN] : is(('noun'.p59_underlying), x) ]
[ Prop_29  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK2_First: x: x=x.IK2_Link){
        qcn_0++;
        if (((noun.p59_underlying) == x)){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ Exists x : broom(x) & 'occupied'(x) ]
[ Prop_30  x x_ix ;
    for (x=IK40_First: x: x=x.IK40_Link){
        if (((Adj_34_t1_v9(x)))){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : broom(x) & 'occupied'(x) ]
[ Prop_31  x x_ix ;
    for (x=IK40_First: x: x=x.IK40_Link){
        if (((Adj_34_t1_v9(x)))){
            rtrue;
        }
    }
    rfalse;
];

! Force this to be true via 'now':
! [ DoesNotExist x IN[ thing(x) IN] : is(('noun'.p59_underlying), x) ]
[ Prop_32  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK2_First: x: x=x.IK2_Link){
        qcn_0++;
        Relation_NowN1toV(noun,p59_underlying,x);
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];

! True or false?
! [ Exists x : person(x) & is('player', (x.p72_other_party)) ]
[ Prop_33  x x_ix ;
    for (x=IK8_First: x: x=x.IK8_Link){
        if ((player == (x.p72_other_party))){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : person(x) & is('player', (x.p72_other_party)) ]
[ Prop_34  x x_ix ;
    for (x=IK8_First: x: x=x.IK8_Link){
        if ((player == (x.p72_other_party))){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & called='box'(x) & 'enterable'(x) & is('location', ContainerOf(x)) ]
[ Prop_35  x x_ix ;
    for (x=TestContainmentRange(real_location): x: x=TestContainmentRange(real_location,x)){
        if ((x ofclass K2_thing) && ((Adj_62_t1_v9(x)))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];

! Find next x satisfying:
! [ thing(x) ]
[ Prop_36  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];

! Find next x satisfying:
! [ thing(x) ]
[ Prop_37  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];

! Find next x satisfying:
! [ thing(x) ]
[ Prop_38  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];

! How many x satisfy this?
! [ thing(x) & 'marked for listing'(x) ]
[ Prop_39  x x_ix counter;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_58_t1_v9(x)))){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! Find next x satisfying:
! [ thing(x) & 'marked for listing'(x) ]
[ Prop_40  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_58_t1_v9(x)))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! Abstraction for set of x such that:
! [ thing(x) & 'unmentioned'(x) ]
[ Prop_41 reason x x_ix total counter selection best best_with;
    if (reason >= 0) { x = reason; reason = -1; }
    switch (reason) {
        -6: ! Find the extremal x satisfying:
            if (property_loop_sign>0) best=MIN_NEGATIVE_NUMBER;
            else best=MAX_POSITIVE_NUMBER;
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((Adj_61_t1_v9(x)))){
                    if (property_loop_sign>0) {
                        if (x.property_to_be_totalled >= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    } else {
                        if (x.property_to_be_totalled <= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    }
                }
                .NextOuterLoop_3;
            }
            return best_with;
        -5: ! Find a total property value over all x satisfying:
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((Adj_61_t1_v9(x)))){
                    total = total + x.property_to_be_totalled;
                    jump NextOuterLoop_6;
                }
                .NextOuterLoop_6;
            }
            return total;
        -4: ! Find a random x satisfying:
            selection = -1;
            while (true) {
                counter = 0;
                for (x=IK2_First: x: x=x.IK2_Link){
                    if (((Adj_61_t1_v9(x)))){
                        counter++;
                        if (counter == selection) return x;
                        jump NextOuterLoop_7;
                    }
                    .NextOuterLoop_7;
                }
                if ((counter == 0) || (selection >= 0)) return nothing;
                selection = random(counter);
            }
        -3: ! How many x satisfy this?
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((Adj_61_t1_v9(x)))){
                    counter++;
                    jump NextOuterLoop_5;
                }
                .NextOuterLoop_5;
            }
            return counter;
        -2: ! Find next x satisfying:
            if (x_ix > 0) {
                x_ix--;
                jump NextOuterLoop_4;
            }
            if (x) jump NextOuterLoop_4;
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((Adj_61_t1_v9(x)))){
                    return x;
                }
                .NextOuterLoop_4;
            }
            return nothing;
        -1: ! True or false?
            if ((x ofclass K2_thing) && ((Adj_61_t1_v9(x)))){
                rtrue;
            }
            rfalse;
    }
];

! True or false?
! [ Exists x : thing(x) & 'locale-supportable'(x) & is(const_0, SupporterOf(x)) ]
[ Prop_42  const_0 x x_ix ;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing) && ((Adj_30_t1_v9(x)))){
            rtrue;
        }
    }
    rfalse;
];

! Find next x satisfying:
! [ thing(x) & is(const_0, SupporterOf(x)) ]
[ Prop_43  const_0 x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! True or false?
! [ Exists x : thing(x) & 'locale-supportable'(x) & is(const_0, SupporterOf(x)) ]
[ Prop_44  const_0 x x_ix ;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing) && ((Adj_30_t1_v9(x)))){
            rtrue;
        }
    }
    rfalse;
];

! Find next x satisfying:
! [ thing(x) & is(const_0, SupporterOf(x)) ]
[ Prop_45  const_0 x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! How many x satisfy this?
! [ thing(x) & is('actor', CarrierOf(x)) ]
[ Prop_46  x x_ix counter;
    objectloop (x in actor) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! True or false?
! [ Exists x : player's holdall(x) & called='current working sack'(x) & is('actor', HolderOf(x)) ]
[ Prop_47  x x_ix ;
    for (x=nothing: false: ){
        if ((actor == HolderOf(x))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];

! Find next x satisfying:
! [ thing(x) & is('actor', CarrierOf(x)) ]
[ Prop_48  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    objectloop (x in actor) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! How many x satisfy this?
! [ thing(x) & is('actor', CarrierOf(x)) ]
[ Prop_49  x x_ix counter;
    objectloop (x in actor) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! How many x satisfy this?
! [ thing(x) & is(const_0, SupporterOf(x)) ]
[ Prop_50  const_0 x x_ix counter;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! How many x satisfy this?
! [ thing(x) & is(const_0, ContainerOf(x)) ]
[ Prop_51  const_0 x x_ix counter;
    for (x=TestContainmentRange(const_0): x: x=TestContainmentRange(const_0,x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! How many x satisfy this?
! [ thing(x) & is('second noun', SupporterOf(x)) ]
[ Prop_52  x x_ix counter;
    objectloop (x in second) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! How many x satisfy this?
! [ thing(x) & is('second noun', ContainerOf(x)) ]
[ Prop_53  x x_ix counter;
    for (x=TestContainmentRange(second): x: x=TestContainmentRange(second,x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! Find next x satisfying:
! [ thing(x) & encloses('location', x) ]
[ Prop_54  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        if ((IndirectlyContains(real_location,x))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! True or false?
! [ Exists x : container(x) & 'opaque'(x) & 'closed'(x) & encloses(x, const_0) ]
[ Prop_55  const_0 x x_ix ;
    for (x=IK5_First: x: x=x.IK5_Link){
        if (((Adj_63_t1_v9(x))) && ((Adj_66_t1_v9(x))) && (IndirectlyContains(x,const_0))){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & 'described'(x) & NOT[ 'scenery'(x) NOT] & is('noun', ContainerOf(x)) ]
[ Prop_56  x x_ix ;
    for (x=TestContainmentRange(noun): x: x=TestContainmentRange(noun,x)){
        if ((x ofclass K2_thing) && ((Adj_56_t1_v9(x)))){
            if (~~(((Adj_52_t1_v9(x))))){
                rtrue;
            }
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & NOT[ is(x, 'player') NOT] & is('noun', ContainerOf(x)) ]
[ Prop_57  x x_ix ;
    for (x=TestContainmentRange(noun): x: x=TestContainmentRange(noun,x)){
        if ((x ofclass K2_thing)){
            if (~~((x == player))){
                rtrue;
            }
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & 'described'(x) & NOT[ 'scenery'(x) NOT] & is('noun', SupporterOf(x)) ]
[ Prop_58  x x_ix ;
    objectloop (x in noun) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing) && ((Adj_56_t1_v9(x)))){
            if (~~(((Adj_52_t1_v9(x))))){
                rtrue;
            }
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & NOT[ is(x, 'player') NOT] & is('noun', SupporterOf(x)) ]
[ Prop_59  x x_ix ;
    objectloop (x in noun) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            if (~~((x == player))){
                rtrue;
            }
        }
    }
    rfalse;
];

! True or false?
! [ Card>=1 x IN[ thing(x) & is((x.p59_underlying), 'noun') IN] ]
[ Prop_60  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((x.p59_underlying) == noun)){
            qcn_0++;
            qcy_0++;
        }
    }
    if (qcy_0 >= 1){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & 'described'(x) & NOT[ 'scenery'(x) NOT] & is('noun', ContainerOf(x)) ]
[ Prop_61  x x_ix ;
    for (x=TestContainmentRange(noun): x: x=TestContainmentRange(noun,x)){
        if ((x ofclass K2_thing) && ((Adj_56_t1_v9(x)))){
            if (~~(((Adj_52_t1_v9(x))))){
                rtrue;
            }
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & 'described'(x) & NOT[ 'scenery'(x) NOT] & is('noun', SupporterOf(x)) ]
[ Prop_62  x x_ix ;
    objectloop (x in noun) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing) && ((Adj_56_t1_v9(x)))){
            if (~~(((Adj_52_t1_v9(x))))){
                rtrue;
            }
        }
    }
    rfalse;
];

! Find next x satisfying:
! [ thing(x) & encloses('noun', x) ]
[ Prop_63  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        if ((IndirectlyContains(noun,x))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! True or false?
! [ Exists x : broom(x) & is('player', CarrierOf(x)) ]
[ Prop_64  x x_ix ;
    objectloop (x in player) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K40_broom)){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ DoesNotExist x IN[ broom(x) IN] : is('player', CarrierOf(x)) ]
[ Prop_65  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK40_First: x: x=x.IK40_Link){
        qcn_0++;
        if ((player == CarrierOf(x))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! Force this to be true via 'now':
! [ DoesNotExist x IN[ thing(x) IN] : is(('player'.p59_underlying), x) ]
[ Prop_66  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK2_First: x: x=x.IK2_Link){
        qcn_0++;
        Relation_NowN1toV(player,p59_underlying,x);
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];

! True or false?
! [ DoesNotExist x IN[ rideable animal(x) IN] : is(x, CarrierOf('actor')) ]
[ Prop_67  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=nothing: false: ){
        qcn_0++;
        if ((x == CarrierOf(actor))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ DoesNotExist x IN[ rideable vehicle(x) IN] : is(x, SupporterOf('actor')) ]
[ Prop_68  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK22_First: x: x=x.IK22_Link){
        qcn_0++;
        if ((x == SupporterOf(actor))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! Force this to be true via 'now':
! [ ForAll x IN[ door(x) IN] : 'unlocked'(x) ]
[ Prop_69  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK4_First: x: x=x.IK4_Link){
        qcn_0++;
        (Adj_71_t2_v9(x));
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];

! Force this to be true via 'now':
! [ ForAll x IN[ container(x) IN] : 'unlocked'(x) ]
[ Prop_70  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK5_First: x: x=x.IK5_Link){
        qcn_0++;
        (Adj_71_t2_v9(x));
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];

! Force this to be true via 'now':
! [ ForAll x IN[ door(x) IN] : 'open'(x) ]
[ Prop_71  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK4_First: x: x=x.IK4_Link){
        qcn_0++;
        (Adj_65_t2_v9(x));
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];

! Force this to be true via 'now':
! [ ForAll x IN[ container(x) IN] : 'open'(x) ]
[ Prop_72  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK5_First: x: x=x.IK5_Link){
        qcn_0++;
        (Adj_65_t2_v9(x));
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];

! Find a random x satisfying:
! [ person(x) & 'visible'(x) & NOT[ is(x, 'player') NOT] ]
[ Prop_73  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK8_First: x: x=x.IK8_Link){
            if (((Adj_3_t1_v9(x)))){
                if (~~((x == player))){
                    counter++;
                    if (counter == selection) return x;
                    jump NextOuterLoop_7;
                }
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! True or false?
! [ DoesNotExist x IN[ person(x) IN] : is('player', (x.p72_other_party)) ]
[ Prop_74  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK8_First: x: x=x.IK8_Link){
        qcn_0++;
        if ((player == (x.p72_other_party))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! Force this to be true via 'now':
! [ DoesNotExist x IN[ person(x) IN] : is('player', (x.p72_other_party)) ]
[ Prop_75  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK8_First: x: x=x.IK8_Link){
        qcn_0++;
        Relation_NowSN1to1(x,p72_other_party,player);
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];

! True or false?
! [ Exists x : person(x) & is(const_0, SupporterOf(x)) ]
[ Prop_76  const_0 x x_ix ;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K8_person)){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : stairs(x) & 'closed'(x) ]
[ Prop_77  x x_ix ;
    for (x=IK35_First: x: x=x.IK35_Link){
        if (((Adj_66_t1_v9(x)))){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : stairs(x) & 'closed'(x) ]
[ Prop_78  x x_ix ;
    for (x=IK35_First: x: x=x.IK35_Link){
        if (((Adj_66_t1_v9(x)))){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : stairs(x) & 'closed'(x) ]
[ Prop_79  x x_ix ;
    for (x=IK35_First: x: x=x.IK35_Link){
        if (((Adj_66_t1_v9(x)))){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : telephone(x) & called='current phone'(x) & can-touch('player', x) ]
[ Prop_80  x x_ix ;
    for (x=IK29_First: x: x=x.IK29_Link){
        if ((TestTouchability(player,x))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];

! Find a random x satisfying:
! [ thing(x) & 'visible'(x) & NOT[ is('player', WearerOf(x)) NOT] ]
[ Prop_81  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK2_First: x: x=x.IK2_Link){
            if (((Adj_3_t1_v9(x)))){
                if (~~((player == WearerOf(x)))){
                    counter++;
                    if (counter == selection) return x;
                    jump NextOuterLoop_7;
                }
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! Find a random x satisfying:
! [ room(x) & region-contains('dursley's house', x) ]
[ Prop_82  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK1_First: x: x=x.IK1_Link){
            if ((TestRegionalContainment(x,I99_dursley_s_house))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! True or false?
! [ Exists x : suit(x) & is('player', WearerOf(x)) ]
[ Prop_83  x x_ix ;
    objectloop (x in player) if (WearerOf(x)==parent(x)){
        if ((x ofclass K31_suit)){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ DoesNotExist x IN[ clothing(x) IN] : is('player', WearerOf(x)) ]
[ Prop_84  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK30_First: x: x=x.IK30_Link){
        qcn_0++;
        if ((player == WearerOf(x))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];




[ Resolver_0 t_0 t_1 filename line;
if ((((t_0 ofclass K3_direction)))) { return  RoomOrDoorFrom(t_1,t_0) ; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_1 t_0 t_1 filename line;
if ((((t_0 ofclass K4_door)))) { return  OtherSideOfDoor(t_0,t_1) ; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_2 t_0 filename line;
if ((((t_0 ofclass K2_thing)))) { (PHR_966_r5 (t_0)); rtrue; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_3 t_0 t_1 filename line;
if ((((t_1 ofclass K1_room)))) { return  DoorFrom(t_1,t_0) ; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_4 t_0 t_1 filename line;
if ((((t_1 ofclass K1_room)))) { return  MapConnection(t_1,t_0) ; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_5 t_0 t_1 filename line;
if ((((t_0 ofclass K4_door))) && (((t_1 ofclass K1_room)))) { return  DirectionDoorLeadsIn(t_0,t_1) ; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_6 t_0 t_1 filename line;
if ((((t_0 ofclass K3_direction))) && (((t_1 ofclass K1_room)))) { return  MapConnection(t_1,t_0) ; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_7 t_0 t_1 filename line;
if ((((t_0 ofclass K3_direction)))) { return  MapConnection(t_1,t_0) ; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_8 t_0 t_1 filename line;
if ((((t_1 ofclass K1_room)))) { return  RoomOrDoorFrom(t_1,t_0) ; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_9 t_0 filename line;
if ((((t_0 ofclass K2_thing)))) { (PHR_1061_r20 (t_0)); rtrue; }
ArgumentTypeFailed(filename, line);
  rfalse; ];



Array ConstantListPointers --> 
 0 0;

Constant SC_793 = "	achieved";
Constant SC_794 = "	failed";
Constant SC_795 = "	pending";
Constant SC_393 = "                (If you ever need help, type help.)";
Constant SC_740 = "     I hope you respond to this letter. I would really like to keep in touch! Three months since I went to hogwarts for the";
Constant SC_736 = "     I leave you my old school broom. I never was any good at quidditch.";
Constant SC_596 = "  ";
Constant SC_88 = " ";
Constant SC_342 = " ~Why are you doing... (Petunia looks around nervously) Magic, in our house?~";
Constant SC_389 = " (";
Constant SC_691 = " 1981";
Constant SC_595 = " >";
Constant SC_703 = " Dudley's old favourite toy";
Constant SC_722 = " In this outfit, the person in the mirror reminds you of your sister, Marge.";
Constant SC_86 = " N = Next";
Constant SC_87 = " P = Previous";
Constant SC_769 = " To the west is your work. To the east, a small bakery. And south, your garden.";
Constant SC_551 = " accepts your thanks.";
Constant SC_359 = " again";
Constant SC_727 = " all over the walls.";
Constant SC_200 = " already riding ";
Constant SC_494 = " back to the ";
Constant SC_275 = " breathing.";
Constant SC_531 = " can't take that position.";
Constant SC_202 = " cannot be ridden.";
Constant SC_485 = " dismount";
Constant SC_516 = " do";
Constant SC_567 = " flies from the tip, causing ";
Constant SC_761 = " flutter past.";
Constant SC_448 = " from ";
Constant SC_675 = " from play";
Constant SC_498 = " from play.";
Constant SC_333 = " from the ground.";
Constant SC_335 = " from under ";
Constant SC_445 = " here";
Constant SC_216 = " in, the Boss comes up to you. ~Late again, Dursley?~ He says. ~Well, i hope this is the last time. Make sure you are here at 8:30 Tomorrow, On The Dot.~";
Constant SC_301 = " is ";
Constant SC_533 = " is already ";
Constant SC_534 = " is now ";
Constant SC_227 = " is waiting for you to carry on the conversation.";
Constant SC_250 = " isn't here.";
Constant SC_701 = " leading ";
Constant SC_390 = " leading towards ";
Constant SC_482 = " mount";
Constant SC_518 = " not respond.";
Constant SC_203 = " not riding anything.";
Constant SC_267 = " off-road.";
Constant SC_526 = " on the other side of the line.";
Constant SC_435 = " or ";
Constant SC_601 = " or H to reveal another hint";
Constant SC_729 = " owner: Vernon Dursley";
Constant SC_798 = " there are other offices to either side of you.";
Constant SC_492 = " to ";
Constant SC_589 = " to fly into the air, before coming slowly back down.";
Constant SC_586 = " to jump back";
Constant SC_702 = " towards ";
Constant SC_477 = " under ";
Constant SC_347 = " with a soft pinging noise.";
Constant SC_712 = " work ";
Constant SC_440 = " you ";
Constant SC_762 = " you might need to get your keys to unlock the car. they are inside the suitcase.";
Constant SC_566 = "!, and ";
Constant SC_327 = "~";
Constant SC_850 = "~, and on the next turn say  ~";
Constant SC_851 = "~, and on the next turn say ~";
Constant SC_841 = "~, and then next turn write ~";
Constant SC_786 = "~, our priciest model. (Don't tell them about it being pricey)";
Constant SC_469 = "~-yes, their son, Harry-~";
Constant SC_257 = "~.";
Constant SC_454 = "~And finally, bird-watchers everywhere have reported that the nation's owls have been behaving very unusually today.";
Constant SC_361 = "~Can I order another 50 drills? the last ones where excellent.~";
Constant SC_365 = "~Er - Petunia, dear - you haven't heard from your sister lately, have you?~";
Constant SC_552 = "~Funny stuff on the news. Owls... shooting stars...";
Constant SC_514 = "~Good afternoon. How was your day, Vernon?~ Asks petunia.";
Constant SC_322 = "~Good morning! How may i help you, sir?~ asks the shop attendant.";
Constant SC_341 = "~Good morning~ Says Petunia.";
Constant SC_338 = "~Good morning. How did you sleep?~ Asks Petunia.";
Constant SC_244 = "~Great. Now, how do i get it?~";
Constant SC_561 = "~Harry. Nasty, common name, if you ask me.~";
Constant SC_360 = "~Hello Dursley. This is Mr. Mason.~";
Constant SC_273 = "~Hello again. How are you?~";
Constant SC_130 = "~Hello, this is Xander speaking... Hello? Hello? Who is this? Damn, i shouldn't have tried to fix the phone myself... Anya! Come here for a minute!~";
Constant SC_356 = "~Hello. How are you?~";
Constant SC_525 = "~Hello?~ says ";
Constant SC_242 = "~Hmmm... Well, goodbye Dursley.~";
Constant SC_559 = "~I Suppose so.~";
Constant SC_314 = "~My number is 12586. call me back if you ever gain a civil tongue.~ Says Mr. Mason, rather coldly.";
Constant SC_367 = "~No, and will you please not mention her unless you have to?~ says Petunia.";
Constant SC_366 = "~No. Why?~ Says Petunia, rather sharply.";
Constant SC_233 = "~Now, what do you want?~";
Constant SC_562 = "~Oh, yes. Yes, I quite agree...~";
Constant SC_246 = "~Oh... ok. Thanks. If you remember, call me at 12856.~";
Constant SC_245 = "~Oh... ok. Thanks. If you remember, call me at 893.~";
Constant SC_134 = "~Ok, Thanks. I'll do that.~";
Constant SC_133 = "~Ok. And then what?~ Asks the customer.";
Constant SC_207 = "~Ok. Here's your ";
Constant SC_352 = "~Shan't! Shan't!~ Says Dudley.";
Constant SC_339 = "~Since there";
Constant SC_554 = "~So?~ Snapped Petunia.";
Constant SC_326 = "~Sorry~, you say gruffly, before realising that this small man is wearing a violet cloak.";
Constant SC_181 = "~Thanks.~";
Constant SC_544 = "~That doesn't sound right... I think that range is suited for something else.~";
Constant SC_247 = "~That's great. Now, what drills would you reccomend for ";
Constant SC_468 = "~The Potters, that's right, that's what I heard -~";
Constant SC_558 = "~Their son - he'd be about Dudley's age now, wouldn't he?~";
Constant SC_209 = "~We're out of those, sorry.~";
Constant SC_555 = "~Well, I just thought... maybe... it was something to do with... you know... ";
Constant SC_459 = "~Well, Ted, I don";
Constant SC_183 = "~Well, goodbye Dursley.~";
Constant SC_313 = "~Well, my number is 893. Call me back if you ever gain a civil tongue. ~";
Constant SC_337 = "~What on earth... How are you flying that?~";
Constant SC_560 = "~What's his name again? Howard, isn't it?~";
Constant SC_210 = "~You need to pay for that. That'll be a pound.~";
Constant SC_117 = "~time~ will tell you the time of day";
Constant SC_449 = "(";
Constant SC_253 = "(addressing ";
Constant SC_241 = "(first ending your conversation with ";
Constant SC_229 = "(first hanging up on ";
Constant SC_575 = "(on ";
Constant SC_391 = "(under ";
Constant SC_230 = ")";
Constant SC_436 = ", ";
Constant SC_550 = ", but to no avail.";
Constant SC_529 = ", cutting the connection.";
Constant SC_588 = ", while spreading warmth.";
Constant SC_223 = ", you flip the rollerdex back to today's page.";
Constant SC_222 = ", you inadvertantly flip the rollerdex to a random page.";
Constant SC_226 = ", you reveal ";
Constant SC_434 = ",";
Constant SC_472 = ". Now the cup is empty.";
Constant SC_321 = ". You are wearing ";
Constant SC_201 = ".";
Constant SC_208 = ".~";
Constant SC_709 = "... I ha";
Constant SC_598 = "/";
Constant SC_500 = "0";
Constant SC_501 = "1";
Constant SC_411 = "10:";
Constant SC_162 = "10th";
Constant SC_412 = "11:";
Constant SC_163 = "11th";
Constant SC_413 = "12:";
Constant SC_164 = "12th";
Constant SC_414 = "13:";
Constant SC_165 = "13th";
Constant SC_415 = "14:";
Constant SC_166 = "14th";
Constant SC_416 = "15:";
Constant SC_167 = "15th";
Constant SC_417 = "16:";
Constant SC_168 = "16th";
Constant SC_418 = "17:";
Constant SC_169 = "17th";
Constant SC_419 = "18:";
Constant SC_170 = "18th";
Constant SC_420 = "19:";
Constant SC_171 = "19th";
Constant SC_402 = "1:";
Constant SC_502 = "2";
Constant SC_421 = "20:";
Constant SC_172 = "20th";
Constant SC_422 = "21:";
Constant SC_173 = "21st";
Constant SC_423 = "22:";
Constant SC_174 = "22nd";
Constant SC_424 = "23:";
Constant SC_175 = "23rd";
Constant SC_425 = "24:";
Constant SC_176 = "24th";
Constant SC_177 = "25th";
Constant SC_178 = "26th";
Constant SC_179 = "27th";
Constant SC_180 = "28th";
Constant SC_403 = "2:";
Constant SC_154 = "2nd";
Constant SC_503 = "3";
Constant SC_404 = "3:";
Constant SC_155 = "3rd";
Constant SC_504 = "4";
Constant SC_405 = "4:";
Constant SC_156 = "4th";
Constant SC_505 = "5";
Constant SC_406 = "5:";
Constant SC_157 = "5th";
Constant SC_506 = "6";
Constant SC_407 = "6:";
Constant SC_158 = "6th";
Constant SC_507 = "7";
Constant SC_408 = "7:";
Constant SC_159 = "7th";
Constant SC_508 = "8";
Constant SC_409 = "8:";
Constant SC_160 = "8th";
Constant SC_509 = "9";
Constant SC_410 = "9:";
Constant SC_161 = "9th";
Constant SC_199 = ": ";
Constant SC_446 = ":";
Constant SC_437 = "> ";
Constant SC_74 = ">";
Constant SC_433 = "?";
Constant SC_574 = "?~";
Constant SC_31 = "A book of the meals with the highest possible calorie content.";
Constant SC_28 = "A comprehensive guide to help you ensure the over-enrichment of your favourite child.";
Constant SC_29 = "A full and unabridged history on the subject of drills, drilling, drillmaking, and more!";
Constant SC_731 = "A glance at the diary tells you it holds nothing interesting - just some old appointments and dates to keep.";
Constant SC_15 = "A large wooden wardrobe, made of the finest materials to please Petunia.";
Constant SC_30 = "A list of the best of Pompous Complaints and snide remarks.";
Constant SC_52 = "A standard work desk.";
Constant SC_58 = "A typical filing cabinet, full of unanswered complaints that you still need to send to the relevant people.";
Constant SC_303 = "Above you is ";
Constant SC_94 = "Acknowledgements";
Constant SC_357 = "After reading the rolodex, you look out the window to see an owl perched on the windowsill. How strange.";
Constant SC_4 = "All of the pencils have the name ~Petunia Evans~ written on the base.";
Constant SC_653 = "Also, I would like to thank Stephen Fry, for unwittingly lending his dulcet tones to the introduction. The audiobook introduction to the first book is on soundcloud for free, although it only covers the first five minutes.";
Constant SC_455 = "Although owls normally hunt at night and are hardly ever seen in daylight, there have been hundreds of sightings of these birds flying in every direction since sunrise.";
Constant SC_457 = "And now, over to Jim McGuffin with the weather. Going to be any more showers of owls tonight, Jim?~.";
Constant SC_553 = "And there were a lot of funny-looking people in town today...~";
Constant SC_69 = "Another hoard of Dudley's favourite toys..";
Constant SC_778 = "Answer any questions from customer, and respond to any niceties.";
Constant SC_788 = "Answer two customer phone calls:";
Constant SC_64 = "Antique and antiquated.";
Constant SC_145 = "April";
Constant SC_604 = "Are";
Constant SC_23 = "As clean as the rest of the room.";
Constant SC_8 = "As good-looking as ever.";
Constant SC_213 = "As you ";
Constant SC_204 = "As you back out of Privet Drive, you notice a tabby cat out of the corner of your eye. you also notice that the cat looks like it is reading a map. you look round again, but the map has gone. As you drive round the corner of the road, you notice the cat reading the sign - no, looking at the sign; cats can't read maps or signs.";
Constant SC_537 = "As you break into the car, the alarm goes off. Now the police will be after you.";
Constant SC_349 = "As you climb into bed, you hear slight mutterings from outside, and the sound of a motorbike.";
Constant SC_725 = "As you enter the attic, you see pictures of ";
Constant SC_773 = "As you enter your office, ";
Constant SC_734 = "As you examine the handle, you see the name Lily Potter engraved into it. and there's a card on the side - it says ";
Constant SC_324 = "As you fly out to the highway, you notice a tabby cat out of the corner of your eye. you also notice that the cat looks like it is reading a map. you look round again, but the map has gone. as you drive round the corner of the road, you notice the cat reading the sign - no, looking at the sign; cats can't read maps or signs. The people on the street seem to be looking at you rather strangely.";
Constant SC_363 = "As you get into the car, you hope that the events of today were all in your imagination, even though imagination is something which you do not approve of.";
Constant SC_353 = "As you go about looking at the document, the phone rings. How convenient.";
Constant SC_271 = "As you go to pick up the phone, it rings. You pick it up.";
Constant SC_853 = "As you look out the window, you see the cat from this morning, as well as a tall, thin man, who silently walks from the corner of the street. He holds up a small object, and suddenly, all the lamps in the street go out.";
Constant SC_730 = "As you open the diary, a letter falls out, sent from Lilly Potter.";
Constant SC_225 = "As you pick up ";
Constant SC_767 = "As you sit in the usual morning traffic jam, you notice how there seem to be a lot of strangely dressed people about. people in cloaks.";
Constant SC_766 = "As you sit in the usual traffic jam, you notice a lot of people around in robes. They seem to be surprised to see another person in robes on the road. ";
Constant SC_192 = "As you sit there thinking about your day, Petunia comes into the room, carrying a tray with 2 cups of tea.~Here's your tea, Vernon~.";
Constant SC_348 = "As you stroll out of the shop, you notice another group of robed people standing further down the road. I wonder what they could be talking about?";
Constant SC_453 = "As you switch in the television, you are greeted with the sight of the last few minutes of the evening news.";
Constant SC_325 = "As you're a bit distracted, you don't see where you are going, and you bump into someone. ";
Constant SC_723 = "Attic stairs";
Constant SC_149 = "August";
Constant SC_119 = "Be careful about commas. Commas can't be used like this: ~next, try eating porridge~ unless next is a person. Commas can only be used to instruct others, e.g. ~Ron, pick up my bag~, or ~Dumbledore, inventory~.";
Constant SC_131 = "Beep...Beep...Beep... i guess someone didn't pay their phone bill.";
Constant SC_302 = "Below you is ";
Constant SC_784 = "Bk 44 model T";
Constant SC_697 = "Buffy at 5550101";
Constant SC_692 = "Call ";
Constant SC_127 = "Call Mr. Plow, that's my name, that name again is Mr. Plow. ";
Constant SC_668 = "Change to ";
Constant SC_489 = "Cheats are already off.";
Constant SC_487 = "Cheats are already on.";
Constant SC_830 = "Cheats";
Constant SC_689 = "Daddy, ";
Constant SC_9 = "Darkness";
Constant SC_700 = "Dawn at 5550193";
Constant SC_739 = "Dear Petunia,";
Constant SC_153 = "December";
Constant SC_693 = "Doc Brown at 5554385";
Constant SC_522 = "Don't be silly.";
Constant SC_328 = "Don't be sorry, my dear sir, for nothing could upset me today!";
Constant SC_121 = "Don't hesitate to try commands not on this list, as there might be some that work in places. if it looks like it would make sense for something to work, try it.";
Constant SC_59 = "Drawer";
Constant SC_688 = "Dudley on his highchair, ";
Constant SC_592 = "Dudley to run squealing around the room.";
Constant SC_726 = "Dudley";
Constant SC_68 = "Dudley's cot, and of limited interest.";
Constant SC_89 = "ENTER = Select";
Constant SC_232 = "Enter the combination lock code:";
Constant SC_330 = "Even Muggles such as yourself should be celebrating, this happy, happy day!~";
Constant SC_124 = "Even though there are some odd looking people outside, it does not legitimise calling the police.";
Constant SC_283 = "Even though you are able to eat half a cow's worth of meat in one sitting, you don't think you could eat Dudley.";
Constant SC_238 = "Even though you got the biggest clothing the store could sell you, you can barely wear one set of clothing, let alone two.";
Constant SC_219 = "Even though you have your chance to yell at a few people, your heart isn't in it.";
Constant SC_490 = "Even with cheats on, that's impossible.";
Constant SC_456 = "Experts are unable to explain why the owls have suddenly changed their sleeping pattern. Most mysterious.";
Constant SC_143 = "February";
Constant SC_685 = "Finishing day: ";
Constant SC_682 = "Finishing work: ";
Constant SC_789 = "First call";
Constant SC_679 = "First phone call: ";
Constant SC_777 = "First step:";
Constant SC_129 = "For Holy assistance on earth, press 1. For Heavenly Guidance, press 2. For tomorrow's football results, press 3.";
Constant SC_139 = "Friday";
Constant SC_91 = "General Game Commands (for specific hints, type hints)";
Constant SC_678 = "Getting onto public roads: ";
Constant SC_676 = "Getting up: ";
Constant SC_698 = "God at 5550123";
Constant SC_848 = "Great. Now, how do I make an order?";
Constant SC_843 = "Great. Now, how do I order the drill?";
Constant SC_783 = "HAL 6502";
Constant SC_609 = "Has";
Constant SC_608 = "Have";
Constant SC_616 = "He";
Constant SC_132 = "Hello. Would you like to buy... hang on... isn't that a number from our building? Yeah, it's that no good Dursley fellow! he's always prank calling us!";
Constant SC_355 = "Hello? Says the voice on the other end of the line. ";
Constant SC_100 = "Help";
Constant SC_636 = "Her";
Constant SC_647 = "Hers";
Constant SC_641 = "Him";
Constant SC_635 = "His";
Constant SC_535 = "Hmm... I think the car keys are in my suitcase.";
Constant SC_708 = "Hmm... The time is ";
Constant SC_847 = "How awful. Now, how do i order the drill?";
Constant SC_299 = "How can you carjack that? It isn't a vehicle.";
Constant SC_231 = "How could you go through it when you are carrying it?";
Constant SC_264 = "How is that possible?";
Constant SC_193 = "How to Spoil your Children Handbook";
Constant SC_236 = "How would you manage that?";
Constant SC_311 = "I didn't understand that sentence.";
Constant SC_652 = "I would also like to thank my Dad, for a lot of helpful input and ideas, as well as all the game testers who helped me find and remove bugs.";
Constant SC_655 = "I would like to give a special mention to Erik Temple, since I used some of the code in one of his examples.";
Constant SC_305 = "If you took one of Dudley's toys, he would notice.";
Constant SC_439 = "In ";
Constant SC_6 = "In these, Dudley looks like a beach ball wearing a bobble hat.";
Constant SC_122 = "In this country, making prank calls to the police is frowned upon.";
Constant SC_670 = "Increase score by ";
Constant SC_2 = "Influenced by ~Harry Potter and the Philosopher's stone~ by J.K. Rowling.";
Constant SC_75 = "Instructions";
Constant SC_605 = "Is";
Constant SC_854 = "It is pitch black.";
Constant SC_10 = "It is pitch dark, and you can't see a thing.";
Constant SC_627 = "It";
Constant SC_47 = "It's a Ford.";
Constant SC_95 = "Itinerary";
Constant SC_637 = "Its";
Constant SC_142 = "January";
Constant SC_148 = "July";
Constant SC_147 = "June";
Constant SC_828 = "Last Menu";
Constant SC_681 = "Lunch: ";
Constant SC_144 = "March";
Constant SC_146 = "May";
Constant SC_135 = "Monday";
Constant SC_659 = "Move ";
Constant SC_396 = "Mr Dursley was the director of a firm called Grunnings, which made drills. He was a big, beefy man with hardly any neck, although he did have a very large moustache. Mrs Dursley was thin and blonde and had nearly twice the usual amount of neck, which came in very useful as she spent so much of her time craning over garden fences, spying on the neighbours. The Dursleys had a small son called Dudley and in their opinion there was no finer boy anywhere.";
Constant SC_694 = "Mr Plow at 5553226";
Constant SC_394 = "Mr and Mrs Dursley, of number four, Privet Drive, were proud to say that they were perfectly normal, thank you very much.";
Constant SC_362 = "Mr. Finnigan";
Constant SC_224 = "Mr. Mason continues. ~You know, we've been having a lot of strange events today. Our building site is continually being swooped by owls, even during the day. And there's also some other strange things happening. Shooting stars and the likes.~";
Constant SC_196 = "Mr. Mason gets bored and hangs up. ~If you remember, call me at 12856.~";
Constant SC_60 = "Mr. Mason";
Constant SC_686 = "Mummy at the table, ";
Constant SC_649 = "My first acknowledgements go to Graham Nelson, the creator of inform 7, Without which i would be more than a little bit stuck.";
Constant SC_108 = "N/S/E/W";
Constant SC_779 = "Next Step:";
Constant SC_781 = "Next step:";
Constant SC_651 = "Next, I would, slightly unneccesarily, like to acknowledge J.K. Rowling, who wrote the Harry Potter books, without which I wouldn't be able to create the game.";
Constant SC_107 = "North/South/East/West";
Constant SC_152 = "November";
Constant SC_495 = "Now all doors, vehicles, and containers are unlocked and open.";
Constant SC_488 = "Now cheats are off.";
Constant SC_486 = "Now cheats are on.";
Constant SC_845 = "Now, how do I make an order?";
Constant SC_151 = "October";
Constant SC_262 = "Ok. Here you go!";
Constant SC_441 = "On ";
Constant SC_277 = "One for you, One for Petunia, and three for Dudley, when he grows up to a good, healthy size.";
Constant SC_278 = "One for you, One for Vernon, and three for Dudley, when he grows up to a good, healthy size.";
Constant SC_25 = "One of the few things to escape Petunia's scrubbing, because it often has water running into it.";
Constant SC_72 = "One of the few things to escape Petunia's scrubbing, the sink is a little smudged and dirty.";
Constant SC_3 = "Orion Zymaris";
Constant SC_462 = "Perhaps people have been celebrating Bonfire Night early - it's not untill next week, folks! But I can promise a wet night tonight.";
Constant SC_669 = "Person";
Constant SC_687 = "Petunia at the table, ";
Constant SC_597 = "Please press SPACE to continue.";
Constant SC_470 = "Potter? Petunia's sister's husband? I need to get back to the office and call petunia.";
Constant SC_599 = "Press SPACE to return to the menu or H to reveal another hint.";
Constant SC_600 = "Press SPACE to return to the menu";
Constant SC_115 = "Push/press";
Constant SC_662 = "Put ";
Constant SC_827 = "Q = ";
Constant SC_82 = "QUIT";
Constant SC_829 = "Quit Menu";
Constant SC_79 = "RESTART";
Constant SC_80 = "RESTORE a saved game";
Constant SC_329 = "Rejoice, for You-Know-Who has gone at last!";
Constant SC_90 = "Sample Hint";
Constant SC_140 = "Saturday";
Constant SC_400 = "Search:  ";
Constant SC_792 = "Second call";
Constant SC_680 = "Second call: ";
Constant SC_650 = "Second, to Emily Short, who has done a lot of work to improve Inform.";
Constant SC_150 = "September";
Constant SC_92 = "Settings";
Constant SC_617 = "She";
Constant SC_466 = "Shooting stars all over Britain Owls flying by daylight? Mysterious people in cloaks all over the place? And a whisper, a whisper about the Potters... Maybe you should ask Petunia about this.";
Constant SC_345 = "Since you pressed the button without getting in, you have to wait for the elevator to come back to the ";
Constant SC_24 = "Sink";
Constant SC_429 = "Sit on it";
Constant SC_99 = "Some basic Commands:";
Constant SC_5 = "Some books bought for Dudley, in case he ever turns out to like reading.";
Constant SC_280 = "Some chairs.";
Constant SC_71 = "Some spells: Expelliarmus, Incendio, WIngardium Leviosa, Avada Kadavra, Expecto Patronum.";
Constant SC_218 = "Still,you find it difficult to focus for the rest of the day. Why where the oddly dressed people talking about your sister's son?";
Constant SC_44 = "Streets";
Constant SC_677 = "Success";
Constant SC_141 = "Sunday";
Constant SC_114 = "Switch on/Switch off";
Constant SC_785 = "T1000";
Constant SC_684 = "Talking to petunia about Potters: ";
Constant SC_512 = "Talking to yourself is unrewarding.";
Constant SC_26 = "Tap";
Constant SC_782 = "Tell them to ~ask for a ";
Constant SC_76 = "That doesn't seem right.";
Constant SC_298 = "That doesn't seem the most sanitary thing to drink from, if it even contains liquid to drink.";
Constant SC_182 = "That doesn't sound right... I think that range is suited for something else.";
Constant SC_720 = "That is spectacular. Nice and flashy. Just what you were looking for.";
Constant SC_261 = "That isn't enough!";
Constant SC_540 = "That isn't vital right now.";
Constant SC_539 = "That one's already broken.";
Constant SC_719 = "That outfit looks wonderful!";
Constant SC_212 = "That seems like a rather pointless, if typical, thing for you to say. ";
Constant SC_281 = "That seems rather suicidal.";
Constant SC_312 = "That would be immoral.";
Constant SC_239 = "That would be impossible.";
Constant SC_240 = "That would be laughable.";
Constant SC_259 = "That would be ridiculous.";
Constant SC_309 = "That would be rude.";
Constant SC_258 = "That would not fit under there.";
Constant SC_618 = "That";
Constant SC_475 = "That's already under there!";
Constant SC_77 = "That's already unlocked.";
Constant SC_846 = "That's no good! Now, how do I order the drill?";
Constant SC_63 = "The Baker's";
Constant SC_293 = "The Bk 44 model T is reccomended for hard work and long lasting life.";
Constant SC_123 = "The Doc will be with you about twenty seconds ago.";
Constant SC_397 = "The Dursleys had everything they wanted, but they also had a secret, and their greatest fear was that somebody would discover it. They didn't think they could bear it if anyone found out about the Potters. Mrs Potter was Mrs Dursley's sister, but they hadn't met for several years; in fact, Mrs Dursley pretended she didn't have a sister, because her sister and her good-for-nothing husband were as unDursleyish as it was possible to be. The Dursleys shuddered to think what the neighbours would say if the Potters arrived in the street. The Dursleys knew that the Potters had a small son too, but they had never seen him. This boy was another good reason for keeping the Potters away; they didn't want Dudley mixing with a child like that.";
Constant SC_696 = "The Ghostbusters at 5552368";
Constant SC_61 = "The Grunnings building looms large to the west of you, on the other side of the highway.";
Constant SC_295 = "The HAL 6502 is reccomended for use with smaller screws and where finesse is needed.";
Constant SC_294 = "The Qz 77 is reccomended for it's low, low price.";
Constant SC_695 = "The Simpsons at 5558707";
Constant SC_125 = "The Simpsons phone was accidentally made radioactive after Homer had a night of drinking. They dare not touch it.";
Constant SC_296 = "The T1000 is reccomended for use with large bolts and large scale work";
Constant SC_755 = "The T1000 is reccomended for use with large bolts and large scale work.";
Constant SC_717 = "The best kind of suit - a birthday suit!";
Constant SC_648 = "The black bar at the top of the game (Not the top of the hints menu) has a bunch of stats about the game so far. The first two numbers, 0/1, tell you the score (Not needed till later) and the turn count respectively. The next bit tells you the time within the game. Next is the current room, and last of all is the current region, e.g. Dursley's house, rather than a single room.";
Constant SC_98 = "The commands forward and backward, left and right do not work in this game";
Constant SC_211 = "The customer doesn't understand you. Much like the rest of the world.";
Constant SC_195 = "The customer gets bored and hangs up. ~If you remember, call me at 893.~";
Constant SC_346 = "The elevator comes back to the ";
Constant SC_426 = "The elevator seems to be being used at the moment. There are stairs, you know. do you know what they are?";
Constant SC_737 = "The handle says that it is a cleansweep five.";
Constant SC_18 = "The landing is gleaming, scrubbed and well kept, courtesy of Petunia.";
Constant SC_292 = "The latest drill models - The Bk 44 model T, The Qz  77, the T1000, and the HAL 6502.";
Constant SC_799 = "The nametag reads ~Hello! My Name is ";
Constant SC_78 = "The notepad has never been written in, and is blank.";
Constant SC_768 = "The people in cloaks still seem to be around, and in large numbers.";
Constant SC_524 = "The phone rings but there is no reply.";
Constant SC_358 = "The phone rings";
Constant SC_189 = "The police car comes into the carpark. You run.";
Constant SC_746 = "The rest of the letter seems to have been torn off.";
Constant SC_22 = "The room is gleaming white, and still wet from Petunia's obsessive and never ending cleaning.";
Constant SC_728 = "The smeltings schoolbook ";
Constant SC_745 = "The world of magic is amazing, and there's so much to do! We";
Constant SC_633 = "Their";
Constant SC_645 = "Theirs";
Constant SC_640 = "Them";
Constant SC_654 = "Then there are all the authors of the extensions in the game:";
Constant SC_770 = "There are a lot of people on the roads with cheap cars... disgraceful.";
Constant SC_120 = "There are other commands in the game, but they should be reasonably obvious, or explained during the course of the game";
Constant SC_511 = "There is no reply.";
Constant SC_452 = "There is nothing underneath ";
Constant SC_519 = "There's no one here but you.";
Constant SC_251 = "There's no one here to talk to.";
Constant SC_70 = "There's not a lot in here. Dudley needs it for later, when he'll be getting more toys.";
Constant SC_316 = "There's nothing to lie on.";
Constant SC_318 = "There's nothing to sit on.";
Constant SC_319 = "There's nothing to stand on.";
Constant SC_656 = "These are the cheats commands:";
Constant SC_716 = "These pyjamas are great, with the little dollar signs all over them!";
Constant SC_395 = "They were the last people you'd expect to be involved in anything strange or mysterious,  because they just didn't hold with such nonsense.";
Constant SC_626 = "They";
Constant SC_350 = "This is the end of chapter 1";
Constant SC_16 = "This is your bedside table. It has a drawer attached.";
Constant SC_40 = "This looks like a good, proper size for a steak. what does it weigh... twenty, twenty five pounds? A whole half a cow's worth...";
Constant SC_49 = "This one looks rather old. Bloody owners can't even be bothered to work for a new car.";
Constant SC_46 = "This one seems to be a Daihatsu.";
Constant SC_715 = "This suit is rather business-like. Nice and grey.";
Constant SC_704 = "This was Dudley's";
Constant SC_279 = "Those are called chairs.";
Constant SC_721 = "Those clothes are a very nice, vibrant shade.";
Constant SC_614 = "Those";
Constant SC_138 = "Thursday";
Constant SC_832 = "Time delays off";
Constant SC_831 = "Time delays on";
Constant SC_735 = "To Petunia";
Constant SC_775 = "To do your job properly:";
Constant SC_707 = "Toast, stale because it wasn't eaten this morning.";
Constant SC_198 = "Today's been a bit tiring. You should get to bed.";
Constant SC_21 = "Toilet";
Constant SC_136 = "Tuesday";
Constant SC_536 = "Type in a word to look for related hints. You can name an item, to find all hints relating to it, a person, or a room. Type ~all~ to find a list of all hints. Warning: hints do not include easter eggs. Find those on your own.";
Constant SC_83 = "UNDO the last command";
Constant SC_101 = "Undo";
Constant SC_776 = "Unless the person is Mr Mason, or another experienced customer:";
Constant SC_128 = "Unless there's slaying to be done, I wouldn't reccomend it.";
Constant SC_270 = "Unless there's something important to tell Mr Mason, i wouldn't reccomend it.";
Constant SC_269 = "Unless there's something important to tell the customer, i wouldn't reccomend it.";
Constant SC_690 = "Vernon, ";
Constant SC_461 = "Viewers as far apart as Kent, Yorkshire, and Dundee have been phoning in to tell me that instead of the rain I promised yesterday, they've had a downpour of shooting stars!";
Constant SC_323 = "Wait, How are you flying that?";
Constant SC_683 = "Watching television: ";
Constant SC_137 = "Wednesday";
Constant SC_392 = "Welcome to An Interactive Fiction version of Harry Potter.";
Constant SC_467 = "What a good idea.";
Constant SC_255 = "What do you want to write: ";
Constant SC_93 = "What does that top bar do?";
Constant SC_542 = "What exactly do you want to use it for?";
Constant SC_564 = "What, is that a shakespearian play or something?";
Constant SC_398 = "When Mr and Mrs Dursley woke up on the dull, grey Tuesday our story starts, there was nothing about the cloudy sky outside to suggest that strange and mysterious things would soon be happening all over the country.";
Constant SC_220 = "When the boss comes in to tell you that you can go home, you barely notice.";
Constant SC_126 = "Who you gonna call? obviously not the ghost busters. They must be out of business.";
Constant SC_285 = "Why would you want to carjack your own car?";
Constant SC_282 = "Why would you want to do that?";
Constant SC_474 = "With what?";
Constant SC_563 = "Without another word, you and Petunia both go upstairs to bed.";
Constant SC_844 = "Wonderful. Now, how do i order the drill?";
Constant SC_787 = "Work for today:";
Constant SC_432 = "Would you like to ";
Constant SC_699 = "Xander at 5550168";
Constant SC_543 = "Xc912";
Constant SC_438 = "You ";
Constant SC_368 = "You appear in ";
Constant SC_532 = "You are already ";
Constant SC_480 = "You are already riding ";
Constant SC_513 = "You are already talking to ";
Constant SC_320 = "You are carrying ";
Constant SC_483 = "You are not riding anything.";
Constant SC_370 = "You are now ";
Constant SC_549 = "You attempt to play ";
Constant SC_274 = "You can hear ";
Constant SC_20 = "You can see Dudley's fingermarks all over the walls here. He frequents the hall, as it is in between the television and the fridge. There are rooms southwest, east, west, above, south, northeast and north of you.";
Constant SC_771 = "You can see a huge amount of cars on the road. Lots of busy people these days";
Constant SC_45 = "You can see the highway to the east. There is a small shop on the other side.";
Constant SC_774 = "You can see your desk, with a phone on it.";
Constant SC_266 = "You can't drive the ";
Constant SC_315 = "You can't lie down on ";
Constant SC_317 = "You can't sit down on ";
Constant SC_530 = "You can't take that position ";
Constant SC_307 = "You can't take that.";
Constant SC_852 = "You can't write like that - say ~write in ";
Constant SC_849 = "You can't write like that - say ~write on ";
Constant SC_265 = "You can't write on something without a pen.";
Constant SC_547 = "You can't write on that.";
Constant SC_484 = "You dismount ";
Constant SC_576 = "You don't have a phone handy.";
Constant SC_228 = "You finish the ";
Constant SC_523 = "You get a busy signal.";
Constant SC_479 = "You get out from under ";
Constant SC_344 = "You go down the elevator, back to the carpark.";
Constant SC_478 = "You go under ";
Constant SC_343 = "You go up the elevator. when you look out of the elevator, you see there are offices to either side of you.";
Constant SC_364 = "You gulp down some ";
Constant SC_557 = "You gulp down some Tea.";
Constant SC_772 = "You hope that all these people are going to make money, or they'll just be wasting space on the roads.";
Constant SC_42 = "You look around and see a driveway with the car on it, the garage where the car came out of, and the highway to the north.";
Constant SC_733 = "You look around at the sight of lots of old things that no one can be bothered doing anything with.";
Constant SC_749 = "You look around the kitchen ";
Constant SC_11 = "You look around. There is a wardrobe, a bed, a bedside table with drawer attached, and a door to the north-west.";
Constant SC_718 = "You look in the mirror.";
Constant SC_399 = "You manage to eat yourself. You are in darkness.";
Constant SC_481 = "You mount ";
Constant SC_491 = "You move ";
Constant SC_493 = "You move the ";
Constant SC_268 = "You need a vehicle to do that.";
Constant SC_187 = "You need to open the garage before you can leave.";
Constant SC_252 = "You need to specify who you want to speak to.";
Constant SC_331 = "You notice the cat from this morning sitting on the garden wall. Despite your attempts to shoo it away, it is still sitting there, looking sternly at you.";
Constant SC_284 = "You own this vehicle already. why damage it?";
Constant SC_332 = "You pick up ";
Constant SC_354 = "You pick up the phone.";
Constant SC_369 = "You pull on the panel, lowering a set of stairs to the ground that lead to the roof.";
Constant SC_476 = "You put ";
Constant SC_528 = "You put down ";
Constant SC_243 = "You put down the office phone, cutting the connection.";
Constant SC_310 = "You put yourself under ";
Constant SC_234 = "You reach up to open the wardrobe, but you can't quite get there. You need to get up first.";
Constant SC_496 = "You restore the score to ";
Constant SC_217 = "You rush over to the phone and pick it up, but part-way through putting in your home phone number, you realise that you're overreacting, and put the phone down.";
Constant SC_521 = "You say goodbye to ";
Constant SC_515 = "You say hello to ";
Constant SC_351 = "You say hello to Dudley.";
Constant SC_304 = "You see nothing unexpected in that direction.";
Constant SC_235 = "You should be out of bed before trying to reach the door.";
Constant SC_308 = "You should leave these. They're family possessions.";
Constant SC_548 = "You sit down, and bash out something reminiscent of an old Beatles song.";
Constant SC_538 = "You smash open the windows with a satisfying, and very loud, noise of breaking glass.";
Constant SC_334 = "You take ";
Constant SC_276 = "You take a big bite from the ";
Constant SC_447 = "You take the suitcase from ";
Constant SC_463 = "You turn on the Television, but the only thing on is children's shows.";
Constant SC_541 = "You turn on the tap, rub some soap into your hands, and scrub them thoroughly.";
Constant SC_458 = "You turn the tv on, but there's nothing good to watch.";
Constant SC_738 = "You unfold the letter, and see a message written in the recognisable handwriting of Petunia's sister.";
Constant SC_510 = "You unlock ";
Constant SC_732 = "You walk in to the cupboard to be greeted by the sight of years of accumulated junk that Petunia insisted was kept away from the rest of the suspiciously clean house.";
Constant SC_297 = "You wouldn't fit in there.";
Constant SC_256 = "You write ~";
Constant SC_615 = "You";
Constant SC_527 = "You're not on the line with anyone.";
Constant SC_520 = "You're not talking to ";
Constant SC_254 = "You're not talking to anyone.";
Constant SC_260 = "You've already done that!";
Constant SC_53 = "Your battle scarred telephone, scratched from years of rage at wrong numbers and irritating customers.";
Constant SC_197 = "Your boss walks into the office. ~Good Job~, he says. ~I see you've made a few good sales. go, take a break; have some lunch.~.";
Constant SC_336 = "Your lovely wife Petunia.";
Constant SC_14 = "Your name is Vernon Dursley. You live at number four, privet drive.";
Constant SC_35 = "Your wife Petunia. She looks perfect.";
Constant SC_634 = "Your";
Constant SC_646 = "Yours";
Constant SC_427 = "@{5C}p";
Constant SC_800 = "a ";
Constant SC_37 = "a coffee cup";
Constant SC_383 = "a cot";
Constant SC_802 = "a door through to the dining room";
Constant SC_801 = "a door through to the living-room";
Constant SC_57 = "a filing cabinet";
Constant SC_590 = "a fire to start, which you quickly extinguish!";
Constant SC_758 = "a flock of small brown owls";
Constant SC_38 = "a fridge";
Constant SC_796 = "a ginger cat with bandy legs";
Constant SC_581 = "a gorilla shaped cloud of mist";
Constant SC_580 = "a green jet of light";
Constant SC_757 = "a large tawny owl";
Constant SC_760 = "a large white owl";
Constant SC_724 = "a latched panel in the ceiling";
Constant SC_839 = "a number with no spaces or dashes, e.g. 1234-4536 becomes 12344536";
Constant SC_671 = "a number";
Constant SC_291 = "a paper on which is written:";
Constant SC_55 = "a rolodex";
Constant SC_62 = "a shop door";
Constant SC_759 = "a small white owl";
Constant SC_191 = "a smashed and battered car.";
Constant SC_39 = "a steak";
Constant SC_375 = "a suitcase";
Constant SC_67 = "a tea cup";
Constant SC_747 = "a white door";
Constant SC_56 = "a window";
Constant SC_790 = "achieved";
Constant SC_97 = "acknowledgements";
Constant SC_819 = "after finishing your calls, you should be let out to get lunch. take the money from your desk before going. applies to work office or dursley's office or vernon's office.";
Constant SC_306 = "after he spent an hour counting them.";
Constant SC_825 = "after watching tv, petunia will eventually come into the room with some tea. maybe play some piano while waiting for her. when she does, drink the tea. you don't want to hurt her feelings, do you? applies to living-room and dursley's bedroom. applies to petunia.";
Constant SC_401 = "all";
Constant SC_443 = "also ";
Constant SC_54 = "an important customer service document";
Constant SC_754 = "and a fridge.";
Constant SC_386 = "and books with titles such as ";
Constant SC_752 = "and see ";
Constant SC_818 = "answer any niceties of mr. mason same as you did for the other customer. he will then ask for a drill that has a specific use. the list of specific uses for the drill is on a paper in the suitcase. if you left that at home, go to your cabinet and look through it untill you find the spare copy. applies to work office or dursley's office or vernon's office. applies to mr. mason.";
Constant SC_815 = "answer the customer's questions with simple answers, like ~hello~, ~good~, ~terrible~. applies to work office or dursley's office or vernon's office. applies to customer.";
Constant SC_658 = "any room";
Constant SC_660 = "any thing";
Constant SC_661 = "any thing/any room";
Constant SC_602 = "are";
Constant SC_184 = "as you close the garage, a secret hole opens in the floor, revealing a Ferrari, which is slowly brought out to ground level";
Constant SC_41 = "as you look at the walls you see that Dudley has thrown his cereal everywhere. ~little tyke!~ you chortle.";
Constant SC_756 = "as you look out the window, you see ";
Constant SC_286 = "as you open the drawer, you see ";
Constant SC_248 = "ask them for the HAL 6502";
Constant SC_249 = "ask them for the hal 6502";
Constant SC_713 = "at 8:30";
Constant SC_664 = "back in/on ";
Constant SC_85 = "bar";
Constant SC_12 = "bedroom window";
Constant SC_826 = "before going to bed, look out the window. applies to dursley's bedroom.";
Constant SC_186 = "big, grey, spacious, it's like any other garage you know";
Constant SC_579 = "blue sparks";
Constant SC_380 = "breadstick";
Constant SC_33 = "broom";
Constant SC_379 = "bun";
Constant SC_205 = "call 8953";
Constant SC_838 = "call/phone ";
Constant SC_442 = "can ";
Constant SC_753 = "cereal all over the walls, ";
Constant SC_372 = "coffee";
Constant SC_32 = "cupboard";
Constant SC_711 = "d";
Constant SC_378 = "doughnut";
Constant SC_742 = "downright horrible. There are also some real show-offs here too. James Potter is the most boisterous of them, but his";
Constant SC_111 = "drink";
Constant SC_110 = "eat";
Constant SC_50 = "elevator button";
Constant SC_517 = "es";
Constant SC_105 = "examine";
Constant SC_431 = "expelliarmus";
Constant SC_791 = "failed";
Constant SC_450 = "first standing up)";
Constant SC_741 = "first time and already I feel like an old timer. I'm still wary of some of the teachers we have though. Some of them are";
Constant SC_833 = "flip ";
Constant SC_214 = "fly";
Constant SC_84 = "foo";
Constant SC_118 = "for talking to people, if something seems like it is worded like a yes or no question, try answering yes or no, as it probably is a yes or no question";
Constant SC_373 = "fridge";
Constant SC_743 = "friend Sirius is pretty self-centered too. On the other hand, the rest of his friends aren't bad. Remus Lupin is rather";
Constant SC_751 = "from your chair ";
Constant SC_750 = "from your highchair ";
Constant SC_764 = "front door";
Constant SC_809 = "get car keys from inside suitcase to unlock car. type ~bedside~ to find out where to get combination for the lock. applies to kitchen.";
Constant SC_103 = "get down";
Constant SC_812 = "get in car and go north. then go west to enter grunnings carpark. applies to garden and highway.";
Constant SC_835 = "get out from under ";
Constant SC_813 = "get out of car, go up elevator or stairs, and go north to enter dursley's office. applies to carpark, corridor, and work office or dursley's office or vernon's office.";
Constant SC_823 = "get out of the office and go back down to the carpark. get into your car and go back to your home. applies to grunnings carpark and highway and garden.";
Constant SC_104 = "get up";
Constant SC_822 = "go back across the road and back up to your office, where the rest of the day will go by in a cutscene. applies to carpark and street and work office or dursley's office or vernon's office.";
Constant SC_807 = "go downstairs and enter the kitchen. applies to landing.";
Constant SC_820 = "go downstairs, walk across the road, and enter the bakery. buy some lunch. a donut, maybe. applies to work office or dursley's office or vernon's office. applies to carpark. applies to bakery or bakers.";
Constant SC_824 = "go into the living room.sit down and turn on the tv - there might be something interesting. applies to hall and living room or living-room.";
Constant SC_106 = "go to";
Constant SC_834 = "go under ";
Constant SC_272 = "good";
Constant SC_572 = "hardiness and ability to withstand impact";
Constant SC_607 = "has";
Constant SC_606 = "have";
Constant SC_621 = "he";
Constant SC_556 = "her lot.~";
Constant SC_631 = "her";
Constant SC_644 = "hers";
Constant SC_639 = "him";
Constant SC_630 = "his";
Constant SC_471 = "how can you drink from an empty cup?";
Constant SC_27 = "how to spoil your children handbook";
Constant SC_613 = "ies";
Constant SC_577 = "in ";
Constant SC_188 = "in trouble";
Constant SC_116 = "inv/i/take inventory/inventory";
Constant SC_48 = "is this- is this a clown car?";
Constant SC_603 = "is";
Constant SC_625 = "it";
Constant SC_573 = "its low price";
Constant SC_632 = "its";
Constant SC_744 = "kind, and his friend Peter Pettigrew is quite well mannered, if frustratingly shy.";
Constant SC_112 = "lock/unlock";
Constant SC_806 = "look at the clock. applies to dursley's bedroom.";
Constant SC_428 = "look chair";
Constant SC_811 = "look in the garage. applies to garden.";
Constant SC_836 = "look under ";
Constant SC_102 = "look";
Constant SC_706 = "looking at the small meal, you wonder if it will be enough to sustain you till your lunch-time doughnut.";
Constant SC_810 = "maybe take a look around the other rooms of the house before leaving. you might find something interesting. applies to dursley's house.";
Constant SC_587 = "no obvious ill effects";
Constant SC_714 = "now";
Constant SC_594 = "objects to dance around more energetically than you could ever manage";
Constant SC_593 = "objects to dance around more energetically than you could ever manage.";
Constant SC_578 = "on ";
Constant SC_705 = "one of Dudley's favourite toys";
Constant SC_667 = "open sesame (opens and unlocks all doors and containers and vehicles in the whole game)";
Constant SC_804 = "open the wardrobe and try on some clothes. applies to dursley's bedroom.";
Constant SC_113 = "open/close";
Constant SC_837 = "put/hide ";
Constant SC_610 = "re";
Constant SC_814 = "read the importand customer service document to recieve phone call. applies to work office or dursley's office or vernon's office.";
Constant SC_583 = "red sparks";
Constant SC_673 = "remove ";
Constant SC_672 = "restore score (changes the score to what it was before being artificially inflated)";
Constant SC_340 = "s Cereal all over the place, can you go get the broom and clean it up?~";
Constant SC_611 = "s";
Constant SC_190 = "safe";
Constant SC_803 = "say ~get up~ to get out of bed. applies to dursley's bedroom.";
Constant SC_444 = "see ";
Constant SC_81 = "see some suggestions for AMUSING things to do";
Constant SC_622 = "she";
Constant SC_288 = "some boring papers to send off";
Constant SC_842 = "some text";
Constant SC_289 = "some work that you filed yesterday";
Constant SC_663 = "something off-stage";
Constant SC_674 = "something";
Constant SC_665 = "somewhere";
Constant SC_51 = "stairs";
Constant SC_374 = "steak";
Constant SC_460 = "t know about that, but it's not only the owls that have been acting oddly today.";
Constant SC_666 = "take (anything, even fixed things or doors)";
Constant SC_109 = "take";
Constant SC_808 = "talk to petunia and dudley. applies to kitchen. applies to dudley and petunia.";
Constant SC_382 = "tea";
Constant SC_657 = "teleport to/Apparate to ";
Constant SC_780 = "tell the customer to ~call 8953~. ";
Constant SC_237 = "that cereal's Dudleys. and it's also been in his mouth.";
Constant SC_623 = "that";
Constant SC_17 = "the bedroom door";
Constant SC_371 = "the coffee cup";
Constant SC_34 = "the cupboard door";
Constant SC_65 = "the dining room door";
Constant SC_377 = "the door";
Constant SC_388 = "the fridge";
Constant SC_43 = "the front door";
Constant SC_387 = "the how to spoil your children handbook";
Constant SC_376 = "the important customer service document";
Constant SC_748 = "the kitchen door";
Constant SC_36 = "the kitchen table";
Constant SC_66 = "the living-room door";
Constant SC_384 = "the pair of glasses";
Constant SC_19 = "the staircase";
Constant SC_381 = "the tea cup";
Constant SC_569 = "the time is ";
Constant SC_585 = "the wand to burn a hole in the wall!";
Constant SC_584 = "the wand to shoot out of your hand!";
Constant SC_385 = "the wand";
Constant SC_7 = "the";
Constant SC_628 = "their";
Constant SC_642 = "theirs";
Constant SC_638 = "them";
Constant SC_816 = "there is a prompt in the customer service document that tells you to ~call 8953~ and so on. follow the words in the quotation marks. applies to work office or dursley's office or vernon's office. applies to customer.";
Constant SC_624 = "they";
Constant SC_619 = "those";
Constant SC_817 = "to recieve next phone call, read the rolodex. if it isn't on the right page, it will still make the call, although you should flip it till it says it is on today's page. applies to work office or dursley's office or vernon's office. applies to mr. mason.";
Constant SC_300 = "to the ";
Constant SC_840 = "to write on something, say ~write on ";
Constant SC_96 = "top bar";
Constant SC_805 = "try looking in the bedside table's drawer. applies to dursley's bedroom.";
Constant SC_451 = "underneath the ";
Constant SC_430 = "unlock case with dursley";
Constant SC_710 = "ve";
Constant SC_215 = "walk";
Constant SC_821 = "when you walk out of the shop, ~listen~ to the people on the street. you might find something of use in their conversation... applies to bakery or bakers. applies to street. ";
Constant SC_221 = "while ";
Constant SC_582 = "white sparks";
Constant SC_570 = "work with large, tough, unweildy bolts";
Constant SC_571 = "working with small, fiddly screws";
Constant SC_612 = "y";
Constant SC_465 = "you ";
Constant SC_185 = "you can see your ferrari taking pride of place in your garage.";
Constant SC_499 = "you can't do that.";
Constant SC_546 = "you flip the rollerdex back to today's page.";
Constant SC_545 = "you flip the rollerdex to a random page.";
Constant SC_464 = "you gently move the priceless car to the Garden.";
Constant SC_473 = "you grab the broom and clean the mess up. ~Thank you Vernon~.";
Constant SC_568 = "you jump out of the window.";
Constant SC_13 = "you look out the window and see the lovely gray of Surrey suburbia.";
Constant SC_263 = "you need to be in a car to drive.";
Constant SC_765 = "you need your suitcase to get to work, don't you?";
Constant SC_206 = "you put down the office phone, cutting the connection.";
Constant SC_497 = "you remove ";
Constant SC_797 = "you see an office door to the north with the words ~Vernon Dursley~ on a plaque in front of it. ";
Constant SC_194 = "you see few cars in the Carpark today. Must be lots of people skipping work today. Slackers. It's people like them that keep our profits down... ";
Constant SC_591 = "you to appear in another room.";
Constant SC_565 = "you wave the wand and shout ";
Constant SC_620 = "you";
Constant SC_287 = "your Complaints section, which takes a whole drawer on it's own";
Constant SC_290 = "your collection of the yearly editions of 101 Pompous Complaints";
Constant SC_73 = "your garden is to the west.";
Constant SC_763 = "your normal work vehicle, coloured a dark shade of Greyish-black.";
Constant SC_629 = "your";
Constant SC_643 = "yours";

#ifndef p0_specification; Constant p0_specification = 0; #endif;
#ifndef p1_indefinite_appearance_tex; Constant p1_indefinite_appearance_tex = 0; #endif;
#ifndef p2_variable_initial_value; Constant p2_variable_initial_value = 0; #endif;
#ifndef short_name; Constant short_name = 0; #endif;
#ifndef plural; Constant plural = 0; #endif;
#ifndef article; Constant article = 0; #endif;
#ifndef description; Constant description = 0; #endif;
#ifndef map_region; Constant map_region = 0; #endif;
#ifndef initial; Constant initial = 0; #endif;
#ifndef p9_opposite; Constant p9_opposite = 0; #endif;
#ifndef door_to; Constant door_to = 0; #endif;
#ifndef capacity; Constant capacity = 0; #endif;
#ifndef with_key; Constant with_key = 0; #endif;
#ifndef p13_openyesno; Constant p13_openyesno = 0; #endif;
#ifndef p14_calling_number; Constant p14_calling_number = 0; #endif;
#ifndef p15_owner; Constant p15_owner = 0; #endif;
#ifndef pluralname; Constant pluralname = 0; #endif;
#ifndef proper; Constant proper = 0; #endif;
#ifndef privately_named; Constant privately_named = 0; #endif;
#ifndef light; Constant light = 0; #endif;
#ifndef visited; Constant visited = 0; #endif;
#ifndef light; Constant light = 0; #endif;
#ifndef edible; Constant edible = 0; #endif;
#ifndef static; Constant static = 0; #endif;
#ifndef scenery; Constant scenery = 0; #endif;
#ifndef clothing; Constant clothing = 0; #endif;
#ifndef pushable; Constant pushable = 0; #endif;
#ifndef moved; Constant moved = 0; #endif;
#ifndef concealed; Constant concealed = 0; #endif;
#ifndef workflag; Constant workflag = 0; #endif;
#ifndef mentioned; Constant mentioned = 0; #endif;
#ifndef enterable; Constant enterable = 0; #endif;
#ifndef transparent; Constant transparent = 0; #endif;
#ifndef open; Constant open = 0; #endif;
#ifndef openable; Constant openable = 0; #endif;
#ifndef lockable; Constant lockable = 0; #endif;
#ifndef locked; Constant locked = 0; #endif;
#ifndef female; Constant female = 0; #endif;
#ifndef neuter; Constant neuter = 0; #endif;
#ifndef on; Constant on = 0; #endif;
#ifndef p57_recurring; Constant p57_recurring = 0; #endif;
#ifndef p59_underlying; Constant p59_underlying = 0; #endif;
#ifndef p60_large; Constant p60_large = 0; #endif;
#ifndef p61_small; Constant p61_small = 0; #endif;
#ifndef p62_medium; Constant p62_medium = 0; #endif;
#ifndef p63_huge; Constant p63_huge = 0; #endif;
#ifndef p64_ambiguously_plural; Constant p64_ambiguously_plural = 0; #endif;
#ifndef p66_cost; Constant p66_cost = 0; #endif;
#ifndef p67_seen; Constant p67_seen = 0; #endif;
#ifndef p69_familiar; Constant p69_familiar = 0; #endif;
#ifndef p71_inuse; Constant p71_inuse = 0; #endif;
#ifndef p72_other_party; Constant p72_other_party = 0; #endif;
#ifndef p73_posture; Constant p73_posture = 0; #endif;
#ifndef p74_posture_permission; Constant p74_posture_permission = 0; #endif;
#ifndef p75_posture_friendly; Constant p75_posture_friendly = 0; #endif;
#ifndef p77_occupied; Constant p77_occupied = 0; #endif;
#ifndef p78_foodlevel; Constant p78_foodlevel = 0; #endif;
#ifndef p79_drinklevel; Constant p79_drinklevel = 0; #endif;
#ifndef p80_venture; Constant p80_venture = 0; #endif;
#ifndef worn; Constant worn = 0; #endif;
#ifndef vector; Constant vector = 0; #endif;
#ifndef room_index; Constant room_index = 0; #endif;
#ifndef door_dir; Constant door_dir = 0; #endif;
#ifndef door_to; Constant door_to = 0; #endif;
#ifndef found_in; Constant found_in = 0; #endif;
#ifndef absent; Constant absent = 0; #endif;
#ifndef list_together; Constant list_together = 0; #endif;
#ifndef cap_short_name; Constant cap_short_name = 0; #endif;
#ifndef mark_as_room; Constant mark_as_room = 0; #endif;
#ifndef mark_as_thing; Constant mark_as_thing = 0; #endif;
#ifndef component_parent; Constant component_parent = 0; #endif;
#ifndef component_child; Constant component_child = 0; #endif;
#ifndef component_sibling; Constant component_sibling = 0; #endif;
#ifndef regional_found_in; Constant regional_found_in = 0; #endif;
#ifndef IK1_Count; Constant IK1_Count = 0; #endif;
#ifndef IK1_Link; Constant IK1_Link = 0; #endif;
#ifndef IK2_Count; Constant IK2_Count = 0; #endif;
#ifndef IK2_Link; Constant IK2_Link = 0; #endif;
#ifndef IK3_Count; Constant IK3_Count = 0; #endif;
#ifndef IK3_Link; Constant IK3_Link = 0; #endif;
#ifndef IK4_Count; Constant IK4_Count = 0; #endif;
#ifndef IK4_Link; Constant IK4_Link = 0; #endif;
#ifndef IK5_Count; Constant IK5_Count = 0; #endif;
#ifndef IK5_Link; Constant IK5_Link = 0; #endif;
#ifndef IK6_Count; Constant IK6_Count = 0; #endif;
#ifndef IK6_Link; Constant IK6_Link = 0; #endif;
#ifndef IK7_Count; Constant IK7_Count = 0; #endif;
#ifndef IK7_Link; Constant IK7_Link = 0; #endif;
#ifndef IK8_Count; Constant IK8_Count = 0; #endif;
#ifndef IK8_Link; Constant IK8_Link = 0; #endif;
#ifndef IK9_Count; Constant IK9_Count = 0; #endif;
#ifndef IK9_Link; Constant IK9_Link = 0; #endif;
#ifndef IK10_Count; Constant IK10_Count = 0; #endif;
#ifndef IK10_Link; Constant IK10_Link = 0; #endif;
#ifndef IK11_Count; Constant IK11_Count = 0; #endif;
#ifndef IK11_Link; Constant IK11_Link = 0; #endif;
#ifndef IK12_Count; Constant IK12_Count = 0; #endif;
#ifndef IK12_Link; Constant IK12_Link = 0; #endif;
#ifndef IK13_Count; Constant IK13_Count = 0; #endif;
#ifndef IK13_Link; Constant IK13_Link = 0; #endif;
#ifndef IK14_Count; Constant IK14_Count = 0; #endif;
#ifndef IK14_Link; Constant IK14_Link = 0; #endif;
#ifndef IK15_Count; Constant IK15_Count = 0; #endif;
#ifndef IK15_Link; Constant IK15_Link = 0; #endif;
#ifndef IK16_Count; Constant IK16_Count = 0; #endif;
#ifndef IK16_Link; Constant IK16_Link = 0; #endif;
#ifndef IK17_Count; Constant IK17_Count = 0; #endif;
#ifndef IK17_Link; Constant IK17_Link = 0; #endif;
#ifndef IK18_Count; Constant IK18_Count = 0; #endif;
#ifndef IK18_Link; Constant IK18_Link = 0; #endif;
#ifndef IK19_Count; Constant IK19_Count = 0; #endif;
#ifndef IK19_Link; Constant IK19_Link = 0; #endif;
#ifndef IK20_Count; Constant IK20_Count = 0; #endif;
#ifndef IK20_Link; Constant IK20_Link = 0; #endif;
#ifndef IK21_Count; Constant IK21_Count = 0; #endif;
#ifndef IK21_Link; Constant IK21_Link = 0; #endif;
#ifndef IK22_Count; Constant IK22_Count = 0; #endif;
#ifndef IK22_Link; Constant IK22_Link = 0; #endif;
#ifndef IK23_Count; Constant IK23_Count = 0; #endif;
#ifndef IK23_Link; Constant IK23_Link = 0; #endif;
#ifndef IK24_Count; Constant IK24_Count = 0; #endif;
#ifndef IK24_Link; Constant IK24_Link = 0; #endif;
#ifndef IK25_Count; Constant IK25_Count = 0; #endif;
#ifndef IK25_Link; Constant IK25_Link = 0; #endif;
#ifndef IK26_Count; Constant IK26_Count = 0; #endif;
#ifndef IK26_Link; Constant IK26_Link = 0; #endif;
#ifndef IK27_Count; Constant IK27_Count = 0; #endif;
#ifndef IK27_Link; Constant IK27_Link = 0; #endif;
#ifndef IK28_Count; Constant IK28_Count = 0; #endif;
#ifndef IK28_Link; Constant IK28_Link = 0; #endif;
#ifndef IK29_Count; Constant IK29_Count = 0; #endif;
#ifndef IK29_Link; Constant IK29_Link = 0; #endif;
#ifndef IK30_Count; Constant IK30_Count = 0; #endif;
#ifndef IK30_Link; Constant IK30_Link = 0; #endif;
#ifndef IK31_Count; Constant IK31_Count = 0; #endif;
#ifndef IK31_Link; Constant IK31_Link = 0; #endif;
#ifndef IK32_Count; Constant IK32_Count = 0; #endif;
#ifndef IK32_Link; Constant IK32_Link = 0; #endif;
#ifndef IK33_Count; Constant IK33_Count = 0; #endif;
#ifndef IK33_Link; Constant IK33_Link = 0; #endif;
#ifndef IK34_Count; Constant IK34_Count = 0; #endif;
#ifndef IK34_Link; Constant IK34_Link = 0; #endif;
#ifndef IK35_Count; Constant IK35_Count = 0; #endif;
#ifndef IK35_Link; Constant IK35_Link = 0; #endif;
#ifndef IK36_Count; Constant IK36_Count = 0; #endif;
#ifndef IK36_Link; Constant IK36_Link = 0; #endif;
#ifndef IK37_Count; Constant IK37_Count = 0; #endif;
#ifndef IK37_Link; Constant IK37_Link = 0; #endif;
#ifndef IK38_Count; Constant IK38_Count = 0; #endif;
#ifndef IK38_Link; Constant IK38_Link = 0; #endif;
#ifndef IK39_Count; Constant IK39_Count = 0; #endif;
#ifndef IK39_Link; Constant IK39_Link = 0; #endif;
#ifndef IK40_Count; Constant IK40_Count = 0; #endif;
#ifndef IK40_Link; Constant IK40_Link = 0; #endif;
#ifndef IK41_Count; Constant IK41_Count = 0; #endif;
#ifndef IK41_Link; Constant IK41_Link = 0; #endif;
#ifndef IK42_Count; Constant IK42_Count = 0; #endif;
#ifndef IK42_Link; Constant IK42_Link = 0; #endif;
#ifndef IK43_Count; Constant IK43_Count = 0; #endif;
#ifndef IK43_Link; Constant IK43_Link = 0; #endif;
#ifndef IK44_Count; Constant IK44_Count = 0; #endif;
#ifndef IK44_Link; Constant IK44_Link = 0; #endif;
#ifndef IK45_Count; Constant IK45_Count = 0; #endif;
#ifndef IK45_Link; Constant IK45_Link = 0; #endif;
#ifndef IK46_Count; Constant IK46_Count = 0; #endif;
#ifndef IK46_Link; Constant IK46_Link = 0; #endif;
#ifndef IK47_Count; Constant IK47_Count = 0; #endif;
#ifndef IK47_Link; Constant IK47_Link = 0; #endif;
#ifndef IK48_Count; Constant IK48_Count = 0; #endif;
#ifndef IK48_Link; Constant IK48_Link = 0; #endif;
#ifndef IK49_Count; Constant IK49_Count = 0; #endif;
#ifndef IK49_Link; Constant IK49_Link = 0; #endif;
#ifndef IK50_Count; Constant IK50_Count = 0; #endif;
#ifndef IK50_Link; Constant IK50_Link = 0; #endif;
#ifndef IK51_Count; Constant IK51_Count = 0; #endif;
#ifndef IK51_Link; Constant IK51_Link = 0; #endif;
#ifndef IK52_Count; Constant IK52_Count = 0; #endif;
#ifndef IK52_Link; Constant IK52_Link = 0; #endif;
#ifndef IK53_Count; Constant IK53_Count = 0; #endif;
#ifndef IK53_Link; Constant IK53_Link = 0; #endif;
#ifndef IK54_Count; Constant IK54_Count = 0; #endif;
#ifndef IK54_Link; Constant IK54_Link = 0; #endif;
#ifndef KD_Count; Constant KD_Count = 0; #endif;
#ifndef name; Constant name = 0; #endif;
#ifndef parse_name; Constant parse_name = 0; #endif;
#ifndef action_bitmap; Constant action_bitmap = 0; #endif;

#IFNDEF cap_short_name;
Constant cap_short_name = short_name;
#ENDIF;
Array I7_ST_say_one_of --> 35;
Array I7_ST_say_first_time --> 6;

Array Runtime_Quotations_Displayed --> 1;

[ InitialHeapAllocation obj pv;
    pv = (Global_Vars-->34); (Global_Vars-->34) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->35); (Global_Vars-->35) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->41); (Global_Vars-->41) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->45); (Global_Vars-->45) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->46); (Global_Vars-->46) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->47); (Global_Vars-->47) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->48); (Global_Vars-->48) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->49); (Global_Vars-->49) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->50); (Global_Vars-->50) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->51); (Global_Vars-->51) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->52); (Global_Vars-->52) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->53); (Global_Vars-->53) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->54); (Global_Vars-->54) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->55); (Global_Vars-->55) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->56); (Global_Vars-->56) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->57); (Global_Vars-->57) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->58); (Global_Vars-->58) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->59); (Global_Vars-->59) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->60); (Global_Vars-->60) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->61); (Global_Vars-->61) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->62); (Global_Vars-->62) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->63); (Global_Vars-->63) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->64); (Global_Vars-->64) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->65); (Global_Vars-->65) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->66); (Global_Vars-->66) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->67); (Global_Vars-->67) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->68); (Global_Vars-->68) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->73); (Global_Vars-->73) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->74); (Global_Vars-->74) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
    pv = (Global_Vars-->75); (Global_Vars-->75) = BlkValueCreate(INDEXED_TEXT_TY,pv,INDEXED_TEXT_TY);
];
[ DistributeBlockConstants obj pv;
];
#ifdef TARGET_ZCODE;
Constant MEMORY_HEAP_SIZE = 16384;
#ifnot;
Constant MEMORY_HEAP_SIZE = 65536;
#endif;


Array KD0_phrase_nothing_to_nothing --> ! phrase nothing -> nothing
    PHRASE_TY 1    UNKNOWN_TY;
Array Default_Value_0 --> KD0_phrase_nothing_to_nothing Def_Phrase_0 "default value of phrase nothing -> nothing";
[ Def_Phrase_0 a b c d e f g h;
    return false;
];

Array KD1_values_based_rule_producin --> ! values based rule producing values
    RULE_TY 2 VALUE_TY VALUE_TY;
Array KD2_activity --> ! activity
    ACTIVITY_TY 1 NIL_TY;
Array KD3_list_of_telephones --> ! list of telephones
    LIST_OF_TY 1 9;
Array KD4_relation_of_rooms_to_doors --> ! relation of rooms to doors
    RELATION_TY 2 9 9;
Array KD5_relation_of_things_to_thin --> ! relation of things to things
    RELATION_TY 2 9 9;
Array KD6_relation_of_people_to_peop --> ! relation of people to people
    RELATION_TY 2 9 9;
Array KD7_relation_of_things_to_post --> ! relation of things to postures
    RELATION_TY 2 9 46;
[ DefaultValueFinder K;
    if (K == KD0_phrase_nothing_to_nothing) return Default_Value_0;
    return 0;
];


Constant BLK_HEADER_N = 0;
Constant BLK_HEADER_FLAGS = 1;
Constant BLK_FLAG_MULTIPLE = $$00000001;
Constant BLK_FLAG_16_BIT   = $$00000010;
Constant BLK_FLAG_WORD     = $$00000100;
Constant BLK_FLAG_RESIDENT = $$00001000;
Constant BLK_HEADER_KOV = 1;

Constant BLK_DATA_OFFSET = 2*WORDSIZE;

Constant BLK_DATA_MULTI_OFFSET = 4*WORDSIZE;
Constant BLK_NEXT 2;
Constant BLK_PREV 3;

#IFDEF MEMORY_HEAP_SIZE;

! Constant SHOW_ALLOCATIONS = 1; ! Uncomment this for debugging purposes

[ BlkType txb;
	return txb-->BLK_HEADER_KOV;
];

[ BlkSize txb bsize n; ! Size of an individual block, including header
	if (txb == 0) return 0;
	for (bsize=1: n<txb->BLK_HEADER_N: bsize=bsize*2) n++;
	return bsize;
];

[ BlkTotalSize txb tsize; ! Combined size of multiple-blocks for a value
	if (txb == 0) return 0;
	if ((txb->BLK_HEADER_FLAGS) & BLK_FLAG_MULTIPLE == 0)
		return BlkSize(txb);
	for (:txb~=NULL:txb=txb-->BLK_NEXT) {
		tsize = tsize + BlkSize(txb);
	}
	return tsize;
];

[ BlkDebug txb n k i bsize tot dtot kov;
	if (txb == 0) "Block never created.";
	kov = txb-->BLK_HEADER_KOV;
	print "Block ", txb, " (kov ", kov, "): ";
	for (:txb~=NULL:txb = txb-->BLK_NEXT) {
		if (k++ == 100) " ... and so on.";
		if (txb-->BLK_HEADER_KOV ~= kov)
			print "*Wrong kov=", txb-->BLK_HEADER_KOV, "* ";
		n = txb->BLK_HEADER_N;
		for (bsize=1:n>0:n--) bsize=bsize*2;
		i = bsize - BLK_DATA_OFFSET;
		dtot = dtot+i;
		tot = tot+bsize;
		print txb, "(", bsize, ") > ";
	}
	print dtot, " data in ", tot, " bytes^";
];

[ BlkDebugDecomposition from to txb pf;
	if (to==0) to = NULL;
	for (txb=from:(txb~=to) && (txb~=NULL):txb=txb-->BLK_NEXT) {
		if (pf) print "+";
		print BlkSize(txb);
		pf = true;
	}
	print "^";
];

Array Blk_Heap -> MEMORY_HEAP_SIZE + 16; ! Plus 16 to allow room for head-free-block

[ HeapInitialise n bsize blk2;
	blk2 = Blk_Heap + 16;
	Blk_Heap->BLK_HEADER_N = 4;
	Blk_Heap-->BLK_HEADER_KOV = 0;
	Blk_Heap->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
	Blk_Heap-->BLK_NEXT = blk2;
	Blk_Heap-->BLK_PREV = NULL;
	for (bsize=1: bsize < MEMORY_HEAP_SIZE: bsize=bsize*2) n++;
	blk2->BLK_HEADER_N = n;
	blk2-->BLK_HEADER_KOV = 0;
	blk2->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
	blk2-->BLK_NEXT = NULL;
	blk2-->BLK_PREV = Blk_Heap;
];

[ HeapNetFreeSpace multiple txb asize;
	for (txb=Blk_Heap-->BLK_NEXT: txb~=NULL: txb=txb-->BLK_NEXT) {
		asize = asize + BlkSize(txb);
		if (multiple) asize = asize - BLK_DATA_MULTI_OFFSET;
		else asize = asize - BLK_DATA_OFFSET;
	}
	return asize;
];

Constant SMALLEST_BLK_WORTH_ALLOCATING = 12; ! i.e. 2^12 = 4096 bytes

[ HeapMakeSpace size multiple  newblocksize newblock B n;
	for (::) {
		if (multiple) {
			if (HeapNetFreeSpace(multiple) >= size) rtrue;
		} else {
			if (HeapLargestFreeBlock(0) >= size) rtrue;
		}
		newblocksize = 1;
		for (n=0: (n<SMALLEST_BLK_WORTH_ALLOCATING) || (newblocksize<size): n++)
			newblocksize = newblocksize*2;
		while (newblocksize < size+16) newblocksize = newblocksize*2;
		newblock = VM_AllocateMemory(newblocksize);
		if (newblock == 0) rfalse;
		newblock->BLK_HEADER_N = n;
		newblock-->BLK_HEADER_KOV = 0;
		newblock->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
		newblock-->BLK_NEXT = NULL;
		newblock-->BLK_PREV = NULL;
		for (B = Blk_Heap-->BLK_NEXT:B ~= NULL:B = B-->BLK_NEXT)
			if (B-->BLK_NEXT == NULL) {
				B-->BLK_NEXT = newblock;
				newblock-->BLK_PREV = B;
				jump Linked;
			}
		Blk_Heap-->BLK_NEXT = newblock;
		newblock-->BLK_PREV = Blk_Heap;
		.Linked; ;
		#ifdef SHOW_ALLOCATIONS;
		print "Increasing heap to free space map: "; BlkDebugDecomposition(Blk_Heap, 0);
		#endif;
	}
	rtrue;
];

[ HeapLargestFreeBlock multiple txb asize best;
	best = 0;
	for (txb=Blk_Heap-->BLK_NEXT: txb~=NULL: txb=txb-->BLK_NEXT) {
		asize = BlkSize(txb);
		if (multiple) asize = asize - BLK_DATA_MULTI_OFFSET;
		else asize = asize - BLK_DATA_OFFSET;
		if (asize > best) best = asize;
	}
	return best;
];

[ BlkAllocate size kov flags
	dsize n m free_block min_m max_m smallest_oversized_block secondhalf i hsize head tail;
	
	if (HeapMakeSpace(size, flags & BLK_FLAG_MULTIPLE) == false) 
		return BlkAllocationError("ran out");

	! Calculate the header size for a block of this KOV
	if (flags & BLK_FLAG_MULTIPLE) hsize = BLK_DATA_MULTI_OFFSET;
	else hsize = BLK_DATA_OFFSET;

	! Calculate the data size
	n=0; for (dsize=1: dsize < hsize+size: dsize=dsize*2) n++;

	! Seek a free block closest to the correct size, but starting from the
	! block after the fixed head-free-block, which we can't touch
	min_m = 10000; max_m = 0;
	for (free_block = Blk_Heap-->BLK_NEXT:
		free_block ~= NULL:
		free_block = free_block-->BLK_NEXT) {
		m = free_block->BLK_HEADER_N;
		! Current block the ideal size
		if (m == n) jump CorrectSizeFound;
		! Current block too large: find the smallest which is larger than needed
		if (m > n) {
			if (min_m > m) {
				min_m = m;
				smallest_oversized_block = free_block;
			}
		}
		! Current block too small: find the largest which is smaller than needed
		if (m < n) {
			if (max_m < m) {
				max_m = m;
			}
		}
	}

	if (min_m == 10000) {
		! Case I: No block is large enough to hold the entire size
		if (flags & BLK_FLAG_MULTIPLE == 0) return BlkAllocationError("too fragmented");
		! Set dsize to the size in bytes if the largest block available
		for (dsize=1: max_m > 0: dsize=dsize*2) max_m--;
		! Split as a head (dsize-hsize), which we can be sure fits into one block,
		! plus a tail (size-(dsize-hsize), which might be a list of blocks
		head = BlkAllocate(dsize-hsize, kov, flags);
		if (head == 0) return BlkAllocationError("head block not available");
		tail = BlkAllocate(size-(dsize-hsize), kov, flags);
		if (tail == 0) return BlkAllocationError("tail block not available");
		head-->BLK_NEXT = tail;
		tail-->BLK_PREV = head;
		return head;
	}

	! Case II: No block is the right size, but some exist which are too big
	! Set dsize to the size in bytes of the smallest oversized block
	for (dsize=1,m=1: m<=min_m: dsize=dsize*2) m++;
	free_block = smallest_oversized_block;
	while (min_m > n) {
		! Repeatedly halve free_block at the front until the two smallest
		! fragments left are the correct size: then take the frontmost
		dsize = dsize/2;
		secondhalf = free_block + dsize;
		secondhalf-->BLK_NEXT = free_block-->BLK_NEXT;
		if (secondhalf-->BLK_NEXT ~= NULL)
			(secondhalf-->BLK_NEXT)-->BLK_PREV = secondhalf;
		secondhalf-->BLK_PREV = free_block;
		free_block-->BLK_NEXT = secondhalf;
		free_block->BLK_HEADER_N = (free_block->BLK_HEADER_N) - 1;
		secondhalf->BLK_HEADER_N = free_block->BLK_HEADER_N;
		secondhalf-->BLK_HEADER_KOV = free_block-->BLK_HEADER_KOV;
		secondhalf->BLK_HEADER_FLAGS = free_block->BLK_HEADER_FLAGS;
		min_m--;
	}
	
	! Once that is done, free_block points to a block which is exactly the
	! right size, so we can fall into...
	
	! Case III: There is a free block which has the correct size.
	.CorrectSizeFound;
	! Delete the free block from the double linked list of free blocks: note
	! that it cannot be the head of this list, which is fixed
	if (free_block-->BLK_NEXT == NULL) {
		! We remove final block, so previous is now final
		(free_block-->BLK_PREV)-->BLK_NEXT = NULL;
	} else {
		! We remove a middle block, so join previous to next
		(free_block-->BLK_PREV)-->BLK_NEXT = free_block-->BLK_NEXT;
		(free_block-->BLK_NEXT)-->BLK_PREV = free_block-->BLK_PREV;
	}
	free_block-->BLK_HEADER_KOV = KindAtomic(kov);
	free_block->BLK_HEADER_FLAGS = flags;
	if (flags & BLK_FLAG_MULTIPLE) {
		free_block-->BLK_NEXT = NULL;
		free_block-->BLK_PREV = NULL;
	}
	
	! Zero out the data bytes in the memory allocated
	for (i=hsize:i<dsize:i++) free_block->i=0;
	return free_block;
];

[ BlkAllocationError reason;
	print "*** Memory ", (string) reason, " ***^";
	RunTimeProblem(RTP_HEAPERROR);
	rfalse;
];

[ BlkMerge block first last pv nx;
	first = block; last = block;
	while (last-->BLK_NEXT == last+BlkSize(last))
		last = last-->BLK_NEXT;
	while ((first-->BLK_PREV + BlkSize(first-->BLK_PREV) == first) &&
		(first-->BLK_PREV ~= Blk_Heap))
		first = first-->BLK_PREV;
	pv = first-->BLK_PREV;
	nx = last-->BLK_NEXT;
	#ifdef SHOW_ALLOCATIONS;
	print "Merging: "; BlkDebugDecomposition(pv-->BLK_NEXT, nx); print "^";
	#endif;
	if (BlkRecut(first, last)) {
		#ifdef SHOW_ALLOCATIONS;
		print " --> "; BlkDebugDecomposition(pv-->BLK_NEXT, nx); print "^";
		#endif;
	}
];

[ BlkRecut first last tsize backsize mfrom mto bnext backend n dsize fine_so_far;
	if (first == last) rfalse;
	mfrom = first; mto = last + BlkSize(last);
	bnext = last-->BLK_NEXT;
	fine_so_far = true;
	for (:mto>mfrom: mto = mto - backsize) {
		for (n=0, backsize=1: backsize*2 <= mto-mfrom: n++) backsize=backsize*2;
		if ((fine_so_far) && (backsize == BlkSize(last))) {
			bnext = last; last = last-->BLK_PREV;
			bnext-->BLK_PREV = last;
			last-->BLK_NEXT = bnext;
			continue;
		}
		fine_so_far = false; ! From this point, "last" is meaningless
		backend = mto - backsize;
		backend->BLK_HEADER_N = n;
		backend-->BLK_HEADER_KOV = 0;
		backend->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
		backend-->BLK_NEXT = bnext;
		if (bnext ~= NULL) {
			bnext-->BLK_PREV = backend;
			bnext = backend;
		}
	}
	if (fine_so_far) rfalse;
	rtrue;
];

[ BlkFree block fromtxb ptxb;
	if (block == 0) return;
	if ((block->BLK_HEADER_FLAGS) & BLK_FLAG_RESIDENT) return;
	BlkValueDestroy(block);
	if ((block->BLK_HEADER_FLAGS) & BLK_FLAG_MULTIPLE) {
		if (block-->BLK_PREV ~= NULL) (block-->BLK_PREV)-->BLK_NEXT = NULL;
		fromtxb = block;
		for (:(block-->BLK_NEXT)~=NULL:block = block-->BLK_NEXT) ;
		while (block ~= fromtxb) {
			ptxb = block-->BLK_PREV; BlkFreeSingleBlock(block); block = ptxb;
		}
	}
	BlkFreeSingleBlock(block);
];

[ BlkFreeSingleBlock block free nx;
	block-->BLK_HEADER_KOV = 0;
	block->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
	for (free = Blk_Heap:free ~= NULL:free = free-->BLK_NEXT) {
		nx = free-->BLK_NEXT;
		if (nx == NULL) {
			free-->BLK_NEXT = block;
			block-->BLK_PREV = free;
			block-->BLK_NEXT = NULL;
			BlkMerge(block);
			return;
		}
		if (UnsignedCompare(nx, block) == 1) {
			free-->BLK_NEXT = block;
			block-->BLK_PREV = free;
			block-->BLK_NEXT = nx;
			nx-->BLK_PREV = block;
			BlkMerge(block);
			return;
		}
	}
];

[ BlkResize block req newsize dsize newblk kov n i otxb flags;
	if (block == 0) "*** Cannot resize null block ***";
	kov = block-->BLK_HEADER_KOV;
	flags = block->BLK_HEADER_FLAGS;
	if (flags & BLK_FLAG_MULTIPLE == 0) "*** Cannot resize inextensible block ***";
	otxb = block;
	newsize = req;
	for (:: block = block-->BLK_NEXT) {
		n = block->BLK_HEADER_N;
		for (dsize=1: n>0: n--) dsize = dsize*2;
		i = dsize - BLK_DATA_MULTI_OFFSET;
		newsize = newsize - i;
		if (newsize > 0) {
			if (block-->BLK_NEXT ~= NULL) continue;
			newblk = BlkAllocate(newsize, kov, flags);
			if (newblk == 0) rfalse;
			block-->BLK_NEXT = newblk;
			newblk-->BLK_PREV = block;
			rtrue;
		}
		if (block-->BLK_NEXT ~= NULL) {
			BlkFree(block-->BLK_NEXT);
			block-->BLK_NEXT = NULL;
		}
		rtrue;
	}
];

[ DebugHeap;
	print "Managing a heap of initially ", MEMORY_HEAP_SIZE+16, " bytes.^";
	print HeapNetFreeSpace(false), " bytes currently free.^";
	print "Free space decomposition: "; BlkDebugDecomposition(Blk_Heap);
	print "Free space map: "; BlkDebug(Blk_Heap);
];

#IFNOT; ! IFDEF MEMORY_HEAP_SIZE

[ HeapInitialise; ];
[ BlkFree; ];
[ DebugHeap;
	"This story file does not use a heap of managed memory.";
];

#ENDIF; ! IFDEF MEMORY_HEAP_SIZE

#IFDEF MEMORY_HEAP_SIZE;

[ BlkValueExtent block  tsize flags;
	if (block == 0) return 0;
	flags = block->BLK_HEADER_FLAGS;
	if (flags & BLK_FLAG_MULTIPLE == 0)
		tsize = BlkSize(block) - BLK_DATA_OFFSET;
	else
		for (:block~=NULL:block=block-->BLK_NEXT)
			tsize = tsize + BlkSize(block) - BLK_DATA_MULTI_OFFSET;
	if (flags & BLK_FLAG_16_BIT) return tsize/2;
	if (flags & BLK_FLAG_WORD) return tsize/WORDSIZE;
	return tsize;
];

[ BlkValueSetExtent block tsize flags wsize;
	if (block == 0) return 0;
	flags = block->BLK_HEADER_FLAGS; wsize = 1;
	if (flags & BLK_FLAG_WORD) wsize = WORDSIZE;
	if (flags & BLK_FLAG_16_BIT) wsize = 2;
	return BlkResize(block, (tsize)*wsize);
];

[ BlkValueRead block pos dsize hsize flags wsize ot op;
	if (block==0) rfalse;
	flags = block->BLK_HEADER_FLAGS; wsize = 1;
	if (flags & BLK_FLAG_WORD) wsize = WORDSIZE;
	if (flags & BLK_FLAG_16_BIT) wsize = 2;
	ot = block; op = pos;
	pos = pos*wsize;
	if (flags & BLK_FLAG_MULTIPLE) hsize = BLK_DATA_MULTI_OFFSET;
	else hsize = BLK_DATA_OFFSET;
	for (:block~=NULL:block=block-->BLK_NEXT) {
		dsize = BlkSize(block) - hsize;
		if ((pos >= 0) && (pos<dsize)) {
			block = block + hsize + pos;
			switch(wsize) {
				1: return block->0;
				2:	#Iftrue (WORDSIZE == 2); return block-->0;
					#ifnot; return (block->0)*256 + (block->1);
					#endif;
				4: return block-->0;
			}
		}
		pos = pos - dsize;
	}
	"*** BlkValueRead: reading from index out of range: ", op, " in ", ot, " ***";
];

[ BlkValueWrite block pos val dsize hsize flags wsize ot op;
	if (block==0) rfalse;
	flags = block->BLK_HEADER_FLAGS; wsize = 1;
	if (flags & BLK_FLAG_WORD) wsize = WORDSIZE;
	if (flags & BLK_FLAG_16_BIT) wsize = 2;
	ot = block; op = pos;
	pos = pos*wsize;
	if (flags & BLK_FLAG_MULTIPLE) hsize = BLK_DATA_MULTI_OFFSET;
	else hsize = BLK_DATA_OFFSET;
	for (:block~=NULL:block=block-->BLK_NEXT) {
		dsize = BlkSize(block) - hsize;
		if ((pos >= 0) && (pos<dsize)) {
			block = block + hsize + pos;
			switch(wsize) {
				1: block->0 = val;
				2:	#Iftrue (WORDSIZE == 2); block-->0 = val;
					#ifnot; block->0 = (val/256)%256; block->1 = val%256;
					#endif;
				4: block-->0 = val;
			}
			return;
		}
		pos = pos - dsize;
	}
	"*** BlkValueWrite: writing to index out of range: ", op, " in ", ot, " ***";
];

Constant CREATE_KOVS     = 1;
Constant CAST_KOVS       = 2;
Constant DESTROY_KOVS    = 3;
Constant PRECOPY_KOVS    = 4;
Constant COPY_KOVS       = 5;
Constant COMPARE_KOVS    = 6;
Constant READ_FILE_KOVS  = 7;
Constant WRITE_FILE_KOVS = 8;
Constant HASH_KOVS       = 9;

Global block_value_tally;
[ BlkValueCreate kov cast_from skov  block sf;

	if (skov == 0 && (kov < 0 || kov >= BASE_KIND_HWM)) skov = kov;

	sf = KOVSupportFunction(kov);
	if (sf) block = sf(CREATE_KOVS, cast_from, skov);
	else { print "*** Impossible runtime creation ***^"; rfalse; }

#ifdef SHOW_ALLOCATIONS;
	print "[created ", kov, " at ", block, ": ", block_value_tally++, "]^";
#endif;
	return block;
];

[ BlkValueCast block tokov fromkov fromval  sf;
	sf = KOVSupportFunction(tokov);
	if (sf) return sf(CAST_KOVS, fromval, fromkov, block);
	else { print "*** Impossible runtime cast ***^"; rfalse; }
];

[ BlkValueDestroy block  k rv sf;
	if (block == 0) return;
	k = block-->BLK_HEADER_KOV;
	sf = KOVSupportFunction(k);
	if (sf) return sf(DESTROY_KOVS, block);
	else { print "*** Impossible runtime deallocation ***^"; rfalse; }
];

[ BlkValueCopy blockto blockfrom dsize i sf;
	if (blockto == 0) { print "*** Deep copy failed: destination empty ***^"; rfalse; }
	if (blockfrom == 0) { print "*** Deep copy failed: source empty ***^"; rfalse; }

	if (blockfrom->BLK_HEADER_N == 0) {
		! A hack to handle precompiled array constants: N=0 blocks otherwise don't exist
		LIST_OF_TY_CopyRawArray(blockto, blockfrom, 1, 0);
		return blockto;
	}

	if (blockfrom-->BLK_HEADER_KOV ~= blockto-->BLK_HEADER_KOV) {
		print "*** Deep copy failed: types mismatch ***^"; rfalse;
	}

	BlkValueDestroy(blockto);

	dsize = BlkValueExtent(blockfrom);

	if (((blockfrom->BLK_HEADER_FLAGS) & BLK_FLAG_MULTIPLE) &&
		(BlkValueSetExtent(blockto, dsize, -1) == false)) {
		print "*** Deep copy failed: resizing failed ***^"; rfalse;
	}

	sf = KOVSupportFunction(blockfrom-->BLK_HEADER_KOV);

	if (sf) sf(PRECOPY_KOVS, blockto, blockfrom);

	for (i=0:i<dsize:i++) BlkValueWrite(blockto, i, BlkValueRead(blockfrom, i));

	if (sf) sf(COPY_KOVS, blockto, blockfrom);
	else { print "*** Impossible runtime copy ***^"; rfalse; }
	return blockto;
];

[ BlkValueCompare blockleft blockright  kov sf;
	if ((blockleft == 0) && (blockright == 0)) return 0;
	if (blockleft == 0) return 1;
	if (blockright == 0) return -1;
	if (blockleft-->BLK_HEADER_KOV ~= blockright-->BLK_HEADER_KOV)
		return blockleft-->BLK_HEADER_KOV - blockright-->BLK_HEADER_KOV;
	kov = blockleft-->BLK_HEADER_KOV;

	sf = KOVSupportFunction(kov);
	if (sf) return sf(COMPARE_KOVS, blockleft, blockright);
	else { print "*** Impossible runtime comparison ***^"; rfalse; }
];

[ BlkValueInitialCopy blockto blockfrom dsize i;
	if (blockto == 0) { print "*** Initial copy failed: destination empty ***^"; rfalse; }
	if (blockfrom == 0) { print "*** Initial copy failed: source empty ***^"; rfalse; }
	dsize = 1; for (i=1: i<=blockfrom->BLK_HEADER_N: i++) dsize=dsize*2;
	for (i=0:i<dsize:i++) blockto->i = blockfrom->i;
	return blockto;
];

[ BlkValueHash block  kov sf;
	if (block == 0) return 0;
	kov = block-->BLK_HEADER_KOV;
	sf = KOVSupportFunction(kov);
	if (sf) return sf(HASH_KOVS, block);
	else { print "*** Impossible runtime hashing ***^"; rfalse; }
];

[ KOVHashValue kov value;
	if (KOVIsBlockValue(kov)) return BlkValueHash(value);
	return value;
];

[ BlkValueReadFromFile block auxf ch kov  sf;
	sf = KOVSupportFunction(kov);
	if (sf) return sf(READ_FILE_KOVS, block, auxf, ch);
	rfalse;
];

[ BlkValueWriteToFile block kov  sf;
	sf = KOVSupportFunction(kov);
	if (sf) return sf(WRITE_FILE_KOVS, block);
	rfalse;
];

#IFNOT; ! IFDEF MEMORY_HEAP_SIZE

[ BlkValueReadFromFile; rfalse; ];
[ BlkValueWriteToFile; rfalse; ];
[ BlkValueCreate x y z; ];
[ BlkValueDestroy x; ];
[ BlkValueCopy x y; ];
[ BlkValueCompare x y; ];

#ENDIF; ! IFDEF MEMORY_HEAP_SIZE

#IFDEF MEMORY_HEAP_SIZE; ! Will exist if any use is made of indexed texts

#IFDEF TARGET_ZCODE;
Constant IT_Storage_Flags = BLK_FLAG_MULTIPLE;
Constant ZSCII_Tables;
#IFNOT;
Constant IT_Storage_Flags = BLK_FLAG_MULTIPLE + BLK_FLAG_16_BIT;
Constant Large_Unicode_Tables;
#ENDIF;

Constant UNIC_NCT = 10000; ! Safe as highest case-change delta is 8383

#IFDEF ZSCII_Tables;
Array CharCasingChart0 -->
    $0061 (  26) (     -32) $009b (   3) (       3) $00a1 (   1) (UNIC_NCT)
    $00a4 (   2) (       3) $00a6 (   1) (UNIC_NCT) $00a9 (   6) (       6)
    $00b5 (   5) (       5) $00bf (   5) (       5) $00c9 (  -3) (       1)
    $00cd (   3) (       3) $00d3 (  -3) (       1) $00d7 (   2) (       2)
    $00dc (   1) (       1) $0000
;

Array CharCasingChart1 -->
    $0041 (  26) (      32) $009e (   3) (      -3) $00a7 (   2) (      -3)
    $00af (   6) (      -6) $00ba (   5) (      -5) $00c4 (   5) (      -5)
    $00ca (  -3) (      -1) $00d0 (   3) (      -3) $00d4 (  -3) (      -1)
    $00d9 (   2) (      -2) $00dd (   1) (      -1) $0000
;
#ENDIF; ! ZSCII_Tables

#IFDEF Small_Unicode_Tables;
Array CharCasingChart0 -->
    $0061 (  26) (     -32) $00aa (   1) (UNIC_NCT) $00b5 (   1) (UNIC_NCT) $00ba (   1) (UNIC_NCT)
    $00df (   1) (UNIC_NCT) $00e0 (  23) (     -32) $00f8 (   7) (     -32) $00ff (   1) (UNIC_NCT)
    $0000
;

Array CharCasingChart1 -->
    $0041 (  26) (      32) $00c0 (  23) (      32) $00d8 (   7) (      32) $0000
;

#ENDIF; ! Small_Unicode_Tables

#IFDEF Large_Unicode_Tables;
Array CharCasingChart0 -->
    $0061 (  26) (     -32) $00aa (   1) (UNIC_NCT) $00b5 (   1) (     743) $00ba (   1) (UNIC_NCT)
    $00df (   1) (UNIC_NCT) $00e0 (  23) (     -32) $00f8 (   7) (     -32) $00ff (   1) (     121)
    $0101 ( -47) (      -1) $0131 (   1) (    -232) $0133 (  -5) (      -1) $0138 (   1) (UNIC_NCT)
    $013a ( -15) (      -1) $0149 (   1) (UNIC_NCT) $014b ( -45) (      -1) $017a (  -5) (      -1)
    $017f (   1) (    -300) $0180 (   1) (UNIC_NCT) $0183 (  -3) (      -1) $0188 (   1) (      -1)
    $018c (   1) (      -1) $018d (   1) (UNIC_NCT) $0192 (   1) (      -1) $0195 (   1) (      97)
    $0199 (   1) (      -1) $019a (   2) (UNIC_NCT) $019e (   1) (     130) $01a1 (  -5) (      -1)
    $01a8 (   1) (      -1) $01aa (   2) (UNIC_NCT) $01ad (   1) (      -1) $01b0 (   1) (      -1)
    $01b4 (  -3) (      -1) $01b9 (   1) (      -1) $01ba (   1) (UNIC_NCT) $01bd (   1) (      -1)
    $01be (   1) (UNIC_NCT) $01bf (   1) (      56) $01c6 (   1) (      -2) $01c9 (   1) (      -2)
    $01cc (   1) (      -2) $01ce ( -15) (      -1) $01dd (   1) (     -79) $01df ( -17) (      -1)
    $01f0 (   1) (UNIC_NCT) $01f3 (   1) (      -2) $01f5 (   1) (      -1) $01f9 ( -39) (      -1)
    $0221 (   1) (UNIC_NCT) $0223 ( -17) (      -1) $0234 (   3) (UNIC_NCT) $0250 (   3) (UNIC_NCT)
    $0253 (   1) (    -210) $0254 (   1) (    -206) $0255 (   1) (UNIC_NCT) $0256 (   2) (    -205)
    $0258 (   1) (UNIC_NCT) $0259 (   1) (    -202) $025a (   1) (UNIC_NCT) $025b (   1) (    -203)
    $025c (   4) (UNIC_NCT) $0260 (   1) (    -205) $0261 (   2) (UNIC_NCT) $0263 (   1) (    -207)
    $0264 (   4) (UNIC_NCT) $0268 (   1) (    -209) $0269 (   1) (    -211) $026a (   5) (UNIC_NCT)
    $026f (   1) (    -211) $0270 (   2) (UNIC_NCT) $0272 (   1) (    -213) $0273 (   2) (UNIC_NCT)
    $0275 (   1) (    -214) $0276 (  10) (UNIC_NCT) $0280 (   1) (    -218) $0281 (   2) (UNIC_NCT)
    $0283 (   1) (    -218) $0284 (   4) (UNIC_NCT) $0288 (   1) (    -218) $0289 (   1) (UNIC_NCT)
    $028a (   2) (    -217) $028c (   6) (UNIC_NCT) $0292 (   1) (    -219) $0293 (  29) (UNIC_NCT)
    $0390 (   1) (UNIC_NCT) $03ac (   1) (     -38) $03ad (   3) (     -37) $03b0 (   1) (UNIC_NCT)
    $03b1 (  17) (     -32) $03c2 (   1) (     -31) $03c3 (   9) (     -32) $03cc (   1) (     -64)
    $03cd (   2) (     -63) $03d0 (   1) (     -62) $03d1 (   1) (     -57) $03d5 (   1) (     -47)
    $03d6 (   1) (     -54) $03d7 (   1) (UNIC_NCT) $03d9 ( -23) (      -1) $03f0 (   1) (     -86)
    $03f1 (   1) (     -80) $03f2 (   1) (       7) $03f3 (   1) (UNIC_NCT) $03f5 (   1) (     -96)
    $03f8 (   1) (      -1) $03fb (   1) (      -1) $0430 (  32) (     -32) $0450 (  16) (     -80)
    $0461 ( -33) (      -1) $048b ( -53) (      -1) $04c2 ( -13) (      -1) $04d1 ( -37) (      -1)
    $04f9 (   1) (      -1) $0501 ( -15) (      -1) $0561 (  38) (     -48) $0587 (   1) (UNIC_NCT)
    $1d00 (  44) (UNIC_NCT) $1d62 (  10) (UNIC_NCT) $1e01 (-149) (      -1) $1e96 (   5) (UNIC_NCT)
    $1e9b (   1) (     -59) $1ea1 ( -89) (      -1) $1f00 (   8) (       8) $1f10 (   6) (       8)
    $1f20 (   8) (       8) $1f30 (   8) (       8) $1f40 (   6) (       8) $1f50 (   1) (UNIC_NCT)
    $1f51 (   1) (       8) $1f52 (   1) (UNIC_NCT) $1f53 (   1) (       8) $1f54 (   1) (UNIC_NCT)
    $1f55 (   1) (       8) $1f56 (   1) (UNIC_NCT) $1f57 (   1) (       8) $1f60 (   8) (       8)
    $1f70 (   2) (      74) $1f72 (   4) (      86) $1f76 (   2) (     100) $1f78 (   2) (     128)
    $1f7a (   2) (     112) $1f7c (   2) (     126) $1f80 (   8) (       8) $1f90 (   8) (       8)
    $1fa0 (   8) (       8) $1fb0 (   2) (       8) $1fb2 (   1) (UNIC_NCT) $1fb3 (   1) (       9)
    $1fb4 (  -3) (UNIC_NCT) $1fb7 (   1) (UNIC_NCT) $1fbe (   1) (   -7205) $1fc2 (   1) (UNIC_NCT)
    $1fc3 (   1) (       9) $1fc4 (  -3) (UNIC_NCT) $1fc7 (   1) (UNIC_NCT) $1fd0 (   2) (       8)
    $1fd2 (   2) (UNIC_NCT) $1fd6 (   2) (UNIC_NCT) $1fe0 (   2) (       8) $1fe2 (   3) (UNIC_NCT)
    $1fe5 (   1) (       7) $1fe6 (   2) (UNIC_NCT) $1ff2 (   1) (UNIC_NCT) $1ff3 (   1) (       9)
    $1ff4 (  -3) (UNIC_NCT) $1ff7 (   1) (UNIC_NCT) $2071 (   1) (UNIC_NCT) $207f (   1) (UNIC_NCT)
    $210a (   1) (UNIC_NCT) $210e (   2) (UNIC_NCT) $2113 (   1) (UNIC_NCT) $212f (   1) (UNIC_NCT)
    $2134 (   1) (UNIC_NCT) $2139 (   1) (UNIC_NCT) $213d (   1) (UNIC_NCT) $2146 (   4) (UNIC_NCT)
    $fb00 (   7) (UNIC_NCT) $fb13 (   5) (UNIC_NCT) $ff41 (  26) (     -32) $0000
;

Array CharCasingChart1 -->
    $0041 (  26) (      32) $00c0 (  23) (      32) $00d8 (   7) (      32) $0100 ( -47) (       1)
    $0130 (   1) (    -199) $0132 (  -5) (       1) $0139 ( -15) (       1) $014a ( -45) (       1)
    $0178 (   1) (    -121) $0179 (  -5) (       1) $0181 (   1) (     210) $0182 (  -3) (       1)
    $0186 (   1) (     206) $0187 (   1) (       1) $0189 (   2) (     205) $018b (   1) (       1)
    $018e (   1) (      79) $018f (   1) (     202) $0190 (   1) (     203) $0191 (   1) (       1)
    $0193 (   1) (     205) $0194 (   1) (     207) $0196 (   1) (     211) $0197 (   1) (     209)
    $0198 (   1) (       1) $019c (   1) (     211) $019d (   1) (     213) $019f (   1) (     214)
    $01a0 (  -5) (       1) $01a6 (   1) (     218) $01a7 (   1) (       1) $01a9 (   1) (     218)
    $01ac (   1) (       1) $01ae (   1) (     218) $01af (   1) (       1) $01b1 (   2) (     217)
    $01b3 (  -3) (       1) $01b7 (   1) (     219) $01b8 (   1) (       1) $01bc (   1) (       1)
    $01c4 (   1) (       2) $01c7 (   1) (       2) $01ca (   1) (       2) $01cd ( -15) (       1)
    $01de ( -17) (       1) $01f1 (   1) (       2) $01f4 (   1) (       1) $01f6 (   1) (     -97)
    $01f7 (   1) (     -56) $01f8 ( -39) (       1) $0220 (   1) (    -130) $0222 ( -17) (       1)
    $0386 (   1) (      38) $0388 (   3) (      37) $038c (   1) (      64) $038e (   2) (      63)
    $0391 (  17) (      32) $03a3 (   9) (      32) $03d2 (   3) (UNIC_NCT) $03d8 ( -23) (       1)
    $03f4 (   1) (     -60) $03f7 (   1) (       1) $03f9 (   1) (      -7) $03fa (   1) (       1)
    $0400 (  16) (      80) $0410 (  32) (      32) $0460 ( -33) (       1) $048a ( -53) (       1)
    $04c0 (   1) (UNIC_NCT) $04c1 ( -13) (       1) $04d0 ( -37) (       1) $04f8 (   1) (       1)
    $0500 ( -15) (       1) $0531 (  38) (      48) $10a0 (  38) (UNIC_NCT) $1e00 (-149) (       1)
    $1ea0 ( -89) (       1) $1f08 (   8) (      -8) $1f18 (   6) (      -8) $1f28 (   8) (      -8)
    $1f38 (   8) (      -8) $1f48 (   6) (      -8) $1f59 (  -7) (      -8) $1f68 (   8) (      -8)
    $1fb8 (   2) (      -8) $1fba (   2) (     -74) $1fc8 (   4) (     -86) $1fd8 (   2) (      -8)
    $1fda (   2) (    -100) $1fe8 (   2) (      -8) $1fea (   2) (    -112) $1fec (   1) (      -7)
    $1ff8 (   2) (    -128) $1ffa (   2) (    -126) $2102 (   1) (UNIC_NCT) $2107 (   1) (UNIC_NCT)
    $210b (   3) (UNIC_NCT) $2110 (   3) (UNIC_NCT) $2115 (   1) (UNIC_NCT) $2119 (   5) (UNIC_NCT)
    $2124 (   1) (UNIC_NCT) $2126 (   1) (   -7517) $2128 (   1) (UNIC_NCT) $212a (   1) (   -8383)
    $212b (   1) (   -8262) $212c (   2) (UNIC_NCT) $2130 (   2) (UNIC_NCT) $2133 (   1) (UNIC_NCT)
    $213e (   2) (UNIC_NCT) $2145 (   1) (UNIC_NCT) $ff21 (  26) (      32) $0000
;

#ENDIF; ! Large_Unicode_Tables

[ CharIsOfCase c case
	i tab min max len par;
	if (c<'A') rfalse;
	if (case == 0) {
		if ((c >= 'a') && (c <= 'z')) rtrue;
		tab = CharCasingChart0;
	} else {
		if ((c >= 'A') && (c <= 'Z')) rtrue;
		tab = CharCasingChart1;
	}
	if (c<128) rfalse;
	while (tab-->i) {
		min = tab-->i; i++;
		len = tab-->i; i++;
		i++;
		par = 0;
		if (len<0) { par = 1; len = -len; }
		if (c < min) rfalse;
		if (c < min+len) {
			if (par) { if ((c-min) % 2 == 0) rtrue; }
			else { rtrue; }
		}
	}
	rfalse;
];

[ CharToCase c case
	i tab min max len par del f;
	if (c<'A') return c;
	if (case == 1) {
		if ((c >= 'a') && (c <= 'z')) return c-32;
		tab = CharCasingChart0;
	} else {
		if ((c >= 'A') && (c <= 'Z')) return c+32;
		tab = CharCasingChart1;
	}
	if (c<128) return c;
	while (tab-->i) {
		min = tab-->i; i++;
		len = tab-->i; i++;
		del = tab-->i; i++;
		par = 0;
		if (len<0) { par = 1; len = -len; }
		if (c < min) return c;
		if (c < min+len) {
			f = false;
			if (par) { if ((c-min) % 2 == 0) f = true; }
			else { f = true; }
			if (f) {
				if (del == UNIC_NCT) return c;
				return c+del;
			}
		}
	}
	return c;
];

#IFDEF TARGET_ZCODE;
[ IT_RevCase ch;
	if (ch<'A') return ch;
	if ((ch >= 'a') && (ch <= 'z')) return ch-'a'+'A';
	if ((ch >= 'A') && (ch <= 'Z')) return ch-'A'+'a';
	if (ch<128) return ch;
	if ((ch >= 155) && (ch <= 157)) return ch+3; ! a, o, u umlaut in ZSCII
	if ((ch >= 158) && (ch <= 160)) return ch-3; ! A, O, U umlaut
	if ((ch >= 164) && (ch <= 165)) return ch+3; ! e, i umlaut
	if ((ch >= 167) && (ch <= 168)) return ch-3; ! E, I umlaut
	if ((ch >= 169) && (ch <= 174)) return ch+6; ! a, e, i, o, u, y acute
	if ((ch >= 175) && (ch <= 180)) return ch-6; ! A, E, I, O, U, Y acute
	if ((ch >= 181) && (ch <= 185)) return ch+5; ! a, e, i, o, u grave
	if ((ch >= 186) && (ch <= 190)) return ch-5; ! A, E, I, O, U grave
	if ((ch >= 191) && (ch <= 195)) return ch+5; ! a, e, i, o, u circumflex
	if ((ch >= 196) && (ch <= 200)) return ch-5; ! A, E, I, O, U circumflex
	if (ch == 201) return 202; ! a circle
	if (ch == 202) return 201; ! A circle
	if (ch == 203) return 204; ! o slash
	if (ch == 204) return 203; ! O slash
	if ((ch >= 205) && (ch <= 207)) return ch+3; ! a, n, o tilde
	if ((ch >= 208) && (ch <= 210)) return ch-3; ! A, N, O tilde
	if (ch == 211) return 212; ! ae ligature
	if (ch == 212) return 211; ! AE ligature
	if (ch == 213) return 214; ! c cedilla
	if (ch == 214) return 213; ! C cedilla
	if (ch == 215 or 216) return ch+2; ! thorn, eth
	if (ch == 217 or 218) return ch-2; ! Thorn, Eth
	if (ch == 220) return 221; ! oe ligature
	if (ch == 221) return 220; ! OE ligature
	return ch;
];
#IFNOT;
[ IT_RevCase ch;
	if (ch<'A') return ch;
	if ((ch >= 'a') && (ch <= 'z')) return ch-'a'+'A';
	if ((ch >= 'A') && (ch <= 'Z')) return ch-'A'+'a';
	if (ch<128) return ch;
	if (CharIsOfCase(ch, 0)) return CharToCase(ch, 1);
	if (CharIsOfCase(ch, 1)) return CharToCase(ch, 0);
	return ch;
];
#ENDIF;

[ CharTestCases case i j;
	for (i=32: i<$E0; i++) {
		if ((i>=127) && (i<155)) continue;
		print i, " - ", (char) i, " -";
		if (CharIsOfCase(i, 0)) print "  lower";
		if (CharIsOfCase(i, 1)) print "  upper";
		j = CharToCase(i, 0); if (j ~= i) print "  tolower: ", (char) j;
		j = CharToCase(i, 1); if (j ~= i) print "  toupper: ", (char) j;
		print "^";
	}
];


[ INDEXED_TEXT_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:     return INDEXED_TEXT_TY_Create(arg1);
		CAST_KOVS:       return INDEXED_TEXT_TY_Cast(arg1, arg2, arg3);
		DESTROY_KOVS:    rfalse;
		PRECOPY_KOVS:    rfalse;
		COPY_KOVS:       rfalse;
		COMPARE_KOVS:    return INDEXED_TEXT_TY_Compare(arg1, arg2);
		READ_FILE_KOVS:  if (arg3 == -1) rtrue;
			             return INDEXED_TEXT_TY_ReadFile(arg1, arg2, arg3);
		WRITE_FILE_KOVS: return INDEXED_TEXT_TY_WriteFile(arg1);
		HASH_KOVS:       return INDEXED_TEXT_TY_Hash(arg1);
	}
];

[ INDEXED_TEXT_TY_Create opcast x;
	x =  BlkAllocate(32, INDEXED_TEXT_TY, IT_Storage_Flags);
	if (opcast) INDEXED_TEXT_TY_Cast(opcast, TEXT_TY, x);
	return x;
];

#ifndef IT_MemoryBufferSize;
Constant IT_MemoryBufferSize = 512;
#endif;

Constant IT_Memory_NoBuffers = 2;

#ifndef IT_Memory_NoBuffers;
Constant IT_Memory_NoBuffers = 1;
#endif;

#ifdef TARGET_ZCODE;
Array IT_MemoryBuffer -> IT_MemoryBufferSize*IT_Memory_NoBuffers; ! Where characters are bytes
#ifnot;
Array IT_MemoryBuffer --> (IT_MemoryBufferSize+2)*IT_Memory_NoBuffers; ! Where characters are words
#endif;

Global RawBufferAddress = IT_MemoryBuffer;
Global RawBufferSize = IT_MemoryBufferSize;

Global IT_cast_nesting;

[ INDEXED_TEXT_TY_Cast tx fromkov indt
	len i str oldstr offs realloc news buff buffx freebuff results;
	#ifdef TARGET_ZCODE;
	buffx = IT_MemoryBufferSize;
	#ifnot;
	buffx = (IT_MemoryBufferSize + 2)*WORDSIZE;
	#endif;
	
	buff = RawBufferAddress + IT_cast_nesting*buffx;
	IT_cast_nesting++;
	if (IT_cast_nesting > IT_Memory_NoBuffers) {
		buff = VM_AllocateMemory(buffx); freebuff = buff;
		if (buff == 0) {
			BlkAllocationError("ran out with too many simultaneous indexed text conversions");
			return;
		}
	}

	.RetryWithLargerBuffer;
	if (tx == 0) {
		#ifdef TARGET_ZCODE;
		buff-->0 = 1;
		buff->2 = 0;
		#ifnot;
		buff-->0 = 0;
		#endif;
		len = 1;
	} else {
		#ifdef TARGET_ZCODE;
		@output_stream 3 buff;
		#ifnot;
		if (unicode_gestalt_ok == false) { RunTimeProblem(RTP_NOGLULXUNICODE); jump Failed; }
		oldstr = glk_stream_get_current();
		str = glk_stream_open_memory_uni(buff, RawBufferSize, filemode_Write, 0);
		glk_stream_set_current(str);
		#endif;

		@push say__p; @push say__pc;
		ClearParagraphing();
		if (fromkov == SNIPPET_TY) print (PrintSnippet) tx;
		else {
			if (tx ofclass String) print (string) tx;
			if (tx ofclass Routine) (tx)();	
		}
		@pull say__pc; @pull say__p;

		#ifdef TARGET_ZCODE;

		@output_stream -3;
		len = buff-->0;
		if (len > RawBufferSize-1) len = RawBufferSize-1;
		offs = 2;
		buff->(len+2) = 0;

		#ifnot; ! i.e. GLULX
		
		results = buff + buffx - 2*WORDSIZE;
		glk_stream_close(str, results);
		if (oldstr) glk_stream_set_current(oldstr);
		len = results-->1;
		if (len > RawBufferSize-1) {
			! Glulx had to truncate text output because the buffer ran out:
			! len is the number of characters which it tried to print
			news = RawBufferSize;
			while (news < len) news=news*2;
			news = news*4; ! Bytes rather than words
			i = VM_AllocateMemory(news);
			if (i ~= 0) {
				if (freebuff) VM_FreeMemory(freebuff);
				freebuff = i;
				buff = i;
				RawBufferSize = news/4;
				jump RetryWithLargerBuffer;
			}
			! Memory allocation refused: all we can do is to truncate the text
			len = RawBufferSize-1;
		}
		offs = 0;
		buff-->(len) = 0;

		#endif;

		len++;
	}

	IT_cast_nesting--;

	if (indt == 0) {
		indt = BlkAllocate(len+1, INDEXED_TEXT_TY, IT_Storage_Flags);
		if (indt == 0) jump Failed;
	} else {
		if (BlkValueSetExtent(indt, len+1, 1) == false) { indt = 0; jump Failed; }
	}

	#ifdef TARGET_ZCODE;
	for (i=0:i<=len:i++) BlkValueWrite(indt, i, buff->(i+offs));
	#ifnot;
	for (i=0:i<=len:i++) BlkValueWrite(indt, i, buff-->(i+offs));
	#endif;

	.Failed;
	if (freebuff) VM_FreeMemory(freebuff);

	return indt;
];

[ INDEXED_TEXT_TY_Compare indtleft indtright pos ch1 ch2 dsizeleft dsizeright;
	dsizeleft = BlkValueExtent(indtleft);
	dsizeright = BlkValueExtent(indtright);
	for (pos=0:(pos<dsizeleft) && (pos<dsizeright):pos++) {
		ch1 = BlkValueRead(indtleft, pos);
		ch2 = BlkValueRead(indtright, pos);
		if (ch1 ~= ch2) return ch1-ch2;
		if (ch1 == 0) return 0;
	}
	if (pos == dsizeleft) return -1;
	return 1;
];

[ INDEXED_TEXT_TY_Distinguish indtleft indtright;
	if (INDEXED_TEXT_TY_Compare(indtleft, indtright) == 0) rfalse;
	rtrue;
];

[ INDEXED_TEXT_TY_Hash indt  rv len i;
	rv = 0;
	len = BlkValueExtent(indt);
	for (i=0: i<len: i++)
		rv = rv * 33 + BlkValueRead(indt, i);
	return rv;
];

[ INDEXED_TEXT_TY_Say indt  ch i dsize;
	if ((indt==0) || (BlkType(indt) ~= INDEXED_TEXT_TY)) return;
	dsize = BlkValueExtent(indt);
	for (i=0:i<dsize:i++) {
		ch = BlkValueRead(indt, i);
		if (ch == 0) break;
		#ifdef TARGET_ZCODE;
		print (char) ch;
		#ifnot; ! TARGET_ZCODE
		glk_put_char_uni(ch);
		#endif;
	}
];

[ INDEXED_TEXT_TY_WriteFile txb len pos ch;
	len = BlkValueExtent(txb);
	print "S";
	for (pos=0: pos<=len: pos++) {
		if (pos == len) ch = 0; else ch = BlkValueRead(txb, pos);
		if (ch == 0) {
			print "0;"; break;
		} else {
			print ch, ",";
		}
	}
];

[ INDEXED_TEXT_TY_ReadFile indt auxf ch i v dg pos tsize;
	tsize = BlkValueExtent(indt);
	while (ch ~= 32 or 9 or 10 or 13 or 0 or -1) {
		ch = FileIO_GetC(auxf);
		if (ch == ',' or ';') {
			if (pos+1 >= tsize) {
				if (BlkValueSetExtent(indt, 2*pos, 20) == false) break;
				tsize = BlkValueExtent(indt);
			}
			BlkValueWrite(indt, pos++, v);
			v = 0;
			if (ch == ';') break;
		} else {
			dg = ch - '0';
			v = v*10 + dg;
		}
	}
	BlkValueWrite(indt, pos, 0);
	return indt;
];

[ INDEXED_TEXT_TY_ROGPR indt
	pos len wa wl wpos bdm ch own;
	if (indt == 0) return GPR_FAIL;
	bdm = true; own = wn;
	len = BlkValueExtent(indt);
	for (pos=0: pos<=len: pos++) {
		if (pos == len) ch = 0; else ch = BlkValueRead(indt, pos);
		if (ch == 32 or 9 or 10 or 0) {
			if (bdm) continue;
			bdm = true;
			if (wpos ~= wl) return GPR_FAIL;
			if (ch == 0) break;
		} else {
			if (bdm) {
				bdm = false;
				if (NextWordStopped() == -1) return GPR_FAIL;
				wa = WordAddress(wn-1);
				wl = WordLength(wn-1);
				wpos = 0;
			}
			if (wa->wpos ~= ch or IT_RevCase(ch)) return GPR_FAIL;
			wpos++;
		}
	}
	if (wn == own) return GPR_FAIL; ! Progress must be made to avoid looping
	return GPR_PREPOSITION;
];

Constant CHR_BLOB = 1; ! Construe as an array of characters
Constant WORD_BLOB = 2; ! Of words
Constant PWORD_BLOB = 3; ! Of punctuated words
Constant UWORD_BLOB = 4; ! Of unpunctuated words
Constant PARA_BLOB = 5; ! Of paragraphs
Constant LINE_BLOB = 6; ! Of lines

Constant REGEXP_BLOB = 7; ! Not a blob type as such, but needed as a distinct value

Constant WS_BRM = 1;
Constant SKIPPED_BRM = 2;
Constant ACCEPTED_BRM = 3;
Constant ACCEPTEDP_BRM = 4;
Constant ACCEPTEDN_BRM = 5;
Constant ACCEPTEDPN_BRM = 6;

[ IT_BlobAccess indt blobtype cindt wanted rindt
	brm oldbrm ch i dsize csize blobcount gp cl j;
	if ((indt==0) || (BlkType(indt) ~= INDEXED_TEXT_TY)) return 0;
	if (blobtype == CHR_BLOB) return IT_CharacterLength(indt);
	dsize = BlkValueExtent(indt);
	if (cindt) csize = BlkValueExtent(cindt);
	else if (rindt) "*** rindt without cindt ***";
	brm = WS_BRM;
	for (i=0:i<dsize:i++) {
		ch = BlkValueRead(indt, i);
		if (ch == 0) break;
		oldbrm = brm;
		if (ch == 10 or 13 or 32 or 9) {
			if (oldbrm ~= WS_BRM) {
				gp = 0;
				for (j=i:j<dsize:j++) {
					ch = BlkValueRead(indt, j);
					if (ch == 0) { brm = WS_BRM; break; }
					if (ch == 10 or 13) { gp++; continue; }
					if (ch ~= 32 or 9) break;
				}
				ch = BlkValueRead(indt, i);
				if (j == dsize) brm = WS_BRM;
				switch (blobtype) {
					PARA_BLOB: if (gp >= 2) brm = WS_BRM;
					LINE_BLOB: if (gp >= 1) brm = WS_BRM;
					default: brm = WS_BRM;
				}
			}
		} else {
			gp = false;
			if ((blobtype == WORD_BLOB or PWORD_BLOB or UWORD_BLOB) &&
				(ch == '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}'))
				gp = true;
			switch (oldbrm) {
				WS_BRM:
					brm = ACCEPTED_BRM;
					if (blobtype == WORD_BLOB) {
						if (gp) brm = SKIPPED_BRM;
					}
					if (blobtype == PWORD_BLOB) {
						if (gp) brm = ACCEPTEDP_BRM;
					}
				SKIPPED_BRM:
					if (blobtype == WORD_BLOB) {
						if (gp == false) brm = ACCEPTED_BRM;
					}
				ACCEPTED_BRM:
					if (blobtype == WORD_BLOB) {
						if (gp) brm = SKIPPED_BRM;
					}
					if (blobtype == PWORD_BLOB) {
						if (gp) brm = ACCEPTEDP_BRM;
					}
				ACCEPTEDP_BRM:
					if (blobtype == PWORD_BLOB) {
						if (gp == false) brm = ACCEPTED_BRM;
						else {
							if ((ch == BlkValueRead(indt, i-1)) &&
								(ch == '-' or '.')) blobcount--;
							blobcount++;
						}
					}
				ACCEPTEDN_BRM:
					if (blobtype == WORD_BLOB) {
						if (gp) brm = SKIPPED_BRM;
					}
					if (blobtype == PWORD_BLOB) {
						if (gp) brm = ACCEPTEDP_BRM;
					}
				ACCEPTEDPN_BRM:
					if (blobtype == PWORD_BLOB) {
						if (gp == false) brm = ACCEPTED_BRM;
						else {
							if ((ch == BlkValueRead(indt, i-1)) &&
								(ch == '-' or '.')) blobcount--;
							blobcount++;
						}
					}
			}
		}
		if (brm == ACCEPTED_BRM or ACCEPTEDP_BRM) {
			if (oldbrm ~= brm) blobcount++;
			if ((cindt) && (blobcount == wanted)) {
				if (rindt) {
					BlkValueWrite(cindt, cl, 0);
					IT_Concatenate(cindt, rindt, CHR_BLOB);
					csize = BlkValueExtent(cindt);
					cl = IT_CharacterLength(cindt);
					if (brm == ACCEPTED_BRM) brm = ACCEPTEDN_BRM;
					if (brm == ACCEPTEDP_BRM) brm = ACCEPTEDPN_BRM;
				} else {
					if (cl+1 >= csize) {
						if (BlkValueSetExtent(cindt, 2*cl, 2) == false) break;
						csize = BlkValueExtent(cindt);
					}
					BlkValueWrite(cindt, cl++, ch);
				}
			} else {
				if (rindt) {
					if (cl+1 >= csize) {
						if (BlkValueSetExtent(cindt, 2*cl, 3) == false) break;
						csize = BlkValueExtent(cindt);
					}
					BlkValueWrite(cindt, cl++, ch);
				}
			}
		} else {
			if ((rindt) && (brm ~= ACCEPTEDN_BRM or ACCEPTEDPN_BRM)) {
				if (cl+1 >= csize) {
					if (BlkValueSetExtent(cindt, 2*cl, 4) == false) break;
					csize = BlkValueExtent(cindt);
				}
				BlkValueWrite(cindt, cl++, ch);
			}
		}
	}
	if (cindt) BlkValueWrite(cindt, cl++, 0);
	return blobcount;
];

[ IT_GetBlob cindt indt wanted blobtype;
	if ((indt==0) || (BlkType(indt) ~= INDEXED_TEXT_TY)) return;
	if (blobtype == CHR_BLOB) return IT_GetCharacter(cindt, indt, wanted);
	IT_BlobAccess(indt, blobtype, cindt, wanted);
	return cindt;
];

[ IT_ReplaceBlob blobtype indt wanted rindt cindt ilen rlen i;
	if (blobtype == CHR_BLOB) {
		ilen = IT_CharacterLength(indt);
		rlen = IT_CharacterLength(rindt);
		wanted--;
		if ((wanted >= 0) && (wanted<ilen)) {
			if (rlen == 1) {
				BlkValueWrite(indt, wanted, BlkValueRead(rindt, 0));
			} else {
				cindt = BlkValueCreate(INDEXED_TEXT_TY);
				if (BlkValueSetExtent(cindt, ilen+rlen+1, 5)) {
					for (i=0:i<wanted:i++)
						BlkValueWrite(cindt, i, BlkValueRead(indt, i));
					for (i=0:i<rlen:i++)
						BlkValueWrite(cindt, wanted+i, BlkValueRead(rindt, i));
					for (i=wanted+1:i<ilen:i++)
						BlkValueWrite(cindt, rlen+i-1, BlkValueRead(indt, i));
					BlkValueWrite(cindt, rlen+ilen, 0);
					BlkValueCopy(indt, cindt);
				}
				BlkFree(cindt);
			}
		}
	} else {
		cindt = BlkValueCreate(INDEXED_TEXT_TY);
		IT_BlobAccess(indt, blobtype, cindt, wanted, rindt);
		BlkValueCopy(indt, cindt);	
		BlkFree(cindt);
	}
];

[ IT_ReplaceText blobtype indt findt rindt
	cindt csize ilen flen i cl mpos ch chm whitespace punctuation;
	
	if (blobtype == REGEXP_BLOB or CHR_BLOB) 
		return IT_Replace_RE(blobtype, indt, findt, rindt);
	
	ilen = IT_CharacterLength(indt);
	flen = IT_CharacterLength(findt);
	cindt = BlkValueCreate(INDEXED_TEXT_TY);
	csize = BlkValueExtent(cindt);
	mpos = 0;

	whitespace = true; punctuation = false;
	for (i=0:i<=ilen:i++) {
		ch = BlkValueRead(indt, i);
		.MoreMatching;
		chm = BlkValueRead(findt, mpos++);
		if (mpos == 1) {
			switch (blobtype) {
				WORD_BLOB:
					if ((whitespace == false) && (punctuation == false)) chm = -1;
			}
		}
		whitespace = false;
		if (ch == 10 or 13 or 32 or 9) whitespace = true;
		punctuation = false;
		if (ch == '.' or ',' or '!' or '?'
			or '-' or '/' or '"' or ':' or ';'
			or '(' or ')' or '[' or ']' or '{' or '}') {
			if (blobtype == WORD_BLOB) chm = -1;
			punctuation = true;
		}
		if (ch == chm) {
			if (mpos == flen) {
				if (i == ilen) chm = 0;
				else chm = BlkValueRead(indt, i+1);
				if ((blobtype == CHR_BLOB) ||
					(chm == 0 or 10 or 13 or 32 or 9) ||
					(chm == '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}')) {
					mpos = 0;
					cl = cl - (flen-1);
					BlkValueWrite(cindt, cl, 0);
					IT_Concatenate(cindt, rindt, CHR_BLOB);
					csize = BlkValueExtent(cindt);
					cl = IT_CharacterLength(cindt);
					continue;
				}
			}
		} else {
			mpos = 0;
		}
		if (cl+1 >= csize) {
			if (BlkValueSetExtent(cindt, 2*cl, 9) == false) break;
			csize = BlkValueExtent(cindt);
		}
		BlkValueWrite(cindt, cl++, ch);
	}
	BlkValueCopy(indt, cindt);	
	BlkFree(cindt);
];

[ IT_CharacterLength indt ch i dsize;
	if ((indt==0) || (BlkType(indt) ~= INDEXED_TEXT_TY)) return 0;
	dsize = BlkValueExtent(indt);
	for (i=0:i<dsize:i++) {
		ch = BlkValueRead(indt, i);
		if (ch == 0) return i;
	}
	return dsize;
];

[ INDEXED_TEXT_TY_Empty indt;
	if ((indt==0) || (BlkType(indt) ~= INDEXED_TEXT_TY)) rfalse;
	if (IT_CharacterLength(indt) == 0) rtrue;
	rfalse;
];

[ IT_GetCharacter cindt indt i ch;
	if ((indt==0) || (BlkType(indt) ~= INDEXED_TEXT_TY)) return;
	if ((i<=0) || (i>IT_CharacterLength(indt))) ch = 0;
	else ch = BlkValueRead(indt, i-1);
	BlkValueWrite(cindt, 0, ch);
	BlkValueWrite(cindt, 1, 0);
	return cindt;
];

[ IT_CharactersOfCase indt case i ch len;
	if ((indt==0) || (BlkType(indt) ~= INDEXED_TEXT_TY)) rfalse;
	len = IT_CharacterLength(indt);
	for (i=0:i<len:i++) {
		ch = BlkValueRead(indt, i);
		if ((ch) && (CharIsOfCase(ch, case) == false)) rfalse;
	}
	rtrue;
];

[ IT_CharactersToCase cindt indt case i ch len bnd;
	if ((indt==0) || (BlkType(indt) ~= INDEXED_TEXT_TY)) return;
	len = IT_CharacterLength(indt);
	if (BlkValueSetExtent(cindt, len+1, 11) == false) return cindt;
	bnd = 1;
	for (i=0:i<len:i++) {
		ch = BlkValueRead(indt, i);
		if (case < 2) {
			BlkValueWrite(cindt, i, CharToCase(ch, case));
		} else {
			BlkValueWrite(cindt, i, CharToCase(ch, bnd));
			if (case == 2) {
				bnd = 0;
				if (ch == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') bnd = 1;
			}
			if (case == 3) {
				if (ch ~= 0 or 10 or 13 or 32 or 9) {
					if (bnd == 1) bnd = 0;
					else {
						if (ch == '.' or '!' or '?') bnd = 1;
					}
				}
			}
		}
	}
	BlkValueWrite(cindt, len, 0);
	return cindt;
];

[ IT_Concatenate indt_to indt_from blobtype indt_ref
	pos len ch i tosize x y case;
	if ((indt_to==0) || (BlkType(indt_to) ~= INDEXED_TEXT_TY)) rfalse;
	if ((indt_from==0) || (BlkType(indt_from) ~= INDEXED_TEXT_TY)) return indt_to;
	switch(blobtype) {
		CHR_BLOB, 0:
			pos = IT_CharacterLength(indt_to);
			len = IT_CharacterLength(indt_from);
			if (BlkValueSetExtent(indt_to, pos+len+1, 10) == false) return indt_to;
			for (i=0:i<len:i++) {
				ch = BlkValueRead(indt_from, i);
				BlkValueWrite(indt_to, i+pos, ch);
			}
			BlkValueWrite(indt_to, len+pos, 0);
			return indt_to;
		REGEXP_BLOB:
			return IT_RE_Concatenate(indt_to, indt_from, blobtype, indt_ref);
		default:
			print "*** IT_Concatenate used on impossible blob type ***^";
			rfalse;
	}
];

[ SetPlayersCommand indt_from i len at;
	len = IT_CharacterLength(indt_from);
	if (len > 118) len = 118;
	#ifdef TARGET_ZCODE;
	buffer->1 = len; at = 2;
	#ifnot;
	buffer-->0 = len; at = 4;
	#endif;
	for (i=0:i<len:i++) buffer->(i+at) = CharToCase(BlkValueRead(indt_from, i), 0);
	for (:at+i<120:i++) buffer->(at+i) = ' ';
	VM_Tokenise(buffer, parse);
	players_command = 100 + WordCount(); ! The snippet variable ``player's command''
];

#IFNOT; ! IFDEF MEMORY_HEAP_SIZE

[ INDEXED_TEXT_TY_Support t a b c; rfalse; ];
[ INDEXED_TEXT_TY_Say indt; ];
[ SetPlayersCommand indt_from; ];
[ INDEXED_TEXT_TY_Create; ];
[ INDEXED_TEXT_TY_Cast a b c; ];
[ INDEXED_TEXT_TY_Empty t; rfalse; ];

#ENDIF; ! IFDEF MEMORY_HEAP_SIZE

#IFDEF MEMORY_HEAP_SIZE; ! Will exist if any use is made of indexed texts

Global IT_RE_Trace = false; ! Change to true for (a lot of) debugging data in use
[ IT_RE_SetTrace F; IT_RE_Trace = F; ];

! Character classes

Constant NEWLINE_RE_CC = -1;
Constant TAB_RE_CC = -2;
Constant DIGIT_RE_CC = -3;
Constant NONDIGIT_RE_CC = -4;
Constant WHITESPACE_RE_CC = -5;
Constant NONWHITESPACE_RE_CC = -6;
Constant PUNCTUATION_RE_CC = -7;
Constant NONPUNCTUATION_RE_CC = -8;
Constant WORD_RE_CC = -9;
Constant NONWORD_RE_CC = -10;
Constant ANYTHING_RE_CC = -11;
Constant NOTHING_RE_CC = -12;
Constant RANGE_RE_CC = -13;
Constant LCASE_RE_CC = -14;
Constant NONLCASE_RE_CC = -15;
Constant UCASE_RE_CC = -16;
Constant NONUCASE_RE_CC = -17;

! Control structures

Constant SUBEXP_RE_CC = -20;
Constant DISJUNCTION_RE_CC = -21;
Constant CHOICE_RE_CC = -22;
Constant QUANTIFIER_RE_CC = -23;
Constant IF_RE_CC = -24;
Constant CONDITION_RE_CC = -25;
Constant THEN_RE_CC = -26;
Constant ELSE_RE_CC = -27;

! Substring matchers

Constant VARIABLE_RE_CC = -30;
Constant LITERAL_RE_CC = -31;

! Positional matchers

Constant START_RE_CC = -40;
Constant END_RE_CC = -41;
Constant BOUNDARY_RE_CC = -42;
Constant NONBOUNDARY_RE_CC = -43;
Constant ALWAYS_RE_CC = -44;
Constant NEVER_RE_CC = -45;

! Mode switches

Constant SENSITIVITY_RE_CC = -50;

Constant RE_MAX_PACKETS = 32;

Constant RE_PACKET_SIZE = 14; ! Words of memory used per packet
Constant RE_PACKET_SIZE_IN_BYTES = WORDSIZE*RE_PACKET_SIZE; ! Bytes used per packet

Array RE_PACKET_space --> RE_MAX_PACKETS*RE_PACKET_SIZE;

Constant RE_CCLASS = 0;      ! One of the class codes defined above
Constant RE_PAR1 = 1;        ! Three parameters whose meaning depends on class code
Constant RE_PAR2 = 2;
Constant RE_PAR3 = 3;
Constant RE_NEXT = 4;        ! Younger sibling in the compiled tree
Constant RE_PREVIOUS = 5;    ! Elder sibling
Constant RE_DOWN = 6;        ! Child
Constant RE_UP = 7;          ! Parent
Constant RE_DATA1 = 8;       ! Backtracking data
Constant RE_DATA2 = 9;
Constant RE_CONSTRAINT = 10;
Constant RE_CACHE1 = 11;
Constant RE_CACHE2 = 12;
Constant RE_MODES = 13;

[ IT_RE_Node n cc par1 par2 par3  offset;
	if ((n<0) || (n >= RE_MAX_PACKETS)) rfalse;
	offset = RE_PACKET_space + n*RE_PACKET_SIZE_IN_BYTES;
	offset-->RE_CCLASS = cc;
	offset-->RE_PAR1 = par1;
	offset-->RE_PAR2 = par2;
	offset-->RE_PAR3 = par3;
	offset-->RE_NEXT = NULL;
	offset-->RE_PREVIOUS = NULL;
	offset-->RE_DOWN = NULL;
	offset-->RE_UP = NULL;
	offset-->RE_DATA1 = -1; ! Match start
	offset-->RE_DATA2 = -1; ! Match end
	offset-->RE_CONSTRAINT = -1; ! Rewind edge
	return offset;
];

[ IT_RE_NodeAddress n;
	if ((n<0) || (n >= RE_MAX_PACKETS)) return -1;
	return RE_PACKET_space + n*RE_PACKET_SIZE_IN_BYTES;
];

Array RE_Subexpressions --> 11; ! Address of node for this subexpression
Array Allocated_Match_Vars --> 10; ! Indexed text to hold values of the variables

[ IT_RE_DebugMatchVars indt
	offset n i;
	print RE_Subexpressions-->10, " collecting subexps^";
	for (n=0:(n<RE_Subexpressions-->10) && (n<10): n++) {
		offset = RE_Subexpressions-->n;
		print "Subexp ", offset-->RE_PAR1,
			" = [", offset-->RE_DATA1, ",", offset-->RE_DATA2, "] = ";
		for (i=offset-->RE_DATA1:i<offset-->RE_DATA2:i++)
			print (char) BlkValueRead(indt, i);
		print "^";
	}
];

[ IT_RE_CreateMatchVars indt
	offset n i ch cindt cl csize;
	for (n=0:(n<RE_Subexpressions-->10) && (n<10): n++) {
		offset = RE_Subexpressions-->n;
		if (Allocated_Match_Vars-->n == 0)
			Allocated_Match_Vars-->n = INDEXED_TEXT_TY_Create(); ! Permanently
		cindt = Allocated_Match_Vars-->n;
		csize = BlkValueExtent(cindt);
		cl = 0;
		for (i=offset-->RE_DATA1:i<offset-->RE_DATA2:i++) {
			ch = BlkValueRead(indt, i);
			if (cl+1 >= csize) {
				if (BlkValueSetExtent(cindt, 2*cl, 6) == false) break;
				csize = BlkValueExtent(cindt);
			}
			BlkValueWrite(cindt, cl++, ch);
		}
		BlkValueWrite(cindt, cl, 0);
	}
];

[ IT_RE_EmptyMatchVars indt
	n;
	for (n=0:(n<RE_Subexpressions-->10) && (n<10): n++)
		if (Allocated_Match_Vars-->n ~= 0)
			BlkValueWrite(Allocated_Match_Vars-->n, 0, 0);
];

[ IT_RE_GetMatchVar indt vn
	offset;
	if ((vn<0) || (vn>=10) || (vn >= RE_Subexpressions-->10)) jump Nope;
	offset = RE_Subexpressions-->vn;
	if (offset == 0) jump Nope;
	if (offset-->RE_DATA1 < 0) jump Nope;
	if (Allocated_Match_Vars-->vn == 0) {
		print "*** ", vn, " unallocated! ***^";
		jump Nope;
	}
	BlkValueCopy(indt, Allocated_Match_Vars-->vn);
	return indt;

	.Nope;
	BlkValueWrite(indt, 0, 0);
	return indt;
];

[ IT_MV_End n end
	offset;
	offset = RE_Subexpressions-->n;
	if (end==0) return offset-->RE_DATA1;
	return offset-->RE_DATA2;
];

[ IT_RE_Clear_Markers token;
	for (: token ~= NULL: token = token-->RE_NEXT) {
		if (token-->RE_DOWN ~= NULL) IT_RE_Clear_Markers(token-->RE_DOWN);
		token-->RE_DATA1 = -1;
		token-->RE_DATA2 = -1;
		token-->RE_CONSTRAINT = -1;
	}
];

[ IT_RE_DebugTree findt detail;
	print "Pattern: ", (INDEXED_TEXT_TY_Say) findt, "^";
	IT_RE_DebugSubtree(findt, 1, RE_PACKET_space, detail);
];

[ IT_RE_DebugSubtree findt depth offset detail
	cup;
	if (offset ~= NULL) {
		cup = offset-->RE_UP;
		if (offset-->RE_PREVIOUS ~= NULL) print "*** broken initial previous ***^";
	}
	while (offset ~= NULL) {
		if (offset-->RE_UP ~= cup) print "*** broken up matching ***^";
		spaces(depth*2);
		IT_RE_DebugNode(offset, findt, detail);
		if (offset-->RE_DOWN ~= NULL) {
			if ((offset-->RE_DOWN)-->RE_UP ~= offset)
				print "*** broken down/up ***^";
			IT_RE_DebugSubtree(findt, depth+1, offset-->RE_DOWN, detail);
		}
		if (offset-->RE_NEXT ~= NULL) {
			if ((offset-->RE_NEXT)-->RE_PREVIOUS ~= offset)
				print "*** broken next/previous ***^";
		}
		offset = offset-->RE_NEXT;
	}
];

[ IT_RE_DebugNode offset findt detail
	i par1 par2 par3;
	if (offset == NULL) "[NULL]";
	print "[", (offset-RE_PACKET_space)/(RE_PACKET_SIZE_IN_BYTES), "] ";
	! for (i=0:i<RE_PACKET_SIZE:i++) print offset-->i, " ";
	par1 = offset-->RE_PAR1;
	par2 = offset-->RE_PAR2;
	par3 = offset-->RE_PAR3;
	switch (offset-->RE_CCLASS) {
		DIGIT_RE_CC: print "DIGIT";
		NONDIGIT_RE_CC: print "NONDIGIT";
		UCASE_RE_CC: print "UCASE";
		NONUCASE_RE_CC: print "NONUCASE";
		LCASE_RE_CC: print "LCASE";
		NONLCASE_RE_CC: print "NONLCASE";
		WHITESPACE_RE_CC: print "WHITESPACE";
		NONWHITESPACE_RE_CC: print "NONWHITESPACE";
		PUNCTUATION_RE_CC: print "PUNCTUATION";
		NONPUNCTUATION_RE_CC: print "NONPUNCTUATION";
		WORD_RE_CC: print "WORD";
		NONWORD_RE_CC: print "NONWORD";
		ALWAYS_RE_CC: print "ALWAYS";
		NEVER_RE_CC: print "NEVER";
		START_RE_CC: print "START";
		END_RE_CC: print "END";
		BOUNDARY_RE_CC: print "BOUNDARY";
		NONBOUNDARY_RE_CC: print "NONBOUNDARY";
		ANYTHING_RE_CC: print "ANYTHING";
		NOTHING_RE_CC: print "NOTHING";
		RANGE_RE_CC: print "RANGE"; if (par3 == true) print " (negated)";
			print " ";
			for (i=par1:i<par2:i++) print (char) BlkValueRead(findt, i);
		VARIABLE_RE_CC: print "VARIABLE ", par1;
		SUBEXP_RE_CC:
			if (par1 == 0) print "EXP";
			else print "SUBEXP ";
			if (par1 >= 0) print "= V", par1;
			if (par2 == 1) {
				if (par3 == 0) print " (?=...) lookahead";
				else print " (?<=...) lookbehind of width ", par3;
			}
			if (par2 == 2) {
				if (par3 == 0) print " (?!...) negated lookahead";
				else print " (?<!...) negated lookbehind of width ", par3;
			}
			if (par2 == 3) print " uncollecting";
			if (par2 == 0 or 3) {
				if (par3 == 1) print " forcing case sensitivity";
				if (par3 == 2) print " forcing case insensitivity";
			}
			if (par2 == 4) print " (?>...) possessive";
		NEWLINE_RE_CC: print "NEWLINE";
		TAB_RE_CC: print "TAB";
		QUANTIFIER_RE_CC: print "QUANTIFIER min=", par1, " max=", par2;
			if (par3) print " (lazy)"; else print " (greedy)";
		LITERAL_RE_CC: print "LITERAL";
			print " ";
			for (i=par1:i<par2:i++) print (char) BlkValueRead(findt, i);
		DISJUNCTION_RE_CC: print "DISJUNCTION of ", par1, " choices";
		CHOICE_RE_CC: print "CHOICE no ", par1;
		SENSITIVITY_RE_CC: print "SENSITIVITY";
			if (par1) print " off"; else print " on";
		IF_RE_CC: print "IF"; if (par1 >= 1) print " = V", par1;
		CONDITION_RE_CC: print "CONDITION"; if (par1 >= 1) print " = V", par1;
		THEN_RE_CC: print "THEN";
		ELSE_RE_CC: print "ELSE";
	}
	if (detail)
		print ": ", offset-->RE_DATA1, ", ", offset-->RE_DATA2, ", ", offset-->RE_CONSTRAINT;
	print "^";
];

[ IT_CHR_CompileTree findt exactly
	root literal fto no_packets token attach_to;

	fto = IT_CharacterLength(findt);

	root = IT_RE_Node(0, SUBEXP_RE_CC, 0, 0, 0);
	literal = IT_RE_Node(1, LITERAL_RE_CC, 0, fto, 0);
	
	root-->RE_DOWN = literal;
	literal-->RE_UP = root;

	if (exactly) {
		no_packets = 2;
		if (no_packets+3 > RE_MAX_PACKETS) return "regexp too complex";
		exactly = RE_PACKET_space-->RE_DOWN;
		token = IT_RE_Node(no_packets++, START_RE_CC, 0, 0, 0);
		RE_PACKET_space-->RE_DOWN = token; token-->RE_UP = RE_PACKET_space;
		attach_to = IT_RE_Node(no_packets++, SUBEXP_RE_CC, -1, 3, 0);
		token-->RE_NEXT = attach_to; attach_to-->RE_PREVIOUS = token;
		attach_to-->RE_UP = RE_PACKET_space;
		attach_to-->RE_NEXT = IT_RE_Node(no_packets++, END_RE_CC, 0, 0, 0);
		(attach_to-->RE_NEXT)-->RE_PREVIOUS = attach_to;
		(attach_to-->RE_NEXT)-->RE_UP = RE_PACKET_space;
		attach_to-->RE_DOWN = exactly;
		while (exactly ~= NULL) {
			exactly-->RE_UP = attach_to; exactly = exactly-->RE_NEXT;
		}
	}
	
	no_packets = IT_RE_ExpandChoices(RE_PACKET_space, no_packets);
];

Array Subexp_Posns --> 20;
[ IT_RE_CompileTree findt exactly
	no_packets ffrom fto cc par1 par2 par3
	quantifiable token attach_to no_subs blevel bits;

	fto = IT_CharacterLength(findt);
	if (fto == 0) {
		IT_RE_Node(no_packets++, NEVER_RE_CC, 0, 0, 0); ! Empty regexp never matches
		return 1;
	}

	attach_to = IT_RE_Node(no_packets++, SUBEXP_RE_CC, 0, 0, 0);
	RE_Subexpressions-->0 = attach_to; RE_Subexpressions-->10 = 1; no_subs = 1;

	quantifiable = false; blevel = 0;
	
	for (ffrom = 0: ffrom < fto: ) {
		cc = BlkValueRead(findt, ffrom++); par1 = 0; par2 = 0; par3 = 0;
		if (cc == '\') {
			if (ffrom == fto) return "Search pattern not terminated";
			cc = BlkValueRead(findt, ffrom++);
			switch (cc) {
				'b': cc = BOUNDARY_RE_CC;
				'B': cc = NONBOUNDARY_RE_CC;
				'd': cc = DIGIT_RE_CC;
				'D': cc = NONDIGIT_RE_CC;
				'l': cc = LCASE_RE_CC;
				'L': cc = NONLCASE_RE_CC;
				'n': cc = NEWLINE_RE_CC;
				'p': cc = PUNCTUATION_RE_CC;
				'P': cc = NONPUNCTUATION_RE_CC;
				's': cc = WHITESPACE_RE_CC;
				'S': cc = NONWHITESPACE_RE_CC;
				't': cc = TAB_RE_CC;
				'u': cc = UCASE_RE_CC;
				'U': cc = NONUCASE_RE_CC;
				'w': cc = WORD_RE_CC;
				'W': cc = NONWORD_RE_CC;
				default:
					if ((cc >= '1') && (cc <= '9')) {
						par1 = cc-'0';
						cc = VARIABLE_RE_CC;
					} else {
						if (((cc >= 'a') && (cc <= 'z')) ||
							((cc >= 'A') && (cc <= 'Z'))) return "unknown escape";
						cc = LITERAL_RE_CC;
						par1 = ffrom-1; par2 = ffrom;
					}
			}
			quantifiable = true;
		} else {
			switch (cc) {
				'(': par2 = 0;
					!if (BlkValueRead(findt, ffrom) == ')') return "empty subexpression";
					if (BlkValueRead(findt, ffrom) == '?') {
						ffrom++;
						bits = true;
						if (BlkValueRead(findt, ffrom) == '-') { ffrom++; bits = false; }
						else if (BlkValueRead(findt, ffrom) == '<') { ffrom++; bits = false; }
						switch (cc = BlkValueRead(findt, ffrom++)) {
							'#': while (BlkValueRead(findt, ffrom++) ~= 0 or ')') ;
								if (BlkValueRead(findt, ffrom-1) == 0)
									return "comment never ends";
								continue;
							'(': cc = BlkValueRead(findt, ffrom);
								if ((cc == '1' or '2' or '3' or '4' or
									'5' or '6' or '7' or '8' or '9') &&
									(BlkValueRead(findt, ffrom+1) ==')')) {
									ffrom = ffrom + 2;
									par1 = cc - '0';
								} else ffrom--;
								cc = IF_RE_CC; ! (?(...)...) conditional
								quantifiable = false;
								if (blevel == 20) return "subexpressions too deep";
								Subexp_Posns-->(blevel++) = IT_RE_NodeAddress(no_packets);
								jump CClassKnown;
							'=': par2 = 1; ! (?=...) lookahead/behind
								par3 = 0; if (bits == false) par3 = -1;
							'!': par2 = 2; ! (?!...) negated lookahead/behind
								par3 = 0; if (bits == false) par3 = -1;
							':': par2 = 3; ! (?:...) uncollecting subexpression
							'>': par2 = 4; ! (?>...) possessive
							default:
								if (BlkValueRead(findt, ffrom) == ')') {
									if (cc == 'i') {
										cc = SENSITIVITY_RE_CC; par1 = bits; ffrom++;
										jump CClassKnown;
									}
								}
								if (BlkValueRead(findt, ffrom) == ':') {
									if (cc == 'i') {
										par1 = bits; par2 = 3; par3 = bits+1; ffrom++;
										jump AllowForm;
									}
								}
								return "unknown (?...) form";
						}
					}
					.AllowForm;
					if (par2 == 0) par1 = no_subs++; else par1 = -1;
					cc = SUBEXP_RE_CC; 
					quantifiable = false;
					if (blevel == 20) return "subexpressions too deep";
					Subexp_Posns-->(blevel++) = IT_RE_NodeAddress(no_packets);
				')': if (blevel == 0) return "subexpression bracket mismatch";
					blevel--;
					attach_to = Subexp_Posns-->blevel;
					if (attach_to-->RE_DOWN == NULL) {
						if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
						attach_to-->RE_DOWN =
							IT_RE_Node(no_packets++, ALWAYS_RE_CC, 0, 0, 0);
						(attach_to-->RE_DOWN)-->RE_UP = attach_to;
					}
					quantifiable = true;
					continue;
				'.': cc = ANYTHING_RE_CC; quantifiable = true;
				'|': cc = CHOICE_RE_CC; quantifiable = false;
				'^': cc = START_RE_CC; quantifiable = false;
				'$': cc = END_RE_CC; quantifiable = false;
				'{': if (quantifiable == false) return "quantifier misplaced";
					par1 = 0; par2 = -1; bits = 1;
					while ((cc=BlkValueRead(findt, ffrom++)) ~= 0 or '}') {
						if (cc == ',') {
							bits++;
							if (bits >= 3) return "too many colons in ?{...}";
							continue;
						}
						if ((cc >= '0') || (cc <= '9')) {
							if (bits == 1) {
								if (par1 < 0) par1 = 0;
								par1 = par1*10 + (cc-'0');
							} else {
								if (par2 < 0) par2 = 0;
								par2 = par2*10 + (cc-'0');
							}
						} else return "non-digit in ?{...}";
					}
					if (cc ~= '}') return "{x,y} quantifier never ends";
					cc = QUANTIFIER_RE_CC;
					if (par2 == -1) {
						if (bits == 2) par2 = 30000;
						else par2 = par1;
					}
					if (par1 > par2) return "{x,y} with x greater than y";
					if (BlkValueRead(findt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
				'<', '[': par3 = false; if (cc == '<') bits = '>'; else bits = ']';
					if (BlkValueRead(findt, ffrom) == '^') { ffrom++; par3 = true; }
					par1 = ffrom;
					if (BlkValueRead(findt, ffrom) == bits) { ffrom++; }
					while (cc ~= bits or 0) {
						cc = BlkValueRead(findt, ffrom++);
						if (cc == '\') {
							cc = BlkValueRead(findt, ffrom++);
							if (cc ~= 0) cc = BlkValueRead(findt, ffrom++);
						}
					}
					if (cc == 0) return "Character range never ends";
					par2 = ffrom-1;
					if ((par2 > par1 + 1) &&
						(BlkValueRead(findt, par1) == ':') &&
						(BlkValueRead(findt, par2-1) == ':') &&
						(BlkValueRead(findt, par2-2) ~= '\'))
						return "POSIX named character classes unsupported";
					bits = IT_RE_RangeSyntaxCorrect(findt, par1, par2);
					if (bits) return bits;
					if (par1 < par2) cc = RANGE_RE_CC;
					else cc = NOTHING_RE_CC;
					quantifiable = true;
				'*': if (quantifiable == false) return "quantifier misplaced";
					cc = QUANTIFIER_RE_CC;
					par1 = 0; par2 = 30000;
					if (BlkValueRead(findt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
				'+': if (quantifiable == false) return "quantifier misplaced";
					cc = QUANTIFIER_RE_CC;
					par1 = 1; par2 = 30000;
					if (BlkValueRead(findt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
				'?': if (quantifiable == false) return "quantifier misplaced";
					cc = QUANTIFIER_RE_CC;
					par1 = 0; par2 = 1;
					if (BlkValueRead(findt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
			}
		}
		
		.CClassKnown;
		
		if (cc >= 0) {
			quantifiable = true;
			if ((attach_to-->RE_CCLASS == LITERAL_RE_CC) &&
				(BlkValueRead(findt, ffrom) ~= '*' or '+' or '?' or '{')) {
				(attach_to-->RE_PAR2)++;
				if (IT_RE_Trace == 2) {
					print "Extending literal by ", cc, "=", (char) cc, "^";
				}
				continue;
			}
			cc = LITERAL_RE_CC; par1 = ffrom-1; par2 = ffrom;
		}
		
		if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";

		if (IT_RE_Trace == 2) {
			print "Attaching packet ", no_packets+1, " to ";
			IT_RE_DebugNode(attach_to, findt);
			IT_RE_DebugTree(findt);
		}

		token = IT_RE_Node(no_packets++, cc, par1, par2, par3);

		if ((token-->RE_CCLASS == SUBEXP_RE_CC) && (token-->RE_PAR2 == 0)) {
			RE_Subexpressions-->(token-->RE_PAR1) = token;
			(RE_Subexpressions-->10)++;
		}
		
		if ((attach_to-->RE_CCLASS == SUBEXP_RE_CC or CHOICE_RE_CC or IF_RE_CC) &&
			(attach_to-->RE_DOWN == NULL)) {
			attach_to-->RE_DOWN = token; token-->RE_UP = attach_to;
		} else {
			if ((token-->RE_CCLASS == CHOICE_RE_CC) &&
				((attach_to-->RE_UP)-->RE_CCLASS == CHOICE_RE_CC)) {
				no_packets--; token = attach_to-->RE_UP;
			} else {
				if (token-->RE_CCLASS == CHOICE_RE_CC) {
					while (attach_to-->RE_PREVIOUS ~= NULL)
						attach_to = attach_to-->RE_PREVIOUS;
				}
				if (token-->RE_CCLASS == QUANTIFIER_RE_CC or CHOICE_RE_CC) {
					token-->RE_PREVIOUS = attach_to-->RE_PREVIOUS;
					token-->RE_UP = attach_to-->RE_UP;
					if ((attach_to-->RE_UP ~= NULL) && (attach_to-->RE_PREVIOUS == NULL))
						(attach_to-->RE_UP)-->RE_DOWN = token;
					token-->RE_DOWN = attach_to;
					bits = attach_to;
					while (bits ~= NULL) {
						bits-->RE_UP = token;
						bits = bits-->RE_NEXT;
					}
					attach_to-->RE_PREVIOUS = NULL;
					if (token-->RE_PREVIOUS ~= NULL)
						(token-->RE_PREVIOUS)-->RE_NEXT = token;
				} else {
					attach_to-->RE_NEXT = token; token-->RE_PREVIOUS = attach_to;
					token-->RE_UP = attach_to-->RE_UP;
				}
			}
		}
		
		if (token-->RE_CCLASS == CHOICE_RE_CC) {
			if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
			token-->RE_NEXT = IT_RE_Node(no_packets++, CHOICE_RE_CC, 0, 0, 0);
			(token-->RE_NEXT)-->RE_PREVIOUS = token;
			(token-->RE_NEXT)-->RE_UP = token-->RE_UP;
			token = token-->RE_NEXT;
		}

		attach_to = token;

		if (IT_RE_Trace == 2) {
			print "Result:^";
			IT_RE_DebugTree(findt);
		}

	}
	
	if (blevel ~= 0) return "subexpression bracket mismatch";

	if (exactly) {
		if (no_packets+3 > RE_MAX_PACKETS) return "regexp too complex";
		exactly = RE_PACKET_space-->RE_DOWN;
		token = IT_RE_Node(no_packets++, START_RE_CC, 0, 0, 0);
		RE_PACKET_space-->RE_DOWN = token; token-->RE_UP = RE_PACKET_space;
		attach_to = IT_RE_Node(no_packets++, SUBEXP_RE_CC, -1, 3, 0);
		token-->RE_NEXT = attach_to; attach_to-->RE_PREVIOUS = token;
		attach_to-->RE_UP = RE_PACKET_space;
		attach_to-->RE_NEXT = IT_RE_Node(no_packets++, END_RE_CC, 0, 0, 0);
		(attach_to-->RE_NEXT)-->RE_PREVIOUS = attach_to;
		(attach_to-->RE_NEXT)-->RE_UP = RE_PACKET_space;
		attach_to-->RE_DOWN = exactly;
		while (exactly ~= NULL) {
			exactly-->RE_UP = attach_to; exactly = exactly-->RE_NEXT;
		}
	}
	
	no_packets = IT_RE_ExpandChoices(RE_PACKET_space, no_packets);

	if (IT_RE_Trace) {
		print "Compiled pattern:^";
		IT_RE_DebugTree(findt);
	}
	
	bits = IT_RE_CheckTree(RE_PACKET_space, no_subs); if (bits) return bits;
	
	return no_packets;
];

[ IT_RE_RangeSyntaxCorrect findt rf rt
	i chm;
	for (i=rf: i<rt: i++) {
		chm = BlkValueRead(findt, i);
		if ((chm == '\') && (i+1<rt)) {
			chm = BlkValueRead(findt, ++i);
			if (((chm >= 'a') && (chm <= 'z')) ||
				((chm >= 'A') && (chm <= 'Z'))) {
				if (chm ~= 's' or 'S' or 'p' or 'P' or 'w' or 'W' or 'd'
					or 'D' or 'n' or 't' or 'l' or 'L' or 'u' or 'U')
					return "Invalid escape in {} range";
			}
		}
		if ((i+2<rt) && (BlkValueRead(findt, i+1) == '-')) {
			if (chm > BlkValueRead(findt, i+2)) return "Invalid {} range";
			i=i+2;
		}
	}
	rfalse;
];

[ IT_RE_ExpandChoices token no_packets
	rv prev nex holder new ct n cond_node then_node else_node;
	while (token ~= NULL) {
		if (token-->RE_CCLASS == IF_RE_CC) {
			if ((token-->RE_DOWN)-->RE_CCLASS == CHOICE_RE_CC) {
				for (nex=token-->RE_DOWN, n=0: nex~=NULL: nex=nex-->RE_NEXT) n++;
				if (n~=2) return "conditional has too many clauses";
				if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
				cond_node = IT_RE_Node(no_packets++, CONDITION_RE_CC, 0, 0, 0);
				if (token-->RE_PAR1 >= 1) {
					cond_node-->RE_PAR1 = token-->RE_PAR1;
				}
				then_node = token-->RE_DOWN;
				then_node-->RE_CCLASS = THEN_RE_CC;
				else_node = then_node-->RE_NEXT;
				else_node-->RE_CCLASS = ELSE_RE_CC;
				if (cond_node-->RE_PAR1 < 1) {
					cond_node-->RE_DOWN = then_node-->RE_DOWN;
					then_node-->RE_DOWN = (then_node-->RE_DOWN)-->RE_NEXT;
					if (then_node-->RE_DOWN ~= NULL)
						(then_node-->RE_DOWN)-->RE_PREVIOUS = NULL;
					(cond_node-->RE_DOWN)-->RE_NEXT = NULL;
					(cond_node-->RE_DOWN)-->RE_UP = cond_node;
				}
				token-->RE_DOWN = cond_node; cond_node-->RE_UP = token;
				cond_node-->RE_NEXT = then_node; then_node-->RE_PREVIOUS = cond_node;
			} else {
				if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
				cond_node = IT_RE_Node(no_packets++, CONDITION_RE_CC, 0, 0, 0);
				if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
				then_node = IT_RE_Node(no_packets++, THEN_RE_CC, 0, 0, 0);
				if (token-->RE_PAR1 >= 1) {
					cond_node-->RE_PAR1 = token-->RE_PAR1;
					then_node-->RE_DOWN = token-->RE_DOWN;
				} else {
					cond_node-->RE_DOWN = token-->RE_DOWN;
					then_node-->RE_DOWN = (token-->RE_DOWN)-->RE_NEXT;
					(cond_node-->RE_DOWN)-->RE_NEXT = NULL;
					(cond_node-->RE_DOWN)-->RE_UP = cond_node;
				}
				token-->RE_DOWN = cond_node;
				cond_node-->RE_UP = token; cond_node-->RE_NEXT = then_node;
				then_node-->RE_PREVIOUS = cond_node; then_node-->RE_UP = token;
				then_node-->RE_NEXT = NULL;
				if (then_node-->RE_DOWN ~= NULL)
					(then_node-->RE_DOWN)-->RE_PREVIOUS = NULL;
				for (nex = then_node-->RE_DOWN: nex ~= NULL: nex = nex-->RE_NEXT) {
					nex-->RE_UP = then_node;
				}
			}
			
			if (cond_node-->RE_DOWN ~= NULL) {
				nex = cond_node-->RE_DOWN;
				if ((nex-->RE_CCLASS ~= SUBEXP_RE_CC) ||
					(nex-->RE_NEXT ~= NULL) ||
					(nex-->RE_PAR2 ~= 1 or 2)) {
					!IT_RE_DebugSubtree(0, 0, nex, true);
					return "condition not lookahead/behind";
				}
			}
		}
		if ((token-->RE_CCLASS == CHOICE_RE_CC) && (token-->RE_PAR1 < 1)) {
			prev = token-->RE_PREVIOUS;
			nex = token-->RE_NEXT;
			while ((nex ~= NULL) && (nex-->RE_CCLASS == CHOICE_RE_CC))
				nex = nex-->RE_NEXT;
			holder = token-->RE_UP; if (holder == NULL) return "bang";
			if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
			new = IT_RE_Node(no_packets++, DISJUNCTION_RE_CC, 0, 0, 0);
			holder-->RE_DOWN = new; new-->RE_UP = holder;
			if (prev ~= NULL) {
				prev-->RE_NEXT = new; new-->RE_PREVIOUS = prev;
			}
			if (nex ~= NULL) {
				nex-->RE_PREVIOUS = new; new-->RE_NEXT = nex;
			}
			new-->RE_DOWN = token;
			token-->RE_PREVIOUS = NULL;
			ct = 1;
			while (token ~= NULL) {
				token-->RE_PAR1 = ct++;
				token-->RE_UP = new;
				if ((token-->RE_NEXT ~= NULL) &&
					((token-->RE_NEXT)-->RE_CCLASS ~= CHOICE_RE_CC))
					token-->RE_NEXT = NULL;
				token = token-->RE_NEXT;
			}
			new-->RE_PAR1 = ct-1;
			if (token ~= NULL) token-->RE_NEXT = NULL;
			token = new; continue;
		}
		if (token-->RE_DOWN ~= NULL) {
			no_packets = IT_RE_ExpandChoices(token-->RE_DOWN, no_packets);
			if ((no_packets<0) || (no_packets >= RE_MAX_PACKETS)) break;
		}
		token = token-->RE_NEXT;
	}
	return no_packets;
];

[ IT_RE_CheckTree token no_subs
	rv;
	while (token ~= NULL) {
		if (token-->RE_CCLASS == VARIABLE_RE_CC) {
			if (token-->RE_PAR1 >= no_subs) return "reference to nonexistent group";
		}
		if ((token-->RE_CCLASS == SUBEXP_RE_CC) &&
			(token-->RE_PAR2 == 1 or 2) &&
			(token-->RE_PAR3 == -1)) {
			token-->RE_PAR3 = IT_RE_Width(token-->RE_DOWN);
			if (token-->RE_PAR3 == -1) return "variable length lookbehind not implemented";
		}
		if (token-->RE_DOWN ~= NULL) {
			rv = IT_RE_CheckTree(token-->RE_DOWN, no_subs);
			if (rv) return rv;
		}
		token = token-->RE_NEXT;
	}
	rfalse;
];

[ IT_RE_Width token downwards
	w rv aw choice;
	while (token ~= NULL) {
		switch (token-->RE_CCLASS) {
			DIGIT_RE_CC, NONDIGIT_RE_CC, WHITESPACE_RE_CC, NONWHITESPACE_RE_CC,
			PUNCTUATION_RE_CC, NONPUNCTUATION_RE_CC, WORD_RE_CC, NONWORD_RE_CC,
			ANYTHING_RE_CC, NOTHING_RE_CC, RANGE_RE_CC, NEWLINE_RE_CC, TAB_RE_CC,
			UCASE_RE_CC, NONUCASE_RE_CC, LCASE_RE_CC, NONLCASE_RE_CC:
				w++;
			START_RE_CC, END_RE_CC, BOUNDARY_RE_CC, NONBOUNDARY_RE_CC, ALWAYS_RE_CC:
				;
			LITERAL_RE_CC:
				w = w + token-->RE_PAR2 - token-->RE_PAR1;
			VARIABLE_RE_CC:
				return -1;
			IF_RE_CC:
				rv = IT_RE_Width((token-->RE_DOWN)-->RE_NEXT);
				if (rv == -1) return -1;
				if (rv ~= IT_RE_Width(((token-->RE_DOWN)-->RE_NEXT)-->RE_NEXT))
					return -1;
				w = w + rv;
			SUBEXP_RE_CC:
				if (token-->RE_PAR2 == 1 or 2) rv = 0;
				else {
					rv = IT_RE_Width(token-->RE_DOWN);
					if (rv == -1) return -1;
				}
				w = w + rv;
			QUANTIFIER_RE_CC:
				if (token-->RE_PAR1 ~= token-->RE_PAR2) return -1;
				rv = IT_RE_Width(token-->RE_DOWN);
				if (rv == -1) return -1;
				w = w + rv*(token-->RE_PAR1);				
			DISJUNCTION_RE_CC:
				aw = -1;
				for (choice = token-->RE_DOWN: choice ~= NULL: choice = choice-->RE_NEXT) {
					rv = IT_RE_Width(choice-->RE_DOWN);
					!print "Option found ", rv, "^";
					if (rv == -1) return -1;
					if ((aw >= 0) && (aw ~= rv)) return -1;
					aw = rv;
				}
				w = w + aw;
			SENSITIVITY_RE_CC:
				;
		}
		if (downwards) return w;
		if (token ~= NULL) token = token-->RE_NEXT;
	}
	return w;
];

Global IT_RE_RewindCount;
[ IT_RE_PrintNoRewinds; print IT_RE_RewindCount; ];

Constant CIS_MFLAG = 1;
Constant ACCUM_MFLAG = 2;

[ IT_RE_Parse findt indt ipos insens
	ilen rv root i initial_mode;

	ilen = IT_CharacterLength(indt);
	if ((ipos<0) || (ipos>ilen)) return -1;
	
	root = RE_PACKET_space;
	
	initial_mode = 0; if (insens) initial_mode = CIS_MFLAG;
	
	IT_RE_Clear_Markers(RE_PACKET_space);
	
	for (:ipos<=ilen:ipos++) {
		if ((RE_PACKET_space-->RE_DOWN ~= NULL) &&
			((RE_PACKET_space-->RE_DOWN)-->RE_CCLASS == START_RE_CC) &&
			(ipos>0)) { rv = -1; break; }
		if (ipos > 0) IT_RE_EraseConstraints(RE_PACKET_space, initial_mode);
		IT_RE_RewindCount = 0;
		rv = IT_RE_ParseAtPosition(findt, indt, ipos, ilen, RE_PACKET_space, initial_mode);
		if (rv >= 0) break;
	}

	if (rv == -1) {
		root-->RE_DATA1 = -1;
		root-->RE_DATA2 = -1;
	} else {
		root-->RE_DATA1 = ipos;
		root-->RE_DATA2 = ipos+rv;
	}
	return rv;
];

[ IT_RE_ParseAtPosition findt indt ifrom ito token mode_flags
	outcome ipos npos rv i ch edge rewind_this;

	if (ifrom > ito) return -1;

	ipos = ifrom;

	.Rewind;
	while (token ~= NULL) {
		outcome = false;
		if (IT_RE_Trace) {
			print "Matching at ", ipos, ": ";
			IT_RE_DebugNode(token, findt, true);
		}

		if (ipos<ito) ch = BlkValueRead(indt, ipos); else ch = 0;

		token-->RE_MODES = mode_flags; ! Save in case of backtrack

		switch (token-->RE_CCLASS) {
			
			! Should never happen
			
			CHOICE_RE_CC: return "internal error";
			
			! Mode switches
			
			SENSITIVITY_RE_CC:
				if (token-->RE_PAR1) mode_flags = mode_flags | CIS_MFLAG;
				else mode_flags = mode_flags & (~CIS_MFLAG);
				outcome = true;
		
			! Zero-length positional markers
			
			ALWAYS_RE_CC:
				outcome = true;
			NEVER_RE_CC:
			START_RE_CC:
				if (ipos == 0) outcome = true;
			END_RE_CC:
				if (BlkValueRead(indt, ipos) == 0) outcome = true;
			BOUNDARY_RE_CC:
				rv = 0;
				if (BlkValueRead(indt, ipos) == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (ipos == 0) ch = 0;
				else ch = BlkValueRead(indt, ipos-1);
				if (ch == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (rv == 1) outcome = true;
			NONBOUNDARY_RE_CC:
				rv = 0;
				if (BlkValueRead(indt, ipos) == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (ipos == 0) ch = 0;
				else ch = BlkValueRead(indt, ipos-1);
				if (ch == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (rv ~= 1) outcome = true;

			! Control constructs
		
			IF_RE_CC:
				i = token-->RE_PAR1; ch = false;
				if (IT_RE_Trace) {
					print "Trying conditional from ", ipos, ": ";
					IT_RE_DebugNode(token, findt, true);
				}
				if (i >= 1) {
					 if ((i<RE_Subexpressions-->10) &&
					 	((RE_Subexpressions-->i)-->RE_DATA1 >= 0)) ch = true;
				} else {					 	
					rv = IT_RE_ParseAtPosition(findt, indt, ipos, ito,
						(token-->RE_DOWN)-->RE_DOWN, mode_flags);
					if (rv >= 0) ch = true;
				}
				if (IT_RE_Trace) {
					print "Condition found to be ", ch, "^";
				}
				if (ch) {
					rv = IT_RE_ParseAtPosition(findt, indt, ipos, ito,
						((token-->RE_DOWN)-->RE_NEXT)-->RE_DOWN, mode_flags);
					!print "Then clause returned ", rv, "^";
				} else {
					if ((((token-->RE_DOWN)-->RE_NEXT)-->RE_NEXT) == NULL)
						rv = 0; ! The empty else clause matches
					else rv = IT_RE_ParseAtPosition(findt, indt, ipos, ito,
						(((token-->RE_DOWN)-->RE_NEXT)-->RE_NEXT)-->RE_DOWN, mode_flags);
					!print "Else clause returned ", rv, "^";
				}
				if (rv >= 0) {
					outcome = true;
					ipos = ipos + rv;
				}
			DISJUNCTION_RE_CC:
				if (IT_RE_Trace) {
					print "Trying disjunction from ", ipos, ": ";
					IT_RE_DebugNode(token, findt, true);
				}
				for (ch = token-->RE_DOWN: ch ~= NULL: ch = ch-->RE_NEXT) {
					if (ch-->RE_PAR1 <= token-->RE_CONSTRAINT) continue;
					if (IT_RE_Trace) {
						print "Trying choice at ", ipos, ": ";
						IT_RE_DebugNode(ch, findt, true);
					}
					rv = IT_RE_ParseAtPosition(findt, indt, ipos, ito,
						ch-->RE_DOWN, mode_flags);
					if (rv >= 0) {
						token-->RE_DATA1 = ipos; ! Where match was made
						token-->RE_DATA2 = ch-->RE_PAR1; ! Option taken
						ipos = ipos + rv;
						outcome = true;
						if (IT_RE_Trace) {
							print "Choice worked with width ", rv, ": ";
							IT_RE_DebugNode(ch, findt, true);
						}
						break;
					} else {
						if (mode_flags & ACCUM_MFLAG == false)
							IT_RE_FailSubexpressions(ch-->RE_DOWN);
					}						
				}
				if (outcome == false) {
					if (IT_RE_Trace) {
						print "Failed disjunction from ", ipos, ": ";
						IT_RE_DebugNode(token, findt, true);
					}
					token-->RE_DATA1 = ipos; ! Where match was tried
					token-->RE_DATA2 = -1; ! No option was taken
				}
			SUBEXP_RE_CC:
				if (token-->RE_PAR2 == 1 or 2) {
					npos = ipos - token-->RE_PAR3;
					if (npos<0) rv = -1; ! Lookbehind fails: nothing behind
					else rv = IT_RE_ParseAtPosition(findt, indt, npos, ito, token-->RE_DOWN,
						mode_flags);
				} else {
					switch (token-->RE_PAR3) {
						0: rv = IT_RE_ParseAtPosition(findt, indt, ipos, ito, token-->RE_DOWN,
							mode_flags);
						1: rv = IT_RE_ParseAtPosition(findt, indt, ipos, ito, token-->RE_DOWN,
							mode_flags & (~CIS_MFLAG));
						2: rv = IT_RE_ParseAtPosition(findt, indt, ipos, ito, token-->RE_DOWN,
							mode_flags | CIS_MFLAG);
					}
				}
				npos = ipos;
				if (rv >= 0) npos = ipos + rv;
				switch (token-->RE_PAR2) {
					1: if (rv >= 0) rv = 0;
					2: if (rv >= 0) rv = -1; else rv = 0;
				}
				if (rv >= 0) {
					token-->RE_DATA1 = ipos;
					ipos = ipos + rv;
					token-->RE_DATA2 = npos;
					outcome = true;
				} else {
					if (mode_flags & ACCUM_MFLAG == false) {
						token-->RE_DATA1 = -1;
						token-->RE_DATA2 = -1;
					}
				}
				if (token-->RE_PAR2 == 2) IT_RE_FailSubexpressions(token, true);
			QUANTIFIER_RE_CC:
				token-->RE_DATA1 = ipos;
				if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
					(token-->RE_DOWN)-->RE_CACHE1 = -1;
					(token-->RE_DOWN)-->RE_CACHE2 = -1;	
				}
				if (IT_RE_Trace) {
					print "Trying quantifier from ", ipos, ": ";
					IT_RE_DebugNode(token, findt, true);
				}
				if (token-->RE_PAR3 == false) { ! Greedy quantifier
					!edge = ito; if (token-->RE_CONSTRAINT >= 0) edge = token-->RE_CONSTRAINT;
					edge = token-->RE_PAR2;
					if (token-->RE_CONSTRAINT >= 0) edge = token-->RE_CONSTRAINT;
					rv = -1;
					for (i=0, npos=ipos: i<edge: i++) {
						if (IT_RE_Trace) {
							print "Trying quant rep ", i+1, " at ", npos, ": ";
							IT_RE_DebugNode(token, findt, true);
						}
						rv = IT_RE_ParseAtPosition(findt, indt, npos, ito, token-->RE_DOWN,
							mode_flags | ACCUM_MFLAG);
						if (rv < 0) break;
						if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
							(token-->RE_DOWN)-->RE_CACHE1 = (token-->RE_DOWN)-->RE_DATA1;
							(token-->RE_DOWN)-->RE_CACHE2 = (token-->RE_DOWN)-->RE_DATA2;	
						}
						if ((rv == 0) && (token-->RE_PAR2 == 30000) && (i>=1)) { i++; break; }
						npos = npos + rv;
					}
					if ((i >= token-->RE_PAR1) && (i <= token-->RE_PAR2))
						outcome = true;
				} else { ! Lazy quantifier
					edge = token-->RE_PAR1;
					if (token-->RE_CONSTRAINT > edge) edge = token-->RE_CONSTRAINT;
					for (i=0, npos=ipos: (npos<ito) && (i < token-->RE_PAR2): i++) {
						if (i >= edge) break;
						if (IT_RE_Trace) {
							print "Trying quant rep ", i+1, " at ", npos, ": ";
							IT_RE_DebugNode(token, findt, true);
						}
						rv = IT_RE_ParseAtPosition(findt, indt, npos, ito, token-->RE_DOWN,
							mode_flags | ACCUM_MFLAG);
						if (rv < 0) break;
						if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
							(token-->RE_DOWN)-->RE_CACHE1 = (token-->RE_DOWN)-->RE_DATA1;
							(token-->RE_DOWN)-->RE_CACHE2 = (token-->RE_DOWN)-->RE_DATA2;	
						}
						if ((rv == 0) && (token-->RE_PAR2 == 30000) && (i>=1)) { i++; break; }
						npos = npos + rv;
					}
					if ((i >= edge) && (i <= token-->RE_PAR2))
						outcome = true;
				}
				if (outcome) {
					if (token-->RE_PAR3 == false) { ! Greedy quantifier
						if (i > token-->RE_PAR1) { ! I.e., if we have been greedy
							token-->RE_DATA2 = i-1; ! And its edge limitation
						} else {
							token-->RE_DATA2 = -1;
						}
					} else { ! Lazy quantifier
						if (i < token-->RE_PAR2) { ! I.e., if we have been lazy
							token-->RE_DATA2 = i+1; ! And its edge limitation
						} else {
							token-->RE_DATA2 = -1;
						}
					}
					ipos = npos;
					if ((i == 0) && (mode_flags & ACCUM_MFLAG == false))
						IT_RE_FailSubexpressions(token-->RE_DOWN);
					if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
						(token-->RE_DOWN)-->RE_DATA1 = (token-->RE_DOWN)-->RE_CACHE1;
						(token-->RE_DOWN)-->RE_DATA2 = (token-->RE_DOWN)-->RE_CACHE2;	
					}
					if (IT_RE_Trace) {
						print "Successful quant reps ", i, ": ";
						IT_RE_DebugNode(token, findt, true);
					}
				} else {
					!token-->RE_DATA2 = -1;
					if (mode_flags & ACCUM_MFLAG == false)
						IT_RE_FailSubexpressions(token-->RE_DOWN);
					if (IT_RE_Trace) {
						print "Failed quant reps ", i, ": ";
						IT_RE_DebugNode(token, findt, true);
					}
				}
				
			! Character classes
				
			NOTHING_RE_CC: ;
			ANYTHING_RE_CC: if (ch) outcome = true; ipos++;
			WHITESPACE_RE_CC:
				if (ch == 10 or 13 or 32 or 9) { outcome = true; ipos++; }
			NONWHITESPACE_RE_CC:
				if ((ch) && (ch ~= 10 or 13 or 32 or 9)) { outcome = true; ipos++; }
			PUNCTUATION_RE_CC:
				if (ch == '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') { outcome = true; ipos++; }
			NONPUNCTUATION_RE_CC:
				if ((ch) && (ch ~= '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}')) { outcome = true; ipos++; }
			WORD_RE_CC:
				if ((ch) && (ch ~= 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}')) { outcome = true; ipos++; }
			NONWORD_RE_CC:
				if (ch == 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') { outcome = true; ipos++; }
			DIGIT_RE_CC:
				if (ch == '0' or '1' or '2' or '3' or '4'
					or '5' or '6' or '7' or '8' or '9') { outcome = true; ipos++; }
			NONDIGIT_RE_CC:
				if ((ch) && (ch ~= '0' or '1' or '2' or '3' or '4'
					or '5' or '6' or '7' or '8' or '9')) { outcome = true; ipos++; }
			LCASE_RE_CC:
				if (CharIsOfCase(ch, 0)) { outcome = true; ipos++; }
			NONLCASE_RE_CC:
				if ((ch) && (CharIsOfCase(ch, 0) == false)) { outcome = true; ipos++; }
			UCASE_RE_CC:
				if (CharIsOfCase(ch, 1)) { outcome = true; ipos++; }
			NONUCASE_RE_CC:
				if ((ch) && (CharIsOfCase(ch, 1) == false)) { outcome = true; ipos++; }
			NEWLINE_RE_CC: if (ch == 10) { outcome = true; ipos++; }
			TAB_RE_CC: if (ch == 9) { outcome = true; ipos++; }
			RANGE_RE_CC:
				if (IT_RE_Range(ch, findt,
					token-->RE_PAR1, token-->RE_PAR2, token-->RE_PAR3, mode_flags & CIS_MFLAG))
					{ outcome = true; ipos++; }
			
			! Substring matches
			
			LITERAL_RE_CC:
				rv = IT_RE_MatchSubstring(indt, ipos,
					findt, token-->RE_PAR1, token-->RE_PAR2, mode_flags & CIS_MFLAG);
				if (rv >= 0) { ipos = ipos + rv; outcome = true; }
			VARIABLE_RE_CC:
				i = token-->RE_PAR1;
				if ((RE_Subexpressions-->i)-->RE_DATA1 >= 0) {
					rv = IT_RE_MatchSubstring(indt, ipos,
						indt, (RE_Subexpressions-->i)-->RE_DATA1,
						(RE_Subexpressions-->i)-->RE_DATA2, mode_flags & CIS_MFLAG);
					if (rv >= 0) { ipos = ipos + rv; outcome = true; }
				}
				.NeverMatchIncompleteVar;
		}
		
		if (outcome == false) {
			if (IT_RE_RewindCount++ >= 10000) {
				if (IT_RE_RewindCount == 10001) {
					style bold; print "OVERFLOW^"; style roman;
				}
				return -1;
			}
			if (IT_RE_Trace) {
				print "Rewind sought from failure at pos ", ipos, " with: ";
					IT_RE_DebugNode(token, findt, true);
			}
			if ((token-->RE_CCLASS == QUANTIFIER_RE_CC) &&
				(IT_RE_SeekBacktrack(token-->RE_DOWN, findt, false, ito, false)))
				jump RewindFound;
			if (mode_flags & ACCUM_MFLAG == false) IT_RE_FailSubexpressions(token);
			token = token-->RE_PREVIOUS;
			while (token ~= NULL) {
				if (IT_RE_SeekBacktrack(token, findt, true, ito, false)) {
					.RewindFound;
					ipos = token-->RE_DATA1;
					mode_flags = token-->RE_MODES;
					if (mode_flags & ACCUM_MFLAG == false)
						IT_RE_FailSubexpressions(token, true);
					if (ipos == -1)
						IT_RE_DebugTree(findt, true);
					if (IT_RE_Trace) {
						print "^[", ifrom, ",", ito, "] rewinding to ", ipos, " at ";
						IT_RE_DebugNode(token, findt, true);
					}
					jump Rewind;
				}
				token = token-->RE_PREVIOUS;
			}
			if (IT_RE_Trace)
				print "^Rewind impossible^";
			return -1;
		}

		token = token-->RE_NEXT;
	}
	return ipos - ifrom;
];

[ IT_RE_SeekBacktrack token findt downwards ito report_only
	untried;
	for (: token ~= NULL: token = token-->RE_NEXT) {
		if ((IT_RE_Trace) && (report_only == false)) {
			print "Scan for rewind: ";
			IT_RE_DebugNode(token, findt, true);
		}
		if ((token-->RE_CCLASS == SUBEXP_RE_CC) &&
			(token-->RE_PAR2 == 1 or 2 or 4)) {
			if (downwards) rfalse;
			continue;
		}
		if (token-->RE_DOWN ~= NULL) {
			if ((IT_RE_Trace) && (report_only == false)) print "Descend^";
			if (IT_RE_SeekBacktrack(token-->RE_DOWN, findt, false, ito, report_only)) rtrue;
		}
		untried = false;
		switch (token-->RE_CCLASS) {
			DISJUNCTION_RE_CC:
				if ((token-->RE_DATA2 >= 1) &&
					(token-->RE_DATA2 < token-->RE_PAR1) &&
					(token-->RE_CONSTRAINT < token-->RE_PAR1)) { ! Matched but earlier than last
					if (report_only) rtrue;
					if (token-->RE_CONSTRAINT == -1)
						token-->RE_CONSTRAINT = 1;
					else
						(token-->RE_CONSTRAINT)++;
					untried = true;
				}
			QUANTIFIER_RE_CC:
				if (token-->RE_CONSTRAINT ~= -2) {
					if ((IT_RE_Trace) && (report_only == false)) {
						print "Quant with cons not -2: ";
						IT_RE_DebugNode(token, findt, true);
					}
					if (token-->RE_DATA2 >= 0) {
						if (report_only) rtrue;
						token-->RE_CONSTRAINT = token-->RE_DATA2;
						untried = true;
					}
				}
		}
		if (untried) {
			if (IT_RE_Trace) {
				print "Grounds for rewind at: ";
				IT_RE_DebugNode(token, findt, true);
			}
			IT_RE_EraseConstraints(token-->RE_NEXT);
			IT_RE_EraseConstraints(token-->RE_DOWN);
			rtrue;
		}
		if (downwards) rfalse;
	}
	rfalse;
];

[ IT_RE_FailSubexpressions token downwards;
	for (: token ~= NULL: token = token-->RE_NEXT) {
		if (token-->RE_DOWN ~= NULL) IT_RE_FailSubexpressions(token-->RE_DOWN);
		if (token-->RE_CCLASS == SUBEXP_RE_CC) {
			token-->RE_DATA1 = -1;
			token-->RE_DATA2 = -1;
		}
		if (downwards) break;
	}
];

[ IT_RE_EraseConstraints token;
	while (token ~= NULL) {
		switch (token-->RE_CCLASS) {
			DISJUNCTION_RE_CC: token-->RE_CONSTRAINT = -1;
			QUANTIFIER_RE_CC: token-->RE_CONSTRAINT = -1;
		}
		if (token-->RE_DOWN) IT_RE_EraseConstraints(token-->RE_DOWN);
		token = token-->RE_NEXT;
	}
];

[ IT_RE_MatchSubstring indt ipos mindt mfrom mto insens
	i ch;
	if (mfrom < 0) return 0;
	if (insens)
		for (i=mfrom:i<mto:i++) {
			ch = BlkValueRead(mindt, i);
			if (BlkValueRead(indt, ipos++) ~= ch or IT_RevCase(ch))
				return -1;
		}
	else
		for (i=mfrom:i<mto:i++)
			if (BlkValueRead(indt, ipos++) ~= BlkValueRead(mindt, i))
				return -1;
	return mto-mfrom;
];

[ IT_RE_Range ch findt rf rt negate insens
	i chm upper crev;
	if (ch == 0) rfalse;
	if (negate == true) {
		if (IT_RE_Range(ch, findt, rf, rt, false, insens)) rfalse;
		rtrue;
	}
	for (i=rf: i<rt: i++) {
		chm = BlkValueRead(findt, i);
		if ((chm == '\') && (i+1<rt)) {
			chm = BlkValueRead(findt, ++i);
			switch (chm) {
				's':
					if (ch == 10 or 13 or 32 or 9) rtrue;
				'S':
					if ((ch) && (ch ~= 10 or 13 or 32 or 9)) rtrue;
				'p':
					if (ch == '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}') rtrue;
				'P':
					if ((ch) && (ch ~= '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}')) rtrue;
				'w':
					if ((ch) && (ch ~= 10 or 13 or 32 or 9
						or '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}')) rtrue;
				'W':
					if (ch == 10 or 13 or 32 or 9
						or '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}') rtrue;
				'd':
					if (ch == '0' or '1' or '2' or '3' or '4'
						or '5' or '6' or '7' or '8' or '9') rtrue;
				'D':
					if ((ch) && (ch ~= '0' or '1' or '2' or '3' or '4'
						or '5' or '6' or '7' or '8' or '9')) rtrue;
				'l': if (CharIsOfCase(ch, 0)) rtrue;
				'L': if (CharIsOfCase(ch, 0) == false) rtrue;
				'u': if (CharIsOfCase(ch, 1)) rtrue;
				'U': if (CharIsOfCase(ch, 1) == false) rtrue;
				'n': if (ch == 10) rtrue;
				't': if (ch == 9) rtrue;
			}
		}
		if ((i+2<rt) && (BlkValueRead(findt, i+1) == '-')) {
			upper = BlkValueRead(findt, i+2);
			if ((ch >= chm) && (ch <= upper)) rtrue;
			if (insens) {
				crev = IT_RevCase(ch);
				if ((crev >= chm) && (crev <= upper)) rtrue;
			}
			i=i+2;
		} else {
			if (chm == ch) rtrue;
			if ((insens) && (chm == IT_RevCase(ch))) rtrue;
		}
	}
	rfalse;
];

[ IT_Replace_RE findtype indt findt rindt insens exactly
	cindt csize ilen i cl mpos cpos ch chm;
	ilen = IT_CharacterLength(indt);

	IT_RE_Err = 0;
	switch (findtype) {
		REGEXP_BLOB: i = IT_RE_CompileTree(findt, exactly);
		CHR_BLOB: i = IT_CHR_CompileTree(findt, exactly);
		default: "*** bad findtype ***";
	}
	
	if ((i<0) || (i>RE_MAX_PACKETS)) {
		IT_RE_Err = i;
		print "*** Regular expression error: ", (string) IT_RE_Err, " ***^";
		RunTimeProblem(RTP_REGEXPSYNTAXERROR);
		return 0;
	}

	if (IT_RE_Trace) {
		IT_RE_DebugTree(findt);
		print "(compiled to ", i, " packets)^";
	}
	
	if (findtype == REGEXP_BLOB) IT_RE_EmptyMatchVars();

	mpos = 0; chm = 0; cpos = 0;
	while (IT_RE_Parse(findt, indt, mpos, insens) >= 0) {
		chm++;
		
		if (IT_RE_Trace) {
			print "^*** Match ", chm, " found (", RE_PACKET_space-->RE_DATA1, ",",
				RE_PACKET_space-->RE_DATA2, "): ";
			if (RE_PACKET_space-->RE_DATA1 == RE_PACKET_space-->RE_DATA2) {
				print "<empty>";
			}
			for (i=RE_PACKET_space-->RE_DATA1:i<RE_PACKET_space-->RE_DATA2:i++) {
				print (char) BlkValueRead(indt, i);
			}
			print " ***^";
		}
		
		if (rindt == 0) break; ! Accept only one match, replace nothing
		
		if (rindt ~= 0 or 1) {
			if (chm == 1) {
				cindt = BlkValueCreate(INDEXED_TEXT_TY);
				csize = BlkValueExtent(cindt);
			}

			for (i=cpos:i<RE_PACKET_space-->RE_DATA1:i++) {
				ch = BlkValueRead(indt, i);
				if (cl+1 >= csize) {
					if (BlkValueSetExtent(cindt, 2*cl, 7) == false) break;
					csize = BlkValueExtent(cindt);
				}
				BlkValueWrite(cindt, cl++, ch);
			}
			BlkValueWrite(cindt, cl, 0);
	
			IT_Concatenate(cindt, rindt, findtype, indt);
			csize = BlkValueExtent(cindt);
			cl = IT_CharacterLength(cindt);			
		}

		mpos = RE_PACKET_space-->RE_DATA2; cpos = mpos;
		if (RE_PACKET_space-->RE_DATA1 == RE_PACKET_space-->RE_DATA2)
			mpos++;

		if (IT_RE_Trace) {
			if (chm == 100) { ! Purely to keep the output from being excessive
				print "(Stopping after 100 matches.)^"; break;
			}
		}
	}
	if (chm > 0) {
		if (rindt ~= 0 or 1) {
			for (i=cpos:i<ilen:i++) {
				ch = BlkValueRead(indt, i);
				if (cl+1 >= csize) {
					if (BlkValueSetExtent(cindt, 2*cl, 8) == false) break;
					csize = BlkValueExtent(cindt);
				}
				BlkValueWrite(cindt, cl++, ch);
			}
		}
		
		if (findtype == REGEXP_BLOB) {
			IT_RE_CreateMatchVars(indt);
			if (IT_RE_Trace)
				IT_RE_DebugMatchVars(indt);
		}

		if (rindt ~= 0 or 1) {
			BlkValueWrite(cindt, cl, 0);
			BlkValueCopy(indt, cindt);	
			BlkFree(cindt);
		}
	}
	return chm;
];

[ IT_RE_Concatenate indt_to indt_from blobtype indt_ref
	pos len ch i tosize x y case;
	if ((indt_to==0) || (BlkType(indt_to) ~= INDEXED_TEXT_TY)) rfalse;
	if ((indt_from==0) || (BlkType(indt_from) ~= INDEXED_TEXT_TY)) return indt_to;
	pos = IT_CharacterLength(indt_to);
	tosize = BlkValueExtent(indt_to);
	len = IT_CharacterLength(indt_from);
	for (i=0:i<len:i++) {
		ch = BlkValueRead(indt_from, i);
		if ((ch == '\') && (i < len-1)) {
			ch = BlkValueRead(indt_from, ++i);
			if (ch == 'n') ch = 10;
			if (ch == 't') ch = 9;
			case = -1;
			if (ch == 'l') case = 0;
			if (ch == 'u') case = 1;
			if (case >= 0) ch = BlkValueRead(indt_from, ++i);
			if ((ch >= '0') && (ch <= '9')) {
				ch = ch - '0';
				if (ch < RE_Subexpressions-->10) {
					x = (RE_Subexpressions-->ch)-->RE_DATA1;
					y = (RE_Subexpressions-->ch)-->RE_DATA2;
					if (x >= 0) {
						for (:x<y:x++) {
							ch = BlkValueRead(indt_ref, x);
							if (pos+1 >= tosize) {
								if (BlkValueSetExtent(indt_to, 2*tosize, 11) == false) break;
								tosize = BlkValueExtent(indt_to);
							}
							if (case >= 0)
								BlkValueWrite(indt_to, pos++, CharToCase(ch, case));
							else
								BlkValueWrite(indt_to, pos++, ch);
						}
					}
				}
				continue;
			}
			
		}
		if (pos+1 >= tosize) {
			if (BlkValueSetExtent(indt_to, 2*tosize, 12) == false) break;
			tosize = BlkValueExtent(indt_to);
		}
		BlkValueWrite(indt_to, pos++, ch);
	}
	BlkValueWrite(indt_to, pos, 0);
	return indt_to;
];

#ENDIF; ! IFDEF MEMORY_HEAP_SIZE

#IFDEF MEMORY_HEAP_SIZE; ! Will exist if any use is made of indexed texts

[ STORED_ACTION_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:     return STORED_ACTION_TY_Create();
		CAST_KOVS:       rfalse;
		DESTROY_KOVS:    return STORED_ACTION_TY_Destroy(arg1);
		PRECOPY_KOVS:    rfalse;
		COPY_KOVS:       return STORED_ACTION_TY_Copy(arg1, arg2);
		COMPARE_KOVS:    return STORED_ACTION_TY_Compare(arg1, arg2);
		READ_FILE_KOVS:  rfalse;
		WRITE_FILE_KOVS: rfalse;
		HASH_KOVS:       return STORED_ACTION_TY_Hash(arg1);
	}
];

[ STORED_ACTION_TY_Create stora;
	stora = BlkAllocate(6*WORDSIZE, STORED_ACTION_TY, BLK_FLAG_WORD);
	BlkValueWrite(stora, 0, ##Wait); ! action
	BlkValueWrite(stora, 1, 0); ! noun
	BlkValueWrite(stora, 2, 0); ! second
	BlkValueWrite(stora, 3, player); ! actor
	BlkValueWrite(stora, 4, false); ! whether a request
	BlkValueWrite(stora, 5, 0); ! indexed text of command if necessary, 0 if not
	return stora;
];

[ STORED_ACTION_TY_New a n s ac req  stora;
	if (stora == 0) stora = STORED_ACTION_TY_Create();
	BlkValueWrite(stora, 0, a);
	BlkValueWrite(stora, 1, n);
	BlkValueWrite(stora, 2, s);
	BlkValueWrite(stora, 3, ac);
	BlkValueWrite(stora, 4, req);
	BlkValueWrite(stora, 5, 0);
	return stora;
];

[ STORED_ACTION_TY_Destroy stora toc;
	toc = BlkValueRead(stora, 5);
	if (toc) BlkFree(toc);
];

[ STORED_ACTION_TY_Copy storato storafrom tocfrom tocto;
	tocfrom = BlkValueRead(storafrom, 5);
	if (tocfrom == 0) return;
	tocto = INDEXED_TEXT_TY_Support(CREATE_KOVS);
	BlkValueCopy(tocto, tocfrom);
	BlkValueWrite(storato, 5, tocto);
];

[ STORED_ACTION_TY_Compare storaleft storaright delta itleft itright;
	delta = BlkValueRead(storaleft, 0) - BlkValueRead(storaright, 0);
	if (delta) return delta;
	delta = BlkValueRead(storaleft, 1) - BlkValueRead(storaright, 1);
	if (delta) return delta;
	delta = BlkValueRead(storaleft, 2) - BlkValueRead(storaright, 2);
	if (delta) return delta;
	delta = BlkValueRead(storaleft, 3) - BlkValueRead(storaright, 3);
	if (delta) return delta;
	delta = BlkValueRead(storaleft, 4) - BlkValueRead(storaright, 4);
	if (delta) return delta;
	itleft = BlkValueRead(storaleft, 5);
	itright = BlkValueRead(storaright, 5);
	if ((itleft ~= 0) && (itright ~= 0))
		return INDEXED_TEXT_TY_Support(COMPARE_KOVS, itleft, itright);
	return itleft - itright;
];

[ STORED_ACTION_TY_Distinguish stora1 stora2;
	if (STORED_ACTION_TY_Compare(stora1, stora2) == 0) rfalse;
	rtrue;
];

[ STORED_ACTION_TY_Hash stora  rv it;
	rv = BlkValueRead(stora, 0);
	rv = rv * 33 + BlkValueRead(stora, 1);
	rv = rv * 33 + BlkValueRead(stora, 2);
	rv = rv * 33 + BlkValueRead(stora, 3);
	rv = rv * 33 + BlkValueRead(stora, 4);
	it = BlkValueRead(stora, 5);
	if (it ~= 0)
		rv = rv * 33 + INDEXED_TEXT_TY_Support(HASH_KOVS, it);
	return rv;
];

[ STORED_ACTION_TY_Say stora text_of_command saved_command saved_pn saved_action K1 K2 at;
	if ((stora==0) || (BlkType(stora) ~= STORED_ACTION_TY)) return;
	text_of_command = BlkValueRead(stora, 5);
	if (text_of_command) {
		saved_command = INDEXED_TEXT_TY_Support(CREATE_KOVS);
		INDEXED_TEXT_TY_Support(CAST_KOVS, players_command, SNIPPET_TY, saved_command);
		SetPlayersCommand(text_of_command);
	}
	saved_pn = parsed_number; saved_action = action;
	action = BlkValueRead(stora, 0);
	at = FindAction(-1);
	K1 = ActionData-->(at+AD_NOUN_KOV);
	K2 = ActionData-->(at+AD_SECOND_KOV);
	if (K1 ~= OBJECT_TY) {
		parsed_number = BlkValueRead(stora, 1);
		if ((K1 == UNDERSTANDING_TY) && (text_of_command == 0)) {
			if (saved_command == 0) saved_command = INDEXED_TEXT_TY_Create();
			INDEXED_TEXT_TY_Cast(players_command, SNIPPET_TY, saved_command);
			text_of_command = INDEXED_TEXT_TY_Create();
			INDEXED_TEXT_TY_Cast(parsed_number, TEXT_TY, text_of_command);
			SetPlayersCommand(text_of_command);
			parsed_number = players_command;
		}
	}
	if (K2 ~= OBJECT_TY) {
		parsed_number = BlkValueRead(stora, 2);
		if ((K2 == UNDERSTANDING_TY) && (text_of_command == 0)) {
			if (saved_command == 0) saved_command = INDEXED_TEXT_TY_Create();
			INDEXED_TEXT_TY_Cast(players_command, SNIPPET_TY, saved_command);
			text_of_command = INDEXED_TEXT_TY_Create();
			INDEXED_TEXT_TY_Cast(parsed_number, TEXT_TY, text_of_command);
			SetPlayersCommand(text_of_command);
			parsed_number = players_command;
		}
	}	
	DB_Action(BlkValueRead(stora, 3), BlkValueRead(stora, 4), BlkValueRead(stora, 0),
		BlkValueRead(stora, 1), BlkValueRead(stora, 2), true);
	parsed_number = saved_pn; action = saved_action;
	if (text_of_command) {
		SetPlayersCommand(saved_command);
		BlkFree(saved_command);
	}
];

[ STORED_ACTION_TY_Involves stora item at;
	at = FindAction(BlkValueRead(stora, 0));
	if (at) {
		if ((ActionData-->(at+AD_NOUN_KOV) == OBJECT_TY) &&
			(BlkValueRead(stora, 1) == item)) rtrue;
		if ((ActionData-->(at+AD_SECOND_KOV) == OBJECT_TY) &&
			(BlkValueRead(stora, 2) == item)) rtrue;
	}
	if (BlkValueRead(stora, 3) == item) rtrue;
	rfalse;
];

[ STORED_ACTION_TY_Part stora ind at ado;
	if (ind == 1 or 2) {
		if (ind == 1) ado = AD_NOUN_KOV; else ado = AD_SECOND_KOV;
		at = FindAction(BlkValueRead(stora, 0));
		if ((at) && (ActionData-->(at+ado) == OBJECT_TY)) return BlkValueRead(stora, ind);
		return nothing;
	}
	return BlkValueRead(stora, ind);
];

Array SAT_Tmp-->7;
[ STORED_ACTION_TY_Adopt stora at;
	SAT_Tmp-->1 = action;
	SAT_Tmp-->2 = noun;
	SAT_Tmp-->3 = second;
	SAT_Tmp-->4 = actor;
	SAT_Tmp-->5 = act_requester;
	SAT_Tmp-->6 = parsed_number;
	action = BlkValueRead(stora, 0);
	at = FindAction(-1);
	if (ActionData-->(at+AD_NOUN_KOV) == OBJECT_TY) noun = BlkValueRead(stora, 1);
	else { parsed_number = BlkValueRead(stora, 1); noun = nothing; }
	if (ActionData-->(at+AD_SECOND_KOV) == OBJECT_TY) second = BlkValueRead(stora, 2);
	else { parsed_number = BlkValueRead(stora, 2); second = nothing; }
	actor = BlkValueRead(stora, 3);
	if (BlkValueRead(stora, 4)) act_requester = player; else act_requester = nothing;
];

[ STORED_ACTION_TY_Unadopt;
	action = SAT_Tmp-->1;
	noun = SAT_Tmp-->2;
	second = SAT_Tmp-->3;	
	actor = SAT_Tmp-->4;	
	act_requester = SAT_Tmp-->5;
	parsed_number = SAT_Tmp-->6;
	return SAT_Tmp-->0;
];

[ STORED_ACTION_TY_Current stora at text_of_command;
	if ((stora==0) || (BlkType(stora) ~= STORED_ACTION_TY)) return 0;
	BlkValueWrite(stora, 0, action);
	at = FindAction(-1);
	if (ActionData-->(at+AD_NOUN_KOV) == OBJECT_TY) BlkValueWrite(stora, 1, noun);
	else BlkValueWrite(stora, 1, parsed_number);
	if (ActionData-->(at+AD_SECOND_KOV) == OBJECT_TY) BlkValueWrite(stora, 2, second);
	else BlkValueWrite(stora, 2, parsed_number);
	BlkValueWrite(stora, 3, actor);
	if (act_requester) BlkValueWrite(stora, 4, true); else BlkValueWrite(stora, 4, false);
	if ((at) && ((ActionData-->(at+AD_NOUN_KOV) == UNDERSTANDING_TY) ||
			(ActionData-->(at+AD_SECOND_KOV) == UNDERSTANDING_TY))) {
		text_of_command = BlkValueRead(stora, 5);
		if (text_of_command == 0) {
			text_of_command = INDEXED_TEXT_TY_Support(CREATE_KOVS);
			BlkValueWrite(stora, 5, text_of_command);
		}
		INDEXED_TEXT_TY_Support(CAST_KOVS, players_command, SNIPPET_TY, text_of_command);
	} else BlkValueWrite(stora, 5, 0);
	return stora;
];

[ STORED_ACTION_TY_Try stora ks  text_of_command saved_command;
	if ((stora==0) || (BlkType(stora) ~= STORED_ACTION_TY)) return;
	if (ks) { @push keep_silent; keep_silent=1; }
	text_of_command = BlkValueRead(stora, 5);
	if (text_of_command) {
		saved_command = INDEXED_TEXT_TY_Support(CREATE_KOVS);
		INDEXED_TEXT_TY_Support(CAST_KOVS, players_command, SNIPPET_TY, saved_command);
		SetPlayersCommand(text_of_command);
	}
	TryAction(BlkValueRead(stora, 4), BlkValueRead(stora, 3),
		BlkValueRead(stora, 0), BlkValueRead(stora, 1), BlkValueRead(stora, 2));
	if (text_of_command) {
		SetPlayersCommand(saved_command);
		BlkFree(saved_command);
	}
	if (ks) { @pull keep_silent; }
];

#IFNOT; ! IFDEF MEMORY_HEAP_SIZE

[ STORED_ACTION_TY_Say stora; ];
[ STORED_ACTION_TY_New a n s ac req stora; return false; ];
[ STORED_ACTION_TY_Support t a b c; rfalse; ];

#ENDIF; ! IFDEF MEMORY_HEAP_SIZE

#IFDEF MEMORY_HEAP_SIZE; ! Will exist if any use is made of heap

[ LIST_OF_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:     arg3 = LIST_OF_TY_Create(arg2);
		                 if (arg1) LIST_OF_TY_CopyRawArray(arg3, arg1, 2, 0);
		                 return arg3;
		CAST_KOVS:       rfalse;
		DESTROY_KOVS:    return LIST_OF_TY_Destroy(arg1);
		PRECOPY_KOVS:    return LIST_OF_TY_PreCopy(arg1, arg2);
		COPY_KOVS:       return LIST_OF_TY_Copy(arg1, arg2);
		COMPARE_KOVS:    return LIST_OF_TY_Compare(arg1, arg2);
		READ_FILE_KOVS:  rfalse;
		WRITE_FILE_KOVS: rfalse;
		HASH_KOVS:       return LIST_OF_TY_Hash(arg1);
	}
];

Constant LIST_ITEM_KOV_F = 0; ! Entry 0: the kind of the list
Constant LIST_LENGTH_F = 1; ! Entry 1: length, i.e., number of items
Constant LIST_ITEM_BASE = 2; ! List items begin at this entry

[ LIST_OF_TY_Create skov list;
	skov = KindBaseTerm(skov, 0);
	list = BlkAllocate(28*WORDSIZE, LIST_OF_TY, BLK_FLAG_MULTIPLE + BLK_FLAG_WORD);
	BlkValueWrite(list, LIST_ITEM_KOV_F, skov);
	BlkValueWrite(list, LIST_LENGTH_F, 0);
	return list;
];

[ LIST_OF_TY_CopyRawArray list arr rea cast len i ex bk v w;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return false;
	ex = BlkValueExtent(list);
	len = arr-->2;
	if ((len+LIST_ITEM_BASE > ex) &&
		(BlkValueSetExtent(list, len+LIST_ITEM_BASE) == false)) return 0;
	BlkValueWrite(list, LIST_LENGTH_F, len);
	if (rea == 2) bk = BlkValueRead(list, LIST_ITEM_KOV_F);
	else {
		bk = arr-->1;
		BlkValueWrite(list, LIST_ITEM_KOV_F, bk);
	}
	for (i=0:i<len:i++) {
		v = arr-->(i+3);
		if (KindAtomic(bk) == LIST_OF_TY) {
			w = LIST_OF_TY_Create(v-->1);
			LIST_OF_TY_CopyRawArray(w, v, 0, KindBaseTerm(bk, 0));
			BlkValueWrite(list, i+LIST_ITEM_BASE, w);
		} else {
			if ((cast) && (cast ~= bk)) {
				if (KOVIsBlockValue(cast)) v = BlkValueCreate(cast, v, bk);
			} else {
				if (KOVIsBlockValue(bk)) v = BlkValueCreate(bk, v);
			}
			BlkValueWrite(list, i+LIST_ITEM_BASE, v);
		}
	}
	if ((cast) && (cast ~= bk)) BlkValueWrite(list, LIST_ITEM_KOV_F, cast);
	#ifdef SHOW_ALLOCATIONS;
	print "Copied raw array to list: "; LIST_OF_TY_Say(list, 1); print "^";
	#endif;
	return list;
];

[ LIST_OF_TY_Destroy list no_items i;
	if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
		no_items = BlkValueRead(list, LIST_LENGTH_F);
		for (i=0; i<no_items; i++) BlkFree(BlkValueRead(list, i+LIST_ITEM_BASE));
	}
	return list;
];

Global precopied_list_kov;

[ LIST_OF_TY_PreCopy lto lfrom list;
	precopied_list_kov = BlkValueRead(lto, LIST_ITEM_KOV_F);
];

[ LIST_OF_TY_Copy lto lfrom list no_items i nv bk val splk;
	no_items = BlkValueRead(lfrom, LIST_LENGTH_F);
	bk = BlkValueRead(lfrom, LIST_ITEM_KOV_F);
	if (precopied_list_kov ~= 0 or 1) BlkValueWrite(lto, LIST_ITEM_KOV_F, precopied_list_kov);
	else BlkValueWrite(lto, LIST_ITEM_KOV_F, bk);
	if ((precopied_list_kov == INDEXED_TEXT_TY) && (bk == TEXT_TY)) {
		for (i=0; i<no_items; i++) {
			nv = BlkValueCreate(INDEXED_TEXT_TY);
			INDEXED_TEXT_TY_Cast(BlkValueRead(lfrom, i+LIST_ITEM_BASE), TEXT_TY, nv);
			BlkValueWrite(lto, i+LIST_ITEM_BASE, nv);
		}
	} else {
		if (KOVIsBlockValue(bk)) {
			for (i=0; i<no_items; i++) {
				val = BlkValueRead(lfrom, i+LIST_ITEM_BASE);
				nv = BlkValueCreate(BlkType(val));
				BlkValueCopy(nv, val);
				BlkValueWrite(lto, i+LIST_ITEM_BASE, nv);
			}
		}
	}
	precopied_list_kov = 0;
];

[ LIST_OF_TY_Compare listleft listright delta no_items i cf;
	delta = BlkValueRead(listleft, LIST_LENGTH_F) - BlkValueRead(listright, LIST_LENGTH_F);
	if (delta) return delta;
	no_items = BlkValueRead(listleft, LIST_LENGTH_F);
	if (no_items == 0) return 0;
	delta = BlkValueRead(listleft, LIST_ITEM_KOV_F) - BlkValueRead(listright, LIST_ITEM_KOV_F);
	if (delta) return delta;
	cf = LIST_OF_TY_ComparisonFn(listleft);
	if (cf == 0 or UnsignedCompare) {
		for (i=0; i<no_items; i++) {
			delta = BlkValueRead(listleft, i+LIST_ITEM_BASE) -
				BlkValueRead(listright, i+LIST_ITEM_BASE);
			if (delta) return delta;
		}
	} else {
		for (i=0; i<no_items; i++) {
			delta = cf(BlkValueRead(listleft, i+LIST_ITEM_BASE),
				BlkValueRead(listright, i+LIST_ITEM_BASE));
			if (delta) return delta;
		}
	}
	return 0;
];

[ LIST_OF_TY_ComparisonFn list;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return 0;
	return KOVComparisonFunction(BlkValueRead(list, LIST_ITEM_KOV_F));
];

[ LIST_OF_TY_Distinguish txb1 txb2;
	if (LIST_OF_TY_Compare(txb1, txb2) == 0) rfalse;
	rtrue;
];

[ LIST_OF_TY_Hash list  len kov rv i;
	rv = 0;
	len = BlkValueRead(list, LIST_LENGTH_F);
	kov = BlkValueRead(list, LIST_ITEM_KOV_F);
	for (i=0: i<len: i++)
		rv = rv * 33 + KOVHashValue(kov, BlkValueRead(list, i+LIST_ITEM_BASE));
	return rv;
];

[ LIST_OF_TY_Say list format no_items v i bk;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	bk = KindAtomic(BlkValueRead(list, LIST_ITEM_KOV_F));
	! print "kov=", BlkValueRead(list, LIST_ITEM_KOV_F), ":";
	if (format == 1) print "{";
	for (i=0:i<no_items:i++) {
		v = BlkValueRead(list, i+LIST_ITEM_BASE);
		switch (format) {
			2: print (the) v;
			3: print (a) v;
			default:
				if (bk == LIST_OF_TY) LIST_OF_TY_Say(v, 1);
				else if ((bk == TEXT_TY or INDEXED_TEXT_TY) && (format == 1)) {
					print "~"; PrintKindValuePair(bk, v); print "~";
				}
				else PrintKindValuePair(bk, v);
		}
		if (i<no_items-2) print ", ";
		if (i==no_items-2) {
			if (format == 1) print ", "; else {
				#ifdef SERIAL_COMMA; if (no_items ~= 2) print ","; #endif;
				print (string) LISTAND2__TX;
			}
		}
	}
	if (format == 1) print "}";
];

[ LIST_OF_TY_Desc list desc kov obj no_items ex len i;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return false;
	ex = BlkValueExtent(list);
	len = desc(-3);
!	for (len=0, obj=desc(-2, nothing, len): obj: len++, obj=desc(-2, obj, len)) ;
!	len++;
	if (len+LIST_ITEM_BASE > ex) {
		if (BlkValueSetExtent(list, len+LIST_ITEM_BASE) == false)
			return 0;
	}
	if (kov) BlkValueWrite(list, LIST_ITEM_KOV_F, kov);
	else BlkValueWrite(list, LIST_ITEM_KOV_F, OBJECT_TY);
	BlkValueWrite(list, LIST_LENGTH_F, len);
	obj = 0;
	for (i=0: i<len: i++) {
		obj = desc(-2, obj, i);
		! print "i = ", i, " and obj = ", obj, "^";
		BlkValueWrite(list, i+LIST_ITEM_BASE, obj);
	}
	return list;
];

[ LIST_OF_TY_FindItem list v i no_items cf;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) rfalse;
	cf = LIST_OF_TY_ComparisonFn(list);
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (cf == 0 or UnsignedCompare) {
		for (i=0; i<no_items; i++)
			if (v == BlkValueRead(list, i+LIST_ITEM_BASE)) rtrue;
	} else {
		for (i=0; i<no_items; i++)
			if (cf(v, BlkValueRead(list, i+LIST_ITEM_BASE)) == 0) rtrue;
	}
	rfalse;
];

[ LIST_OF_TY_InsertItem list v posnflag posn nodups i no_items ex nv;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return false;
	if (nodups && (LIST_OF_TY_FindItem(list, v))) return list;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if ((posnflag) && ((posn<1) || (posn > no_items+1))) {
		print "*** Couldn't add at entry ", posn, " in the list ";
		LIST_OF_TY_Say(list, true);
		print ", which has entries in the range 1 to ", no_items, " ***^";
		RunTimeProblem(RTP_LISTRANGEERROR);
		rfalse;
	}
	ex = BlkValueExtent(list);
	if (no_items+LIST_ITEM_BASE+1 > ex) {
		if (BlkValueSetExtent(list, ex+16) == false) return 0;
	}
	if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
		nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F));
		BlkValueCopy(nv, v);
		v = nv;
	}
	if (posnflag) {
		posn--;
		for (i=no_items:i>posn:i--) {
			BlkValueWrite(list, i+LIST_ITEM_BASE,
				BlkValueRead(list, i-1+LIST_ITEM_BASE));			
		}
		BlkValueWrite(list, posn+LIST_ITEM_BASE, v);
	} else {
		BlkValueWrite(list, no_items+LIST_ITEM_BASE, v);
	}
	BlkValueWrite(list, LIST_LENGTH_F, no_items+1);
	return list;
];

[ LIST_OF_TY_AppendList list more posnflag posn nodups v i j no_items msize ex nv;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return false;
	if ((more==0) || (BlkType(more) ~= LIST_OF_TY)) return list;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if ((posnflag) && ((posn<1) || (posn > no_items+1))) {
		print "*** Couldn't add at entry ", posn, " in the list ";
		LIST_OF_TY_Say(list, true);
		print ", which has entries in the range 1 to ", no_items, " ***^";
		RunTimeProblem(RTP_LISTRANGEERROR);
		rfalse;
	}
	msize = BlkValueRead(more, LIST_LENGTH_F);
	ex = BlkValueExtent(list);
	if (no_items+msize+LIST_ITEM_BASE > ex) {
		if (BlkValueSetExtent(list, no_items+msize+LIST_ITEM_BASE+8) == false)
			return 0;
	}
	if (posnflag) {
		posn--;
		for (i=no_items+msize:i>=posn+msize:i--) {
			BlkValueWrite(list, i+LIST_ITEM_BASE,
				BlkValueRead(list, i-msize+LIST_ITEM_BASE));			
		}
		! BlkValueWrite(list, posn, v);
		for (j=0: j<msize: j++) {
			v = BlkValueRead(more, j+LIST_ITEM_BASE);
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
				nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F));
				BlkValueCopy(nv, v);
				v = nv;
			}
			BlkValueWrite(list, posn+j+LIST_ITEM_BASE, v);
		}
	} else {
		for (i=0, j=0: i<msize: i++) {
			v = BlkValueRead(more, i+LIST_ITEM_BASE);
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
				nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F));
				BlkValueCopy(nv, v);
				v = nv;
			}
			if ((nodups == 0) || (LIST_OF_TY_FindItem(list, v) == false)) {
				BlkValueWrite(list, no_items+j+LIST_ITEM_BASE, v);
				j++;
			}
		}
	}
	BlkValueWrite(list, LIST_LENGTH_F, no_items+j);
	return list;
];

[ LIST_OF_TY_RemoveValue list v forgive i j no_items odsize f cf delendum;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) rfalse;
	cf = LIST_OF_TY_ComparisonFn(list);
	no_items = BlkValueRead(list, LIST_LENGTH_F); odsize = no_items;
	for (i=0; i<no_items; i++) {
		delendum = BlkValueRead(list, i+LIST_ITEM_BASE);
		if (cf == 0 or UnsignedCompare)
			f = (v == delendum);
		else
			f = (cf(v, delendum) == 0);
		if (f) {
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
				BlkFree(delendum);
			for (j=i+1; j<no_items; j++)
				BlkValueWrite(list, j-1+LIST_ITEM_BASE,
					BlkValueRead(list, j+LIST_ITEM_BASE));
			no_items--; i--;
			BlkValueWrite(list, LIST_LENGTH_F, no_items);
		}
	}
	if (odsize ~= no_items) rfalse;
	if (forgive) rfalse;
	print "*** Couldn't remove: the value ";
	PrintKindValuePair(BlkValueRead(list, LIST_ITEM_KOV_F), v);
	print " was not present in the list ";
	LIST_OF_TY_Say(list, true);
	print " ***^";
	RunTimeProblem(RTP_LISTRANGEERROR);
];

[ LIST_OF_TY_RemoveItemRange list from to forgive i d no_items;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) rfalse;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if ((from > to) || (from <= 0) || (to > no_items)) {
		if (forgive) {
			if (from <= 0) from = 1;
			if (to >= no_items) to = no_items;
			if (from > to) return list;
		} else {
			print "*** Couldn't remove entries ", from, " to ", to, " from the list ";
			LIST_OF_TY_Say(list, true);
			print ", which has entries in the range 1 to ", no_items, " ***^";
			RunTimeProblem(RTP_LISTRANGEERROR);
			rfalse;
		}
	}
	to--; from--;
	d = to-from+1;
	if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
		for (i=0; i<d; i++)
			BlkFree(BlkValueRead(list, from+i+LIST_ITEM_BASE));
	for (i=from: i<no_items-d: i++)
		BlkValueWrite(list, i+LIST_ITEM_BASE,
			BlkValueRead(list, i+d+LIST_ITEM_BASE));
	BlkValueWrite(list, LIST_LENGTH_F, no_items-d);
	return list;
];

[ LIST_OF_TY_Remove_List list rlist i j k v w no_items odsize rsize cf f;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) rfalse;
	no_items = BlkValueRead(list, LIST_LENGTH_F); odsize = no_items;
	rsize = BlkValueRead(rlist, LIST_LENGTH_F);
	cf = LIST_OF_TY_ComparisonFn(list);
	for (i=0: i<no_items: i++) {
		v = BlkValueRead(list, i+LIST_ITEM_BASE);
		for (k=0: k<rsize: k++) {
			w = BlkValueRead(rlist, k+LIST_ITEM_BASE);
			if (cf == 0 or UnsignedCompare)
				f = (v == w);
			else
				f = (cf(v, w) == 0);
			if (f) {
				if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
					BlkFree(v);
				for (j=i+1: j<no_items: j++)
					BlkValueWrite(list, j+LIST_ITEM_BASE-1, 
						BlkValueRead(list, j+LIST_ITEM_BASE));
				no_items--; i--;
				BlkValueWrite(list, LIST_LENGTH_F, no_items);
				break;
			}
		}
	}
	rfalse;
];

[ LIST_OF_TY_GetLength list;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return 0;
	return BlkValueRead(list, LIST_LENGTH_F);
];

[ LIST_OF_TY_Empty list;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) rfalse;
	if (BlkValueRead(list, LIST_LENGTH_F) == 0) rtrue;
	rfalse;
];

[ LIST_OF_TY_SetLength list newsize this_way_only truncation_end no_items ex i dv;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return 0;
	if (newsize < 0) "*** Cannot resize a list to negative length ***";
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (no_items < newsize) {
		if (this_way_only == -1) return list;
		ex = BlkValueExtent(list);
		if (newsize+LIST_ITEM_BASE > ex) {
			if (BlkValueSetExtent(list, newsize+LIST_ITEM_BASE) == false)
				return 0;
		}
		dv = DefaultValueOfKOV(BlkValueRead(list, LIST_ITEM_KOV_F));
		for (i=no_items: i<newsize: i++)
			BlkValueWrite(list, LIST_ITEM_BASE+i, dv);
		BlkValueWrite(list, LIST_LENGTH_F, newsize);
	}
	if (no_items > newsize) {
		if (this_way_only == 1) return list;
		if (truncation_end == -1) {
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
				for (i=0: i<no_items-newsize: i++)
					BlkFree(BlkValueRead(list, LIST_ITEM_BASE+i));
			for (i=0: i<newsize: i++)
				BlkValueWrite(list, LIST_ITEM_BASE+i,
					BlkValueRead(list, LIST_ITEM_BASE+no_items-newsize+i));
		} else {
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
				for (i=newsize: i<no_items: i++)
					BlkFree(BlkValueRead(list, LIST_ITEM_BASE+i));
		}
		BlkValueWrite(list, LIST_LENGTH_F, newsize);
	}
	return list;
];

[ LIST_OF_TY_GetItem list i forgive no_items;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return false;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if ((i<=0) || (i>no_items)) {
		if (forgive) return false;
		print "*** Couldn't read from entry ", i, " of a list which";
		switch (no_items) {
			0: print " is empty ***^";
			1: print " has only one entry, numbered 1 ***^";
			default: print " has entries numbered from 1 to ", no_items, " ***^";
		}
		RunTimeProblem(RTP_LISTRANGEERROR);
		if (no_items >= 1) i = 1;
		else return false;
	}
	return BlkValueRead(list, LIST_ITEM_BASE+i-1);
];

[ WriteLIST_OF_TY_GetItem list i val no_items;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return false;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if ((i<=0) || (i>no_items)) {
		print "*** Couldn't write to list entry ", i, " of a list which";
		switch (no_items) {
			0: print " is empty ***^";
			1: print " has only one entry, numbered 1 ***^";
			default: print " has entries numbered from 1 to ", no_items, " ***^";
		}
		return RunTimeProblem(RTP_LISTRANGEERROR);
	}
	BlkValueWrite(list, LIST_ITEM_BASE+i-1, val);
];

[ LIST_OF_TY_PutItem list i v  no_items nv;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return false;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
		nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F));
		BlkValueCopy(nv, v);
		v = nv;
	}
	if ((i<=0) || (i>no_items)) return false;
	BlkValueWrite(list, LIST_ITEM_BASE+i-1, v);
];

[ LIST_OF_TY_Mol list len i;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return 0;
	len = multiple_object-->0;
	LIST_OF_TY_SetLength(list, len);
	for (i=1: i<=len: i++)
		LIST_OF_TY_PutItem(list, i, multiple_object-->i);
	return list;
];

[ LIST_OF_TY_Set_Mol list len i;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return 0;
	len = BlkValueRead(list, LIST_LENGTH_F);
	if (len > 63) len = 63;
	multiple_object-->0 = len;
	for (i=1: i<=len: i++)
		multiple_object-->i = BlkValueRead(list, LIST_ITEM_BASE+i-1);
];

[ LIST_OF_TY_Reverse list no_items i v;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return 0;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (no_items < 2) return list;
	for (i=0;i*2<no_items;i++) {
		v = BlkValueRead(list, LIST_ITEM_BASE+i);
		BlkValueWrite(list, LIST_ITEM_BASE+i,
			BlkValueRead(list, LIST_ITEM_BASE+no_items-1-i));
		BlkValueWrite(list, LIST_ITEM_BASE+no_items-1-i, v);
	}
	return list;
];

[ LIST_OF_TY_Rotate list backwards  no_items i v;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return 0;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (no_items < 2) return list;
	if (backwards) {
		v = BlkValueRead(list, LIST_ITEM_BASE);
		for (i=0:i<no_items-1:i++)
			BlkValueWrite(list, LIST_ITEM_BASE+i,
				BlkValueRead(list, LIST_ITEM_BASE+i+1));
		BlkValueWrite(list, no_items-1+LIST_ITEM_BASE, v);
	} else {
		v = BlkValueRead(list, no_items-1+LIST_ITEM_BASE);
		for (i=no_items-1:i>0:i--)
			BlkValueWrite(list, LIST_ITEM_BASE+i,
				BlkValueRead(list, LIST_ITEM_BASE+i-1));
		BlkValueWrite(list, LIST_ITEM_BASE, v);
	}
	return list;
];

Global LIST_OF_TY_Sort_cf;

[ LIST_OF_TY_Sort list dir prop cf  i j no_items v;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (dir == 2) {
		if (no_items < 2) return;
		for (i=1:i<no_items:i++) {
			j = random(i+1) - 1;
			v = BlkValueRead(list, LIST_ITEM_BASE+i);
			BlkValueWrite(list, LIST_ITEM_BASE+i, BlkValueRead(list, LIST_ITEM_BASE+j));
			BlkValueWrite(list, LIST_ITEM_BASE+j, v);
		}
		return;
	}
	SetSortDomain(ListSwapEntries, ListCompareEntries);
	if (cf) { LIST_OF_TY_Sort_cf = BlkValueCompare; ! dir = -dir;
	}
	else LIST_OF_TY_Sort_cf = 0;
	SortArray(list, prop, dir, no_items, false, 0);
];

[ ListSwapEntries list i j v;
	if (i==j) return;
	v = BlkValueRead(list, LIST_ITEM_BASE+i-1);
	BlkValueWrite(list, LIST_ITEM_BASE+i-1, BlkValueRead(list, LIST_ITEM_BASE+j-1));
	BlkValueWrite(list, LIST_ITEM_BASE+j-1, v);
];

[ ListCompareEntries list col i j d cf;
	if (i==j) return 0;
	i = BlkValueRead(list, LIST_ITEM_BASE+i-1);
	j = BlkValueRead(list, LIST_ITEM_BASE+j-1);
	if (I7S_Col) {
		if (i provides I7S_Col) i=i.I7S_Col; else i=0;
		if (j provides I7S_Col) j=j.I7S_Col; else j=0;
		cf = LIST_OF_TY_Sort_cf;
	} else {
		cf = LIST_OF_TY_ComparisonFn(list);
	}
	if (cf == 0)
		return i - j;
	else
		return cf(i, j);
];

#IFNOT; ! IFDEF MEMORY_HEAP_SIZE

[ LIST_OF_TY_Support t a b c; rfalse; ];
[ LIST_OF_TY_Say list; ];
[ LIST_OF_TY_FindItem list v; rfalse; ];
[ LIST_OF_TY_Empty list; rfalse; ];
[ LIST_OF_TY_SetLength l n; rfalse; ];
[ LIST_OF_TY_InsertItem a b c d e; rfalse; ];

#ENDIF; ! IFDEF MEMORY_HEAP_SIZE

#IFDEF MEMORY_HEAP_SIZE; ! Will exist if any use is made of heap

[ COMBINATION_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:     arg3 = COMBINATION_TY_Create(arg2);
		                 if (arg1) COMBINATION_TY_CopyRawArray(arg3, arg1, 2);
		                 return arg3;
		CAST_KOVS:       rfalse;
		DESTROY_KOVS:    return COMBINATION_TY_Destroy(arg1);
		PRECOPY_KOVS:    return COMBINATION_TY_PreCopy(arg1, arg2);
		COPY_KOVS:       return COMBINATION_TY_Copy(arg1, arg2);
		COMPARE_KOVS:    return COMBINATION_TY_Compare(arg1, arg2);
		READ_FILE_KOVS:  rfalse;
		WRITE_FILE_KOVS: rfalse;
		HASH_KOVS:       return COMBINATION_TY_Hash(arg1);
	}
];

Constant COMBINATION_KIND_F = 0; ! A pointer to a block indicating the kind
Constant COMBINATION_ITEM_BASE = 1; ! List items begin at this entry

[ COMBINATION_TY_Create kind comb N i bk v;
	N = KindBaseArity(kind);
	comb = BlkAllocate((COMBINATION_ITEM_BASE+N)*WORDSIZE, COMBINATION_TY, BLK_FLAG_WORD);
	BlkValueWrite(comb, COMBINATION_KIND_F, kind);
	for (i=0; i<N; i++) {
		bk = KindBaseTerm(kind, i);
		if (KOVIsBlockValue(bk))
			v = BlkValueCreate(bk);
		else
			v = DefaultValueOfKOV(bk);
		BlkValueWrite(comb, COMBINATION_ITEM_BASE+i, v);
	}
	return comb;
];

[ COMBINATION_TY_CopyRawArray comb raw rea len i ex bk v w;
	if ((comb==0) || (BlkType(comb) ~= COMBINATION_TY)) return false;
	ex = BlkValueExtent(comb);
	len = raw-->2;
	if ((len+COMBINATION_ITEM_BASE > ex) &&
		(BlkValueSetExtent(comb, len+COMBINATION_ITEM_BASE) == false)) return 0;
	BlkValueWrite(comb, LIST_LENGTH_F, len);
	if (rea == 2) bk = BlkValueRead(comb, COMBINATION_KIND_F);
	else {
		bk = raw-->1;
		BlkValueWrite(comb, COMBINATION_KIND_F, bk);
	}
	for (i=0:i<len:i++) {
		v = raw-->(i+3);
		if (KOVIsBlockValue(bk)) v = BlkValueCreate(bk, v);
		BlkValueWrite(comb, i+COMBINATION_ITEM_BASE, v);
	}
	#ifdef SHOW_ALLOCATIONS;
	print "Copied raw array to comb: "; COMBINATION_TY_Say(comb, 1); print "^";
	#endif;
	return comb;
];

[ COMBINATION_TY_Destroy comb kind no_items i bk;
	kind = BlkValueRead(comb, COMBINATION_KIND_F);
	no_items = KindBaseArity(kind);
	for (i=0; i<no_items; i++) {
		bk = KindBaseTerm(kind, i);
		if (KOVIsBlockValue(bk))
			BlkFree(BlkValueRead(comb, i+COMBINATION_ITEM_BASE));
	}
	return comb;
];

Global precopied_comb_kov;

[ COMBINATION_TY_PreCopy lto lfrom comb no_items i nv bk;
	precopied_comb_kov = BlkValueRead(lto, COMBINATION_KIND_F);
];

[ COMBINATION_TY_Copy lto lfrom no_items i nv kind bk;
	kind = BlkValueRead(lto, COMBINATION_KIND_F);
	no_items = KindBaseArity(kind);
	BlkValueWrite(lto, COMBINATION_KIND_F, precopied_comb_kov);
	for (i=0; i<no_items; i++) {
		bk = KindBaseTerm(kind, i);
		if (KOVIsBlockValue(bk)) {
			nv = BlkValueCreate(bk);
			BlkValueCopy(nv, BlkValueRead(lfrom, i+COMBINATION_ITEM_BASE));
			BlkValueWrite(lto, i+COMBINATION_ITEM_BASE, nv);
		}
	}
];

[ COMBINATION_TY_Compare listleft listright delta no_items i cf kind bk;
	kind = BlkValueRead(listleft, COMBINATION_KIND_F);
	no_items = KindBaseArity(kind);
	for (i=0; i<no_items; i++) {
		bk = KindBaseTerm(kind, i);
		cf = KOVComparisonFunction(bk);
		if (cf == 0 or UnsignedCompare) {
			delta = BlkValueRead(listleft, i+COMBINATION_ITEM_BASE) -
				BlkValueRead(listright, i+COMBINATION_ITEM_BASE);
			if (delta) return delta;
		} else {
			delta = cf(BlkValueRead(listleft, i+COMBINATION_ITEM_BASE),
				BlkValueRead(listright, i+COMBINATION_ITEM_BASE));
			if (delta) return delta;
		}
	}
	return 0;
];

[ COMBINATION_TY_Distinguish txb1 txb2;
	if (COMBINATION_TY_Compare(txb1, txb2) == 0) rfalse;
	rtrue;
];

[ COMBINATION_TY_Hash comb  kind rv no_items i bk;
	rv = 0;
	kind = BlkValueRead(comb, COMBINATION_KIND_F);
	no_items = KindBaseArity(kind);
	for (i=0: i<no_items: i++) {
		bk = KindBaseTerm(kind, i);
		rv = rv * 33 + KOVHashValue(bk, BlkValueRead(comb, i+COMBINATION_ITEM_BASE));
	}
	return rv;
];

[ COMBINATION_TY_Say comb format no_items v i kind bk;
	if ((comb==0) || (BlkType(comb) ~= COMBINATION_TY)) return;
	kind = BlkValueRead(comb, COMBINATION_KIND_F);
	no_items = KindBaseArity(kind);
	print "(";
	for (i=0; i<no_items; i++) {
		if (i>0) print ", ";
		bk = KindBaseTerm(kind, i);
		v = BlkValueRead(comb, i+COMBINATION_ITEM_BASE);
		if (bk == LIST_OF_TY) LIST_OF_TY_Say(v, 1);
		else PrintKindValuePair(bk, v);
	}
	print ")";
];

#IFNOT; ! IFDEF MEMORY_HEAP_SIZE

[ COMBINATION_TY_Support t a b c; rfalse; ];
[ COMBINATION_TY_Say comb; ];

#ENDIF; ! IFDEF MEMORY_HEAP_SIZE

Constant RRV_NAME     		RR_NAME-4;
Constant RRV_PERMISSIONS	RR_PERMISSIONS-4;
Constant RRV_STORAGE		RR_STORAGE-4;
Constant RRV_KIND		RR_KIND-4;
Constant RRV_HANDLER		RR_HANDLER-4;
Constant RRV_DESCRIPTION	RR_DESCRIPTION-4;
Constant RRV_USED		6;
Constant RRV_FILLED		7;
Constant RRV_DATA_BASE		8;

! valencies
Constant RRVAL_V_TO_V		0;
Constant RRVAL_V_TO_O		RELS_Y_UNIQUE;
Constant RRVAL_O_TO_V		RELS_X_UNIQUE;
Constant RRVAL_O_TO_O		RELS_X_UNIQUE+RELS_Y_UNIQUE;
Constant RRVAL_EQUIV		RELS_EQUIVALENCE+RELS_SYMMETRIC;
Constant RRVAL_SYM_V_TO_V	RELS_SYMMETRIC;
Constant RRVAL_SYM_O_TO_O	RELS_SYMMETRIC+RELS_X_UNIQUE+RELS_Y_UNIQUE;

! dictionary entry flags
Constant RRF_USED	$0001;	! entry contains a value
Constant RRF_DELETED	$0002;	! entry used to contain a value
Constant RRF_SINGLE	$0004;	! entry's Y is a value, not a list
Constant RRF_HASX	$0010;	! 2-in-1 entry contains a corresponding key
Constant RRF_HASY	$0020;	! 2-in-1 entry contains a corresponding value
Constant RRF_ENTKEYX	$0040;	! 2-in-1 entry key is left side KOV
Constant RRF_ENTKEYY	$0080;	! 2-in-1 entry key is right side KOV

! permission/task constants (those commented out here are generated by I7)
!Constant RELS_SYMMETRIC $8000;
!Constant RELS_EQUIVALENCE $4000;
!Constant RELS_X_UNIQUE $2000;
!Constant RELS_Y_UNIQUE $1000;
!Constant RELS_TEST $0800;
!Constant RELS_ASSERT_TRUE $0400;
!Constant RELS_ASSERT_FALSE $0200;
!Constant RELS_SHOW $0100;
!Constant RELS_ROUTE_FIND $0080;
!Constant RELS_ROUTE_FIND_COUNT $0040;
Constant RELS_COPY $0020;
Constant RELS_DESTROY $0010;
!Constant RELS_LOOKUP_ANY $0008;
!Constant RELS_LOOKUP_ALL_X $0004;
!Constant RELS_LOOKUP_ALL_Y $0002;
!Constant RELS_LIST $0001;

Constant RELS_EMPTY $0003;
Constant RELS_SET_VALENCY $0005;

! RELS_LOOKUP_ANY mode selection constants
Constant RLANY_GET_X 1;
Constant RLANY_GET_Y 2;
Constant RLANY_CAN_GET_X 3;
Constant RLANY_CAN_GET_Y 4;

! RELS_LIST mode selection constant
Constant RLIST_ALL_X 1;
Constant RLIST_ALL_Y 2;
Constant RLIST_ALL_PAIRS 3;

Constant RRP_MIN_SIZE      8;   ! minimum number of entries (DO NOT CHANGE)
Constant RRP_PERTURB_SHIFT 5;   ! affects the probe sequence
Constant RRP_RESIZE_SMALL  4;   ! resize factor for small tables
Constant RRP_RESIZE_LARGE  2;   ! resize factor for large tables
Constant RRP_LARGE_IS      256; ! how many entries make a table "large"?
Constant RRP_CROWDED_IS    2;   ! when filled entries outnumber unfilled by _ to 1

[ RelationTest relation task X Y  handler;
	handler = relation-->RR_HANDLER;
	return handler(relation, task, X, Y);
];

[ EmptyRelationHandler relation task X Y;
	if (task == RELS_EMPTY) rtrue;
	rfalse;
];

#IFDEF MEMORY_HEAP_SIZE; ! Will exist if any use is made of heap

[ RELATION_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:     arg3 = RELATION_TY_Create(arg2, arg1);
		                 return arg3;
		CAST_KOVS:       rfalse;
		DESTROY_KOVS:    return RELATION_TY_Destroy(arg1);
		PRECOPY_KOVS:    rfalse;
		COPY_KOVS:       return RELATION_TY_Copy(arg1, arg2);
		COMPARE_KOVS:    return RELATION_TY_Compare(arg1, arg2);
		READ_FILE_KOVS:  rfalse;
		WRITE_FILE_KOVS: rfalse;
		HASH_KOVS:       return arg1;
	}
];

[ RELATION_TY_Create kov from rel i skov handler;
	rel = BlkAllocate((RRV_DATA_BASE + 3*RRP_MIN_SIZE)*WORDSIZE,
		RELATION_TY, BLK_FLAG_WORD+BLK_FLAG_MULTIPLE);
	if ((from == 0) && (kov ~= 0)) from = DefaultValueFinder(kov);
	if (from) {
		for (i=0: i<RRV_DATA_BASE: i++) BlkValueWrite(rel, i, BlkValueRead(from, i));
		if (BlkValueRead(from, RRV_HANDLER) == EmptyRelationHandler) {
			handler = ChooseRelationHandler(BlkValueRead(rel, RRV_KIND));
			BlkValueWrite(rel, RRV_NAME, "anonymous relation");
			BlkValueWrite(rel, RRV_PERMISSIONS,
				RELS_TEST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW);
			BlkValueWrite(rel, RRV_HANDLER, handler);
			BlkValueWrite(rel, RRV_STORAGE, RRP_MIN_SIZE-1);
			BlkValueWrite(rel, RRV_DESCRIPTION, "an anonymous relation");
			BlkValueWrite(rel, RRV_USED, 0);
			BlkValueWrite(rel, RRV_FILLED, 0);
		}
	} else {
		handler = ChooseRelationHandler(kov);
		BlkValueWrite(rel, RRV_NAME, "anonymous relation");
		BlkValueWrite(rel, RRV_PERMISSIONS,
			RELS_TEST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW);
		BlkValueWrite(rel, RRV_STORAGE, RRP_MIN_SIZE-1);
		BlkValueWrite(rel, RRV_KIND, kov);
		BlkValueWrite(rel, RRV_HANDLER, handler);
		BlkValueWrite(rel, RRV_DESCRIPTION, "an anonymous relation");
		BlkValueWrite(rel, RRV_USED, 0);
		BlkValueWrite(rel, RRV_FILLED, 0);
	}
	return rel;
];

[ RELATION_TY_Destroy rel  handler;
	handler = BlkValueRead(rel, RRV_HANDLER);
	handler(rel, RELS_DESTROY);
	return rel;
];

[ RELATION_TY_Copy lto lfrom  handler;
	handler = BlkValueRead(lto, RRV_HANDLER);
	handler(lto, RELS_COPY);
];

[ RELATION_TY_Compare rleft rright ind1 ind2;
	ind1 = BlkValueRead(rleft, RRV_HANDLER);
	ind2 = BlkValueRead(rright, RRV_HANDLER);
	if (ind1 ~= ind2)
		return ind1 - ind2;
	return rleft - rright;
];

[ RELATION_TY_Distinguish rleft rright;
	if (RELATION_TY_Compare(rleft, rright) == 0) rfalse;
	rtrue;
];

[ RELATION_TY_Say rel;
	if (rel == 0) print "(null relation)"; ! shouldn't happen
	else print (string) rel-->RR_NAME;
];

[ RELATION_TY_Name rel txt;
	if (rel) {
		BlkValueWrite(rel, RRV_NAME, txt);
		BlkValueWrite(rel, RRV_DESCRIPTION, txt);
	}
];

[ ChooseRelationHandler kov sym;
	if (KOVIsBlockValue(KindBaseTerm(kov, 0))) {
		if (sym) return SymHashListRelationHandler;
		return HashListRelationHandler;
	}
	if (sym) return SymDoubleHashSetRelationHandler;
	return DoubleHashSetRelationHandler;
];

[ RELATION_TY_SetValency rel val  kov filled cur handler ext;
	filled = BlkValueRead(rel, RRV_FILLED);
	if (filled) { print "*** Illegal valency change ***^"; rfalse; }
	kov = BlkValueRead(rel, RRV_KIND);
	if (val == RRVAL_EQUIV or RRVAL_SYM_V_TO_V or RRVAL_SYM_O_TO_O) {
		if (KindBaseTerm(kov, 0) ~= KindBaseTerm(kov, 1)) {
			print "*** Relation cannot be made symmetric ***^";
			rfalse;
		}
	}
	cur = BlkValueRead(rel, RRV_HANDLER);
	switch (val) {
		RRVAL_V_TO_V:		handler = ChooseRelationHandler(kov, false);
		RRVAL_V_TO_O:		handler = HashTableRelationHandler;
		RRVAL_O_TO_V:		handler = ReversedHashTableRelationHandler;
		RRVAL_O_TO_O:		handler = TwoInOneHashTableRelationHandler;
		RRVAL_EQUIV:		handler = EquivHashTableRelationHandler;
		RRVAL_SYM_V_TO_V:	handler = ChooseRelationHandler(kov, true);
		RRVAL_SYM_O_TO_O:	handler = Sym2in1HashTableRelationHandler;
		default:		print "*** Illegal valency value ***^"; rfalse;
	}
	if (cur == handler) rtrue;
	! adjust size when going to or from 2-in-1
	if (cur == TwoInOneHashTableRelationHandler) {
		ext = BlkValueRead(rel, RRV_STORAGE) + 1;
		BlkValueSetExtent(rel, RRV_DATA_BASE + 3*ext);
	} else if (handler == TwoInOneHashTableRelationHandler) {
		ext = BlkValueRead(rel, RRV_STORAGE) + 1;
		BlkValueSetExtent(rel, RRV_DATA_BASE + 4*ext);
	}
	BlkValueWrite(rel, RRV_HANDLER, handler);
];

[ RELATION_TY_GetValency rel  handler;
	return BlkValueRead(rel, RRV_PERMISSIONS) & VALENCY_MASK;
];

[ DoubleHashSetRelationHandler rel task X Y sym  kov kx ky at tmp v;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	if (task == RELS_SET_VALENCY) {
		return RELATION_TY_SetValency(rel, X);
	} else if (task == RELS_DESTROY) {
		! clear
		kx = KOVIsBlockValue(kx); ky = KOVIsBlockValue(ky);
		if (~~(kx || ky)) return;
		for (at = BlkValueRead(rel, RRV_STORAGE); at >= 0; at--) {
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (tmp & RRF_USED) {
				if (kx) BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
				if (ky) BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2));
			}
			at--;
		}
		return;
	} else if (task == RELS_COPY) {
		X = KOVIsBlockValue(kx); Y = KOVIsBlockValue(ky);
		if (~~(X || Y)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (tmp & RRF_USED) {
				if (X) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
					tmp = BlkValueCopy(BlkValueCreate(kx), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, tmp);
				}
				if (Y) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
					tmp = BlkValueCopy(BlkValueCreate(ky), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, tmp);
				}
			}
			at--;
		}
		return;
	} else if (task == RELS_SHOW) {
		print (string) BlkValueRead(rel, RRV_DESCRIPTION), ":^";
		if (sym) {
			kov = KOVComparisonFunction(kx);
			if (~~kov) kov = UnsignedCompare;
		}
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (tmp & RRF_USED) {
				X = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
				Y = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
				if (sym && (kov(X, Y) > 0)) continue;
				print "  ";
				PrintKindValuePair(kx, X);
				if (sym) print " <=> "; else print " >=> ";
				PrintKindValuePair(ky, Y);
				print "^";
			}
		}
		return;
	} else if (task == RELS_EMPTY) {
		if (BlkValueRead(rel, RRV_USED) == 0) rtrue;
		if (X == 1) {
			DoubleHashSetRelationHandler(rel, RELS_DESTROY);
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 3*at;
				BlkValueWrite(rel, tmp, 0);
				BlkValueWrite(rel, tmp + 1, 0);
				BlkValueWrite(rel, tmp + 2, 0);
			}
			BlkValueWrite(rel, RRV_USED, 0);
			BlkValueWrite(rel, RRV_FILLED, 0);
			rtrue;
		}
		rfalse;
	} else if (task == RELS_LOOKUP_ANY) {
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = RRV_DATA_BASE + 3*at;
			if (BlkValueRead(rel, tmp) & RRF_USED) {
				if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
					v = BlkValueRead(rel, tmp + 2);
					if (KOVIsBlockValue(ky)) {
						if (BlkValueCompare(v, X) ~= 0) continue;
					} else {
						if (v ~= X) continue;
					}
					if (Y == RLANY_CAN_GET_X) rtrue;
					return BlkValueRead(rel, tmp + 1);
				} else {
					v = BlkValueRead(rel, tmp + 1);
					if (KOVIsBlockValue(kx)) {
						if (BlkValueCompare(v, X) ~= 0) continue;
					} else {
						if (v ~= X) continue;
					}
					if (Y == RLANY_CAN_GET_Y) rtrue;
					return BlkValueRead(rel, tmp + 2);
				}
			}
		}
		if (Y == RLANY_GET_X or RLANY_GET_Y)
			print "*** Lookup failed: value not found ***^";
		rfalse;
	} else if (task == RELS_LOOKUP_ALL_X) {
		if (BlkType(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = RRV_DATA_BASE + 3*at;
			if (BlkValueRead(rel, tmp) & RRF_USED) {
				v = BlkValueRead(rel, tmp + 2);
				if (KOVIsBlockValue(ky)) {
					if (BlkValueCompare(v, X) ~= 0) continue;
				} else {
					if (v ~= X) continue;
				}
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 1));
			}
		}
		return Y;
	} else if (task == RELS_LOOKUP_ALL_Y) {
		if (BlkType(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = RRV_DATA_BASE + 3*at;
			if (BlkValueRead(rel, tmp) & RRF_USED) {
				v = BlkValueRead(rel, tmp + 1);
				if (KOVIsBlockValue(kx)) {
					if (BlkValueCompare(v, X) ~= 0) continue;
				} else {
					if (v ~= X) continue;
				}
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 2));
			}
		}
		return Y;
	} else if (task == RELS_LIST) {
		if (X == 0 || BlkType(X) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(X, 0);
		switch (Y) {
			RLIST_ALL_X, RLIST_ALL_Y:
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					if (BlkValueRead(rel, tmp) & RRF_USED) {
						tmp++;
						if (Y == RLIST_ALL_Y) tmp++;
						v = BlkValueRead(rel, tmp);
						LIST_OF_TY_InsertItem(X, v, false, 0, true);
					}
				}
				return X;
			RLIST_ALL_PAIRS:
				! LIST_OF_TY_InsertItem will make a deep copy of the item,
				! so we can reuse a single combination value here
				Y = BlkValueCreate(COMBINATION_TY, 0, kov);
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					if (BlkValueRead(rel, tmp) & RRF_USED) {
						v = BlkValueRead(rel, tmp + 1);
						BlkValueWrite(Y, COMBINATION_ITEM_BASE, v);
						v = BlkValueRead(rel, tmp + 2);
						BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, v);
						LIST_OF_TY_InsertItem(X, Y);
					}
				}
				BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
				BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, 0);
				BlkFree(Y);
				return X;
		}
		rfalse;
	}
	at = DoubleHashSetLookUp(rel, kx, ky, X, Y);
	switch(task) {
		RELS_TEST:
			if (at >= 0) rtrue;
			rfalse;
		RELS_ASSERT_TRUE:
			if (at >= 0) rtrue;
			at = ~at;
			BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
			if (BlkValueRead(rel, RRV_DATA_BASE + 3*at) == 0)
				BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED+RRF_SINGLE);
			if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
			if (KOVIsBlockValue(ky)) { Y = BlkValueCopy(BlkValueCreate(ky), Y); }
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
			DoubleHashSetCheckResize(rel);
			rtrue;
		RELS_ASSERT_FALSE:
			if (at < 0) rtrue;
			BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) - 1);
			if (KOVIsBlockValue(kx))
				BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
			if (KOVIsBlockValue(ky))
				BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2));
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_DELETED);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, 0);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, 0);
			rtrue;
	}
];

[ DoubleHashSetLookUp rel kx ky X Y  hashv i free mask perturb flags;
	! calculate a hash value for the pair
	hashv = KOVHashValue(kx, x) + KOVHashValue(ky, y);
	! look in the first expected slot
	mask = BlkValueRead(rel, RRV_STORAGE);
	i = hashv & mask;
	flags = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
	if (flags == 0) return ~i;
	if (DoubleHashSetEntryMatches(rel, i, kx, ky, X, Y)) return i;
	! not here, keep looking in sequence
	free = -1;
	if (flags & RRF_DELETED) free = i;
	perturb = hashv;
	hashv = i;
	for (::) {
		hashv = hashv*5 + perturb + 1;
		i = hashv & mask;
		flags = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
		if (flags == 0) {
			if (free >= 0) return ~free;
			return ~i;
		}
		if (DoubleHashSetEntryMatches(rel, i, kx, ky, X, Y))
			return i;
		if ((free < 0) && (flags & RRF_DELETED)) free = i;
		#ifdef TARGET_ZCODE;
		@log_shift perturb (-RRP_PERTURB_SHIFT) -> perturb;
		#ifnot;
		@ushiftr perturb RRP_PERTURB_SHIFT perturb;
		#endif;
	}
];

[ DoubleHashSetCheckResize rel  filled ext newext temp i at kov kx ky F X Y;
	filled = BlkValueRead(rel, RRV_FILLED);
	ext = BlkValueRead(rel, RRV_STORAGE) + 1;
	if (filled >= (ext - filled) * RRP_CROWDED_IS) {
		! copy entries to temporary space
		temp = BlkAllocate(ext * (3*WORDSIZE), INDEXED_TEXT_TY, BLK_FLAG_WORD+BLK_FLAG_MULTIPLE);
		for (i=0: i<ext*3: i++)
			BlkValueWrite(temp, i, BlkValueRead(rel, RRV_DATA_BASE+i));
		! resize and clear our data
		if (ext >= RRP_LARGE_IS) newext = ext * RRP_RESIZE_LARGE;
		else newext = ext * RRP_RESIZE_SMALL;
		BlkValueSetExtent(rel, RRV_DATA_BASE + newext*3);
		BlkValueWrite(rel, RRV_STORAGE, newext - 1);
		BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
		for (i=0: i<newext*3: i++)
			BlkValueWrite(rel, RRV_DATA_BASE+i, 0);
		! copy entries back from temporary space
		kov = BlkValueRead(rel, RRV_KIND);
		kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
		for (i=0: i<ext: i++) {
			F = BlkValueRead(temp, 3*i);
			if (F == 0 || (F & RRF_DELETED)) continue;
			X = BlkValueRead(temp, 3*i + 1);
			Y = BlkValueRead(temp, 3*i + 2);
			at = DoubleHashSetLookUp(rel, kx, ky, X, Y);
			if (at >= 0) { print "*** Duplicate entry while resizing ***^"; rfalse; }
			at = ~at;
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, F);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
		}
		! done with temporary space
		BlkFree(temp);
	}
];

[ DoubleHashSetEntryMatches rel at kx ky X Y  cx cy;
	cx = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
	if (KOVIsBlockValue(kx)) {
		if (BlkValueCompare(cx, X) ~= 0) rfalse;
	} else {
		if (cx ~= X) rfalse;
	}
	cy = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
	if (KOVIsBlockValue(ky)) {
		if (BlkValueCompare(cy, Y) ~= 0) rfalse;
	} else {
		if (cy ~= Y) rfalse;
	}
	rtrue;
];

[ HashListRelationHandler rel task X Y  sym kov kx ky;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 1);
];

[ HashTableRelationHandler rel task X Y  kov kx ky;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 0);
];

[ ReversedHashTableRelationHandler rel task X Y  kov kx ky;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	switch (task) {
		RELS_SET_VALENCY:
			return RELATION_TY_SetValency(rel, X);
		RELS_TEST, RELS_ASSERT_TRUE, RELS_ASSERT_FALSE:
			return HashCoreRelationHandler(rel, task, ky, kx, Y, X, 0);
		RELS_LOOKUP_ANY:
			switch (Y) {
				RLANY_GET_X: Y = RLANY_GET_Y;
				RLANY_GET_Y: Y = RLANY_GET_X;
				RLANY_CAN_GET_X: Y = RLANY_CAN_GET_Y;
				RLANY_CAN_GET_Y: Y = RLANY_CAN_GET_X;
			}
		RELS_LOOKUP_ALL_X:
			task = RELS_LOOKUP_ALL_Y;
		RELS_LOOKUP_ALL_Y:
			task = RELS_LOOKUP_ALL_X;
		RELS_SHOW:
		RELS_LIST:
			switch (Y) {
				RLIST_ALL_X: Y = RLIST_ALL_Y;
				RLIST_ALL_Y: Y = RLIST_ALL_X;
			}
	}
	return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 0);
];

[ SymDoubleHashSetRelationHandler rel task X Y;
	if (task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)
		DoubleHashSetRelationHandler(rel, task, Y, X);
	return DoubleHashSetRelationHandler(rel, task, X, Y, 1);
];

[ SymHashListRelationHandler rel task X Y;
	if (task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)
		HashListRelationHandler(rel, task, Y, X);
	return HashListRelationHandler(rel, task, X, Y);
];

[ Sym2in1HashTableRelationHandler rel task X Y;
	if (task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)
		TwoInOneHashTableRelationHandler(rel, task, Y, X);
	return TwoInOneHashTableRelationHandler(rel, task, X, Y, 1);
];

[ HashCoreRelationHandler rel task kx ky X Y mult  sym rev at tmp fl;
	if (task == RELS_SET_VALENCY) {
		return RELATION_TY_SetValency(rel, X);
	} else if (task == RELS_DESTROY) {
		! clear
		kx = KOVIsBlockValue(kx); ky = KOVIsBlockValue(ky);
		if (~~(kx || ky)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (fl & RRF_USED) {
				if (kx) BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
				if (ky || ~~(fl & RRF_SINGLE))
					BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2));
			}
			at--;
		}
		return;
	} else if (task == RELS_COPY) {
		X = KOVIsBlockValue(kx); Y = KOVIsBlockValue(ky);
		if (~~(X || Y)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (fl & RRF_USED) {
				if (X) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
					tmp = BlkValueCopy(BlkValueCreate(kx), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, tmp);
				}
				if (Y || ~~(fl & RRF_SINGLE)) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
					tmp = BlkValueCopy(BlkValueCreate(BlkType(tmp)), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, tmp);
				}
			}
			at--;
		}
		return;
	} else if (task == RELS_SHOW) {
		print (string) BlkValueRead(rel, RRV_DESCRIPTION), ":^";
		! Z-machine doesn't have the room to let us pass sym/rev as parameters
		switch (RELATION_TY_GetValency(rel)) {
			RRVAL_SYM_V_TO_V:
				sym = 1;
				tmp = KOVComparisonFunction(kx);
				if (~~tmp) tmp = UnsignedCompare;
			RRVAL_O_TO_V:
				rev = 1;
		}
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (fl & RRF_USED) {
				X = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
				Y = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
				if (fl & RRF_SINGLE) {
					if (sym && tmp(X, Y) > 0) continue;
					print "  ";
					if (rev) PrintKindValuePair(ky, Y);
					else PrintKindValuePair(kx, X);
					if (sym) print " <=> "; else print " >=> ";
					if (rev) PrintKindValuePair(kx, X);
					else PrintKindValuePair(ky, Y);
					print "^";
				} else {
					for (mult=1: mult<=LIST_OF_TY_GetLength(Y): mult++) {
						fl = LIST_OF_TY_GetItem(Y, mult);
						if (sym && tmp(X, fl) > 0) continue;
						print "  ";
						if (rev) PrintKindValuePair(ky, fl);
						else PrintKindValuePair(kx, X);
						if (sym) print " <=> "; else print " >=> ";
						if (rev) PrintKindValuePair(kx, X);
						else PrintKindValuePair(ky, fl);
						print "^";
					}
				}
			}
		}
		return;
	} else if (task == RELS_EMPTY) {
		if (BlkValueRead(rel, RRV_USED) == 0) rtrue;
		if (X == 1) {
			HashCoreRelationHandler(rel, RELS_DESTROY);
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 3*at;
				BlkValueWrite(rel, tmp, 0);
				BlkValueWrite(rel, tmp + 1, 0);
				BlkValueWrite(rel, tmp + 2, 0);
			}
			BlkValueWrite(rel, RRV_USED, 0);
			BlkValueWrite(rel, RRV_FILLED, 0);
			rtrue;
		}
		rfalse;
	} else if (task == RELS_LOOKUP_ANY) {
		if (Y == RLANY_GET_Y or RLANY_CAN_GET_Y) {
			at = HashCoreLookUp(rel, kx, X);
			if (at >= 0) {
				if (Y == RLANY_CAN_GET_Y) rtrue;
				tmp = RRV_DATA_BASE + 3*at;
				fl = BlkValueRead(rel, tmp);
				tmp = BlkValueRead(rel, tmp + 2);
				if (fl & RRF_SINGLE) return tmp;
				return LIST_OF_TY_GetItem(tmp, 1);
			}
		} else {
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 3*at;
				fl = BlkValueRead(rel, tmp);
				if (fl & RRF_USED) {
					sym = BlkValueRead(rel, tmp + 2);
					if (fl & RRF_SINGLE) {
						if (KOVIsBlockValue(ky)) {
							if (BlkValueCompare(X, sym) ~= 0) continue;
						} else {
							if (X ~= sym) continue;
						}
					} else {
						if (LIST_OF_TY_FindItem(sym, X) == 0) continue;
					}
					if (Y == RLANY_CAN_GET_X) rtrue;
					return BlkValueRead(rel, tmp + 1);
				}
			}
		}
		if (Y == RLANY_GET_X or RLANY_GET_Y)
			print "*** Lookup failed: value not found ***^";
		rfalse;
	} else if (task == RELS_LOOKUP_ALL_X) {
		if (BlkType(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = RRV_DATA_BASE + 3*at;
			fl = BlkValueRead(rel, tmp);
			if (fl & RRF_USED) {
				sym = BlkValueRead(rel, tmp + 2);
				if (fl & RRF_SINGLE) {
					if (KOVIsBlockValue(ky)) {
						if (BlkValueCompare(X, sym) ~= 0) continue;
					} else {
						if (X ~= sym) continue;
					}
				} else {
					if (LIST_OF_TY_FindItem(sym, X) == 0) continue;
				}
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 1));
			}
		}
		return Y;
	} else if (task == RELS_LOOKUP_ALL_Y) {
		if (BlkType(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		at = HashCoreLookUp(rel, kx, X);
		if (at >= 0) {
			tmp = RRV_DATA_BASE + 3*at;
			fl = BlkValueRead(rel, tmp);
			tmp = BlkValueRead(rel, tmp + 2);
			if (fl & RRF_SINGLE)
				LIST_OF_TY_InsertItem(Y, tmp);
			else
				LIST_OF_TY_AppendList(Y, tmp);
		}
		return Y;
	} else if (task == RELS_LIST) {
		if (BlkType(X) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(X, 0);
		switch (Y) {
			RLIST_ALL_X:
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					fl = BlkValueRead(rel, tmp);
					if (fl & RRF_USED)
						LIST_OF_TY_InsertItem(X, BlkValueRead(rel, tmp + 1));
				}
				return X;
			RLIST_ALL_Y:
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					fl = BlkValueRead(rel, tmp);
					if (fl & RRF_USED) {
						tmp = BlkValueRead(rel, tmp + 2);
						if (fl & RRF_SINGLE)
							LIST_OF_TY_InsertItem(X, tmp, false, 0, true);
						else
							LIST_OF_TY_AppendList(X, tmp, false, 0, true);
					}
				}
				return X;
			RLIST_ALL_PAIRS:
				if (RELATION_TY_GetValency(rel) == RRVAL_O_TO_V) rev = 1;
				! LIST_OF_TY_InsertItem will make a deep copy of the item,
				! so we can reuse a single combination value here
				Y = BlkValueCreate(COMBINATION_TY, 0, tmp);
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					fl = BlkValueRead(rel, tmp);
					if (fl & RRF_USED) {
						BlkValueWrite(Y, COMBINATION_ITEM_BASE + rev, BlkValueRead(rel, tmp + 1));
						tmp = BlkValueRead(rel, tmp + 2);
						if (fl & RRF_SINGLE) {
							BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1 - rev, tmp);
							LIST_OF_TY_InsertItem(X, Y);
						} else {
							for (mult = LIST_OF_TY_GetLength(tmp): mult > 0: mult--) {
								BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1 - rev,
									LIST_OF_TY_GetItem(tmp, mult));
								LIST_OF_TY_InsertItem(X, Y);
							}
						}
					}
				}
				BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
				BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, 0);
				BlkFree(Y);
				return X;
		}
		rfalse;
	}
	at = HashCoreLookUp(rel, kx, X);
	switch(task) {
		RELS_TEST:
			if (at < 0) rfalse;
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
			if (fl & RRF_SINGLE) {
				if (KOVIsBlockValue(ky)) {
					if (BlkValueCompare(tmp, Y) == 0) rtrue;
				} else {
					if (tmp == Y) rtrue;
				}
				rfalse;
			} else {
				return LIST_OF_TY_FindItem(tmp, Y);
			}
		RELS_ASSERT_TRUE:
			if (at < 0) {
				! no entry exists for this key, just add one
				at = ~at;
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
				if (BlkValueRead(rel, RRV_DATA_BASE + 3*at) == 0)
					BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED+RRF_SINGLE);
				if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
				if (KOVIsBlockValue(ky)) { Y = BlkValueCopy(BlkValueCreate(ky), Y); }
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
				HashCoreCheckResize(rel);
				break;
			}
			! an entry exists: could be a list or a single value
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);		! flags
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);	! value or list
			if (fl & RRF_SINGLE) {
				! if Y is the same as the stored key, we have nothing to do
				if (KOVIsBlockValue(ky)) {
					if (BlkValueCompare(tmp, Y) == 0) rtrue;
				} else {
					if (tmp == Y) rtrue;
				}
				! it's different: either replace it or expand into a list,
				! depending on the value of mult
				if (mult) {
					fl = LIST_OF_TY_Create(UNKNOWN_TY);	! new list
					BlkValueWrite(fl, LIST_ITEM_KOV_F, ky);
					LIST_OF_TY_SetLength(fl, 2);
					BlkValueWrite(fl, LIST_ITEM_BASE, tmp);	! do not copy
					LIST_OF_TY_PutItem(fl, 2, Y);		! copy if needed
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, fl);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED);
				} else {
					if (KOVIsBlockValue(ky)) {
						BlkFree(tmp);
						Y = BlkValueCopy(BlkValueCreate(ky), Y);
					}
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
				}
			} else {
				! if Y is present already, do nothing. otherwise add it.
				LIST_OF_TY_InsertItem(tmp, Y, 0, 0, 1);
			}
			rtrue;
		RELS_ASSERT_FALSE:
			if (at < 0) rtrue;
			! an entry exists: could be a list or a single value
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);		! flags
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);	! value or list
			if (fl & RRF_SINGLE) {
				! if the stored key isn't Y, we have nothing to do
				if (KOVIsBlockValue(ky)) {
					if (BlkValueCompare(tmp, Y) ~= 0) rtrue;
				} else {
					if (tmp ~= Y) rtrue;
				}
				! delete the entry
				if (KOVIsBlockValue(ky))
					BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2));
				.DeleteEntryIgnoringY;
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) - 1);
				if (KOVIsBlockValue(kx))
					BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_DELETED);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, 0);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, 0);
			} else {
				! remove Y from the list if present
				LIST_OF_TY_RemoveValue(tmp, Y, 1);
				! if the list is now empty, delete the whole entry
				if (LIST_OF_TY_GetLength(tmp) == 0) {
					BlkFree(tmp);
					jump DeleteEntryIgnoringY;
				}
			}
			rtrue;
	}
	rtrue;
];

[ HashCoreLookUp rel kx X  hashv i free mask perturb flags;
!print "[HCLU rel=", rel, " kx=", kx, " X=", X, ": ";
	! calculate a hash value for the key
	hashv = KOVHashValue(kx, x);
	! look in the first expected slot
	mask = BlkValueRead(rel, RRV_STORAGE);
	i = hashv & mask;
!print "hv=", hashv, ", trying ", i;
	if (HashCoreEntryMatches(rel, i, kx, X)) {
!print " - found]^";
		return i;
	}
	flags = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
	if (flags == 0) {
!print " - not found]^";
		return ~i;
	}
	! not here, keep looking in sequence
	free = -1;
	if (flags & RRF_DELETED) free = i;
	perturb = hashv;
	hashv = i;
	for (::) {
		hashv = hashv*5 + perturb + 1;
		i = hashv & mask;
!print ", ", i;
		flags = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
		if (flags == 0) {
!print " - not found]^";
			if (free >= 0) return ~free;
			return ~i;
		}
		if (HashCoreEntryMatches(rel, i, kx, X)) {
!print " - found]^";
			return i;
		}
		if ((free < 0) && (flags & RRF_DELETED)) free = i;
		#ifdef TARGET_ZCODE;
		@log_shift perturb (-RRP_PERTURB_SHIFT) -> perturb;
		#ifnot;
		@ushiftr perturb RRP_PERTURB_SHIFT perturb;
		#endif;
	}
];

[ HashCoreCheckResize rel  filled ext newext temp i at kov kx F X Y;
	filled = BlkValueRead(rel, RRV_FILLED);
	ext = BlkValueRead(rel, RRV_STORAGE) + 1;
	if (filled >= (ext - filled) * RRP_CROWDED_IS) {
		! copy entries to temporary space
		temp = BlkAllocate(ext * (3*WORDSIZE), INDEXED_TEXT_TY, BLK_FLAG_WORD+BLK_FLAG_MULTIPLE);
		for (i=0: i<ext*3: i++)
			BlkValueWrite(temp, i, BlkValueRead(rel, RRV_DATA_BASE+i));
		! resize and clear our data
		if (ext >= RRP_LARGE_IS) newext = ext * RRP_RESIZE_LARGE;
		else newext = ext * RRP_RESIZE_SMALL;
		BlkValueSetExtent(rel, RRV_DATA_BASE + newext*3);
		BlkValueWrite(rel, RRV_STORAGE, newext - 1);
		BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
		for (i=0: i<newext*3: i++)
			BlkValueWrite(rel, RRV_DATA_BASE+i, 0);
		! copy entries back from temporary space
		kov = BlkValueRead(rel, RRV_KIND);
		kx = KindBaseTerm(kov, 0);
		for (i=0: i<ext: i++) {
			F = BlkValueRead(temp, 3*i);
			if (F == 0 || (F & RRF_DELETED)) continue;
			X = BlkValueRead(temp, 3*i + 1);
			Y = BlkValueRead(temp, 3*i + 2);
			at = HashCoreLookUp(rel, kx, X);
			if (at >= 0) { print "*** Duplicate entry while resizing ***^"; rfalse; }
			at = ~at;
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, F);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
		}
		! done with temporary space
		BlkFree(temp);
	}
];

[ HashCoreEntryMatches rel at kx X  cx cy;
	cx = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
	if (KOVIsBlockValue(kx)) {
		if (BlkValueCompare(cx, X) ~= 0) rfalse;
	} else {
		if (cx ~= X) rfalse;
	}
	rtrue;
];

[ EquivHashTableRelationHandler rel task X Y  kx at at2 tmp fl i ext;
	kx = KindBaseTerm(BlkValueRead(rel, RRV_KIND), 0);
	if (task == RELS_SET_VALENCY) {
		return RELATION_TY_SetValency(rel, X);
	} else if (task == RELS_DESTROY) {
		! clear
		if (KOVIsBlockValue(kx)) {
			at = BlkValueRead(rel, RRV_STORAGE);
			while (at >= 0) {
				fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
				if (fl & RRF_USED) {
					BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
				}
				at--;
			}
		}
		return;
	} else if (task == RELS_COPY) {
		if (KOVIsBlockValue(kx)) {
			at = BlkValueRead(rel, RRV_STORAGE);
			while (at >= 0) {
				fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
				if (fl & RRF_USED) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
					tmp = BlkValueCopy(BlkValueCreate(kx), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1);
				}
				at--;
			}
		}
		return;
	} else if (task == RELS_SHOW) {
		print (string) BlkValueRead(rel, RRV_DESCRIPTION), ":^";
		ext = BlkValueRead(rel, RRV_STORAGE);
		! flag all items by negating their group numbers
		for (at=0, X=RRV_DATA_BASE: at<=ext: at++, X=X+3)
			if (BlkValueRead(rel, X) & RRF_USED)
				BlkValueWrite(rel, X + 2, -(BlkValueRead(rel, X + 2)));
		! display groups, unflagging them as we go
		for (at=0, X=RRV_DATA_BASE, fl=0: at<=ext: at++, X=X+3, fl=0) {
			if (BlkValueRead(rel, X) & RRF_USED) {
				fl = BlkValueRead(rel, X + 2);
				if (fl > 0) continue;		! already visited
				BlkValueWrite(rel, X + 2, -fl);	! unflag it
				! display the group starting with this member, but only
				! if there are more members in the group
				tmp = BlkValueRead(rel, X + 1);
				i = 0;
				for (at2=at+1, Y=RRV_DATA_BASE+3*at2: at2<=ext: at2++, Y=Y+3) {
					if (BlkValueRead(rel, Y) & RRF_USED) {
						if (BlkValueRead(rel, Y + 2) ~= fl) continue;
						BlkValueWrite(rel, Y + 2, -fl);
						if (~~i) {
							! print the saved first member
							print "  { ";
							PrintKindValuePair(kx, tmp);
							i = 1;
						}
						print ", ";
						PrintKindValuePair(kx, BlkValueRead(rel, Y + 1));
					}
				}
				if (i) print " }^";
			}
		}
		return;
	} else if (task == RELS_EMPTY) {
		! never empty since R(x,x) is always true
		rfalse;
	} else if (task == RELS_LOOKUP_ANY) {
		! kind of a cheat, but it's faster than searching for a better value to return
		if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
		return X;
	} else if (task == RELS_LOOKUP_ALL_X or RELS_LOOKUP_ALL_Y) {
		if (BlkType(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		BlkValueWrite(Y, LIST_ITEM_KOV_F, kx);
		at = HashCoreLookUp(rel, kx, X);
		if (at < 0) {
			LIST_OF_TY_InsertItem(Y, X);
		} else {
			X = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 3*at;
				fl = BlkValueRead(rel, tmp);
				if (fl & RRF_USED) {
					if (BlkValueRead(rel, tmp + 2) ~= X) continue;
					LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 1));
				}
			}
		}
		return Y;
	} else if (task == RELS_LIST) {
		print "*** Domains of equivalence relations cannot be listed ***^";
		return X;
	}
	at = HashCoreLookUp(rel, kx, X);
	at2 = HashCoreLookUp(rel, kx, Y);
	switch(task) {
		RELS_TEST:
			if (at < 0) {
				! X is a loner, but could still be true if X == Y
				if (KOVIsBlockValue(kx)) {
					if (BlkValueCompare(X, Y) == 0) rtrue;
				} else {
					if (X == Y) rtrue;
				}
				rfalse;
			}
			if (at2 < 0) rfalse;
			if (at == at2) rtrue;
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
			if (BlkValueRead(rel, RRV_DATA_BASE + 3*at2 + 2) == tmp) rtrue;
			rfalse;
		RELS_ASSERT_TRUE:
			! if X and Y are the same, we have nothing to do
			if (KOVIsBlockValue(kx)) {
				if (BlkValueCompare(X, Y) == 0) rtrue;
			} else {
				if (X == Y) rtrue;
			}
			if (at < 0) {
				if (at2 < 0) {
					! X and Y both missing: find a new group number and add both entries
					tmp = 0;		! candidate group number
					ext = BlkValueRead(rel, RRV_STORAGE);
					for (i=0: i<=ext: i++) {
						fl = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
						if (fl & RRF_USED) {
							fl = BlkValueRead(rel, RRV_DATA_BASE + 3*i + 2);
							if (fl > tmp) tmp = fl;
						}
					}
					tmp++;			! new group number
					BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 2);
					! add X entry
					at = ~at;
					if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
					fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
					if (fl == 0)
						BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED+RRF_SINGLE);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, tmp);
					! add Y entry. at2 might change if X and Y have the same hash code.
					at2 = ~(HashCoreLookUp(rel, kx, Y));
					if (KOVIsBlockValue(kx)) { Y = BlkValueCopy(BlkValueCreate(kx), Y); }
					fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at2);
					if (fl == 0)
						BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at2, RRF_USED+RRF_SINGLE);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at2 + 1, Y);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at2 + 2, tmp);
					jump CheckResize;
				}
				! X missing, Y present: add a new X entry
				at = ~at;
				if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
				fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
				if (fl == 0)
					BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED+RRF_SINGLE);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
				tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at2 + 2);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, tmp);
				jump CheckResize;
			}
			if (at2 < 0) {
				! X present, Y missing: add a new Y entry
				at2 = ~at2;
				if (KOVIsBlockValue(kx)) { Y = BlkValueCopy(BlkValueCreate(kx), Y); }
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
				fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at2);
				if (fl == 0)
					BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at2, RRF_USED+RRF_SINGLE);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at2 + 1, Y);
				tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at2 + 2, tmp);
				jump CheckResize;
			}
			! X and Y both present: merge higher group into lower group
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);	! higher group
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at2 + 2);	! lower group
			if (tmp < fl) { i = tmp; tmp = fl; fl = i; }
			ext = BlkValueRead(rel, RRV_STORAGE);
			for (at=0: at<=ext: at++) {
				i = RRV_DATA_BASE + 3*at + 2;
				if (BlkValueRead(rel, i) == tmp)
					BlkValueWrite(rel, i, fl);
			}
			.CheckResize;
			HashCoreCheckResize(rel);
			rtrue;
		RELS_ASSERT_FALSE:
			! if X and Y are already in different groups, we have nothing to do
			if (at < 0 || at2 < 0) rtrue;
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
			if (BlkValueRead(rel, RRV_DATA_BASE + 3*at2 + 2) ~= tmp) rtrue;
			! delete the entry for X
			BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) - 1);
			if (KOVIsBlockValue(kx))
				BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_DELETED);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, 0);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, 0);
			rtrue;
	}
];

[ TwoInOneHashTableRelationHandler rel task X Y sym  kov kx ky at at2 tmp fl;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	if (task == RELS_SET_VALENCY) {
		return RELATION_TY_SetValency(rel, X);
	} else if (task == RELS_DESTROY) {
		! clear
		kx = KOVIsBlockValue(kx); ky = KOVIsBlockValue(ky);
		if (~~(kx || ky)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if (fl & RRF_USED)
				if ((kx && (fl & RRF_ENTKEYX)) || (ky && (fl & RRF_ENTKEYY))) {
					BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1));
				}
			at--;
		}
		return;
	} else if (task == RELS_COPY) {
		X = KOVIsBlockValue(kx); Y = KOVIsBlockValue(ky);
		if (~~(X || Y)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if (fl & RRF_USED) {
				if ((X && (fl & RRF_ENTKEYX)) || (Y && (fl & RRF_ENTKEYY))) {
					! copy the entry key
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1);
					if (fl & RRF_ENTKEYX)
						tmp = BlkValueCopy(BlkValueCreate(kx), tmp);
					else
						tmp = BlkValueCopy(BlkValueCreate(ky), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 1, tmp);
					! update references in X/Y fields pointing here
					if (fl & RRF_HASX) {
						at2 = TwoInOneLookUp(rel, kx,
							BlkValueRead(rel, RRV_DATA_BASE + 4*at + 2),
							RRF_ENTKEYX);
						if (at2 >= 0)
							BlkValueWrite(rel, RRV_DATA_BASE + 4*at2 + 3, tmp);
					}
					if (fl & RRF_HASY) {
						at2 = TwoInOneLookUp(rel, ky,
							BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3),
							RRF_ENTKEYY);
						if (at2 >= 0)
							BlkValueWrite(rel, RRV_DATA_BASE + 4*at2 + 2, tmp);
					}
				}
			}
			at--;
		}
		return;
	} else if (task == RELS_SHOW) {
		print (string) BlkValueRead(rel, RRV_DESCRIPTION), ":^";
		if (sym) {
			kov = KOVComparisonFunction(kx);
			if (~~kov) kov = UnsignedCompare;
		}
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if ((fl & (RRF_USED+RRF_ENTKEYX+RRF_HASY)) ==
				(RRF_USED+RRF_ENTKEYX+RRF_HASY)) {
				X = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1);
				Y = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3);
				if (sym && kov(X, Y) > 0) continue;
				print "  ";
				PrintKindValuePair(kx, X);
				if (sym) print " <=> "; else print " >=> ";
				PrintKindValuePair(ky, Y);
				print "^";
			}
		}
		return;
	} else if (task == RELS_EMPTY) {
		if (BlkValueRead(rel, RRV_USED) == 0) rtrue;
		if (X == 1) {
			TwoInOneHashTableRelationHandler(rel, RELS_DESTROY);
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 4*at;
				BlkValueWrite(rel, tmp, 0);
				BlkValueWrite(rel, tmp + 1, 0);
				BlkValueWrite(rel, tmp + 2, 0);
				BlkValueWrite(rel, tmp + 3, 0);
			}
			BlkValueWrite(rel, RRV_USED, 0);
			BlkValueWrite(rel, RRV_FILLED, 0);
			rtrue;
		}
		rfalse;
	} else if (task == RELS_LOOKUP_ANY) {
		switch (Y) {
			RLANY_GET_X, RLANY_CAN_GET_X:
				at = TwoInOneLookUp(rel, ky, X, RRF_ENTKEYY);
				if (at >= 0) {
					tmp = RRV_DATA_BASE + 4*at;
					if (BlkValueRead(rel, tmp) & RRF_HASX) {
						if (Y == RLANY_CAN_GET_X) rtrue;
						return BlkValueRead(rel, tmp + 2);
					}
				}
			RLANY_GET_Y, RLANY_CAN_GET_Y:
				at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX);
				if (at >= 0) {
					tmp = RRV_DATA_BASE + 4*at;
					if (BlkValueRead(rel, tmp) & RRF_HASY) {
						if (Y == RLANY_CAN_GET_Y) rtrue;
						return BlkValueRead(rel, tmp + 3);
					}
				}
		}
		if (Y == RLANY_GET_X or RLANY_GET_Y)
			print "*** Lookup failed: value not found ***^";
		rfalse;
	} else if (task == RELS_LOOKUP_ALL_X) {
		at = TwoInOneLookUp(rel, ky, X, RRF_ENTKEYY);
		if (at >= 0) {
			tmp = RRV_DATA_BASE + 4*at;
			if (BlkValueRead(rel, tmp) & RRF_HASX)
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 2));
		}
		return Y;
	} else if (task == RELS_LOOKUP_ALL_Y) {
		at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX);
		if (at >= 0) {
			tmp = RRV_DATA_BASE + 4*at;
			if (BlkValueRead(rel, tmp) & RRF_HASY)
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 3));
		}
		return Y;
	} else if (task == RELS_LIST) {
		switch (Y) {
			RLIST_ALL_X:
				fl = RRF_USED+RRF_ENTKEYX+RRF_HASY;
				jump ListEntryKeys;
			RLIST_ALL_Y:
				fl = RRF_USED+RRF_ENTKEYY+RRF_HASX;
				.ListEntryKeys;
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 4*at;
					if ((BlkValueRead(rel, tmp) & fl) == fl)
						LIST_OF_TY_InsertItem(X, BlkValueRead(rel, tmp + 1), false, 0, true);
				}
			RLIST_ALL_PAIRS:
				tmp = BlkValueRead(X, LIST_ITEM_KOV_F);
				if (KindAtomic(tmp) ~= COMBINATION_TY) rfalse;
				! LIST_OF_TY_InsertItem will make a deep copy of the item,
				! so we can reuse a single combination value here
				Y = BlkValueCreate(COMBINATION_TY, 0, tmp);
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 4*at;
					fl = BlkValueRead(rel, tmp);
					if ((fl & (RRF_USED+RRF_ENTKEYX+RRF_HASY)) ==
						(RRF_USED+RRF_ENTKEYX+RRF_HASY)) {
						BlkValueWrite(Y, COMBINATION_ITEM_BASE, BlkValueRead(rel, tmp + 1));
						BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, BlkValueRead(rel, tmp + 3));
						LIST_OF_TY_InsertItem(X, Y);
					}
				}
				BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
				BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, 0);
				BlkFree(Y);
				return X;
		}
		return X;
	}
	at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX);
	switch(task) {
		RELS_TEST:
			if (at < 0) rfalse;
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if (~~(fl & RRF_HASY)) rfalse;
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3);
			if (KOVIsBlockValue(ky)) {
				if (BlkValueCompare(tmp, Y) == 0) rtrue;
			} else {
				if (tmp == Y) rtrue;
			}
			rfalse;
		RELS_ASSERT_TRUE:
			if (at < 0) {
				! create a new forward entry
				at = ~at;
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
				fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
				if (fl == 0)
					BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
				fl = RRF_USED+RRF_HASY+RRF_ENTKEYX;
				if (kx == ky || ~~(KOVIsBlockValue(kx) || KOVIsBlockValue(ky)))
					fl = fl + RRF_ENTKEYY;
				BlkValueWrite(rel, RRV_DATA_BASE + 4*at, fl);
				if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
				BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 1, X);
				BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 2, 0);
			} else {
				fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
				if (fl & RRF_HASY) {
					! if the Y we're inserting is already there, we're done
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3);
					if (KOVIsBlockValue(ky)) {
						if (BlkValueCompare(tmp, Y) == 0) rtrue;
					} else {
						if (tmp == Y) rtrue;
					}
					! it's different, so delete the reverse entry
					at2 = TwoInOneLookUp(rel, ky, tmp, RRF_ENTKEYY);
					if (at2 >= 0) TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY);
				} else {
					BlkValueWrite(rel, RRV_DATA_BASE + 4*at, fl + RRF_HASY);
				}
				! use the existing copy of X
				X = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1);
			}
			! use the existing copy of Y if there is one
			at2 = TwoInOneLookUp(rel, ky, Y, RRF_ENTKEYY);
			if (KOVIsBlockValue(ky)) {
				if (at2 >= 0)
					Y = BlkValueRead(rel, RRV_DATA_BASE + 4*at2 + 1);
				else
					Y = BlkValueCopy(BlkValueCreate(ky), Y);
			}
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 3, Y);
			if (at2 >= 0) {
				! delete existing reverse entry (and its own forward entry)
				TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY, 1);
			} else {
				at2 = ~at2;
			}
			! create reverse entry
			BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at2);
			if (fl == 0)
				BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
			fl = fl | (RRF_USED+RRF_HASX+RRF_ENTKEYY);
			if (kx == ky || ~~(KOVIsBlockValue(kx) || KOVIsBlockValue(ky)))
				fl = fl | RRF_ENTKEYX;
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at2, fl);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at2 + 1, Y);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at2 + 2, X);
			TwoInOneCheckResize(rel);
			rtrue;
		RELS_ASSERT_FALSE:
			! we only have work to do if the entry exists and has a Y which
			! matches the Y we're deleting
			if (at < 0) rtrue;
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if ((fl & RRF_HASY) == 0) rtrue;
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3);
			if (KOVIsBlockValue(ky)) {
				if (BlkValueCompare(tmp, Y) ~= 0) rtrue;
			} else {
				if (tmp ~= Y) rtrue;
			}
			TwoInOneDelete(rel, at, kx, ky, RRF_ENTKEYX, 1);
			rtrue;
	}
];

[ TwoInOneDelete rel at kx ky ekflag both  fl at2 E i;
!print "[2in1DEL at=", at, " (E=", BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1), ") ekflag=", ekflag, " both=", both, "]^";
	fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
	if (ekflag == RRF_ENTKEYX) {
		if (fl & RRF_HASY) {
			i = RRV_DATA_BASE + 4*at + 3;
			if (both) E = BlkValueRead(rel, i);
			BlkValueWrite(rel, i, 0);
			! delete matching Y<-X entry if needed
			if (both) {
				at2 = TwoInOneLookUp(rel, ky, E, RRF_ENTKEYY);
				if (at2 >= 0) TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY);
				if (at2 == at) fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			}
			fl = fl & ~RRF_HASY;
		}
	} else {
		if (fl & RRF_HASX) {
			i = RRV_DATA_BASE + 4*at + 2;
			if (both) E = BlkValueRead(rel, i);
			BlkValueWrite(rel, i, 0);
			! delete matching X->Y entry if needed
			if (both) {
				at2 = TwoInOneLookUp(rel, kx, E, RRF_ENTKEYX);
				if (at2 >= 0) {
					TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYX);
					if (at2 == at) fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
				}
			}
			fl = fl & ~RRF_HASX;
		}
	}
	if ((fl & (RRF_HASX+RRF_HASY)) == 0) {
		! entry is now empty, mark it deleted
		if (((fl & RRF_ENTKEYX) && KOVIsBlockValue(kx)) ||
		    ((ky ~= kx) && (fl & RRF_ENTKEYY) && KOVIsBlockValue(ky))) {
			BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1));
		}
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at, RRF_DELETED);
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 1, 0);
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 2, 0);
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 3, 0);
		BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) - 1);
	} else {
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at, fl);
	}
];

[ TwoInOneLookUp rel ke E ekflag  hashv i free mask perturb flags;
!print "[2in1LU rel=", rel, " ke=", ke, " E=", E, " ekf=", ekflag, ": ";
	! calculate a hash value for the key
	hashv = KOVHashValue(ke, E);
	! look in the first expected slot
	mask = BlkValueRead(rel, RRV_STORAGE);
	i = hashv & mask;
!print "hv=", hashv, ", trying ", i;
	flags = BlkValueRead(rel, RRV_DATA_BASE + 4*i);
	if (flags == 0) {
!print " - not found]^";
		return ~i;
	}
	if ((flags & ekflag) && TwoInOneEntryMatches(rel, i, ke, E)) {
!print " - found]^";
		return i;
	}
	! not here, keep looking in sequence
	free = -1;
	if (flags & RRF_DELETED) free = i;
	perturb = hashv;
	hashv = i;
	for (::) {
		hashv = hashv*5 + perturb + 1;
		i = hashv & mask;
!print ", ", i;
		flags = BlkValueRead(rel, RRV_DATA_BASE + 4*i);
		if (flags == 0) {
!print " - not found]^";
			if (free >= 0) return ~free;
			return ~i;
		}
		if ((flags & ekflag) && TwoInOneEntryMatches(rel, i, ke, E)) {
!print " - found]^";
			return i;
		}
		if ((free < 0) && (flags & RRF_DELETED)) free = i;
		#ifdef TARGET_ZCODE;
		@log_shift perturb (-RRP_PERTURB_SHIFT) -> perturb;
		#ifnot;
		@ushiftr perturb RRP_PERTURB_SHIFT perturb;
		#endif;
	}
];

[ TwoInOneCheckResize rel  filled ext newext temp i at kov kx ky F E X Y;
	filled = BlkValueRead(rel, RRV_FILLED);
	ext = BlkValueRead(rel, RRV_STORAGE) + 1;
	if (filled >= (ext - filled) * RRP_CROWDED_IS) {
		! copy entries to temporary space
		temp = BlkAllocate(ext * (4*WORDSIZE), INDEXED_TEXT_TY, BLK_FLAG_WORD+BLK_FLAG_MULTIPLE);
		for (i=0: i<ext*4: i++)
			BlkValueWrite(temp, i, BlkValueRead(rel, RRV_DATA_BASE+i));
		! resize and clear our data
		if (ext >= RRP_LARGE_IS) newext = ext * RRP_RESIZE_LARGE;
		else newext = ext * RRP_RESIZE_SMALL;
		BlkValueSetExtent(rel, RRV_DATA_BASE + newext*4);
		BlkValueWrite(rel, RRV_STORAGE, newext - 1);
		BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
		for (i=0: i<newext*4: i++)
			BlkValueWrite(rel, RRV_DATA_BASE+i, 0);
		! copy entries back from temporary space
		kov = BlkValueRead(rel, RRV_KIND);
		kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
		for (i=0: i<ext: i++) {
			F = BlkValueRead(temp, 4*i);
			if (F == 0 || (F & RRF_DELETED)) continue;
			E = BlkValueRead(temp, 4*i + 1);
			X = BlkValueRead(temp, 4*i + 2);
			Y = BlkValueRead(temp, 4*i + 3);
			if (F & RRF_ENTKEYX) at = TwoInOneLookUp(rel, kx, E, RRF_ENTKEYX);
			else at = TwoInOneLookUp(rel, ky, E, RRF_ENTKEYY);
			if (at >= 0) { print "*** Duplicate entry while resizing ***^"; rfalse; }
			at = ~at;
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at, F);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 1, E);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 2, X);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 3, Y);
		}
		! done with temporary space
		BlkFree(temp);
	}
];

[ TwoInOneEntryMatches rel at ke E  ce;
	ce = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1);
	if (KOVIsBlockValue(ke)) {
		if (BlkValueCompare(ce, E) ~= 0) rfalse;
	} else {
		if (ce ~= E) rfalse;
	}
	rtrue;
];

#IFNOT; ! IFDEF MEMORY_HEAP_SIZE

[ RELATION_TY_Support t a b c; rfalse; ];
[ RELATION_TY_Say comb; ];
[ RELATION_TY_Name rel txt; ];

#ENDIF; ! IFDEF MEMORY_HEAP_SIZE

[ RELATION_TY_Empty rel set  handler;
	handler = rel-->RR_HANDLER;
	return handler(rel, RELS_EMPTY, set);
];


Array ResourceIDsOfFigures --> 0 1  0;

Array ResourceIDsOfSounds --> 0 3 4 5 6  0;


[ CreateBlockConstants;
];



! End of automatically generated I6 source
! --------------------------------------------------------------------------
